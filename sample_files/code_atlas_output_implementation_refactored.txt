Code Atlas Generation Script - Enhanced with External Library Support and SocketIO Emit Detection
===================================================================================================================
Available implementations:
  - Analysis Original: Always available
  - Analysis Refactored: Yes
  - Reconnaissance Original: Always available
  - Reconnaissance Refactored: Yes
Using: recon:refactored + analysis:refactored (best available refactored)

Discovered 8 Python files to analyze:
  - admin_manager.py
  - database_manager.py
  - decorators.py
  - event_validator.py
  - inheritence_complex.py
  - proxy_handler.py
  - session_manager.py
  - socketio_events.py

Running reconnaissance pass...
[RECON_COMPAT] Using refactored reconnaissance implementation
  === REFACTORED RECONNAISSANCE PASS START ===
  === Analyzing admin_manager.py ===
  [RECON_INIT] Initialized refactored reconnaissance for module: admin_manager
      [IMPORT] Processing direct imports
      [IMPORT] Processing direct imports
    [EXTERNAL_MODULE] Direct import: threading
      [IMPORT] Processing direct imports
    [EXTERNAL_MODULE] Direct import: uuid
    [RECON_CLASS] Starting class analysis: OperationType
    [CLASS_RECON] Processing class: OperationType
      [INHERITANCE] Simple parent: Enum
    [CLASS_RECON] Stored class: admin_manager.OperationType with 1 parents
      [CLASS_CONTEXT] Entered class: admin_manager.OperationType
      [CLASS_ASSIGN] Processing class-level assignment in admin_manager.OperationType
      [CLASS_ATTR] Added attribute USER_MANAGEMENT to admin_manager.OperationType: {'type': 'auto'}
      [CLASS_ATTR] USER_MANAGEMENT: auto
      [CLASS_ASSIGN] Processing class-level assignment in admin_manager.OperationType
      [CLASS_ATTR] Added attribute SYSTEM_CONFIGURATION to admin_manager.OperationType: {'type': 'auto'}
      [CLASS_ATTR] SYSTEM_CONFIGURATION: auto
      [CLASS_ASSIGN] Processing class-level assignment in admin_manager.OperationType
      [CLASS_ATTR] Added attribute DATA_MIGRATION to admin_manager.OperationType: {'type': 'auto'}
      [CLASS_ATTR] DATA_MIGRATION: auto
      [CLASS_ASSIGN] Processing class-level assignment in admin_manager.OperationType
      [CLASS_ATTR] Added attribute SECURITY_AUDIT to admin_manager.OperationType: {'type': 'auto'}
      [CLASS_ATTR] SECURITY_AUDIT: auto
      [CLASS_ASSIGN] Processing class-level assignment in admin_manager.OperationType
      [CLASS_ATTR] Added attribute PERFORMANCE_TUNING to admin_manager.OperationType: {'type': 'auto'}
      [CLASS_ATTR] PERFORMANCE_TUNING: auto
      [CLASS_ASSIGN] Processing class-level assignment in admin_manager.OperationType
      [CLASS_ATTR] Added attribute BACKUP_RESTORE to admin_manager.OperationType: {'type': 'auto'}
      [CLASS_ATTR] BACKUP_RESTORE: auto
      [CLASS_ASSIGN] Processing class-level assignment in admin_manager.OperationType
      [CLASS_ATTR] Added attribute MONITORING_SETUP to admin_manager.OperationType: {'type': 'auto'}
      [CLASS_ATTR] MONITORING_SETUP: auto
      [CLASS_CONTEXT] Exiting class: admin_manager.OperationType
    [CLASS_FINALIZE] Updated admin_manager.OperationType with 7 attributes
    [RECON_CLASS] Completed class analysis: OperationType
    [RECON_CLASS] Starting class analysis: OperationStatus
    [CLASS_RECON] Processing class: OperationStatus
      [INHERITANCE] Simple parent: Enum
    [CLASS_RECON] Stored class: admin_manager.OperationStatus with 1 parents
      [CLASS_CONTEXT] Entered class: admin_manager.OperationStatus
      [CLASS_ASSIGN] Processing class-level assignment in admin_manager.OperationStatus
      [CLASS_ATTR] Added attribute PENDING to admin_manager.OperationStatus: {'type': 'auto'}
      [CLASS_ATTR] PENDING: auto
      [CLASS_ASSIGN] Processing class-level assignment in admin_manager.OperationStatus
      [CLASS_ATTR] Added attribute IN_PROGRESS to admin_manager.OperationStatus: {'type': 'auto'}
      [CLASS_ATTR] IN_PROGRESS: auto
      [CLASS_ASSIGN] Processing class-level assignment in admin_manager.OperationStatus
      [CLASS_ATTR] Added attribute COMPLETED to admin_manager.OperationStatus: {'type': 'auto'}
      [CLASS_ATTR] COMPLETED: auto
      [CLASS_ASSIGN] Processing class-level assignment in admin_manager.OperationStatus
      [CLASS_ATTR] Added attribute FAILED to admin_manager.OperationStatus: {'type': 'auto'}
      [CLASS_ATTR] FAILED: auto
      [CLASS_ASSIGN] Processing class-level assignment in admin_manager.OperationStatus
      [CLASS_ATTR] Added attribute CANCELLED to admin_manager.OperationStatus: {'type': 'auto'}
      [CLASS_ATTR] CANCELLED: auto
      [CLASS_CONTEXT] Exiting class: admin_manager.OperationStatus
    [CLASS_FINALIZE] Updated admin_manager.OperationStatus with 5 attributes
    [RECON_CLASS] Completed class analysis: OperationStatus
    [RECON_CLASS] Starting class analysis: OperationResult
    [CLASS_RECON] Processing class: OperationResult
    [CLASS_RECON] Stored class: admin_manager.OperationResult with 0 parents
      [CLASS_CONTEXT] Entered class: admin_manager.OperationResult
      [CLASS_ATTR] Added attribute operation_id to admin_manager.OperationResult: {'type': 'str'}
      [CLASS_ANN_ATTR] operation_id: str
      [CLASS_ATTR] Added attribute operation_type to admin_manager.OperationResult: {'type': 'OperationType'}
      [CLASS_ANN_ATTR] operation_type: OperationType
      [CLASS_ATTR] Added attribute status to admin_manager.OperationResult: {'type': 'OperationStatus'}
      [CLASS_ANN_ATTR] status: OperationStatus
      [CLASS_ATTR] Added attribute start_time to admin_manager.OperationResult: {'type': 'datetime'}
      [CLASS_ANN_ATTR] start_time: datetime
      [CLASS_ATTR] Added attribute end_time to admin_manager.OperationResult: {'type': 'Optional[datetime]'}
      [CLASS_ANN_ATTR] end_time: Optional[datetime]
      [CLASS_ATTR] Added attribute success to admin_manager.OperationResult: {'type': 'bool'}
      [CLASS_ANN_ATTR] success: bool
      [CLASS_ATTR] Added attribute message to admin_manager.OperationResult: {'type': 'str'}
      [CLASS_ANN_ATTR] message: str
      [CLASS_ATTR] Added attribute data to admin_manager.OperationResult: {'type': 'Dict[str, Any]'}
      [CLASS_ANN_ATTR] data: Dict[str, Any]
      [CLASS_ATTR] Added attribute errors to admin_manager.OperationResult: {'type': 'List[str]'}
      [CLASS_ANN_ATTR] errors: List[str]
      [CLASS_ATTR] Added attribute warnings to admin_manager.OperationResult: {'type': 'List[str]'}
      [CLASS_ANN_ATTR] warnings: List[str]
    [FUNCTION_RECON] Processing method: get_duration
      [RETURN_TYPE] Found return type: Optional[timedelta]
    [FUNCTION_RECON] Stored method: admin_manager.OperationResult.get_duration
    [FUNCTION_RECON] Processing method: add_error
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] error: str
    [FUNCTION_RECON] Stored method: admin_manager.OperationResult.add_error
    [FUNCTION_RECON] Processing method: add_warning
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] warning: str
    [FUNCTION_RECON] Stored method: admin_manager.OperationResult.add_warning
      [CLASS_CONTEXT] Exiting class: admin_manager.OperationResult
    [CLASS_FINALIZE] Updated admin_manager.OperationResult with 10 attributes
    [RECON_CLASS] Completed class analysis: OperationResult
    [RECON_CLASS] Starting class analysis: AdminManager
    [CLASS_RECON] Processing class: AdminManager
    [CLASS_RECON] Stored class: admin_manager.AdminManager with 0 parents
      [CLASS_CONTEXT] Entered class: admin_manager.AdminManager
    [FUNCTION_RECON] Processing method: __init__
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager.__init__
    [FUNCTION_RECON] Processing method: _initialize_system_config
      [RETURN_TYPE] Found return type: None
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager._initialize_system_config
    [FUNCTION_RECON] Processing method: execute_operation
      [RETURN_TYPE] Found return type: Dict[str, Any]
      [PARAM_TYPE] operation_type: str
      [PARAM_TYPE] parameters: Dict[str, Any]
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager.execute_operation
    [FUNCTION_RECON] Processing method: _execute_specific_operation
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] result: OperationResult
      [PARAM_TYPE] parameters: Dict[str, Any]
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager._execute_specific_operation
    [FUNCTION_RECON] Processing method: _handle_user_management
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] result: OperationResult
      [PARAM_TYPE] parameters: Dict[str, Any]
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager._handle_user_management
    [FUNCTION_RECON] Processing method: _handle_system_configuration
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] result: OperationResult
      [PARAM_TYPE] parameters: Dict[str, Any]
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager._handle_system_configuration
    [FUNCTION_RECON] Processing method: _handle_data_migration
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] result: OperationResult
      [PARAM_TYPE] parameters: Dict[str, Any]
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager._handle_data_migration
    [FUNCTION_RECON] Processing method: _handle_security_audit
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] result: OperationResult
      [PARAM_TYPE] parameters: Dict[str, Any]
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager._handle_security_audit
    [FUNCTION_RECON] Processing method: _handle_performance_tuning
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] result: OperationResult
      [PARAM_TYPE] parameters: Dict[str, Any]
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager._handle_performance_tuning
    [FUNCTION_RECON] Processing method: _handle_backup_restore
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] result: OperationResult
      [PARAM_TYPE] parameters: Dict[str, Any]
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager._handle_backup_restore
    [FUNCTION_RECON] Processing method: _handle_monitoring_setup
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] result: OperationResult
      [PARAM_TYPE] parameters: Dict[str, Any]
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager._handle_monitoring_setup
    [FUNCTION_RECON] Processing method: _result_to_dict
      [RETURN_TYPE] Found return type: Dict[str, Any]
      [PARAM_TYPE] result: OperationResult
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager._result_to_dict
    [FUNCTION_RECON] Processing method: _add_audit_entry
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] result: OperationResult
      [PARAM_TYPE] parameters: Dict[str, Any]
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager._add_audit_entry
    [FUNCTION_RECON] Processing method: get_operation_status
      [RETURN_TYPE] Found return type: Optional[Dict[str, Any]]
      [PARAM_TYPE] operation_id: str
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager.get_operation_status
    [FUNCTION_RECON] Processing method: get_active_operations
      [RETURN_TYPE] Found return type: List[str]
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager.get_active_operations
    [FUNCTION_RECON] Processing method: get_system_status
      [RETURN_TYPE] Found return type: Dict[str, Any]
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager.get_system_status
    [FUNCTION_RECON] Processing method: cancel_operation
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] operation_id: str
    [FUNCTION_RECON] Stored method: admin_manager.AdminManager.cancel_operation
    [INIT_ATTRS] Extracting attributes from __init__
    [INIT_ANALYSIS] Found 0 parameter type hints
      [ATTR_ANNOT] operations_history: Dict[str, OperationResult]
      [ATTR_ANNOT] active_operations: Set[str]
      [ATTR_FROM_VALUE] operation_lock inferred as: threading.RLock
      [ATTR_ANNOT] admin_permissions: Dict[str, Set[OperationType]]
      [ATTR_ANNOT] system_config: Dict[str, Any]
      [ATTR_ANNOT] audit_log: List[Dict[str, Any]]
    [INIT_ATTRS] Found 6 attributes
      [CLASS_ATTR] Added attribute operations_history to admin_manager.AdminManager: {'type': 'Dict[str, OperationResult]'}
      [CLASS_ATTR] Added attribute active_operations to admin_manager.AdminManager: {'type': 'Set[str]'}
      [CLASS_ATTR] Added attribute operation_lock to admin_manager.AdminManager: {'type': 'threading.RLock'}
      [CLASS_ATTR] Added attribute admin_permissions to admin_manager.AdminManager: {'type': 'Dict[str, Set[OperationType]]'}
      [CLASS_ATTR] Added attribute system_config to admin_manager.AdminManager: {'type': 'Dict[str, Any]'}
      [CLASS_ATTR] Added attribute audit_log to admin_manager.AdminManager: {'type': 'List[Dict[str, Any]]'}
      [CLASS_CONTEXT] Exiting class: admin_manager.AdminManager
    [CLASS_FINALIZE] Updated admin_manager.AdminManager with 6 attributes
    [RECON_CLASS] Completed class analysis: AdminManager
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] manager: AdminManager
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] result: manager.execute_operation
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] result: manager.execute_operation
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] status: manager.get_system_status
    [RECON_FINALIZE] Collecting results from specialized visitors
  [RECON_SUMMARY] Found 4 classes
  [RECON_SUMMARY] Found 20 functions/methods
  [RECON_SUMMARY] Found 3 state variables
  [RECON_SUMMARY] Found 0 external classes
  [RECON_SUMMARY] Found 0 external functions
    Found 4 classes
    Found 20 functions/methods
    Found 3 state variables
    Found 0 external classes
    Found 0 external functions
  === Analyzing database_manager.py ===
  [RECON_INIT] Initialized refactored reconnaissance for module: database_manager
      [IMPORT] Processing direct imports
    [EXTERNAL_MODULE] Direct import: threading
      [IMPORT] Processing direct imports
      [IMPORT] Processing direct imports
    [RECON_CLASS] Starting class analysis: DatabaseConnection
    [CLASS_RECON] Processing class: DatabaseConnection
    [CLASS_RECON] Stored class: database_manager.DatabaseConnection with 0 parents
      [CLASS_CONTEXT] Entered class: database_manager.DatabaseConnection
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] connection_id: str
    [FUNCTION_RECON] Stored method: database_manager.DatabaseConnection.__init__
    [FUNCTION_RECON] Processing method: execute
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] query: str
      [PARAM_TYPE] params: Optional[tuple]
    [FUNCTION_RECON] Stored method: database_manager.DatabaseConnection.execute
    [FUNCTION_RECON] Processing method: commit
      [RETURN_TYPE] Found return type: None
    [FUNCTION_RECON] Stored method: database_manager.DatabaseConnection.commit
    [FUNCTION_RECON] Processing method: rollback
      [RETURN_TYPE] Found return type: None
    [FUNCTION_RECON] Stored method: database_manager.DatabaseConnection.rollback
    [FUNCTION_RECON] Processing method: begin_transaction
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] isolation_level: Optional[str]
    [FUNCTION_RECON] Stored method: database_manager.DatabaseConnection.begin_transaction
    [FUNCTION_RECON] Processing method: close
      [RETURN_TYPE] Found return type: None
    [FUNCTION_RECON] Stored method: database_manager.DatabaseConnection.close
    [FUNCTION_RECON] Processing method: is_connected
      [RETURN_TYPE] Found return type: bool
    [FUNCTION_RECON] Stored method: database_manager.DatabaseConnection.is_connected
    [FUNCTION_RECON] Processing method: get_stats
      [RETURN_TYPE] Found return type: Dict[str, Any]
    [FUNCTION_RECON] Stored method: database_manager.DatabaseConnection.get_stats
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter connection_id has type hint: str
    [INIT_ANALYSIS] Found 1 parameter type hints
      [ATTR_FROM_PARAM] connection_id = connection_id : str
      [ATTR_FROM_VALUE] is_open inferred as: int
      [ATTR_FROM_VALUE] in_transaction inferred as: int
      [ATTR_FROM_VALUE] isolation_level inferred as: str
      [ATTR_FROM_VALUE] query_count inferred as: int
      [ATTR_FROM_VALUE] last_query_time inferred as: time.time
      [ATTR_FROM_VALUE] lock inferred as: threading.RLock
    [INIT_ATTRS] Found 7 attributes
      [CLASS_ATTR] Added attribute connection_id to database_manager.DatabaseConnection: {'type': 'str'}
      [CLASS_ATTR] Added attribute is_open to database_manager.DatabaseConnection: {'type': 'int'}
      [CLASS_ATTR] Added attribute in_transaction to database_manager.DatabaseConnection: {'type': 'int'}
      [CLASS_ATTR] Added attribute isolation_level to database_manager.DatabaseConnection: {'type': 'str'}
      [CLASS_ATTR] Added attribute query_count to database_manager.DatabaseConnection: {'type': 'int'}
      [CLASS_ATTR] Added attribute last_query_time to database_manager.DatabaseConnection: {'type': 'time.time'}
      [CLASS_ATTR] Added attribute lock to database_manager.DatabaseConnection: {'type': 'threading.RLock'}
      [CLASS_CONTEXT] Exiting class: database_manager.DatabaseConnection
    [CLASS_FINALIZE] Updated database_manager.DatabaseConnection with 7 attributes
    [RECON_CLASS] Completed class analysis: DatabaseConnection
    [RECON_CLASS] Starting class analysis: TransactionManager
    [CLASS_RECON] Processing class: TransactionManager
    [CLASS_RECON] Stored class: database_manager.TransactionManager with 0 parents
      [CLASS_CONTEXT] Entered class: database_manager.TransactionManager
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] connection: DatabaseConnection
      [PARAM_TYPE] isolation_level: str
    [FUNCTION_RECON] Stored method: database_manager.TransactionManager.__init__
    [FUNCTION_RECON] Processing method: begin_transaction
      [RETURN_TYPE] Found return type: None
    [FUNCTION_RECON] Stored method: database_manager.TransactionManager.begin_transaction
    [FUNCTION_RECON] Processing method: commit_transaction
      [RETURN_TYPE] Found return type: None
    [FUNCTION_RECON] Stored method: database_manager.TransactionManager.commit_transaction
    [FUNCTION_RECON] Processing method: rollback_transaction
      [RETURN_TYPE] Found return type: None
    [FUNCTION_RECON] Stored method: database_manager.TransactionManager.rollback_transaction
    [FUNCTION_RECON] Processing method: close_connection
      [RETURN_TYPE] Found return type: None
    [FUNCTION_RECON] Stored method: database_manager.TransactionManager.close_connection
    [FUNCTION_RECON] Processing method: execute_in_transaction
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] query: str
      [PARAM_TYPE] params: Optional[tuple]
    [FUNCTION_RECON] Stored method: database_manager.TransactionManager.execute_in_transaction
    [FUNCTION_RECON] Processing method: transaction_context
    [FUNCTION_RECON] Stored method: database_manager.TransactionManager.transaction_context
    [FUNCTION_RECON] Processing method: get_transaction_info
      [RETURN_TYPE] Found return type: Dict[str, Any]
    [FUNCTION_RECON] Stored method: database_manager.TransactionManager.get_transaction_info
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter connection has type hint: DatabaseConnection
      [INIT_PARAM] Parameter isolation_level has type hint: str
    [INIT_ANALYSIS] Found 2 parameter type hints
      [ATTR_FROM_PARAM] connection = connection : DatabaseConnection
      [ATTR_FROM_PARAM] isolation_level = isolation_level : str
      [ATTR_FROM_VALUE] transaction_started inferred as: int
      [ATTR_ANNOT] start_time: Optional[float]
      [ATTR_FROM_VALUE] operations_count inferred as: int
    [INIT_ATTRS] Found 5 attributes
      [CLASS_ATTR] Added attribute connection to database_manager.TransactionManager: {'type': 'DatabaseConnection'}
      [CLASS_ATTR] Added attribute isolation_level to database_manager.TransactionManager: {'type': 'str'}
      [CLASS_ATTR] Added attribute transaction_started to database_manager.TransactionManager: {'type': 'int'}
      [CLASS_ATTR] Added attribute start_time to database_manager.TransactionManager: {'type': 'Optional[float]'}
      [CLASS_ATTR] Added attribute operations_count to database_manager.TransactionManager: {'type': 'int'}
      [CLASS_CONTEXT] Exiting class: database_manager.TransactionManager
    [CLASS_FINALIZE] Updated database_manager.TransactionManager with 5 attributes
    [RECON_CLASS] Completed class analysis: TransactionManager
    [MODULE_ANN_STATE] _connection_pool: List[DatabaseConnection]
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] _pool_lock: threading.Lock
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] _connection_counter: Unknown
    [FUNCTION_RECON] Processing function: get_db_connection
      [RETURN_TYPE] Found return type: DatabaseConnection
    [FUNCTION_RECON] Stored function: database_manager.get_db_connection
    [FUNCTION_RECON] Processing function: close_all_connections
      [RETURN_TYPE] Found return type: None
    [FUNCTION_RECON] Stored function: database_manager.close_all_connections
    [FUNCTION_RECON] Processing function: get_pool_stats
      [RETURN_TYPE] Found return type: Dict[str, Any]
    [FUNCTION_RECON] Stored function: database_manager.get_pool_stats
    [FUNCTION_RECON] Processing function: create_transaction_manager
      [RETURN_TYPE] Found return type: TransactionManager
      [PARAM_TYPE] isolation_level: str
    [FUNCTION_RECON] Stored function: database_manager.create_transaction_manager
    [FUNCTION_RECON] Processing function: database_transaction
      [PARAM_TYPE] isolation_level: str
    [FUNCTION_RECON] Stored function: database_manager.database_transaction
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] conn: get_db_connection
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] tx_manager: TransactionManager
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] stats: get_pool_stats
    [RECON_FINALIZE] Collecting results from specialized visitors
  [RECON_SUMMARY] Found 2 classes
  [RECON_SUMMARY] Found 21 functions/methods
  [RECON_SUMMARY] Found 6 state variables
  [RECON_SUMMARY] Found 0 external classes
  [RECON_SUMMARY] Found 0 external functions
    Found 2 classes
    Found 21 functions/methods
    Found 6 state variables
    Found 0 external classes
    Found 0 external functions
  === Analyzing decorators.py ===
  [RECON_INIT] Initialized refactored reconnaissance for module: decorators
      [IMPORT] Processing direct imports
      [IMPORT] Processing direct imports
    [EXTERNAL_IMPORT] Processing from threading
    [EXTERNAL_CLASS] Added: threading.Lock (alias: Lock)
      [IMPORT] Processing direct imports
    [MODULE_ANN_STATE] PERFORMANCE_METRICS: Dict[str, List[float]]
    [MODULE_ANN_STATE] AUTH_CACHE: Dict[str, bool]
    [MODULE_ANN_STATE] RATE_LIMIT_CACHE: Dict[str, Dict[str, Any]]
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] TRACE_LOCK: Lock
    [RECON_CLASS] Starting class analysis: DecoratorRegistry
    [CLASS_RECON] Processing class: DecoratorRegistry
    [CLASS_RECON] Stored class: decorators.DecoratorRegistry with 0 parents
      [CLASS_CONTEXT] Entered class: decorators.DecoratorRegistry
    [FUNCTION_RECON] Processing method: __init__
    [FUNCTION_RECON] Stored method: decorators.DecoratorRegistry.__init__
    [FUNCTION_RECON] Processing method: register_decorator
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] name: str
      [PARAM_TYPE] decorator: Callable
    [FUNCTION_RECON] Stored method: decorators.DecoratorRegistry.register_decorator
    [FUNCTION_RECON] Processing method: get_decorator_chain
      [RETURN_TYPE] Found return type: List[str]
      [PARAM_TYPE] func_name: str
    [FUNCTION_RECON] Stored method: decorators.DecoratorRegistry.get_decorator_chain
    [INIT_ATTRS] Extracting attributes from __init__
    [INIT_ANALYSIS] Found 0 parameter type hints
      [ATTR_ANNOT] registered_decorators: Dict[str, Callable]
      [ATTR_ANNOT] decorator_chains: Dict[str, List[str]]
      [ATTR_ANNOT] active_traces: List[str]
    [INIT_ATTRS] Found 3 attributes
      [CLASS_ATTR] Added attribute registered_decorators to decorators.DecoratorRegistry: {'type': 'Dict[str, Callable]'}
      [CLASS_ATTR] Added attribute decorator_chains to decorators.DecoratorRegistry: {'type': 'Dict[str, List[str]]'}
      [CLASS_ATTR] Added attribute active_traces to decorators.DecoratorRegistry: {'type': 'List[str]'}
      [CLASS_CONTEXT] Exiting class: decorators.DecoratorRegistry
    [CLASS_FINALIZE] Updated decorators.DecoratorRegistry with 3 attributes
    [RECON_CLASS] Completed class analysis: DecoratorRegistry
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] _decorator_registry: DecoratorRegistry
    [FUNCTION_RECON] Processing function: trace
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] func: Optional[Callable]
    [FUNCTION_RECON] Stored function: decorators.trace
    [FUNCTION_RECON] Processing function: monitor_performance
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] func: Optional[Callable]
    [FUNCTION_RECON] Stored function: decorators.monitor_performance
    [FUNCTION_RECON] Processing function: validate_auth
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] required_role: Optional[str]
      [PARAM_TYPE] check_session: bool
    [FUNCTION_RECON] Stored function: decorators.validate_auth
    [FUNCTION_RECON] Processing function: rate_limit
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] calls: int
      [PARAM_TYPE] period: int
      [PARAM_TYPE] per_user: bool
      [PARAM_TYPE] key_func: Optional[Callable]
    [FUNCTION_RECON] Stored function: decorators.rate_limit
    [RECON_CLASS] Starting class analysis: ClassBasedDecorator
    [CLASS_RECON] Processing class: ClassBasedDecorator
    [CLASS_RECON] Stored class: decorators.ClassBasedDecorator with 0 parents
      [CLASS_CONTEXT] Entered class: decorators.ClassBasedDecorator
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] config: Dict[str, Any]
    [FUNCTION_RECON] Stored method: decorators.ClassBasedDecorator.__init__
    [FUNCTION_RECON] Processing method: __call__
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] func: Callable
    [FUNCTION_RECON] Stored method: decorators.ClassBasedDecorator.__call__
    [FUNCTION_RECON] Processing method: _validate_arguments
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] func: Callable
      [PARAM_TYPE] args: tuple
      [PARAM_TYPE] kwargs: dict
    [FUNCTION_RECON] Stored method: decorators.ClassBasedDecorator._validate_arguments
    [FUNCTION_RECON] Processing method: _transform_result
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] result: Any
    [FUNCTION_RECON] Stored method: decorators.ClassBasedDecorator._transform_result
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter config has type hint: Dict[str, Any]
    [INIT_ANALYSIS] Found 1 parameter type hints
      [ATTR_FROM_PARAM] config = config : Dict[str, Any]
      [ATTR_FROM_VALUE] call_count inferred as: int
      [ATTR_FROM_VALUE] last_call_time inferred as: int
    [INIT_ATTRS] Found 3 attributes
      [CLASS_ATTR] Added attribute config to decorators.ClassBasedDecorator: {'type': 'Dict[str, Any]'}
      [CLASS_ATTR] Added attribute call_count to decorators.ClassBasedDecorator: {'type': 'int'}
      [CLASS_ATTR] Added attribute last_call_time to decorators.ClassBasedDecorator: {'type': 'int'}
      [CLASS_CONTEXT] Exiting class: decorators.ClassBasedDecorator
    [CLASS_FINALIZE] Updated decorators.ClassBasedDecorator with 3 attributes
    [RECON_CLASS] Completed class analysis: ClassBasedDecorator
    [FUNCTION_RECON] Processing function: create_custom_decorator
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] name: str
      [PARAM_TYPE] pre_hook: Optional[Callable]
      [PARAM_TYPE] post_hook: Optional[Callable]
      [PARAM_TYPE] error_hook: Optional[Callable]
    [FUNCTION_RECON] Stored function: decorators.create_custom_decorator
    [FUNCTION_RECON] Processing function: multi_decorator
      [RETURN_TYPE] Found return type: Callable
    [FUNCTION_RECON] Stored function: decorators.multi_decorator
    [FUNCTION_RECON] Processing function: conditional_decorator
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] condition: Union[bool, Callable]
      [PARAM_TYPE] decorator: Callable
    [FUNCTION_RECON] Stored function: decorators.conditional_decorator
    [FUNCTION_RECON] Processing function: advanced_cache
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] ttl: int
      [PARAM_TYPE] key_func: Optional[Callable]
      [PARAM_TYPE] serializer: Optional[Callable]
      [PARAM_TYPE] validator: Optional[Callable]
    [FUNCTION_RECON] Stored function: decorators.advanced_cache
    [FUNCTION_RECON] Processing function: create_monitoring_decorator
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] metrics_collector: Any
    [FUNCTION_RECON] Stored function: decorators.create_monitoring_decorator
    [FUNCTION_RECON] Processing function: transaction_decorator
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] isolation_level: str
      [PARAM_TYPE] rollback_on: Optional[List[Type[Exception]]]
    [FUNCTION_RECON] Stored function: decorators.transaction_decorator
    [RECON_CLASS] Starting class analysis: PropertyDecorator
    [CLASS_RECON] Processing class: PropertyDecorator
    [CLASS_RECON] Stored class: decorators.PropertyDecorator with 0 parents
      [CLASS_CONTEXT] Entered class: decorators.PropertyDecorator
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] validator: Optional[Callable]
      [PARAM_TYPE] transformer: Optional[Callable]
      [PARAM_TYPE] cache: bool
    [FUNCTION_RECON] Stored method: decorators.PropertyDecorator.__init__
    [FUNCTION_RECON] Processing method: __call__
      [RETURN_TYPE] Found return type: property
      [PARAM_TYPE] func: Callable
    [FUNCTION_RECON] Stored method: decorators.PropertyDecorator.__call__
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter validator has type hint: Optional[Callable]
      [INIT_PARAM] Parameter transformer has type hint: Optional[Callable]
      [INIT_PARAM] Parameter cache has type hint: bool
    [INIT_ANALYSIS] Found 3 parameter type hints
      [ATTR_FROM_PARAM] validator = validator : Optional[Callable]
      [ATTR_FROM_PARAM] transformer = transformer : Optional[Callable]
      [ATTR_FROM_PARAM] cache = cache : bool
      [ATTR_ANNOT] _cache_storage: Dict[int, Any]
    [INIT_ATTRS] Found 4 attributes
      [CLASS_ATTR] Added attribute validator to decorators.PropertyDecorator: {'type': 'Optional[Callable]'}
      [CLASS_ATTR] Added attribute transformer to decorators.PropertyDecorator: {'type': 'Optional[Callable]'}
      [CLASS_ATTR] Added attribute cache to decorators.PropertyDecorator: {'type': 'bool'}
      [CLASS_ATTR] Added attribute _cache_storage to decorators.PropertyDecorator: {'type': 'Dict[int, Any]'}
      [CLASS_CONTEXT] Exiting class: decorators.PropertyDecorator
    [CLASS_FINALIZE] Updated decorators.PropertyDecorator with 4 attributes
    [RECON_CLASS] Completed class analysis: PropertyDecorator
    [FUNCTION_RECON] Processing function: complex_calculation
      [RETURN_TYPE] Found return type: Dict[str, float]
      [PARAM_TYPE] data: List[Dict[str, Any]]
      [PARAM_TYPE] multiplier: float
    [FUNCTION_RECON] Stored function: decorators.complex_calculation
    [FUNCTION_RECON] Processing function: admin_operation
      [RETURN_TYPE] Found return type: Dict[str, Any]
      [PARAM_TYPE] operation_type: str
      [PARAM_TYPE] parameters: Dict[str, Any]
    [FUNCTION_RECON] Stored function: decorators.admin_operation
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] performance_monitor: create_custom_decorator
    [FUNCTION_RECON] Processing function: cached_expensive_operation
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] input_data: Any
    [FUNCTION_RECON] Stored function: decorators.cached_expensive_operation
    [FUNCTION_RECON] Processing function: debug_function
      [RETURN_TYPE] Found return type: str
    [FUNCTION_RECON] Stored function: decorators.debug_function
    [FUNCTION_RECON] Processing function: multi_decorated_function
      [RETURN_TYPE] Found return type: str
      [PARAM_TYPE] param: str
    [FUNCTION_RECON] Stored function: decorators.multi_decorated_function
    [RECON_FINALIZE] Collecting results from specialized visitors
  [RECON_SUMMARY] Found 3 classes
  [RECON_SUMMARY] Found 24 functions/methods
  [RECON_SUMMARY] Found 6 state variables
  [RECON_SUMMARY] Found 1 external classes
  [RECON_SUMMARY] Found 0 external functions
    Found 3 classes
    Found 24 functions/methods
    Found 6 state variables
    Found 1 external classes
    Found 0 external functions
  === Analyzing event_validator.py ===
  [RECON_INIT] Initialized refactored reconnaissance for module: event_validator
      [IMPORT] Processing direct imports
      [IMPORT] Processing direct imports
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] T: TypeVar
    [RECON_CLASS] Starting class analysis: ValidationLevel
    [CLASS_RECON] Processing class: ValidationLevel
      [INHERITANCE] Simple parent: Enum
    [CLASS_RECON] Stored class: event_validator.ValidationLevel with 1 parents
      [CLASS_CONTEXT] Entered class: event_validator.ValidationLevel
      [CLASS_ASSIGN] Processing class-level assignment in event_validator.ValidationLevel
      [CLASS_ATTR] Added attribute INFO to event_validator.ValidationLevel: {'type': 'auto'}
      [CLASS_ATTR] INFO: auto
      [CLASS_ASSIGN] Processing class-level assignment in event_validator.ValidationLevel
      [CLASS_ATTR] Added attribute WARNING to event_validator.ValidationLevel: {'type': 'auto'}
      [CLASS_ATTR] WARNING: auto
      [CLASS_ASSIGN] Processing class-level assignment in event_validator.ValidationLevel
      [CLASS_ATTR] Added attribute ERROR to event_validator.ValidationLevel: {'type': 'auto'}
      [CLASS_ATTR] ERROR: auto
      [CLASS_ASSIGN] Processing class-level assignment in event_validator.ValidationLevel
      [CLASS_ATTR] Added attribute CRITICAL to event_validator.ValidationLevel: {'type': 'auto'}
      [CLASS_ATTR] CRITICAL: auto
      [CLASS_CONTEXT] Exiting class: event_validator.ValidationLevel
    [CLASS_FINALIZE] Updated event_validator.ValidationLevel with 4 attributes
    [RECON_CLASS] Completed class analysis: ValidationLevel
    [RECON_CLASS] Starting class analysis: ValidationResult
    [CLASS_RECON] Processing class: ValidationResult
      [INHERITANCE] Simple parent: Enum
    [CLASS_RECON] Stored class: event_validator.ValidationResult with 1 parents
      [CLASS_CONTEXT] Entered class: event_validator.ValidationResult
      [CLASS_ASSIGN] Processing class-level assignment in event_validator.ValidationResult
      [CLASS_ATTR] Added attribute VALID to event_validator.ValidationResult: {'type': 'auto'}
      [CLASS_ATTR] VALID: auto
      [CLASS_ASSIGN] Processing class-level assignment in event_validator.ValidationResult
      [CLASS_ATTR] Added attribute INVALID to event_validator.ValidationResult: {'type': 'auto'}
      [CLASS_ATTR] INVALID: auto
      [CLASS_ASSIGN] Processing class-level assignment in event_validator.ValidationResult
      [CLASS_ATTR] Added attribute REQUIRES_REVIEW to event_validator.ValidationResult: {'type': 'auto'}
      [CLASS_ATTR] REQUIRES_REVIEW: auto
      [CLASS_ASSIGN] Processing class-level assignment in event_validator.ValidationResult
      [CLASS_ATTR] Added attribute CONDITIONALLY_VALID to event_validator.ValidationResult: {'type': 'auto'}
      [CLASS_ATTR] CONDITIONALLY_VALID: auto
      [CLASS_CONTEXT] Exiting class: event_validator.ValidationResult
    [CLASS_FINALIZE] Updated event_validator.ValidationResult with 4 attributes
    [RECON_CLASS] Completed class analysis: ValidationResult
    [RECON_CLASS] Starting class analysis: ValidationError
    [CLASS_RECON] Processing class: ValidationError
    [CLASS_RECON] Stored class: event_validator.ValidationError with 0 parents
      [CLASS_CONTEXT] Entered class: event_validator.ValidationError
      [CLASS_ATTR] Added attribute field to event_validator.ValidationError: {'type': 'str'}
      [CLASS_ANN_ATTR] field: str
      [CLASS_ATTR] Added attribute message to event_validator.ValidationError: {'type': 'str'}
      [CLASS_ANN_ATTR] message: str
      [CLASS_ATTR] Added attribute level to event_validator.ValidationError: {'type': 'ValidationLevel'}
      [CLASS_ANN_ATTR] level: ValidationLevel
      [CLASS_ATTR] Added attribute code to event_validator.ValidationError: {'type': 'str'}
      [CLASS_ANN_ATTR] code: str
      [CLASS_ATTR] Added attribute context to event_validator.ValidationError: {'type': 'Dict[str, Any]'}
      [CLASS_ANN_ATTR] context: Dict[str, Any]
      [CLASS_ATTR] Added attribute suggestions to event_validator.ValidationError: {'type': 'List[str]'}
      [CLASS_ANN_ATTR] suggestions: List[str]
      [CLASS_CONTEXT] Exiting class: event_validator.ValidationError
    [CLASS_FINALIZE] Updated event_validator.ValidationError with 6 attributes
    [RECON_CLASS] Completed class analysis: ValidationError
    [RECON_CLASS] Starting class analysis: ValidationReport
    [CLASS_RECON] Processing class: ValidationReport
    [CLASS_RECON] Stored class: event_validator.ValidationReport with 0 parents
      [CLASS_CONTEXT] Entered class: event_validator.ValidationReport
      [CLASS_ATTR] Added attribute result to event_validator.ValidationReport: {'type': 'ValidationResult'}
      [CLASS_ANN_ATTR] result: ValidationResult
      [CLASS_ATTR] Added attribute errors to event_validator.ValidationReport: {'type': 'List[ValidationError]'}
      [CLASS_ANN_ATTR] errors: List[ValidationError]
      [CLASS_ATTR] Added attribute warnings to event_validator.ValidationReport: {'type': 'List[ValidationError]'}
      [CLASS_ANN_ATTR] warnings: List[ValidationError]
      [CLASS_ATTR] Added attribute metadata to event_validator.ValidationReport: {'type': 'Dict[str, Any]'}
      [CLASS_ANN_ATTR] metadata: Dict[str, Any]
      [CLASS_ATTR] Added attribute validation_time to event_validator.ValidationReport: {'type': 'float'}
      [CLASS_ANN_ATTR] validation_time: float
      [CLASS_ATTR] Added attribute rules_applied to event_validator.ValidationReport: {'type': 'List[str]'}
      [CLASS_ANN_ATTR] rules_applied: List[str]
    [FUNCTION_RECON] Processing method: is_valid
      [RETURN_TYPE] Found return type: bool
    [FUNCTION_RECON] Stored method: event_validator.ValidationReport.is_valid
    [FUNCTION_RECON] Processing method: has_errors
      [RETURN_TYPE] Found return type: bool
    [FUNCTION_RECON] Stored method: event_validator.ValidationReport.has_errors
    [FUNCTION_RECON] Processing method: has_warnings
      [RETURN_TYPE] Found return type: bool
    [FUNCTION_RECON] Stored method: event_validator.ValidationReport.has_warnings
    [FUNCTION_RECON] Processing method: get_error_codes
      [RETURN_TYPE] Found return type: List[str]
    [FUNCTION_RECON] Stored method: event_validator.ValidationReport.get_error_codes
    [FUNCTION_RECON] Processing method: add_error
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] field: str
      [PARAM_TYPE] message: str
      [PARAM_TYPE] code: str
      [PARAM_TYPE] level: ValidationLevel
      [PARAM_TYPE] context: Dict[str, Any]
      [PARAM_TYPE] suggestions: List[str]
    [FUNCTION_RECON] Stored method: event_validator.ValidationReport.add_error
      [CLASS_CONTEXT] Exiting class: event_validator.ValidationReport
    [CLASS_FINALIZE] Updated event_validator.ValidationReport with 6 attributes
    [RECON_CLASS] Completed class analysis: ValidationReport
    [RECON_CLASS] Starting class analysis: ValidationRule
    [CLASS_RECON] Processing class: ValidationRule
      [INHERITANCE] Simple parent: Protocol
    [CLASS_RECON] Stored class: event_validator.ValidationRule with 1 parents
      [CLASS_CONTEXT] Entered class: event_validator.ValidationRule
    [FUNCTION_RECON] Processing method: validate
      [RETURN_TYPE] Found return type: ValidationReport
      [PARAM_TYPE] data: Any
      [PARAM_TYPE] context: Dict[str, Any]
    [FUNCTION_RECON] Stored method: event_validator.ValidationRule.validate
    [FUNCTION_RECON] Processing method: get_rule_name
      [RETURN_TYPE] Found return type: str
    [FUNCTION_RECON] Stored method: event_validator.ValidationRule.get_rule_name
      [CLASS_CONTEXT] Exiting class: event_validator.ValidationRule
    [CLASS_FINALIZE] Updated event_validator.ValidationRule with 0 attributes
    [RECON_CLASS] Completed class analysis: ValidationRule
    [RECON_CLASS] Starting class analysis: BaseValidationRule
    [CLASS_RECON] Processing class: BaseValidationRule
      [INHERITANCE] Simple parent: ABC
    [CLASS_RECON] Stored class: event_validator.BaseValidationRule with 1 parents
      [CLASS_CONTEXT] Entered class: event_validator.BaseValidationRule
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] rule_name: str
      [PARAM_TYPE] description: str
    [FUNCTION_RECON] Stored method: event_validator.BaseValidationRule.__init__
    [FUNCTION_RECON] Processing method: _validate_implementation
      [RETURN_TYPE] Found return type: ValidationReport
      [PARAM_TYPE] data: Any
      [PARAM_TYPE] context: Dict[str, Any]
    [FUNCTION_RECON] Stored method: event_validator.BaseValidationRule._validate_implementation
    [FUNCTION_RECON] Processing method: validate
      [RETURN_TYPE] Found return type: ValidationReport
      [PARAM_TYPE] data: Any
      [PARAM_TYPE] context: Dict[str, Any]
    [FUNCTION_RECON] Stored method: event_validator.BaseValidationRule.validate
    [FUNCTION_RECON] Processing method: get_rule_name
      [RETURN_TYPE] Found return type: str
    [FUNCTION_RECON] Stored method: event_validator.BaseValidationRule.get_rule_name
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter rule_name has type hint: str
      [INIT_PARAM] Parameter description has type hint: str
    [INIT_ANALYSIS] Found 2 parameter type hints
      [ATTR_FROM_PARAM] rule_name = rule_name : str
      [ATTR_FROM_PARAM] description = description : str
      [ATTR_FROM_VALUE] enabled inferred as: int
      [ATTR_FROM_VALUE] priority inferred as: int
      [ATTR_ANNOT] dependencies: List[str]
    [INIT_ATTRS] Found 5 attributes
      [CLASS_ATTR] Added attribute rule_name to event_validator.BaseValidationRule: {'type': 'str'}
      [CLASS_ATTR] Added attribute description to event_validator.BaseValidationRule: {'type': 'str'}
      [CLASS_ATTR] Added attribute enabled to event_validator.BaseValidationRule: {'type': 'int'}
      [CLASS_ATTR] Added attribute priority to event_validator.BaseValidationRule: {'type': 'int'}
      [CLASS_ATTR] Added attribute dependencies to event_validator.BaseValidationRule: {'type': 'List[str]'}
      [CLASS_CONTEXT] Exiting class: event_validator.BaseValidationRule
    [CLASS_FINALIZE] Updated event_validator.BaseValidationRule with 5 attributes
    [RECON_CLASS] Completed class analysis: BaseValidationRule
    [RECON_CLASS] Starting class analysis: RequiredFieldRule
    [CLASS_RECON] Processing class: RequiredFieldRule
      [INHERITANCE] Simple parent: BaseValidationRule
    [CLASS_RECON] Stored class: event_validator.RequiredFieldRule with 1 parents
      [CLASS_CONTEXT] Entered class: event_validator.RequiredFieldRule
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] required_fields: List[str]
    [FUNCTION_RECON] Stored method: event_validator.RequiredFieldRule.__init__
    [FUNCTION_RECON] Processing method: _validate_implementation
      [RETURN_TYPE] Found return type: ValidationReport
      [PARAM_TYPE] data: Any
      [PARAM_TYPE] context: Dict[str, Any]
    [FUNCTION_RECON] Stored method: event_validator.RequiredFieldRule._validate_implementation
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter required_fields has type hint: List[str]
    [INIT_ANALYSIS] Found 1 parameter type hints
      [ATTR_FROM_PARAM] required_fields = required_fields : List[str]
    [INIT_ATTRS] Found 1 attributes
      [CLASS_ATTR] Added attribute required_fields to event_validator.RequiredFieldRule: {'type': 'List[str]'}
      [CLASS_CONTEXT] Exiting class: event_validator.RequiredFieldRule
    [CLASS_FINALIZE] Updated event_validator.RequiredFieldRule with 1 attributes
    [RECON_CLASS] Completed class analysis: RequiredFieldRule
    [RECON_CLASS] Starting class analysis: DataTypeRule
    [CLASS_RECON] Processing class: DataTypeRule
      [INHERITANCE] Simple parent: BaseValidationRule
    [CLASS_RECON] Stored class: event_validator.DataTypeRule with 1 parents
      [CLASS_CONTEXT] Entered class: event_validator.DataTypeRule
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] field_types: Dict[str, Union[type, List[type]]]
    [FUNCTION_RECON] Stored method: event_validator.DataTypeRule.__init__
    [FUNCTION_RECON] Processing method: _validate_implementation
      [RETURN_TYPE] Found return type: ValidationReport
      [PARAM_TYPE] data: Any
      [PARAM_TYPE] context: Dict[str, Any]
    [FUNCTION_RECON] Stored method: event_validator.DataTypeRule._validate_implementation
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter field_types has type hint: Dict[str, Union[type, List[type]]]
    [INIT_ANALYSIS] Found 1 parameter type hints
      [ATTR_FROM_PARAM] field_types = field_types : Dict[str, Union[type, List[type]]]
    [INIT_ATTRS] Found 1 attributes
      [CLASS_ATTR] Added attribute field_types to event_validator.DataTypeRule: {'type': 'Dict[str, Union[type, List[type]]]'}
      [CLASS_CONTEXT] Exiting class: event_validator.DataTypeRule
    [CLASS_FINALIZE] Updated event_validator.DataTypeRule with 1 attributes
    [RECON_CLASS] Completed class analysis: DataTypeRule
    [RECON_CLASS] Starting class analysis: RegexValidationRule
    [CLASS_RECON] Processing class: RegexValidationRule
      [INHERITANCE] Simple parent: BaseValidationRule
    [CLASS_RECON] Stored class: event_validator.RegexValidationRule with 1 parents
      [CLASS_CONTEXT] Entered class: event_validator.RegexValidationRule
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] field_patterns: Dict[str, str]
    [FUNCTION_RECON] Stored method: event_validator.RegexValidationRule.__init__
    [FUNCTION_RECON] Processing method: _validate_implementation
      [RETURN_TYPE] Found return type: ValidationReport
      [PARAM_TYPE] data: Any
      [PARAM_TYPE] context: Dict[str, Any]
    [FUNCTION_RECON] Stored method: event_validator.RegexValidationRule._validate_implementation
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter field_patterns has type hint: Dict[str, str]
    [INIT_ANALYSIS] Found 1 parameter type hints
      [ATTR_FROM_PARAM] field_patterns = field_patterns : Dict[str, str]
      [ATTR_FROM_VALUE] compiled_patterns inferred as: None
    [INIT_ATTRS] Found 2 attributes
      [CLASS_ATTR] Added attribute field_patterns to event_validator.RegexValidationRule: {'type': 'Dict[str, str]'}
      [CLASS_ATTR] Added attribute compiled_patterns to event_validator.RegexValidationRule: {'type': 'Unknown'}
      [CLASS_CONTEXT] Exiting class: event_validator.RegexValidationRule
    [CLASS_FINALIZE] Updated event_validator.RegexValidationRule with 2 attributes
    [RECON_CLASS] Completed class analysis: RegexValidationRule
    [RECON_CLASS] Starting class analysis: ValidationEngine
    [CLASS_RECON] Processing class: ValidationEngine
    [CLASS_RECON] Stored class: event_validator.ValidationEngine with 0 parents
      [CLASS_CONTEXT] Entered class: event_validator.ValidationEngine
    [FUNCTION_RECON] Processing method: __init__
    [FUNCTION_RECON] Stored method: event_validator.ValidationEngine.__init__
    [FUNCTION_RECON] Processing method: add_rule
      [RETURN_TYPE] Found return type: 'ValidationEngine'
      [PARAM_TYPE] rule: BaseValidationRule
    [FUNCTION_RECON] Stored method: event_validator.ValidationEngine.add_rule
    [FUNCTION_RECON] Processing method: add_rules
      [RETURN_TYPE] Found return type: 'ValidationEngine'
      [PARAM_TYPE] rules: List[BaseValidationRule]
    [FUNCTION_RECON] Stored method: event_validator.ValidationEngine.add_rules
    [FUNCTION_RECON] Processing method: set_global_context
      [RETURN_TYPE] Found return type: 'ValidationEngine'
      [PARAM_TYPE] context: Dict[str, Any]
    [FUNCTION_RECON] Stored method: event_validator.ValidationEngine.set_global_context
    [FUNCTION_RECON] Processing method: validate
      [RETURN_TYPE] Found return type: ValidationReport
      [PARAM_TYPE] data: Any
      [PARAM_TYPE] context: Dict[str, Any]
    [FUNCTION_RECON] Stored method: event_validator.ValidationEngine.validate
    [FUNCTION_RECON] Processing method: _generate_cache_key
      [RETURN_TYPE] Found return type: str
      [PARAM_TYPE] data: Any
      [PARAM_TYPE] context: Dict[str, Any]
    [FUNCTION_RECON] Stored method: event_validator.ValidationEngine._generate_cache_key
    [FUNCTION_RECON] Processing method: _merge_reports
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] main_report: ValidationReport
      [PARAM_TYPE] rule_report: ValidationReport
    [FUNCTION_RECON] Stored method: event_validator.ValidationEngine._merge_reports
    [FUNCTION_RECON] Processing method: create_rule_builder
      [RETURN_TYPE] Found return type: 'ValidationRuleBuilder'
    [FUNCTION_RECON] Stored method: event_validator.ValidationEngine.create_rule_builder
    [INIT_ATTRS] Extracting attributes from __init__
    [INIT_ANALYSIS] Found 0 parameter type hints
      [ATTR_ANNOT] rules: List[BaseValidationRule]
      [ATTR_ANNOT] global_context: Dict[str, Any]
      [ATTR_ANNOT] validation_cache: Dict[str, ValidationReport]
      [ATTR_FROM_VALUE] cache_enabled inferred as: int
    [INIT_ATTRS] Found 4 attributes
      [CLASS_ATTR] Added attribute rules to event_validator.ValidationEngine: {'type': 'List[BaseValidationRule]'}
      [CLASS_ATTR] Added attribute global_context to event_validator.ValidationEngine: {'type': 'Dict[str, Any]'}
      [CLASS_ATTR] Added attribute validation_cache to event_validator.ValidationEngine: {'type': 'Dict[str, ValidationReport]'}
      [CLASS_ATTR] Added attribute cache_enabled to event_validator.ValidationEngine: {'type': 'int'}
      [CLASS_CONTEXT] Exiting class: event_validator.ValidationEngine
    [CLASS_FINALIZE] Updated event_validator.ValidationEngine with 4 attributes
    [RECON_CLASS] Completed class analysis: ValidationEngine
    [RECON_CLASS] Starting class analysis: ValidationRuleBuilder
    [CLASS_RECON] Processing class: ValidationRuleBuilder
    [CLASS_RECON] Stored class: event_validator.ValidationRuleBuilder with 0 parents
      [CLASS_CONTEXT] Entered class: event_validator.ValidationRuleBuilder
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] engine: ValidationEngine
    [FUNCTION_RECON] Stored method: event_validator.ValidationRuleBuilder.__init__
    [FUNCTION_RECON] Processing method: require_fields
      [RETURN_TYPE] Found return type: 'ValidationRuleBuilder'
    [FUNCTION_RECON] Stored method: event_validator.ValidationRuleBuilder.require_fields
    [FUNCTION_RECON] Processing method: field_types
      [RETURN_TYPE] Found return type: 'ValidationRuleBuilder'
    [FUNCTION_RECON] Stored method: event_validator.ValidationRuleBuilder.field_types
    [FUNCTION_RECON] Processing method: field_patterns
      [RETURN_TYPE] Found return type: 'ValidationRuleBuilder'
    [FUNCTION_RECON] Stored method: event_validator.ValidationRuleBuilder.field_patterns
    [FUNCTION_RECON] Processing method: build
      [RETURN_TYPE] Found return type: ValidationEngine
    [FUNCTION_RECON] Stored method: event_validator.ValidationRuleBuilder.build
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter engine has type hint: ValidationEngine
    [INIT_ANALYSIS] Found 1 parameter type hints
      [ATTR_FROM_PARAM] engine = engine : ValidationEngine
      [ATTR_ANNOT] current_rules: List[BaseValidationRule]
    [INIT_ATTRS] Found 2 attributes
      [CLASS_ATTR] Added attribute engine to event_validator.ValidationRuleBuilder: {'type': 'ValidationEngine'}
      [CLASS_ATTR] Added attribute current_rules to event_validator.ValidationRuleBuilder: {'type': 'List[BaseValidationRule]'}
      [CLASS_CONTEXT] Exiting class: event_validator.ValidationRuleBuilder
    [CLASS_FINALIZE] Updated event_validator.ValidationRuleBuilder with 2 attributes
    [RECON_CLASS] Completed class analysis: ValidationRuleBuilder
    [RECON_CLASS] Starting class analysis: EventValidator
    [CLASS_RECON] Processing class: EventValidator
    [CLASS_RECON] Stored class: event_validator.EventValidator with 0 parents
      [CLASS_CONTEXT] Entered class: event_validator.EventValidator
    [FUNCTION_RECON] Processing method: __init__
    [FUNCTION_RECON] Stored method: event_validator.EventValidator.__init__
    [FUNCTION_RECON] Processing method: _setup_default_validations
      [RETURN_TYPE] Found return type: None
    [FUNCTION_RECON] Stored method: event_validator.EventValidator._setup_default_validations
    [FUNCTION_RECON] Processing method: validate_event
      [RETURN_TYPE] Found return type: ValidationReport
      [PARAM_TYPE] event_data: Dict[str, Any]
    [FUNCTION_RECON] Stored method: event_validator.EventValidator.validate_event
    [FUNCTION_RECON] Processing method: validate_result
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] result: Any
    [FUNCTION_RECON] Stored method: event_validator.EventValidator.validate_result
    [FUNCTION_RECON] Processing method: get_validation_details
      [RETURN_TYPE] Found return type: Dict[str, Any]
    [FUNCTION_RECON] Stored method: event_validator.EventValidator.get_validation_details
    [INIT_ATTRS] Extracting attributes from __init__
    [INIT_ANALYSIS] Found 0 parameter type hints
      [ATTR_FROM_VALUE] validation_engine inferred as: ValidationEngine
      [ATTR_ANNOT] event_schemas: Dict[str, ValidationEngine]
    [INIT_ATTRS] Found 2 attributes
      [CLASS_ATTR] Added attribute validation_engine to event_validator.EventValidator: {'type': 'ValidationEngine'}
      [CLASS_ATTR] Added attribute event_schemas to event_validator.EventValidator: {'type': 'Dict[str, ValidationEngine]'}
      [CLASS_CONTEXT] Exiting class: event_validator.EventValidator
    [CLASS_FINALIZE] Updated event_validator.EventValidator with 2 attributes
    [RECON_CLASS] Completed class analysis: EventValidator
    [RECON_CLASS] Starting class analysis: MessageValidator
    [CLASS_RECON] Processing class: MessageValidator
    [CLASS_RECON] Stored class: event_validator.MessageValidator with 0 parents
      [CLASS_CONTEXT] Entered class: event_validator.MessageValidator
    [FUNCTION_RECON] Processing method: __init__
    [FUNCTION_RECON] Stored method: event_validator.MessageValidator.__init__
    [FUNCTION_RECON] Processing method: _setup_default_filters
      [RETURN_TYPE] Found return type: None
    [FUNCTION_RECON] Stored method: event_validator.MessageValidator._setup_default_filters
    [FUNCTION_RECON] Processing method: validate_message
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] message: str
    [FUNCTION_RECON] Stored method: event_validator.MessageValidator.validate_message
    [FUNCTION_RECON] Processing method: get_validation_details
      [RETURN_TYPE] Found return type: Dict[str, Any]
    [FUNCTION_RECON] Stored method: event_validator.MessageValidator.get_validation_details
    [INIT_ATTRS] Extracting attributes from __init__
    [INIT_ANALYSIS] Found 0 parameter type hints
      [ATTR_ANNOT] content_filters: List[Callable[[str], bool]]
      [ATTR_ANNOT] banned_patterns: List[re.Pattern]
      [ATTR_ANNOT] validation_cache: Dict[str, bool]
    [INIT_ATTRS] Found 3 attributes
      [CLASS_ATTR] Added attribute content_filters to event_validator.MessageValidator: {'type': 'List[Callable[[str], bool]]'}
      [CLASS_ATTR] Added attribute banned_patterns to event_validator.MessageValidator: {'type': 'List[re.Pattern]'}
      [CLASS_ATTR] Added attribute validation_cache to event_validator.MessageValidator: {'type': 'Dict[str, bool]'}
      [CLASS_CONTEXT] Exiting class: event_validator.MessageValidator
    [CLASS_FINALIZE] Updated event_validator.MessageValidator with 3 attributes
    [RECON_CLASS] Completed class analysis: MessageValidator
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] event_validator: EventValidator
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] message_validator: MessageValidator
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] test_event_data: Unknown
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] event_validation_result: event_validator.validate_event
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] message_validation_result: message_validator.validate_message
    [FUNCTION_RECON] Processing function: validate_complete_action
      [RETURN_TYPE] Found return type: Dict[str, Any]
      [PARAM_TYPE] event_data: Dict[str, Any]
      [PARAM_TYPE] message_content: str
    [FUNCTION_RECON] Stored function: event_validator.validate_complete_action
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] complete_validation: validate_complete_action
    [RECON_FINALIZE] Collecting results from specialized visitors
  [RECON_SUMMARY] Found 13 classes
  [RECON_SUMMARY] Found 40 functions/methods
  [RECON_SUMMARY] Found 7 state variables
  [RECON_SUMMARY] Found 0 external classes
  [RECON_SUMMARY] Found 0 external functions
    Found 13 classes
    Found 40 functions/methods
    Found 7 state variables
    Found 0 external classes
    Found 0 external functions
  === Analyzing inheritence_complex.py ===
  [RECON_INIT] Initialized refactored reconnaissance for module: inheritence_complex
      [IMPORT] Processing direct imports
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] T: TypeVar
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] U: TypeVar
    [RECON_CLASS] Starting class analysis: Priority
    [CLASS_RECON] Processing class: Priority
      [INHERITANCE] Simple parent: Enum
    [CLASS_RECON] Stored class: inheritence_complex.Priority with 1 parents
      [CLASS_CONTEXT] Entered class: inheritence_complex.Priority
      [CLASS_ASSIGN] Processing class-level assignment in inheritence_complex.Priority
      [CLASS_ATTR] Added attribute LOW to inheritence_complex.Priority: {'type': 'auto'}
      [CLASS_ATTR] LOW: auto
      [CLASS_ASSIGN] Processing class-level assignment in inheritence_complex.Priority
      [CLASS_ATTR] Added attribute MEDIUM to inheritence_complex.Priority: {'type': 'auto'}
      [CLASS_ATTR] MEDIUM: auto
      [CLASS_ASSIGN] Processing class-level assignment in inheritence_complex.Priority
      [CLASS_ATTR] Added attribute HIGH to inheritence_complex.Priority: {'type': 'auto'}
      [CLASS_ATTR] HIGH: auto
      [CLASS_ASSIGN] Processing class-level assignment in inheritence_complex.Priority
      [CLASS_ATTR] Added attribute CRITICAL to inheritence_complex.Priority: {'type': 'auto'}
      [CLASS_ATTR] CRITICAL: auto
      [CLASS_CONTEXT] Exiting class: inheritence_complex.Priority
    [CLASS_FINALIZE] Updated inheritence_complex.Priority with 4 attributes
    [RECON_CLASS] Completed class analysis: Priority
    [RECON_CLASS] Starting class analysis: ProcessingResult
    [CLASS_RECON] Processing class: ProcessingResult
    [CLASS_RECON] Stored class: inheritence_complex.ProcessingResult with 0 parents
      [CLASS_CONTEXT] Entered class: inheritence_complex.ProcessingResult
      [CLASS_ATTR] Added attribute success to inheritence_complex.ProcessingResult: {'type': 'bool'}
      [CLASS_ANN_ATTR] success: bool
      [CLASS_ATTR] Added attribute data to inheritence_complex.ProcessingResult: {'type': 'Any'}
      [CLASS_ANN_ATTR] data: Any
      [CLASS_ATTR] Added attribute errors to inheritence_complex.ProcessingResult: {'type': 'List[str]'}
      [CLASS_ANN_ATTR] errors: List[str]
      [CLASS_ATTR] Added attribute metrics to inheritence_complex.ProcessingResult: {'type': 'Dict[str, float]'}
      [CLASS_ANN_ATTR] metrics: Dict[str, float]
      [CLASS_ATTR] Added attribute timestamp to inheritence_complex.ProcessingResult: {'type': 'float'}
      [CLASS_ANN_ATTR] timestamp: float
      [CLASS_CONTEXT] Exiting class: inheritence_complex.ProcessingResult
    [CLASS_FINALIZE] Updated inheritence_complex.ProcessingResult with 5 attributes
    [RECON_CLASS] Completed class analysis: ProcessingResult
    [RECON_CLASS] Starting class analysis: AbstractProcessor
    [CLASS_RECON] Processing class: AbstractProcessor
      [INHERITANCE] Simple parent: ABC
    [CLASS_RECON] Stored class: inheritence_complex.AbstractProcessor with 1 parents
      [CLASS_CONTEXT] Entered class: inheritence_complex.AbstractProcessor
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] processor_id: str
    [FUNCTION_RECON] Stored method: inheritence_complex.AbstractProcessor.__init__
    [FUNCTION_RECON] Processing method: process_data
      [RETURN_TYPE] Found return type: ProcessingResult
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.AbstractProcessor.process_data
    [FUNCTION_RECON] Processing method: validate_input
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.AbstractProcessor.validate_input
    [FUNCTION_RECON] Processing method: get_statistics
      [RETURN_TYPE] Found return type: Dict[str, int]
    [FUNCTION_RECON] Stored method: inheritence_complex.AbstractProcessor.get_statistics
    [FUNCTION_RECON] Processing method: log_operation
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] operation: str
      [PARAM_TYPE] details: Optional[Dict[str, Any]]
    [FUNCTION_RECON] Stored method: inheritence_complex.AbstractProcessor.log_operation
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter processor_id has type hint: str
    [INIT_ANALYSIS] Found 1 parameter type hints
      [ATTR_FROM_PARAM] processor_id = processor_id : str
      [ATTR_FROM_VALUE] processed_count inferred as: int
      [ATTR_FROM_VALUE] error_count inferred as: int
    [INIT_ATTRS] Found 3 attributes
      [CLASS_ATTR] Added attribute processor_id to inheritence_complex.AbstractProcessor: {'type': 'str'}
      [CLASS_ATTR] Added attribute processed_count to inheritence_complex.AbstractProcessor: {'type': 'int'}
      [CLASS_ATTR] Added attribute error_count to inheritence_complex.AbstractProcessor: {'type': 'int'}
      [CLASS_CONTEXT] Exiting class: inheritence_complex.AbstractProcessor
    [CLASS_FINALIZE] Updated inheritence_complex.AbstractProcessor with 3 attributes
    [RECON_CLASS] Completed class analysis: AbstractProcessor
    [RECON_CLASS] Starting class analysis: AsyncProcessor
    [CLASS_RECON] Processing class: AsyncProcessor
      [INHERITANCE] Simple parent: AbstractProcessor
    [CLASS_RECON] Stored class: inheritence_complex.AsyncProcessor with 1 parents
      [CLASS_CONTEXT] Entered class: inheritence_complex.AsyncProcessor
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] processor_id: str
    [FUNCTION_RECON] Stored method: inheritence_complex.AsyncProcessor.__init__
    [FUNCTION_RECON] Processing method: async_process_data
      [RETURN_TYPE] Found return type: ProcessingResult
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.AsyncProcessor.async_process_data
    [FUNCTION_RECON] Processing method: batch_process
      [RETURN_TYPE] Found return type: List[ProcessingResult]
      [PARAM_TYPE] data_list: List[Any]
    [FUNCTION_RECON] Stored method: inheritence_complex.AsyncProcessor.batch_process
    [FUNCTION_RECON] Processing method: queue_for_async_processing
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.AsyncProcessor.queue_for_async_processing
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter processor_id has type hint: str
    [INIT_ANALYSIS] Found 1 parameter type hints
      [ATTR_ANNOT] async_queue: List[Any]
      [ATTR_FROM_VALUE] batch_size inferred as: int
    [INIT_ATTRS] Found 2 attributes
      [CLASS_ATTR] Added attribute async_queue to inheritence_complex.AsyncProcessor: {'type': 'List[Any]'}
      [CLASS_ATTR] Added attribute batch_size to inheritence_complex.AsyncProcessor: {'type': 'int'}
      [CLASS_CONTEXT] Exiting class: inheritence_complex.AsyncProcessor
    [CLASS_FINALIZE] Updated inheritence_complex.AsyncProcessor with 2 attributes
    [RECON_CLASS] Completed class analysis: AsyncProcessor
    [RECON_CLASS] Starting class analysis: CacheableMixin
    [CLASS_RECON] Processing class: CacheableMixin
    [CLASS_RECON] Stored class: inheritence_complex.CacheableMixin with 0 parents
      [CLASS_CONTEXT] Entered class: inheritence_complex.CacheableMixin
    [FUNCTION_RECON] Processing method: __init__
    [FUNCTION_RECON] Stored method: inheritence_complex.CacheableMixin.__init__
    [FUNCTION_RECON] Processing method: get_cache_key
      [RETURN_TYPE] Found return type: str
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.CacheableMixin.get_cache_key
    [FUNCTION_RECON] Processing method: get_from_cache
      [RETURN_TYPE] Found return type: Optional[Any]
      [PARAM_TYPE] cache_key: str
    [FUNCTION_RECON] Stored method: inheritence_complex.CacheableMixin.get_from_cache
    [FUNCTION_RECON] Processing method: store_in_cache
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] cache_key: str
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.CacheableMixin.store_in_cache
    [FUNCTION_RECON] Processing method: get_cache_statistics
      [RETURN_TYPE] Found return type: Dict[str, Union[int, float]]
    [FUNCTION_RECON] Stored method: inheritence_complex.CacheableMixin.get_cache_statistics
    [INIT_ATTRS] Extracting attributes from __init__
    [INIT_ANALYSIS] Found 0 parameter type hints
      [ATTR_ANNOT] _cache: Dict[str, Any]
      [ATTR_FROM_VALUE] _cache_hits inferred as: int
      [ATTR_FROM_VALUE] _cache_misses inferred as: int
    [INIT_ATTRS] Found 3 attributes
      [CLASS_ATTR] Added attribute _cache to inheritence_complex.CacheableMixin: {'type': 'Dict[str, Any]'}
      [CLASS_ATTR] Added attribute _cache_hits to inheritence_complex.CacheableMixin: {'type': 'int'}
      [CLASS_ATTR] Added attribute _cache_misses to inheritence_complex.CacheableMixin: {'type': 'int'}
      [CLASS_CONTEXT] Exiting class: inheritence_complex.CacheableMixin
    [CLASS_FINALIZE] Updated inheritence_complex.CacheableMixin with 3 attributes
    [RECON_CLASS] Completed class analysis: CacheableMixin
    [RECON_CLASS] Starting class analysis: ValidatedMixin
    [CLASS_RECON] Processing class: ValidatedMixin
    [CLASS_RECON] Stored class: inheritence_complex.ValidatedMixin with 0 parents
      [CLASS_CONTEXT] Entered class: inheritence_complex.ValidatedMixin
    [FUNCTION_RECON] Processing method: __init__
    [FUNCTION_RECON] Stored method: inheritence_complex.ValidatedMixin.__init__
    [FUNCTION_RECON] Processing method: add_validation_rule
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] rule: callable
      [PARAM_TYPE] description: str
    [FUNCTION_RECON] Stored method: inheritence_complex.ValidatedMixin.add_validation_rule
    [FUNCTION_RECON] Processing method: comprehensive_validate
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.ValidatedMixin.comprehensive_validate
    [INIT_ATTRS] Extracting attributes from __init__
    [INIT_ANALYSIS] Found 0 parameter type hints
      [ATTR_ANNOT] validation_rules: List[callable]
      [ATTR_ANNOT] validation_errors: List[str]
    [INIT_ATTRS] Found 2 attributes
      [CLASS_ATTR] Added attribute validation_rules to inheritence_complex.ValidatedMixin: {'type': 'List[callable]'}
      [CLASS_ATTR] Added attribute validation_errors to inheritence_complex.ValidatedMixin: {'type': 'List[str]'}
      [CLASS_CONTEXT] Exiting class: inheritence_complex.ValidatedMixin
    [CLASS_FINALIZE] Updated inheritence_complex.ValidatedMixin with 2 attributes
    [RECON_CLASS] Completed class analysis: ValidatedMixin
    [RECON_CLASS] Starting class analysis: MetricsMixin
    [CLASS_RECON] Processing class: MetricsMixin
    [CLASS_RECON] Stored class: inheritence_complex.MetricsMixin with 0 parents
      [CLASS_CONTEXT] Entered class: inheritence_complex.MetricsMixin
    [FUNCTION_RECON] Processing method: __init__
    [FUNCTION_RECON] Stored method: inheritence_complex.MetricsMixin.__init__
    [FUNCTION_RECON] Processing method: record_metric
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] metric_name: str
      [PARAM_TYPE] value: float
    [FUNCTION_RECON] Stored method: inheritence_complex.MetricsMixin.record_metric
    [FUNCTION_RECON] Processing method: add_metric_callback
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] metric_name: str
      [PARAM_TYPE] callback: callable
    [FUNCTION_RECON] Stored method: inheritence_complex.MetricsMixin.add_metric_callback
    [FUNCTION_RECON] Processing method: get_metric_summary
      [RETURN_TYPE] Found return type: Optional[Dict[str, float]]
      [PARAM_TYPE] metric_name: str
    [FUNCTION_RECON] Stored method: inheritence_complex.MetricsMixin.get_metric_summary
    [INIT_ATTRS] Extracting attributes from __init__
    [INIT_ANALYSIS] Found 0 parameter type hints
      [ATTR_ANNOT] custom_metrics: Dict[str, List[float]]
      [ATTR_ANNOT] metric_callbacks: Dict[str, List[callable]]
    [INIT_ATTRS] Found 2 attributes
      [CLASS_ATTR] Added attribute custom_metrics to inheritence_complex.MetricsMixin: {'type': 'Dict[str, List[float]]'}
      [CLASS_ATTR] Added attribute metric_callbacks to inheritence_complex.MetricsMixin: {'type': 'Dict[str, List[callable]]'}
      [CLASS_CONTEXT] Exiting class: inheritence_complex.MetricsMixin
    [CLASS_FINALIZE] Updated inheritence_complex.MetricsMixin with 2 attributes
    [RECON_CLASS] Completed class analysis: MetricsMixin
    [RECON_CLASS] Starting class analysis: BasicDataProcessor
    [CLASS_RECON] Processing class: BasicDataProcessor
      [INHERITANCE] Simple parent: AsyncProcessor
      [INHERITANCE] Simple parent: CacheableMixin
      [INHERITANCE] Simple parent: ValidatedMixin
    [CLASS_RECON] Stored class: inheritence_complex.BasicDataProcessor with 3 parents
      [CLASS_CONTEXT] Entered class: inheritence_complex.BasicDataProcessor
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] processor_id: str
      [PARAM_TYPE] enable_cache: bool
    [FUNCTION_RECON] Stored method: inheritence_complex.BasicDataProcessor.__init__
    [FUNCTION_RECON] Processing method: validate_input
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.BasicDataProcessor.validate_input
    [FUNCTION_RECON] Processing method: process_data
      [RETURN_TYPE] Found return type: ProcessingResult
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.BasicDataProcessor.process_data
    [FUNCTION_RECON] Processing method: _internal_process
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.BasicDataProcessor._internal_process
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter processor_id has type hint: str
      [INIT_PARAM] Parameter enable_cache has type hint: bool
    [INIT_ANALYSIS] Found 2 parameter type hints
      [ATTR_FROM_PARAM] enable_cache = enable_cache : bool
    [INIT_ATTRS] Found 1 attributes
      [CLASS_ATTR] Added attribute enable_cache to inheritence_complex.BasicDataProcessor: {'type': 'bool'}
      [CLASS_CONTEXT] Exiting class: inheritence_complex.BasicDataProcessor
    [CLASS_FINALIZE] Updated inheritence_complex.BasicDataProcessor with 1 attributes
    [RECON_CLASS] Completed class analysis: BasicDataProcessor
    [RECON_CLASS] Starting class analysis: AdvancedProcessor
    [CLASS_RECON] Processing class: AdvancedProcessor
      [INHERITANCE] Simple parent: BasicDataProcessor
      [INHERITANCE] Simple parent: MetricsMixin
    [CLASS_RECON] Stored class: inheritence_complex.AdvancedProcessor with 2 parents
      [CLASS_CONTEXT] Entered class: inheritence_complex.AdvancedProcessor
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] processor_id: str
      [PARAM_TYPE] priority: Priority
    [FUNCTION_RECON] Stored method: inheritence_complex.AdvancedProcessor.__init__
    [FUNCTION_RECON] Processing method: process_data
      [RETURN_TYPE] Found return type: ProcessingResult
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.AdvancedProcessor.process_data
    [FUNCTION_RECON] Processing method: _processing_time_callback
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] metric_name: str
      [PARAM_TYPE] value: float
      [PARAM_TYPE] history: List[float]
    [FUNCTION_RECON] Stored method: inheritence_complex.AdvancedProcessor._processing_time_callback
    [FUNCTION_RECON] Processing method: _data_size_callback
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] metric_name: str
      [PARAM_TYPE] value: float
      [PARAM_TYPE] history: List[float]
    [FUNCTION_RECON] Stored method: inheritence_complex.AdvancedProcessor._data_size_callback
    [FUNCTION_RECON] Processing method: change_processing_strategy
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] new_strategy: str
    [FUNCTION_RECON] Stored method: inheritence_complex.AdvancedProcessor.change_processing_strategy
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter processor_id has type hint: str
      [INIT_PARAM] Parameter priority has type hint: Priority
    [INIT_ANALYSIS] Found 2 parameter type hints
      [ATTR_FROM_PARAM] priority = priority : Priority
      [ATTR_FROM_VALUE] processing_strategy inferred as: str
    [INIT_ATTRS] Found 2 attributes
      [CLASS_ATTR] Added attribute priority to inheritence_complex.AdvancedProcessor: {'type': 'Priority'}
      [CLASS_ATTR] Added attribute processing_strategy to inheritence_complex.AdvancedProcessor: {'type': 'str'}
      [CLASS_CONTEXT] Exiting class: inheritence_complex.AdvancedProcessor
    [CLASS_FINALIZE] Updated inheritence_complex.AdvancedProcessor with 2 attributes
    [RECON_CLASS] Completed class analysis: AdvancedProcessor
    [RECON_CLASS] Starting class analysis: SpecializedProcessor
    [CLASS_RECON] Processing class: SpecializedProcessor
      [INHERITANCE] Simple parent: AdvancedProcessor
    [CLASS_RECON] Stored class: inheritence_complex.SpecializedProcessor with 1 parents
      [CLASS_CONTEXT] Entered class: inheritence_complex.SpecializedProcessor
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] processor_id: str
      [PARAM_TYPE] specialization: str
    [FUNCTION_RECON] Stored method: inheritence_complex.SpecializedProcessor.__init__
    [FUNCTION_RECON] Processing method: _validate_specialization
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.SpecializedProcessor._validate_specialization
    [FUNCTION_RECON] Processing method: _internal_process
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.SpecializedProcessor._internal_process
    [FUNCTION_RECON] Processing method: _process_numeric
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.SpecializedProcessor._process_numeric
    [FUNCTION_RECON] Processing method: _process_text
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.SpecializedProcessor._process_text
    [FUNCTION_RECON] Processing method: _process_structured
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.SpecializedProcessor._process_structured
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter processor_id has type hint: str
      [INIT_PARAM] Parameter specialization has type hint: str
    [INIT_ANALYSIS] Found 2 parameter type hints
      [ATTR_FROM_PARAM] specialization = specialization : str
      [ATTR_ANNOT] specialist_cache: Dict[str, Any]
    [INIT_ATTRS] Found 2 attributes
      [CLASS_ATTR] Added attribute specialization to inheritence_complex.SpecializedProcessor: {'type': 'str'}
      [CLASS_ATTR] Added attribute specialist_cache to inheritence_complex.SpecializedProcessor: {'type': 'Dict[str, Any]'}
      [CLASS_CONTEXT] Exiting class: inheritence_complex.SpecializedProcessor
    [CLASS_FINALIZE] Updated inheritence_complex.SpecializedProcessor with 2 attributes
    [RECON_CLASS] Completed class analysis: SpecializedProcessor
    [RECON_CLASS] Starting class analysis: ProcessorProtocol
    [CLASS_RECON] Processing class: ProcessorProtocol
      [INHERITANCE] Simple parent: Protocol
    [CLASS_RECON] Stored class: inheritence_complex.ProcessorProtocol with 1 parents
      [CLASS_CONTEXT] Entered class: inheritence_complex.ProcessorProtocol
    [FUNCTION_RECON] Processing method: process_data
      [RETURN_TYPE] Found return type: ProcessingResult
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.ProcessorProtocol.process_data
    [FUNCTION_RECON] Processing method: get_statistics
      [RETURN_TYPE] Found return type: Dict[str, Any]
    [FUNCTION_RECON] Stored method: inheritence_complex.ProcessorProtocol.get_statistics
      [CLASS_CONTEXT] Exiting class: inheritence_complex.ProcessorProtocol
    [CLASS_FINALIZE] Updated inheritence_complex.ProcessorProtocol with 0 attributes
    [RECON_CLASS] Completed class analysis: ProcessorProtocol
    [RECON_CLASS] Starting class analysis: GenericProcessor
    [CLASS_RECON] Processing class: GenericProcessor
    [CLASS_RECON] Stored class: inheritence_complex.GenericProcessor with 0 parents
      [CLASS_CONTEXT] Entered class: inheritence_complex.GenericProcessor
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] input_type: type
      [PARAM_TYPE] output_type: type
    [FUNCTION_RECON] Stored method: inheritence_complex.GenericProcessor.__init__
    [FUNCTION_RECON] Processing method: process_typed_data
      [RETURN_TYPE] Found return type: U
      [PARAM_TYPE] data: T
    [FUNCTION_RECON] Stored method: inheritence_complex.GenericProcessor.process_typed_data
    [FUNCTION_RECON] Processing method: _create_type_converter
      [RETURN_TYPE] Found return type: callable
      [PARAM_TYPE] from_type: type
      [PARAM_TYPE] to_type: type
    [FUNCTION_RECON] Stored method: inheritence_complex.GenericProcessor._create_type_converter
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter input_type has type hint: type
      [INIT_PARAM] Parameter output_type has type hint: type
    [INIT_ANALYSIS] Found 2 parameter type hints
      [ATTR_FROM_PARAM] input_type = input_type : type
      [ATTR_FROM_PARAM] output_type = output_type : type
      [ATTR_ANNOT] type_conversion_cache: Dict[str, Any]
    [INIT_ATTRS] Found 3 attributes
      [CLASS_ATTR] Added attribute input_type to inheritence_complex.GenericProcessor: {'type': 'type'}
      [CLASS_ATTR] Added attribute output_type to inheritence_complex.GenericProcessor: {'type': 'type'}
      [CLASS_ATTR] Added attribute type_conversion_cache to inheritence_complex.GenericProcessor: {'type': 'Dict[str, Any]'}
      [CLASS_CONTEXT] Exiting class: inheritence_complex.GenericProcessor
    [CLASS_FINALIZE] Updated inheritence_complex.GenericProcessor with 3 attributes
    [RECON_CLASS] Completed class analysis: GenericProcessor
    [RECON_CLASS] Starting class analysis: UltimateProcessor
    [CLASS_RECON] Processing class: UltimateProcessor
      [INHERITANCE] Simple parent: SpecializedProcessor
    [CLASS_RECON] Stored class: inheritence_complex.UltimateProcessor with 1 parents
      [CLASS_CONTEXT] Entered class: inheritence_complex.UltimateProcessor
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] processor_id: str
    [FUNCTION_RECON] Stored method: inheritence_complex.UltimateProcessor.__init__
    [FUNCTION_RECON] Processing method: ultimate_process
      [RETURN_TYPE] Found return type: ProcessingResult
      [PARAM_TYPE] data: Dict[str, Any]
    [FUNCTION_RECON] Stored method: inheritence_complex.UltimateProcessor.ultimate_process
    [FUNCTION_RECON] Processing method: _apply_ultimate_enhancements
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] data: Any
    [FUNCTION_RECON] Stored method: inheritence_complex.UltimateProcessor._apply_ultimate_enhancements
    [FUNCTION_RECON] Processing method: ultimate_processing_context
    [FUNCTION_RECON] Stored method: inheritence_complex.UltimateProcessor.ultimate_processing_context
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter processor_id has type hint: str
    [INIT_ANALYSIS] Found 1 parameter type hints
      [ATTR_FROM_VALUE] ultimate_features_enabled inferred as: int
      [ATTR_ANNOT] cross_references: Dict[str, Any]
    [INIT_ATTRS] Found 2 attributes
      [CLASS_ATTR] Added attribute ultimate_features_enabled to inheritence_complex.UltimateProcessor: {'type': 'int'}
      [CLASS_ATTR] Added attribute cross_references to inheritence_complex.UltimateProcessor: {'type': 'Dict[str, Any]'}
      [CLASS_CONTEXT] Exiting class: inheritence_complex.UltimateProcessor
    [CLASS_FINALIZE] Updated inheritence_complex.UltimateProcessor with 2 attributes
    [RECON_CLASS] Completed class analysis: UltimateProcessor
    [FUNCTION_RECON] Processing function: create_processor_hierarchy
      [RETURN_TYPE] Found return type: Dict[str, AbstractProcessor]
      [PARAM_TYPE] processor_configs: List[Dict[str, Any]]
    [FUNCTION_RECON] Stored function: inheritence_complex.create_processor_hierarchy
      [IMPORT] Processing direct imports
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] ultimate_processor: UltimateProcessor
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] test_data: Unknown
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] result: ultimate_processor.ultimate_process
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] stats: ultimate_processor.get_statistics
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] cache_stats: ultimate_processor.get_cache_statistics
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] metric_summary: ultimate_processor.get_metric_summary
    [RECON_FINALIZE] Collecting results from specialized visitors
  [RECON_SUMMARY] Found 13 classes
  [RECON_SUMMARY] Found 46 functions/methods
  [RECON_SUMMARY] Found 8 state variables
  [RECON_SUMMARY] Found 0 external classes
  [RECON_SUMMARY] Found 0 external functions
    Found 13 classes
    Found 46 functions/methods
    Found 8 state variables
    Found 0 external classes
    Found 0 external functions
  === Analyzing proxy_handler.py ===
  [RECON_INIT] Initialized refactored reconnaissance for module: proxy_handler
      [IMPORT] Processing direct imports
    [EXTERNAL_MODULE] Direct import: threading
      [IMPORT] Processing direct imports
      [STATE_ASSIGN] Processing module-level assignment
    [MODULE_STATE] T: TypeVar
    [RECON_CLASS] Starting class analysis: ProxyConfig
    [CLASS_RECON] Processing class: ProxyConfig
    [CLASS_RECON] Stored class: proxy_handler.ProxyConfig with 0 parents
      [CLASS_CONTEXT] Entered class: proxy_handler.ProxyConfig
      [CLASS_ATTR] Added attribute cache_enabled to proxy_handler.ProxyConfig: {'type': 'bool'}
      [CLASS_ANN_ATTR] cache_enabled: bool
      [CLASS_ATTR] Added attribute logging_enabled to proxy_handler.ProxyConfig: {'type': 'bool'}
      [CLASS_ANN_ATTR] logging_enabled: bool
      [CLASS_ATTR] Added attribute metrics_enabled to proxy_handler.ProxyConfig: {'type': 'bool'}
      [CLASS_ANN_ATTR] metrics_enabled: bool
      [CLASS_ATTR] Added attribute timeout_seconds to proxy_handler.ProxyConfig: {'type': 'float'}
      [CLASS_ANN_ATTR] timeout_seconds: float
      [CLASS_ATTR] Added attribute retry_attempts to proxy_handler.ProxyConfig: {'type': 'int'}
      [CLASS_ANN_ATTR] retry_attempts: int
      [CLASS_ATTR] Added attribute circuit_breaker_enabled to proxy_handler.ProxyConfig: {'type': 'bool'}
      [CLASS_ANN_ATTR] circuit_breaker_enabled: bool
      [CLASS_CONTEXT] Exiting class: proxy_handler.ProxyConfig
    [CLASS_FINALIZE] Updated proxy_handler.ProxyConfig with 6 attributes
    [RECON_CLASS] Completed class analysis: ProxyConfig
    [RECON_CLASS] Starting class analysis: ProxyMetrics
    [CLASS_RECON] Processing class: ProxyMetrics
    [CLASS_RECON] Stored class: proxy_handler.ProxyMetrics with 0 parents
      [CLASS_CONTEXT] Entered class: proxy_handler.ProxyMetrics
    [FUNCTION_RECON] Processing method: __init__
    [FUNCTION_RECON] Stored method: proxy_handler.ProxyMetrics.__init__
    [FUNCTION_RECON] Processing method: record_call
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] execution_time: float
      [PARAM_TYPE] success: bool
      [PARAM_TYPE] cache_hit: bool
    [FUNCTION_RECON] Stored method: proxy_handler.ProxyMetrics.record_call
    [FUNCTION_RECON] Processing method: get_success_rate
      [RETURN_TYPE] Found return type: float
    [FUNCTION_RECON] Stored method: proxy_handler.ProxyMetrics.get_success_rate
    [FUNCTION_RECON] Processing method: get_cache_hit_rate
      [RETURN_TYPE] Found return type: float
    [FUNCTION_RECON] Stored method: proxy_handler.ProxyMetrics.get_cache_hit_rate
    [INIT_ATTRS] Extracting attributes from __init__
    [INIT_ANALYSIS] Found 0 parameter type hints
      [ATTR_FROM_VALUE] call_count inferred as: int
      [ATTR_FROM_VALUE] success_count inferred as: int
      [ATTR_FROM_VALUE] error_count inferred as: int
      [ATTR_FROM_VALUE] cache_hits inferred as: int
      [ATTR_FROM_VALUE] cache_misses inferred as: int
      [ATTR_FROM_VALUE] total_execution_time inferred as: float
      [ATTR_FROM_VALUE] average_execution_time inferred as: float
      [ATTR_ANNOT] last_error_time: Optional[float]
      [ATTR_ANNOT] last_success_time: Optional[float]
    [INIT_ATTRS] Found 9 attributes
      [CLASS_ATTR] Added attribute call_count to proxy_handler.ProxyMetrics: {'type': 'int'}
      [CLASS_ATTR] Added attribute success_count to proxy_handler.ProxyMetrics: {'type': 'int'}
      [CLASS_ATTR] Added attribute error_count to proxy_handler.ProxyMetrics: {'type': 'int'}
      [CLASS_ATTR] Added attribute cache_hits to proxy_handler.ProxyMetrics: {'type': 'int'}
      [CLASS_ATTR] Added attribute cache_misses to proxy_handler.ProxyMetrics: {'type': 'int'}
      [CLASS_ATTR] Added attribute total_execution_time to proxy_handler.ProxyMetrics: {'type': 'float'}
      [CLASS_ATTR] Added attribute average_execution_time to proxy_handler.ProxyMetrics: {'type': 'float'}
      [CLASS_ATTR] Added attribute last_error_time to proxy_handler.ProxyMetrics: {'type': 'Optional[float]'}
      [CLASS_ATTR] Added attribute last_success_time to proxy_handler.ProxyMetrics: {'type': 'Optional[float]'}
      [CLASS_CONTEXT] Exiting class: proxy_handler.ProxyMetrics
    [CLASS_FINALIZE] Updated proxy_handler.ProxyMetrics with 9 attributes
    [RECON_CLASS] Completed class analysis: ProxyMetrics
    [RECON_CLASS] Starting class analysis: BaseProxy
    [CLASS_RECON] Processing class: BaseProxy
      [INHERITANCE] Simple parent: ABC
    [CLASS_RECON] Stored class: proxy_handler.BaseProxy with 1 parents
      [CLASS_CONTEXT] Entered class: proxy_handler.BaseProxy
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] target: Any
      [PARAM_TYPE] config: ProxyConfig
    [FUNCTION_RECON] Stored method: proxy_handler.BaseProxy.__init__
    [FUNCTION_RECON] Processing method: _proxy_method_call
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] method_name: str
    [FUNCTION_RECON] Stored method: proxy_handler.BaseProxy._proxy_method_call
    [FUNCTION_RECON] Processing method: __getattr__
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] name: str
    [FUNCTION_RECON] Stored method: proxy_handler.BaseProxy.__getattr__
    [FUNCTION_RECON] Processing method: _create_proxy_method
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] method_name: str
      [PARAM_TYPE] original_method: Callable
    [FUNCTION_RECON] Stored method: proxy_handler.BaseProxy._create_proxy_method
    [FUNCTION_RECON] Processing method: _execute_with_circuit_breaker
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] method_name: str
      [PARAM_TYPE] method: Callable
    [FUNCTION_RECON] Stored method: proxy_handler.BaseProxy._execute_with_circuit_breaker
    [FUNCTION_RECON] Processing method: _get_cache_key
      [RETURN_TYPE] Found return type: str
      [PARAM_TYPE] method_name: str
    [FUNCTION_RECON] Stored method: proxy_handler.BaseProxy._get_cache_key
    [FUNCTION_RECON] Processing method: _metrics_context
      [PARAM_TYPE] method_name: str
    [FUNCTION_RECON] Stored method: proxy_handler.BaseProxy._metrics_context
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter target has type hint: Any
      [INIT_PARAM] Parameter config has type hint: ProxyConfig
    [INIT_ANALYSIS] Found 2 parameter type hints
      [ATTR_FROM_PARAM] target = target : Any
      [ATTR_FROM_VALUE] config inferred as: None
      [ATTR_FROM_VALUE] metrics inferred as: ProxyMetrics
      [ATTR_ANNOT] cache: Dict[str, Any]
      [ATTR_FROM_VALUE] lock inferred as: threading.RLock
      [ATTR_FROM_VALUE] circuit_breaker_open inferred as: int
      [ATTR_FROM_VALUE] circuit_breaker_failures inferred as: int
      [ATTR_FROM_VALUE] circuit_breaker_last_failure inferred as: float
    [INIT_ATTRS] Found 8 attributes
      [CLASS_ATTR] Added attribute target to proxy_handler.BaseProxy: {'type': 'Any'}
      [CLASS_ATTR] Added attribute config to proxy_handler.BaseProxy: {'type': 'Unknown'}
      [CLASS_ATTR] Added attribute metrics to proxy_handler.BaseProxy: {'type': 'ProxyMetrics'}
      [CLASS_ATTR] Added attribute cache to proxy_handler.BaseProxy: {'type': 'Dict[str, Any]'}
      [CLASS_ATTR] Added attribute lock to proxy_handler.BaseProxy: {'type': 'threading.RLock'}
      [CLASS_ATTR] Added attribute circuit_breaker_open to proxy_handler.BaseProxy: {'type': 'int'}
      [CLASS_ATTR] Added attribute circuit_breaker_failures to proxy_handler.BaseProxy: {'type': 'int'}
      [CLASS_ATTR] Added attribute circuit_breaker_last_failure to proxy_handler.BaseProxy: {'type': 'float'}
      [CLASS_CONTEXT] Exiting class: proxy_handler.BaseProxy
    [CLASS_FINALIZE] Updated proxy_handler.BaseProxy with 8 attributes
    [RECON_CLASS] Completed class analysis: BaseProxy
    [RECON_CLASS] Starting class analysis: DataProxy
    [CLASS_RECON] Processing class: DataProxy
      [INHERITANCE] Simple parent: BaseProxy
    [CLASS_RECON] Stored class: proxy_handler.DataProxy with 1 parents
      [CLASS_CONTEXT] Entered class: proxy_handler.DataProxy
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] data_source: Any
      [PARAM_TYPE] config: ProxyConfig
    [FUNCTION_RECON] Stored method: proxy_handler.DataProxy.__init__
    [FUNCTION_RECON] Processing method: _proxy_method_call
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] method_name: str
    [FUNCTION_RECON] Stored method: proxy_handler.DataProxy._proxy_method_call
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter data_source has type hint: Any
      [INIT_PARAM] Parameter config has type hint: ProxyConfig
    [INIT_ANALYSIS] Found 2 parameter type hints
      [ATTR_ANNOT] data_validators: Dict[str, List[Callable]]
      [ATTR_ANNOT] data_transformers: Dict[str, List[Callable]]
    [INIT_ATTRS] Found 2 attributes
      [CLASS_ATTR] Added attribute data_validators to proxy_handler.DataProxy: {'type': 'Dict[str, List[Callable]]'}
      [CLASS_ATTR] Added attribute data_transformers to proxy_handler.DataProxy: {'type': 'Dict[str, List[Callable]]'}
      [CLASS_CONTEXT] Exiting class: proxy_handler.DataProxy
    [CLASS_FINALIZE] Updated proxy_handler.DataProxy with 2 attributes
    [RECON_CLASS] Completed class analysis: DataProxy
    [RECON_CLASS] Starting class analysis: HavenProxy
    [CLASS_RECON] Processing class: HavenProxy
      [INHERITANCE] Simple parent: BaseProxy
    [CLASS_RECON] Stored class: proxy_handler.HavenProxy with 1 parents
      [CLASS_CONTEXT] Entered class: proxy_handler.HavenProxy
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] target: Any
      [PARAM_TYPE] config: ProxyConfig
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.__init__
    [FUNCTION_RECON] Processing method: validate_user_credentials
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] auth_data: Dict[str, Any]
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.validate_user_credentials
    [FUNCTION_RECON] Processing method: get_user_preferences
      [RETURN_TYPE] Found return type: Dict[str, Any]
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.get_user_preferences
    [FUNCTION_RECON] Processing method: validate_room_access
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] user_id: str
      [PARAM_TYPE] room_name: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.validate_room_access
    [FUNCTION_RECON] Processing method: get_user_info
      [RETURN_TYPE] Found return type: Dict[str, Any]
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.get_user_info
    [FUNCTION_RECON] Processing method: validate_admin_role
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.validate_admin_role
    [FUNCTION_RECON] Processing method: validate_moderator_role
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.validate_moderator_role
    [FUNCTION_RECON] Processing method: get_runner_capabilities
      [RETURN_TYPE] Found return type: Dict[str, Any]
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.get_runner_capabilities
    [FUNCTION_RECON] Processing method: get_guest_limitations
      [RETURN_TYPE] Found return type: Dict[str, Any]
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.get_guest_limitations
    [FUNCTION_RECON] Processing method: validate_message_content
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] message: str
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.validate_message_content
    [FUNCTION_RECON] Processing method: log_room_message
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] room: str
      [PARAM_TYPE] user_id: str
      [PARAM_TYPE] message: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.log_room_message
    [FUNCTION_RECON] Processing method: validate_direct_message_permission
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] sender_id: str
      [PARAM_TYPE] recipient_id: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.validate_direct_message_permission
    [FUNCTION_RECON] Processing method: validate_broadcast_permission
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.validate_broadcast_permission
    [FUNCTION_RECON] Processing method: get_room_statistics
      [RETURN_TYPE] Found return type: Dict[str, Any]
      [PARAM_TYPE] room_name: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.get_room_statistics
    [FUNCTION_RECON] Processing method: validate_event_data
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] event_name: str
      [PARAM_TYPE] data: Dict[str, Any]
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.validate_event_data
    [FUNCTION_RECON] Processing method: process_event
      [RETURN_TYPE] Found return type: Dict[str, Any]
      [PARAM_TYPE] event_name: str
      [PARAM_TYPE] data: Dict[str, Any]
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.process_event
    [FUNCTION_RECON] Processing method: user_exists
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy.user_exists
    [FUNCTION_RECON] Processing method: _proxy_method_call
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] method_name: str
    [FUNCTION_RECON] Stored method: proxy_handler.HavenProxy._proxy_method_call
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter target has type hint: Any
      [INIT_PARAM] Parameter config has type hint: ProxyConfig
    [INIT_ANALYSIS] Found 2 parameter type hints
      [ATTR_ANNOT] user_cache: Dict[str, Any]
      [ATTR_ANNOT] room_permissions: Dict[str, Set[str]]
    [INIT_ATTRS] Found 2 attributes
      [CLASS_ATTR] Added attribute user_cache to proxy_handler.HavenProxy: {'type': 'Dict[str, Any]'}
      [CLASS_ATTR] Added attribute room_permissions to proxy_handler.HavenProxy: {'type': 'Dict[str, Set[str]]'}
      [CLASS_CONTEXT] Exiting class: proxy_handler.HavenProxy
    [CLASS_FINALIZE] Updated proxy_handler.HavenProxy with 2 attributes
    [RECON_CLASS] Completed class analysis: HavenProxy
    [RECON_CLASS] Starting class analysis: UserProxy
    [CLASS_RECON] Processing class: UserProxy
      [INHERITANCE] Simple parent: BaseProxy
    [CLASS_RECON] Stored class: proxy_handler.UserProxy with 1 parents
      [CLASS_CONTEXT] Entered class: proxy_handler.UserProxy
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] user_data: Dict[str, Any]
      [PARAM_TYPE] config: ProxyConfig
    [FUNCTION_RECON] Stored method: proxy_handler.UserProxy.__init__
    [FUNCTION_RECON] Processing method: has_role
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] role: str
    [FUNCTION_RECON] Stored method: proxy_handler.UserProxy.has_role
    [FUNCTION_RECON] Processing method: id
      [RETURN_TYPE] Found return type: str
    [FUNCTION_RECON] Stored method: proxy_handler.UserProxy.id
    [FUNCTION_RECON] Processing method: _proxy_method_call
      [RETURN_TYPE] Found return type: Any
      [PARAM_TYPE] method_name: str
    [FUNCTION_RECON] Stored method: proxy_handler.UserProxy._proxy_method_call
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter user_data has type hint: Dict[str, Any]
      [INIT_PARAM] Parameter config has type hint: ProxyConfig
    [INIT_ANALYSIS] Found 2 parameter type hints
      [ATTR_FROM_PARAM] user_data = user_data : Dict[str, Any]
    [INIT_ATTRS] Found 1 attributes
      [CLASS_ATTR] Added attribute user_data to proxy_handler.UserProxy: {'type': 'Dict[str, Any]'}
      [CLASS_CONTEXT] Exiting class: proxy_handler.UserProxy
    [CLASS_FINALIZE] Updated proxy_handler.UserProxy with 1 attributes
    [RECON_CLASS] Completed class analysis: UserProxy
    [RECON_FINALIZE] Collecting results from specialized visitors
  [RECON_SUMMARY] Found 6 classes
  [RECON_SUMMARY] Found 35 functions/methods
  [RECON_SUMMARY] Found 1 state variables
  [RECON_SUMMARY] Found 0 external classes
  [RECON_SUMMARY] Found 0 external functions
    Found 6 classes
    Found 35 functions/methods
    Found 1 state variables
    Found 0 external classes
    Found 0 external functions
  === Analyzing session_manager.py ===
  [RECON_INIT] Initialized refactored reconnaissance for module: session_manager
      [IMPORT] Processing direct imports
    [EXTERNAL_MODULE] Direct import: uuid
      [IMPORT] Processing direct imports
    [EXTERNAL_MODULE] Direct import: threading
    [RECON_CLASS] Starting class analysis: SessionState
    [CLASS_RECON] Processing class: SessionState
      [INHERITANCE] Simple parent: Enum
    [CLASS_RECON] Stored class: session_manager.SessionState with 1 parents
      [CLASS_CONTEXT] Entered class: session_manager.SessionState
      [CLASS_ASSIGN] Processing class-level assignment in session_manager.SessionState
      [CLASS_ATTR] Added attribute CREATED to session_manager.SessionState: {'type': 'auto'}
      [CLASS_ATTR] CREATED: auto
      [CLASS_ASSIGN] Processing class-level assignment in session_manager.SessionState
      [CLASS_ATTR] Added attribute ACTIVE to session_manager.SessionState: {'type': 'auto'}
      [CLASS_ATTR] ACTIVE: auto
      [CLASS_ASSIGN] Processing class-level assignment in session_manager.SessionState
      [CLASS_ATTR] Added attribute IDLE to session_manager.SessionState: {'type': 'auto'}
      [CLASS_ATTR] IDLE: auto
      [CLASS_ASSIGN] Processing class-level assignment in session_manager.SessionState
      [CLASS_ATTR] Added attribute SUSPENDED to session_manager.SessionState: {'type': 'auto'}
      [CLASS_ATTR] SUSPENDED: auto
      [CLASS_ASSIGN] Processing class-level assignment in session_manager.SessionState
      [CLASS_ATTR] Added attribute EXPIRED to session_manager.SessionState: {'type': 'auto'}
      [CLASS_ATTR] EXPIRED: auto
      [CLASS_ASSIGN] Processing class-level assignment in session_manager.SessionState
      [CLASS_ATTR] Added attribute TERMINATED to session_manager.SessionState: {'type': 'auto'}
      [CLASS_ATTR] TERMINATED: auto
      [CLASS_CONTEXT] Exiting class: session_manager.SessionState
    [CLASS_FINALIZE] Updated session_manager.SessionState with 6 attributes
    [RECON_CLASS] Completed class analysis: SessionState
    [RECON_CLASS] Starting class analysis: UserRole
    [CLASS_RECON] Processing class: UserRole
      [INHERITANCE] Simple parent: Enum
    [CLASS_RECON] Stored class: session_manager.UserRole with 1 parents
      [CLASS_CONTEXT] Entered class: session_manager.UserRole
      [CLASS_ASSIGN] Processing class-level assignment in session_manager.UserRole
      [CLASS_ATTR] Added attribute GUEST to session_manager.UserRole: {'type': 'auto'}
      [CLASS_ATTR] GUEST: auto
      [CLASS_ASSIGN] Processing class-level assignment in session_manager.UserRole
      [CLASS_ATTR] Added attribute USER to session_manager.UserRole: {'type': 'auto'}
      [CLASS_ATTR] USER: auto
      [CLASS_ASSIGN] Processing class-level assignment in session_manager.UserRole
      [CLASS_ATTR] Added attribute MODERATOR to session_manager.UserRole: {'type': 'auto'}
      [CLASS_ATTR] MODERATOR: auto
      [CLASS_ASSIGN] Processing class-level assignment in session_manager.UserRole
      [CLASS_ATTR] Added attribute ADMIN to session_manager.UserRole: {'type': 'auto'}
      [CLASS_ATTR] ADMIN: auto
      [CLASS_ASSIGN] Processing class-level assignment in session_manager.UserRole
      [CLASS_ATTR] Added attribute SYSTEM to session_manager.UserRole: {'type': 'auto'}
      [CLASS_ATTR] SYSTEM: auto
      [CLASS_CONTEXT] Exiting class: session_manager.UserRole
    [CLASS_FINALIZE] Updated session_manager.UserRole with 5 attributes
    [RECON_CLASS] Completed class analysis: UserRole
    [RECON_CLASS] Starting class analysis: SessionMetrics
    [CLASS_RECON] Processing class: SessionMetrics
    [CLASS_RECON] Stored class: session_manager.SessionMetrics with 0 parents
      [CLASS_CONTEXT] Entered class: session_manager.SessionMetrics
      [CLASS_ATTR] Added attribute login_time to session_manager.SessionMetrics: {'type': 'datetime'}
      [CLASS_ANN_ATTR] login_time: datetime
      [CLASS_ATTR] Added attribute last_activity to session_manager.SessionMetrics: {'type': 'datetime'}
      [CLASS_ANN_ATTR] last_activity: datetime
      [CLASS_ATTR] Added attribute activity_count to session_manager.SessionMetrics: {'type': 'int'}
      [CLASS_ANN_ATTR] activity_count: int
      [CLASS_ATTR] Added attribute data_transferred to session_manager.SessionMetrics: {'type': 'int'}
      [CLASS_ANN_ATTR] data_transferred: int
      [CLASS_ATTR] Added attribute errors_encountered to session_manager.SessionMetrics: {'type': 'int'}
      [CLASS_ANN_ATTR] errors_encountered: int
      [CLASS_ATTR] Added attribute warnings_issued to session_manager.SessionMetrics: {'type': 'int'}
      [CLASS_ANN_ATTR] warnings_issued: int
      [CLASS_ATTR] Added attribute rooms_joined to session_manager.SessionMetrics: {'type': 'Set[str]'}
      [CLASS_ANN_ATTR] rooms_joined: Set[str]
      [CLASS_ATTR] Added attribute events_emitted to session_manager.SessionMetrics: {'type': 'int'}
      [CLASS_ANN_ATTR] events_emitted: int
      [CLASS_ATTR] Added attribute events_received to session_manager.SessionMetrics: {'type': 'int'}
      [CLASS_ANN_ATTR] events_received: int
      [CLASS_CONTEXT] Exiting class: session_manager.SessionMetrics
    [CLASS_FINALIZE] Updated session_manager.SessionMetrics with 9 attributes
    [RECON_CLASS] Completed class analysis: SessionMetrics
    [RECON_CLASS] Starting class analysis: UserSession
    [CLASS_RECON] Processing class: UserSession
    [CLASS_RECON] Stored class: session_manager.UserSession with 0 parents
      [CLASS_CONTEXT] Entered class: session_manager.UserSession
      [CLASS_ATTR] Added attribute session_id to session_manager.UserSession: {'type': 'str'}
      [CLASS_ANN_ATTR] session_id: str
      [CLASS_ATTR] Added attribute user_id to session_manager.UserSession: {'type': 'str'}
      [CLASS_ANN_ATTR] user_id: str
      [CLASS_ATTR] Added attribute user_role to session_manager.UserSession: {'type': 'UserRole'}
      [CLASS_ANN_ATTR] user_role: UserRole
      [CLASS_ATTR] Added attribute state to session_manager.UserSession: {'type': 'SessionState'}
      [CLASS_ANN_ATTR] state: SessionState
      [CLASS_ATTR] Added attribute created_at to session_manager.UserSession: {'type': 'datetime'}
      [CLASS_ANN_ATTR] created_at: datetime
      [CLASS_ATTR] Added attribute expires_at to session_manager.UserSession: {'type': 'datetime'}
      [CLASS_ANN_ATTR] expires_at: datetime
      [CLASS_ATTR] Added attribute last_activity to session_manager.UserSession: {'type': 'datetime'}
      [CLASS_ANN_ATTR] last_activity: datetime
      [CLASS_ATTR] Added attribute ip_address to session_manager.UserSession: {'type': 'str'}
      [CLASS_ANN_ATTR] ip_address: str
      [CLASS_ATTR] Added attribute user_agent to session_manager.UserSession: {'type': 'str'}
      [CLASS_ANN_ATTR] user_agent: str
      [CLASS_ATTR] Added attribute permissions to session_manager.UserSession: {'type': 'Set[str]'}
      [CLASS_ANN_ATTR] permissions: Set[str]
      [CLASS_ATTR] Added attribute preferences to session_manager.UserSession: {'type': 'Dict[str, Any]'}
      [CLASS_ANN_ATTR] preferences: Dict[str, Any]
      [CLASS_ATTR] Added attribute metrics to session_manager.UserSession: {'type': 'SessionMetrics'}
      [CLASS_ANN_ATTR] metrics: SessionMetrics
      [CLASS_ATTR] Added attribute context_data to session_manager.UserSession: {'type': 'Dict[str, Any]'}
      [CLASS_ANN_ATTR] context_data: Dict[str, Any]
    [FUNCTION_RECON] Processing method: is_valid
      [RETURN_TYPE] Found return type: bool
    [FUNCTION_RECON] Stored method: session_manager.UserSession.is_valid
    [FUNCTION_RECON] Processing method: is_expired
      [RETURN_TYPE] Found return type: bool
    [FUNCTION_RECON] Stored method: session_manager.UserSession.is_expired
    [FUNCTION_RECON] Processing method: time_until_expiry
      [RETURN_TYPE] Found return type: timedelta
    [FUNCTION_RECON] Stored method: session_manager.UserSession.time_until_expiry
    [FUNCTION_RECON] Processing method: update_activity
      [RETURN_TYPE] Found return type: None
    [FUNCTION_RECON] Stored method: session_manager.UserSession.update_activity
      [CLASS_CONTEXT] Exiting class: session_manager.UserSession
    [CLASS_FINALIZE] Updated session_manager.UserSession with 13 attributes
    [RECON_CLASS] Completed class analysis: UserSession
    [RECON_CLASS] Starting class analysis: SessionManager
    [CLASS_RECON] Processing class: SessionManager
    [CLASS_RECON] Stored class: session_manager.SessionManager with 0 parents
      [CLASS_CONTEXT] Entered class: session_manager.SessionManager
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] haven_proxy: HavenProxy
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.__init__
    [FUNCTION_RECON] Processing method: create_session
      [RETURN_TYPE] Found return type: str
      [PARAM_TYPE] user_id: Optional[str]
      [PARAM_TYPE] session_duration: timedelta
      [PARAM_TYPE] ip_address: str
      [PARAM_TYPE] user_agent: str
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.create_session
    [FUNCTION_RECON] Processing method: create_user_session
      [RETURN_TYPE] Found return type: UserSession
      [PARAM_TYPE] user_id: str
      [PARAM_TYPE] session_id: str
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.create_user_session
    [FUNCTION_RECON] Processing method: get_current_session
      [RETURN_TYPE] Found return type: Optional[UserSession]
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.get_current_session
    [FUNCTION_RECON] Processing method: get_current_session_id
      [RETURN_TYPE] Found return type: Optional[str]
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.get_current_session_id
    [FUNCTION_RECON] Processing method: get_current_user_id
      [RETURN_TYPE] Found return type: Optional[str]
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.get_current_user_id
    [FUNCTION_RECON] Processing method: get_current_user
      [RETURN_TYPE] Found return type: Optional[Any]
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.get_current_user
    [FUNCTION_RECON] Processing method: get_current_timestamp
      [RETURN_TYPE] Found return type: float
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.get_current_timestamp
    [FUNCTION_RECON] Processing method: validate_session
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] session_id: str
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.validate_session
    [FUNCTION_RECON] Processing method: validate_room_access
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] room_name: str
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.validate_room_access
    [FUNCTION_RECON] Processing method: get_user_room
      [RETURN_TYPE] Found return type: str
      [PARAM_TYPE] user_id: Optional[str]
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.get_user_room
    [FUNCTION_RECON] Processing method: get_user_rooms
      [RETURN_TYPE] Found return type: List[str]
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.get_user_rooms
    [FUNCTION_RECON] Processing method: get_active_users
      [RETURN_TYPE] Found return type: List[str]
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.get_active_users
    [FUNCTION_RECON] Processing method: cleanup_user_session
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.cleanup_user_session
    [FUNCTION_RECON] Processing method: destroy_session
      [RETURN_TYPE] Found return type: bool
      [PARAM_TYPE] session_id: str
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.destroy_session
    [FUNCTION_RECON] Processing method: _determine_user_role
      [RETURN_TYPE] Found return type: UserRole
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: session_manager.SessionManager._determine_user_role
    [FUNCTION_RECON] Processing method: _get_role_permissions
      [RETURN_TYPE] Found return type: Set[str]
      [PARAM_TYPE] role: UserRole
    [FUNCTION_RECON] Stored method: session_manager.SessionManager._get_role_permissions
    [FUNCTION_RECON] Processing method: _expire_session
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] session_id: str
    [FUNCTION_RECON] Stored method: session_manager.SessionManager._expire_session
    [FUNCTION_RECON] Processing method: _terminate_session
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] session_id: str
      [PARAM_TYPE] reason: str
    [FUNCTION_RECON] Stored method: session_manager.SessionManager._terminate_session
    [FUNCTION_RECON] Processing method: _trigger_event
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] event_name: str
      [PARAM_TYPE] session: UserSession
    [FUNCTION_RECON] Stored method: session_manager.SessionManager._trigger_event
    [FUNCTION_RECON] Processing method: get_session_statistics
      [RETURN_TYPE] Found return type: Dict[str, Any]
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.get_session_statistics
    [FUNCTION_RECON] Processing method: session_context
      [PARAM_TYPE] session_id: str
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.session_context
    [FUNCTION_RECON] Processing method: add_session_event_handler
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] event_name: str
      [PARAM_TYPE] handler: Callable
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.add_session_event_handler
    [FUNCTION_RECON] Processing method: periodic_cleanup
      [RETURN_TYPE] Found return type: Dict[str, int]
    [FUNCTION_RECON] Stored method: session_manager.SessionManager.periodic_cleanup
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter haven_proxy has type hint: HavenProxy
    [INIT_ANALYSIS] Found 1 parameter type hints
      [ATTR_FROM_PARAM] haven_proxy = haven_proxy : HavenProxy
      [ATTR_ANNOT] active_sessions: Dict[str, UserSession]
      [ATTR_ANNOT] user_sessions: Dict[str, List[str]]
      [ATTR_FROM_VALUE] session_lock inferred as: threading.RLock
      [ATTR_ANNOT] current_session_id: Optional[str]
      [ATTR_ANNOT] session_callbacks: Dict[str, List[Callable]]
      [ATTR_FROM_VALUE] cleanup_interval inferred as: int
      [ATTR_FROM_VALUE] max_sessions_per_user inferred as: int
      [ATTR_ANNOT] event_handlers: Dict[str, List[Callable]]
    [INIT_ATTRS] Found 9 attributes
      [CLASS_ATTR] Added attribute haven_proxy to session_manager.SessionManager: {'type': 'HavenProxy'}
      [CLASS_ATTR] Added attribute active_sessions to session_manager.SessionManager: {'type': 'Dict[str, UserSession]'}
      [CLASS_ATTR] Added attribute user_sessions to session_manager.SessionManager: {'type': 'Dict[str, List[str]]'}
      [CLASS_ATTR] Added attribute session_lock to session_manager.SessionManager: {'type': 'threading.RLock'}
      [CLASS_ATTR] Added attribute current_session_id to session_manager.SessionManager: {'type': 'Optional[str]'}
      [CLASS_ATTR] Added attribute session_callbacks to session_manager.SessionManager: {'type': 'Dict[str, List[Callable]]'}
      [CLASS_ATTR] Added attribute cleanup_interval to session_manager.SessionManager: {'type': 'int'}
      [CLASS_ATTR] Added attribute max_sessions_per_user to session_manager.SessionManager: {'type': 'int'}
      [CLASS_ATTR] Added attribute event_handlers to session_manager.SessionManager: {'type': 'Dict[str, List[Callable]]'}
      [CLASS_CONTEXT] Exiting class: session_manager.SessionManager
    [CLASS_FINALIZE] Updated session_manager.SessionManager with 9 attributes
    [RECON_CLASS] Completed class analysis: SessionManager
    [MODULE_ANN_STATE] _global_session_manager: Optional[SessionManager]
    [FUNCTION_RECON] Processing function: initialize_session_manager
      [RETURN_TYPE] Found return type: SessionManager
      [PARAM_TYPE] haven_proxy: HavenProxy
    [FUNCTION_RECON] Stored function: session_manager.initialize_session_manager
    [FUNCTION_RECON] Processing function: get_current_session
      [RETURN_TYPE] Found return type: Optional[UserSession]
    [FUNCTION_RECON] Stored function: session_manager.get_current_session
    [FUNCTION_RECON] Processing function: get_current_user
      [RETURN_TYPE] Found return type: Optional[Any]
    [FUNCTION_RECON] Stored function: session_manager.get_current_user
    [FUNCTION_RECON] Processing function: get_current_user_id
      [RETURN_TYPE] Found return type: Optional[str]
    [FUNCTION_RECON] Stored function: session_manager.get_current_user_id
    [RECON_CLASS] Starting class analysis: SessionInteractionManager
    [CLASS_RECON] Processing class: SessionInteractionManager
    [CLASS_RECON] Stored class: session_manager.SessionInteractionManager with 0 parents
      [CLASS_CONTEXT] Entered class: session_manager.SessionInteractionManager
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] session_manager: SessionManager
    [FUNCTION_RECON] Stored method: session_manager.SessionInteractionManager.__init__
    [FUNCTION_RECON] Processing method: record_user_interaction
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] user1_id: str
      [PARAM_TYPE] user2_id: str
      [PARAM_TYPE] interaction_type: str
      [PARAM_TYPE] data: Dict[str, Any]
    [FUNCTION_RECON] Stored method: session_manager.SessionInteractionManager.record_user_interaction
    [FUNCTION_RECON] Processing method: _get_user_session
      [RETURN_TYPE] Found return type: Optional[UserSession]
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: session_manager.SessionInteractionManager._get_user_session
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter session_manager has type hint: SessionManager
    [INIT_ANALYSIS] Found 1 parameter type hints
      [ATTR_FROM_PARAM] session_manager = session_manager : SessionManager
      [ATTR_ANNOT] interaction_log: List[Dict[str, Any]]
      [ATTR_ANNOT] user_relationships: Dict[str, Set[str]]
      [ATTR_FROM_VALUE] session_analytics inferred as: SessionAnalytics
    [INIT_ATTRS] Found 4 attributes
      [CLASS_ATTR] Added attribute session_manager to session_manager.SessionInteractionManager: {'type': 'SessionManager'}
      [CLASS_ATTR] Added attribute interaction_log to session_manager.SessionInteractionManager: {'type': 'List[Dict[str, Any]]'}
      [CLASS_ATTR] Added attribute user_relationships to session_manager.SessionInteractionManager: {'type': 'Dict[str, Set[str]]'}
      [CLASS_ATTR] Added attribute session_analytics to session_manager.SessionInteractionManager: {'type': 'SessionAnalytics'}
      [CLASS_CONTEXT] Exiting class: session_manager.SessionInteractionManager
    [CLASS_FINALIZE] Updated session_manager.SessionInteractionManager with 4 attributes
    [RECON_CLASS] Completed class analysis: SessionInteractionManager
    [RECON_CLASS] Starting class analysis: SessionAnalytics
    [CLASS_RECON] Processing class: SessionAnalytics
    [CLASS_RECON] Stored class: session_manager.SessionAnalytics with 0 parents
      [CLASS_CONTEXT] Entered class: session_manager.SessionAnalytics
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] session_manager: SessionManager
    [FUNCTION_RECON] Stored method: session_manager.SessionAnalytics.__init__
    [FUNCTION_RECON] Processing method: compute_user_engagement_score
      [RETURN_TYPE] Found return type: float
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: session_manager.SessionAnalytics.compute_user_engagement_score
    [FUNCTION_RECON] Processing method: _get_user_session
      [RETURN_TYPE] Found return type: Optional[UserSession]
      [PARAM_TYPE] user_id: str
    [FUNCTION_RECON] Stored method: session_manager.SessionAnalytics._get_user_session
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter session_manager has type hint: SessionManager
    [INIT_ANALYSIS] Found 1 parameter type hints
      [ATTR_FROM_PARAM] session_manager = session_manager : SessionManager
      [ATTR_ANNOT] analytics_cache: Dict[str, Any]
    [INIT_ATTRS] Found 2 attributes
      [CLASS_ATTR] Added attribute session_manager to session_manager.SessionAnalytics: {'type': 'SessionManager'}
      [CLASS_ATTR] Added attribute analytics_cache to session_manager.SessionAnalytics: {'type': 'Dict[str, Any]'}
      [CLASS_CONTEXT] Exiting class: session_manager.SessionAnalytics
    [CLASS_FINALIZE] Updated session_manager.SessionAnalytics with 2 attributes
    [RECON_CLASS] Completed class analysis: SessionAnalytics
    [RECON_FINALIZE] Collecting results from specialized visitors
  [RECON_SUMMARY] Found 7 classes
  [RECON_SUMMARY] Found 38 functions/methods
  [RECON_SUMMARY] Found 1 state variables
  [RECON_SUMMARY] Found 0 external classes
  [RECON_SUMMARY] Found 0 external functions
    Found 7 classes
    Found 38 functions/methods
    Found 1 state variables
    Found 0 external classes
    Found 0 external functions
  === Analyzing socketio_events.py ===
  [RECON_INIT] Initialized refactored reconnaissance for module: socketio_events
      [IMPORT] Processing direct imports
    [EXTERNAL_IMPORT] Processing from flask_socketio
    [EXTERNAL_CLASS] Added: flask_socketio.SocketIO (alias: SocketIO)
    [EXTERNAL_FUNCTION] Added: flask_socketio.emit (alias: emit)
    [EXTERNAL_FUNCTION] Added: flask_socketio.disconnect (alias: disconnect)
    [EXTERNAL_FUNCTION] Added: flask_socketio.join_room (alias: join_room)
    [EXTERNAL_FUNCTION] Added: flask_socketio.leave_room (alias: leave_room)
    [MODULE_ANN_STATE] _socketio_instance: Optional[SocketIO]
    [MODULE_ANN_STATE] _haven_proxy: Optional[HavenProxy]
    [MODULE_ANN_STATE] _session_manager: Optional[SessionManager]
    [MODULE_ANN_STATE] EVENT_HANDLERS: Dict[str, Callable]
    [MODULE_ANN_STATE] ACTIVE_ROOMS: Dict[str, List[str]]
    [RECON_CLASS] Starting class analysis: SocketIOEventRegistry
    [CLASS_RECON] Processing class: SocketIOEventRegistry
    [CLASS_RECON] Stored class: socketio_events.SocketIOEventRegistry with 0 parents
      [CLASS_CONTEXT] Entered class: socketio_events.SocketIOEventRegistry
    [FUNCTION_RECON] Processing method: __init__
      [PARAM_TYPE] socketio: SocketIO
      [PARAM_TYPE] session_manager: SessionManager
    [FUNCTION_RECON] Stored method: socketio_events.SocketIOEventRegistry.__init__
    [FUNCTION_RECON] Processing method: register_dynamic_event
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] event_name: str
      [PARAM_TYPE] handler: Callable
    [FUNCTION_RECON] Stored method: socketio_events.SocketIOEventRegistry.register_dynamic_event
    [FUNCTION_RECON] Processing method: batch_register_events
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] event_configs: List[Dict[str, Any]]
    [FUNCTION_RECON] Stored method: socketio_events.SocketIOEventRegistry.batch_register_events
    [FUNCTION_RECON] Processing method: create_event_handler
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] config: Dict[str, Any]
    [FUNCTION_RECON] Stored method: socketio_events.SocketIOEventRegistry.create_event_handler
    [FUNCTION_RECON] Processing method: _create_room_handler
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] config: Dict[str, Any]
    [FUNCTION_RECON] Stored method: socketio_events.SocketIOEventRegistry._create_room_handler
    [FUNCTION_RECON] Processing method: _create_broadcast_handler
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] config: Dict[str, Any]
    [FUNCTION_RECON] Stored method: socketio_events.SocketIOEventRegistry._create_broadcast_handler
    [INIT_ATTRS] Extracting attributes from __init__
      [INIT_PARAM] Parameter socketio has type hint: SocketIO
      [INIT_PARAM] Parameter session_manager has type hint: SessionManager
    [INIT_ANALYSIS] Found 2 parameter type hints
      [ATTR_FROM_PARAM] socketio = socketio : SocketIO
      [ATTR_FROM_PARAM] session_manager = session_manager : SessionManager
      [ATTR_FROM_VALUE] event_validator inferred as: EventValidator
      [ATTR_FROM_VALUE] message_validator inferred as: MessageValidator
      [ATTR_ANNOT] registered_events: Dict[str, Callable]
      [ATTR_ANNOT] middleware_stack: List[Callable]
    [INIT_ATTRS] Found 6 attributes
      [CLASS_ATTR] Added attribute socketio to socketio_events.SocketIOEventRegistry: {'type': 'SocketIO'}
      [CLASS_ATTR] Added attribute session_manager to socketio_events.SocketIOEventRegistry: {'type': 'SessionManager'}
      [CLASS_ATTR] Added attribute event_validator to socketio_events.SocketIOEventRegistry: {'type': 'EventValidator'}
      [CLASS_ATTR] Added attribute message_validator to socketio_events.SocketIOEventRegistry: {'type': 'MessageValidator'}
      [CLASS_ATTR] Added attribute registered_events to socketio_events.SocketIOEventRegistry: {'type': 'Dict[str, Callable]'}
      [CLASS_ATTR] Added attribute middleware_stack to socketio_events.SocketIOEventRegistry: {'type': 'List[Callable]'}
      [CLASS_CONTEXT] Exiting class: socketio_events.SocketIOEventRegistry
    [CLASS_FINALIZE] Updated socketio_events.SocketIOEventRegistry with 6 attributes
    [RECON_CLASS] Completed class analysis: SocketIOEventRegistry
    [FUNCTION_RECON] Processing function: register_events
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] socketio: SocketIO
      [PARAM_TYPE] haven_proxy: HavenProxy
    [FUNCTION_RECON] Stored function: socketio_events.register_events
    [FUNCTION_RECON] Processing function: create_dynamic_handler
      [RETURN_TYPE] Found return type: Callable
      [PARAM_TYPE] event_name: str
      [PARAM_TYPE] proxy: HavenProxy
      [PARAM_TYPE] session_manager: SessionManager
    [FUNCTION_RECON] Stored function: socketio_events.create_dynamic_handler
    [FUNCTION_RECON] Processing function: emergency_broadcast
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] message: str
      [PARAM_TYPE] severity: str
    [FUNCTION_RECON] Stored function: socketio_events.emergency_broadcast
    [FUNCTION_RECON] Processing function: admin_notification
      [RETURN_TYPE] Found return type: None
      [PARAM_TYPE] admin_id: str
      [PARAM_TYPE] notification: Dict[str, Any]
    [FUNCTION_RECON] Stored function: socketio_events.admin_notification
    [RECON_FINALIZE] Collecting results from specialized visitors
  [RECON_SUMMARY] Found 1 classes
  [RECON_SUMMARY] Found 10 functions/methods
  [RECON_SUMMARY] Found 5 state variables
  [RECON_SUMMARY] Found 1 external classes
  [RECON_SUMMARY] Found 4 external functions
    Found 1 classes
    Found 10 functions/methods
    Found 5 state variables
    Found 1 external classes
    Found 4 external functions
  
=== PROCESSING INHERITANCE RELATIONSHIPS ===
  Processing admin_manager.OperationType with parents: ['Enum']
      Resolving parent: Enum
      -> Could not resolve parent: Enum
  Processing admin_manager.OperationStatus with parents: ['Enum']
      Resolving parent: Enum
      -> Could not resolve parent: Enum
  Processing admin_manager.OperationResult with parents: []
  Processing admin_manager.AdminManager with parents: []
  Processing database_manager.DatabaseConnection with parents: []
  Processing database_manager.TransactionManager with parents: []
  Processing decorators.DecoratorRegistry with parents: []
  Processing decorators.ClassBasedDecorator with parents: []
  Processing decorators.PropertyDecorator with parents: []
  Processing event_validator.ValidationLevel with parents: ['Enum']
      Resolving parent: Enum
      -> Could not resolve parent: Enum
  Processing event_validator.ValidationResult with parents: ['Enum']
      Resolving parent: Enum
      -> Could not resolve parent: Enum
  Processing event_validator.ValidationError with parents: []
  Processing event_validator.ValidationReport with parents: []
  Processing event_validator.ValidationRule with parents: ['Protocol']
      Resolving parent: Protocol
      -> Could not resolve parent: Protocol
  Processing event_validator.BaseValidationRule with parents: ['ABC']
      Resolving parent: ABC
      -> Could not resolve parent: ABC
  Processing event_validator.RequiredFieldRule with parents: ['BaseValidationRule']
      Resolving parent: BaseValidationRule
        -> Resolved to: event_validator.BaseValidationRule
  Processing event_validator.DataTypeRule with parents: ['BaseValidationRule']
      Resolving parent: BaseValidationRule
        -> Resolved to: event_validator.BaseValidationRule
  Processing event_validator.RegexValidationRule with parents: ['BaseValidationRule']
      Resolving parent: BaseValidationRule
        -> Resolved to: event_validator.BaseValidationRule
  Processing event_validator.ValidationEngine with parents: []
  Processing event_validator.ValidationRuleBuilder with parents: []
  Processing event_validator.EventValidator with parents: []
  Processing event_validator.MessageValidator with parents: []
  Processing inheritence_complex.Priority with parents: ['Enum']
      Resolving parent: Enum
      -> Could not resolve parent: Enum
  Processing inheritence_complex.ProcessingResult with parents: []
  Processing inheritence_complex.AbstractProcessor with parents: ['ABC']
      Resolving parent: ABC
      -> Could not resolve parent: ABC
  Processing inheritence_complex.AsyncProcessor with parents: ['AbstractProcessor']
      Resolving parent: AbstractProcessor
        -> Resolved to: inheritence_complex.AbstractProcessor
  Processing inheritence_complex.CacheableMixin with parents: []
  Processing inheritence_complex.ValidatedMixin with parents: []
  Processing inheritence_complex.MetricsMixin with parents: []
  Processing inheritence_complex.BasicDataProcessor with parents: ['AsyncProcessor', 'CacheableMixin', 'ValidatedMixin']
      Resolving parent: AsyncProcessor
        -> Resolved to: inheritence_complex.AsyncProcessor
      Resolving parent: CacheableMixin
        -> Resolved to: inheritence_complex.CacheableMixin
      Resolving parent: ValidatedMixin
        -> Resolved to: inheritence_complex.ValidatedMixin
  Processing inheritence_complex.AdvancedProcessor with parents: ['BasicDataProcessor', 'MetricsMixin']
      Resolving parent: BasicDataProcessor
        -> Resolved to: inheritence_complex.BasicDataProcessor
      Resolving parent: MetricsMixin
        -> Resolved to: inheritence_complex.MetricsMixin
  Processing inheritence_complex.SpecializedProcessor with parents: ['AdvancedProcessor']
      Resolving parent: AdvancedProcessor
        -> Resolved to: inheritence_complex.AdvancedProcessor
  Processing inheritence_complex.ProcessorProtocol with parents: ['Protocol']
      Resolving parent: Protocol
      -> Could not resolve parent: Protocol
  Processing inheritence_complex.GenericProcessor with parents: []
  Processing inheritence_complex.UltimateProcessor with parents: ['SpecializedProcessor']
      Resolving parent: SpecializedProcessor
        -> Resolved to: inheritence_complex.SpecializedProcessor
  Processing proxy_handler.ProxyConfig with parents: []
  Processing proxy_handler.ProxyMetrics with parents: []
  Processing proxy_handler.BaseProxy with parents: ['ABC']
      Resolving parent: ABC
      -> Could not resolve parent: ABC
  Processing proxy_handler.DataProxy with parents: ['BaseProxy']
      Resolving parent: BaseProxy
        -> Resolved to: proxy_handler.BaseProxy
  Processing proxy_handler.HavenProxy with parents: ['BaseProxy']
      Resolving parent: BaseProxy
        -> Resolved to: proxy_handler.BaseProxy
  Processing proxy_handler.UserProxy with parents: ['BaseProxy']
      Resolving parent: BaseProxy
        -> Resolved to: proxy_handler.BaseProxy
  Processing session_manager.SessionState with parents: ['Enum']
      Resolving parent: Enum
      -> Could not resolve parent: Enum
  Processing session_manager.UserRole with parents: ['Enum']
      Resolving parent: Enum
      -> Could not resolve parent: Enum
  Processing session_manager.SessionMetrics with parents: []
  Processing session_manager.UserSession with parents: []
  Processing session_manager.SessionManager with parents: []
  Processing session_manager.SessionInteractionManager with parents: []
  Processing session_manager.SessionAnalytics with parents: []
  Processing socketio_events.SocketIOEventRegistry with parents: []
  === REFACTORED RECONNAISSANCE PASS COMPLETE ===
Running analysis pass (refactored)...
Log level set to 3
=== USING REFACTORED ANALYSIS PASS ===
=== ANALYSIS PASS START (Refactored Architecture) ===
=== Analyzing admin_manager.py ===
  [RESOLVER] Using implementation: refactored
=== Starting Module Analysis ===
    [FROM_IMPORT] Any -> typing.Any
    [FROM_IMPORT] Dict -> typing.Dict
    [FROM_IMPORT] List -> typing.List
    [FROM_IMPORT] Optional -> typing.Optional
    [FROM_IMPORT] Set -> typing.Set
    [FROM_IMPORT] Union -> typing.Union
    [FROM_IMPORT] dataclass -> dataclasses.dataclass
    [FROM_IMPORT] field -> dataclasses.field
    [FROM_IMPORT] datetime -> datetime.datetime
    [FROM_IMPORT] timedelta -> datetime.timedelta
    [FROM_IMPORT] Enum -> enum.Enum
    [FROM_IMPORT] auto -> enum.auto
    [IMPORT] logging -> logging
    [IMPORT] threading -> threading
    [IMPORT] uuid -> uuid
  [CLASS] Analyzing class: OperationType
    [CONTEXT] Entered class: admin_manager.OperationType
    [SYMBOL_TABLE] Entered class scope
    [CONTEXT] Exited class: admin_manager.OperationType
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: OperationStatus
    [CONTEXT] Entered class: admin_manager.OperationStatus
    [SYMBOL_TABLE] Entered class scope
    [CONTEXT] Exited class: admin_manager.OperationStatus
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: OperationResult
    [CONTEXT] Entered class: admin_manager.OperationResult
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.OperationResult.get_duration
    [CONTEXT] Entered function: admin_manager.OperationResult.get_duration (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.end_time
    [RESOLVE] Attempting to resolve: ['self', 'end_time']
    [RESOLVE] Chain resolution needed for: ['self', 'end_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: admin_manager.OperationResult)
      [SELF_RESOLVER] resolve(self): admin_manager.OperationResult
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> admin_manager.OperationResult
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.end_time
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.end_time
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.end_time
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.end_time
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.end_time
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.end_time
        [CACHE] self.end_time -> admin_manager.OperationResult.end_time (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.start_time
    [RESOLVE] Attempting to resolve: ['self', 'start_time']
    [RESOLVE] Chain resolution needed for: ['self', 'start_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.OperationResult
      [CHAIN] Base resolved: self -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.start_time
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.start_time
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.start_time
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.start_time
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.start_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.OperationResult (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.OperationResult.get_duration
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.OperationResult.get_duration
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.OperationResult.add_error
    [CONTEXT] Entered function: admin_manager.OperationResult.add_error (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'error': 'str'}
        [ARG_TYPE] Processing type annotation for error: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: admin_manager.OperationResult)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(str): admin_manager.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> admin_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.str
      [SYMBOL_UPDATE] Function: error -> admin_manager.str
        [ARG_TYPE] RESOLVED error : admin_manager.str
      [CALL] Found call: self.errors.append
    [RESOLVE] Attempting to resolve: ['self', 'errors', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'errors', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.OperationResult
      [CHAIN] Base resolved: self -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.errors
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.errors
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.errors
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.errors
      [CHAIN] Step 2: Resolving admin_manager.OperationResult.errors.append
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.errors.append
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.errors.append
      [CHAIN] Step 2 resolved: admin_manager.OperationResult.errors.append
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.errors.append
            [INTERMEDIATE] Tracking chain steps for: self.errors.append
            [INTERMEDIATE] Step 1: self.errors
    [RESOLVE] Attempting to resolve: ['self', 'errors']
    [RESOLVE] Chain resolution needed for: ['self', 'errors']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.OperationResult
      [CHAIN] Base resolved: self -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.errors
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.errors
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.errors
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.errors
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.errors
            [INTERMEDIATE] Step 1 resolved to: admin_manager.OperationResult.errors
            [INTERMEDIATE] Step 2: self.errors.append
      -> Resolved to: admin_manager.OperationResult.errors.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: error
    [RESOLVE] Attempting to resolve: ['error']
      [RESOLVE_SIMPLE] Resolving base: error
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found error in function scope: admin_manager.str
      [LOCAL_RESOLVER] can_resolve(error): True
      [SYMBOL_LOOKUP] Found error in function scope: admin_manager.str
      [LOCAL_RESOLVER] resolve(error): admin_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: error -> admin_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.str
      [ATTRIBUTE] Found attribute access: self.errors.append
        [CACHE] self.errors.append -> admin_manager.OperationResult.errors.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.errors
        [CACHE] self.errors -> admin_manager.OperationResult.errors (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [NAME] Found name reference: error
    [RESOLVE] Attempting to resolve: ['error']
      [RESOLVE_SIMPLE] Resolving base: error
      [CACHE] Hit for error: admin_manager.str
    [RESOLVE] RESOLVED to: admin_manager.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.status
    [RESOLVE] Attempting to resolve: ['self', 'status']
    [RESOLVE] Chain resolution needed for: ['self', 'status']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.OperationResult
      [CHAIN] Base resolved: self -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.status
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.status
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.status
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.status
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.status
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationStatus.FAILED
    [RESOLVE] Attempting to resolve: ['OperationStatus', 'FAILED']
    [RESOLVE] Chain resolution needed for: ['OperationStatus', 'FAILED']
      [CHAIN] Resolving base: OperationStatus
      [RESOLVE_SIMPLE] Resolving base: OperationStatus
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable OperationStatus not found in any scope
      [LOCAL_RESOLVER] can_resolve(OperationStatus): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(OperationStatus): False (current_class: admin_manager.OperationResult)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(OperationStatus): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(OperationStatus): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(OperationStatus): admin_manager.OperationStatus
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: OperationStatus -> admin_manager.OperationStatus
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: OperationStatus -> admin_manager.OperationStatus
      [CHAIN] Step 1: Resolving admin_manager.OperationStatus.FAILED
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationStatus.FAILED
        [ATTRIBUTE] Direct match found: admin_manager.OperationStatus.FAILED
      [CHAIN] Step 1 resolved: admin_manager.OperationStatus.FAILED
    [RESOLVE] RESOLVED to: admin_manager.OperationStatus.FAILED
      -> Not module state
      [NAME] Found name reference: OperationStatus
    [RESOLVE] Attempting to resolve: ['OperationStatus']
      [RESOLVE_SIMPLE] Resolving base: OperationStatus
      [CACHE] Hit for OperationStatus: admin_manager.OperationStatus
    [RESOLVE] RESOLVED to: admin_manager.OperationStatus
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationStatus.CANCELLED
    [RESOLVE] Attempting to resolve: ['OperationStatus', 'CANCELLED']
    [RESOLVE] Chain resolution needed for: ['OperationStatus', 'CANCELLED']
      [CHAIN] Resolving base: OperationStatus
      [RESOLVE_SIMPLE] Resolving base: OperationStatus
      [CACHE] Hit for OperationStatus: admin_manager.OperationStatus
      [CHAIN] Base resolved: OperationStatus -> admin_manager.OperationStatus
      [CHAIN] Step 1: Resolving admin_manager.OperationStatus.CANCELLED
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationStatus.CANCELLED
        [ATTRIBUTE] Direct match found: admin_manager.OperationStatus.CANCELLED
      [CHAIN] Step 1 resolved: admin_manager.OperationStatus.CANCELLED
    [RESOLVE] RESOLVED to: admin_manager.OperationStatus.CANCELLED
      -> Not module state
      [NAME] Found name reference: OperationStatus
        [CACHE] OperationStatus -> admin_manager.OperationStatus (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.status
        [CACHE] self.status -> admin_manager.OperationResult.status (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationStatus.FAILED
        [CACHE] OperationStatus.FAILED -> admin_manager.OperationStatus.FAILED (cached)
      -> Not module state
      [NAME] Found name reference: OperationStatus
        [CACHE] OperationStatus -> admin_manager.OperationStatus (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.OperationResult.add_error
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.OperationResult.add_error
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.OperationResult.add_warning
    [CONTEXT] Entered function: admin_manager.OperationResult.add_warning (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'warning': 'str'}
        [ARG_TYPE] Processing type annotation for warning: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: admin_manager.str
    [RESOLVE] RESOLVED to: admin_manager.str
      [SYMBOL_UPDATE] Function: warning -> admin_manager.str
        [ARG_TYPE] RESOLVED warning : admin_manager.str
      [CALL] Found call: self.warnings.append
    [RESOLVE] Attempting to resolve: ['self', 'warnings', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'warnings', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.OperationResult
      [CHAIN] Base resolved: self -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.warnings
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.warnings
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.warnings
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.warnings
      [CHAIN] Step 2: Resolving admin_manager.OperationResult.warnings.append
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.warnings.append
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.warnings.append
      [CHAIN] Step 2 resolved: admin_manager.OperationResult.warnings.append
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.warnings.append
            [INTERMEDIATE] Tracking chain steps for: self.warnings.append
            [INTERMEDIATE] Step 1: self.warnings
    [RESOLVE] Attempting to resolve: ['self', 'warnings']
    [RESOLVE] Chain resolution needed for: ['self', 'warnings']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.OperationResult
      [CHAIN] Base resolved: self -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.warnings
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.warnings
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.warnings
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.warnings
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.warnings
            [INTERMEDIATE] Step 1 resolved to: admin_manager.OperationResult.warnings
            [INTERMEDIATE] Step 2: self.warnings.append
      -> Resolved to: admin_manager.OperationResult.warnings.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: warning
    [RESOLVE] Attempting to resolve: ['warning']
      [RESOLVE_SIMPLE] Resolving base: warning
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found warning in function scope: admin_manager.str
      [LOCAL_RESOLVER] can_resolve(warning): True
      [SYMBOL_LOOKUP] Found warning in function scope: admin_manager.str
      [LOCAL_RESOLVER] resolve(warning): admin_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: warning -> admin_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.str
      [ATTRIBUTE] Found attribute access: self.warnings.append
        [CACHE] self.warnings.append -> admin_manager.OperationResult.warnings.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.warnings
        [CACHE] self.warnings -> admin_manager.OperationResult.warnings (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [NAME] Found name reference: warning
    [RESOLVE] Attempting to resolve: ['warning']
      [RESOLVE_SIMPLE] Resolving base: warning
      [CACHE] Hit for warning: admin_manager.str
    [RESOLVE] RESOLVED to: admin_manager.str
      -> Not module state
    [CONTEXT] Exited function: admin_manager.OperationResult.add_warning
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.OperationResult.add_warning
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: admin_manager.OperationResult
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: AdminManager
    [CONTEXT] Entered class: admin_manager.AdminManager
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager.__init__
    [CONTEXT] Entered function: admin_manager.AdminManager.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.operations_history
    [RESOLVE] Attempting to resolve: ['self', 'operations_history']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_history']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: admin_manager.AdminManager)
      [SELF_RESOLVER] resolve(self): admin_manager.AdminManager
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> admin_manager.AdminManager
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operations_history
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.operations_history
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.operations_history
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(str): admin_manager.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> admin_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.str
      -> Not module state
      [NAME] Found name reference: OperationResult
    [RESOLVE] Attempting to resolve: ['OperationResult']
      [RESOLVE_SIMPLE] Resolving base: OperationResult
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable OperationResult not found in any scope
      [LOCAL_RESOLVER] can_resolve(OperationResult): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(OperationResult): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(OperationResult): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(OperationResult): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(OperationResult): admin_manager.OperationResult
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: OperationResult -> admin_manager.OperationResult
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_operations
    [RESOLVE] Attempting to resolve: ['self', 'active_operations']
    [RESOLVE] Chain resolution needed for: ['self', 'active_operations']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.active_operations
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.active_operations
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.active_operations
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: Set
    [RESOLVE] Attempting to resolve: ['Set']
      [RESOLVE_SIMPLE] Resolving base: Set
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Set not found in any scope
      [LOCAL_RESOLVER] can_resolve(Set): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Set): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Set): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Set): typing.Set (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Set -> typing.Set
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Set
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> admin_manager.str (cached)
      -> Not module state
      [CALL] Found call: set
      -> IGNORED (built-in function)
      [NAME] Found name reference: set
    [RESOLVE] Attempting to resolve: ['set']
      [RESOLVE_SIMPLE] Resolving base: set
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable set not found in any scope
      [LOCAL_RESOLVER] can_resolve(set): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(set): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(set): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(set): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(set): admin_manager.set
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: set -> admin_manager.set
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.set
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operation_lock
    [RESOLVE] Attempting to resolve: ['self', 'operation_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'operation_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.operation_lock
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operation_lock
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operation_lock
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.operation_lock
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.operation_lock
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [CALL] Found call: threading.RLock
    [RESOLVE] Attempting to resolve: ['threading', 'RLock']
    [RESOLVE] Chain resolution needed for: ['threading', 'RLock']
      [CHAIN] Resolving base: threading
      [RESOLVE_SIMPLE] Resolving base: threading
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable threading not found in any scope
      [LOCAL_RESOLVER] can_resolve(threading): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(threading): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(threading): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(threading): threading (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: threading -> threading
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: threading -> threading
      [CHAIN] Step 1: Resolving threading.RLock
        [ATTRIBUTE] Resolving attribute: threading.RLock
        [ATTRIBUTE] Direct match found: threading.RLock
      [CHAIN] Step 1 resolved: threading.RLock
    [RESOLVE] RESOLVED to: threading.RLock
            [INTERMEDIATE] Tracking chain steps for: threading.RLock
            [INTERMEDIATE] Step 1: threading.RLock
      -> Resolved to: threading.RLock
      -> ADDED to calls (external library)
      [ATTRIBUTE] Found attribute access: threading.RLock
        [CACHE] threading.RLock -> threading.RLock (cached)
      -> Not module state
      [NAME] Found name reference: threading
    [RESOLVE] Attempting to resolve: ['threading']
      [RESOLVE_SIMPLE] Resolving base: threading
      [CACHE] Hit for threading: threading
    [RESOLVE] RESOLVED to: threading
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.admin_permissions
    [RESOLVE] Attempting to resolve: ['self', 'admin_permissions']
    [RESOLVE] Chain resolution needed for: ['self', 'admin_permissions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.admin_permissions
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.admin_permissions
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.admin_permissions
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.admin_permissions
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.admin_permissions
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: Dict
        [CACHE] Dict -> typing.Dict (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> admin_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: Set
        [CACHE] Set -> typing.Set (cached)
      -> Not module state
      [NAME] Found name reference: OperationType
    [RESOLVE] Attempting to resolve: ['OperationType']
      [RESOLVE_SIMPLE] Resolving base: OperationType
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable OperationType not found in any scope
      [LOCAL_RESOLVER] can_resolve(OperationType): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(OperationType): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(OperationType): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(OperationType): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(OperationType): admin_manager.OperationType
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: OperationType -> admin_manager.OperationType
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.OperationType
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.system_config
    [RESOLVE] Attempting to resolve: ['self', 'system_config']
    [RESOLVE] Chain resolution needed for: ['self', 'system_config']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.system_config
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.system_config
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.system_config
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: Dict
        [CACHE] Dict -> typing.Dict (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> admin_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.audit_log
    [RESOLVE] Attempting to resolve: ['self', 'audit_log']
    [RESOLVE] Chain resolution needed for: ['self', 'audit_log']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.audit_log
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.audit_log
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.audit_log
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.audit_log
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.audit_log
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: List
    [RESOLVE] Attempting to resolve: ['List']
      [RESOLVE_SIMPLE] Resolving base: List
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable List not found in any scope
      [LOCAL_RESOLVER] can_resolve(List): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(List): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(List): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(List): typing.List (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: List -> typing.List
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.List
      -> Not module state
      [NAME] Found name reference: Dict
        [CACHE] Dict -> typing.Dict (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> admin_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: Any
        [CACHE] Any -> typing.Any (cached)
      -> Not module state
      [CALL] Found call: self._initialize_system_config
    [RESOLVE] Attempting to resolve: ['self', '_initialize_system_config']
    [RESOLVE] Chain resolution needed for: ['self', '_initialize_system_config']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager._initialize_system_config
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager._initialize_system_config
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager._initialize_system_config
      [CHAIN] Step 1 resolved: admin_manager.AdminManager._initialize_system_config
    [RESOLVE] RESOLVED to: admin_manager.AdminManager._initialize_system_config
            [INTERMEDIATE] Tracking chain steps for: self._initialize_system_config
            [INTERMEDIATE] Step 1: self._initialize_system_config
      -> Resolved to: admin_manager.AdminManager._initialize_system_config
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self._initialize_system_config
        [CACHE] self._initialize_system_config -> admin_manager.AdminManager._initialize_system_config (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager.__init__
        Calls: 2
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager._initialize_system_config
    [CONTEXT] Entered function: admin_manager.AdminManager._initialize_system_config (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.system_config
    [RESOLVE] Attempting to resolve: ['self', 'system_config']
    [RESOLVE] Chain resolution needed for: ['self', 'system_config']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.system_config
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.system_config
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.system_config
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager._initialize_system_config
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager._initialize_system_config
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager.execute_operation
    [CONTEXT] Entered function: admin_manager.AdminManager.execute_operation (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'operation_type': 'str', 'parameters': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for operation_type: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: admin_manager.str
    [RESOLVE] RESOLVED to: admin_manager.str
      [SYMBOL_UPDATE] Function: operation_type -> admin_manager.str
        [ARG_TYPE] RESOLVED operation_type : admin_manager.str
      [ASSIGNMENT] Processing: op_type = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: op_type
    [RESOLVE] Attempting to resolve: ['op_type']
      [RESOLVE_SIMPLE] Resolving base: op_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable op_type not found in any scope
      [LOCAL_RESOLVER] can_resolve(op_type): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(op_type): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(op_type): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(op_type): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(op_type): admin_manager.op_type
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: op_type -> admin_manager.op_type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.op_type
      -> Not module state
      [NAME] Found name reference: OperationType
    [RESOLVE] Attempting to resolve: ['OperationType']
      [RESOLVE_SIMPLE] Resolving base: OperationType
      [CACHE] Hit for OperationType: admin_manager.OperationType
    [RESOLVE] RESOLVED to: admin_manager.OperationType
      -> Not module state
      [CALL] Found call: operation_type.upper
    [RESOLVE] Attempting to resolve: ['operation_type', 'upper']
    [RESOLVE] Chain resolution needed for: ['operation_type', 'upper']
      [CHAIN] Resolving base: operation_type
      [RESOLVE_SIMPLE] Resolving base: operation_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found operation_type in function scope: admin_manager.str
      [LOCAL_RESOLVER] can_resolve(operation_type): True
      [SYMBOL_LOOKUP] Found operation_type in function scope: admin_manager.str
      [LOCAL_RESOLVER] resolve(operation_type): admin_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: operation_type -> admin_manager.str
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: operation_type -> admin_manager.str
      [CHAIN] Step 1: Resolving admin_manager.str.upper
        [ATTRIBUTE] Resolving attribute: admin_manager.str.upper
        [ATTRIBUTE] Direct match found: admin_manager.str.upper
      [CHAIN] Step 1 resolved: admin_manager.str.upper
    [RESOLVE] RESOLVED to: admin_manager.str.upper
            [INTERMEDIATE] Tracking chain steps for: operation_type.upper
            [INTERMEDIATE] Step 1: operation_type.upper
      -> Resolved to: admin_manager.str.upper
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: operation_type.upper
        [CACHE] operation_type.upper -> admin_manager.str.upper (cached)
      -> Not module state
      [NAME] Found name reference: operation_type
    [RESOLVE] Attempting to resolve: ['operation_type']
      [RESOLVE_SIMPLE] Resolving base: operation_type
      [CACHE] Hit for operation_type: admin_manager.str
    [RESOLVE] RESOLVED to: admin_manager.str
      -> Not module state
      [NAME] Found name reference: KeyError
    [RESOLVE] Attempting to resolve: ['KeyError']
      [RESOLVE_SIMPLE] Resolving base: KeyError
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable KeyError not found in any scope
      [LOCAL_RESOLVER] can_resolve(KeyError): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(KeyError): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(KeyError): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(KeyError): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(KeyError): admin_manager.KeyError
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: KeyError -> admin_manager.KeyError
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.KeyError
      -> Not module state
      [NAME] Found name reference: operation_type
        [CACHE] operation_type -> admin_manager.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: op.name
    [RESOLVE] Attempting to resolve: ['op', 'name']
    [RESOLVE] Chain resolution needed for: ['op', 'name']
      [CHAIN] Resolving base: op
      [RESOLVE_SIMPLE] Resolving base: op
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable op not found in any scope
      [LOCAL_RESOLVER] can_resolve(op): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(op): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(op): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(op): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(op): admin_manager.op
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: op -> admin_manager.op
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: op -> admin_manager.op
      [CHAIN] Step 1: Resolving admin_manager.op.name
        [ATTRIBUTE] Resolving attribute: admin_manager.op.name
        [ATTRIBUTE] Direct match found: admin_manager.op.name
      [CHAIN] Step 1 resolved: admin_manager.op.name
    [RESOLVE] RESOLVED to: admin_manager.op.name
      -> Not module state
      [NAME] Found name reference: op
    [RESOLVE] Attempting to resolve: ['op']
      [RESOLVE_SIMPLE] Resolving base: op
      [CACHE] Hit for op: admin_manager.op
    [RESOLVE] RESOLVED to: admin_manager.op
      -> Not module state
      [NAME] Found name reference: op
        [CACHE] op -> admin_manager.op (cached)
      -> Not module state
      [NAME] Found name reference: OperationType
        [CACHE] OperationType -> admin_manager.OperationType (cached)
      -> Not module state
      [ASSIGNMENT] Processing: operation_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: admin_manager.str
    [RESOLVE] RESOLVED to: admin_manager.str
      [TYPE_INFERENCE] Call resolved to: admin_manager.str
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for operation_id
      [NAME] Found name reference: operation_id
    [RESOLVE] Attempting to resolve: ['operation_id']
      [RESOLVE_SIMPLE] Resolving base: operation_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable operation_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(operation_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(operation_id): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(operation_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(operation_id): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(operation_id): admin_manager.operation_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: operation_id -> admin_manager.operation_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.operation_id
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
        [CACHE] str -> admin_manager.str (cached)
      -> Not module state
      [CALL] Found call: uuid.uuid4
    [RESOLVE] Attempting to resolve: ['uuid', 'uuid4']
    [RESOLVE] Chain resolution needed for: ['uuid', 'uuid4']
      [CHAIN] Resolving base: uuid
      [RESOLVE_SIMPLE] Resolving base: uuid
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable uuid not found in any scope
      [LOCAL_RESOLVER] can_resolve(uuid): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(uuid): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(uuid): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(uuid): uuid (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: uuid -> uuid
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: uuid -> uuid
      [CHAIN] Step 1: Resolving uuid.uuid4
        [ATTRIBUTE] Resolving attribute: uuid.uuid4
        [ATTRIBUTE] Direct match found: uuid.uuid4
      [CHAIN] Step 1 resolved: uuid.uuid4
    [RESOLVE] RESOLVED to: uuid.uuid4
            [INTERMEDIATE] Tracking chain steps for: uuid.uuid4
            [INTERMEDIATE] Step 1: uuid.uuid4
      -> Resolved to: uuid.uuid4
      -> ADDED to calls (external library)
      [ATTRIBUTE] Found attribute access: uuid.uuid4
        [CACHE] uuid.uuid4 -> uuid.uuid4 (cached)
      -> Not module state
      [NAME] Found name reference: uuid
    [RESOLVE] Attempting to resolve: ['uuid']
      [RESOLVE_SIMPLE] Resolving base: uuid
      [CACHE] Hit for uuid: uuid
    [RESOLVE] RESOLVED to: uuid
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: OperationResult
    [RESOLVE] Attempting to resolve: ['OperationResult']
      [RESOLVE_SIMPLE] Resolving base: OperationResult
      [CACHE] Hit for OperationResult: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [TYPE_INFERENCE] Call resolved to: admin_manager.OperationResult
      [TYPE_INFERENCE] RESOLVED Inferred type: admin_manager.OperationResult (class instantiation)
      [SYMBOL_UPDATE] Function: result -> admin_manager.OperationResult
        [ASSIGNMENT] RESOLVED Updated symbol table: result = admin_manager.OperationResult
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found result in function scope: admin_manager.OperationResult
      [LOCAL_RESOLVER] can_resolve(result): True
      [SYMBOL_LOOKUP] Found result in function scope: admin_manager.OperationResult
      [LOCAL_RESOLVER] resolve(result): admin_manager.OperationResult
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: result -> admin_manager.OperationResult
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [CALL] Found call: OperationResult
    [RESOLVE] Attempting to resolve: ['OperationResult']
      [RESOLVE_SIMPLE] Resolving base: OperationResult
      [CACHE] Hit for OperationResult: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Resolved to: admin_manager.OperationResult
      -> ADDED to instantiations
      [NAME] Found name reference: OperationResult
        [CACHE] OperationResult -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: operation_id
        [CACHE] operation_id -> admin_manager.operation_id (cached)
      -> Not module state
      [NAME] Found name reference: op_type
        [CACHE] op_type -> admin_manager.op_type (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationStatus.PENDING
    [RESOLVE] Attempting to resolve: ['OperationStatus', 'PENDING']
    [RESOLVE] Chain resolution needed for: ['OperationStatus', 'PENDING']
      [CHAIN] Resolving base: OperationStatus
      [RESOLVE_SIMPLE] Resolving base: OperationStatus
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable OperationStatus not found in any scope
      [LOCAL_RESOLVER] can_resolve(OperationStatus): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(OperationStatus): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(OperationStatus): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(OperationStatus): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(OperationStatus): admin_manager.OperationStatus
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: OperationStatus -> admin_manager.OperationStatus
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: OperationStatus -> admin_manager.OperationStatus
      [CHAIN] Step 1: Resolving admin_manager.OperationStatus.PENDING
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationStatus.PENDING
        [ATTRIBUTE] Direct match found: admin_manager.OperationStatus.PENDING
      [CHAIN] Step 1 resolved: admin_manager.OperationStatus.PENDING
    [RESOLVE] RESOLVED to: admin_manager.OperationStatus.PENDING
      -> Not module state
      [NAME] Found name reference: OperationStatus
    [RESOLVE] Attempting to resolve: ['OperationStatus']
      [RESOLVE_SIMPLE] Resolving base: OperationStatus
      [CACHE] Hit for OperationStatus: admin_manager.OperationStatus
    [RESOLVE] RESOLVED to: admin_manager.OperationStatus
      -> Not module state
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable datetime not found in any scope
      [LOCAL_RESOLVER] can_resolve(datetime): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(datetime): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(datetime): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(datetime): datetime.datetime (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: datetime -> datetime.datetime
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operation_lock
    [RESOLVE] Attempting to resolve: ['self', 'operation_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'operation_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.operation_lock
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operation_lock
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operation_lock
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.operation_lock
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.operation_lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(len): admin_manager.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> admin_manager.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_operations
    [RESOLVE] Attempting to resolve: ['self', 'active_operations']
    [RESOLVE] Chain resolution needed for: ['self', 'active_operations']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.active_operations
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.active_operations
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.active_operations
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.system_config
    [RESOLVE] Attempting to resolve: ['self', 'system_config']
    [RESOLVE] Chain resolution needed for: ['self', 'system_config']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.system_config
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.system_config
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.system_config
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [CALL] Found call: result.add_error
    [RESOLVE] Attempting to resolve: ['result', 'add_error']
    [RESOLVE] Chain resolution needed for: ['result', 'add_error']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.add_error
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.add_error
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.add_error
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.add_error
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.add_error
            [INTERMEDIATE] Tracking chain steps for: result.add_error
            [INTERMEDIATE] Step 1: result.add_error
      -> Resolved to: admin_manager.OperationResult.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.add_error
        [CACHE] result.add_error -> admin_manager.OperationResult.add_error (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.end_time
    [RESOLVE] Attempting to resolve: ['result', 'end_time']
    [RESOLVE] Chain resolution needed for: ['result', 'end_time']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.end_time
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.end_time
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.end_time
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.end_time
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.end_time
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: datetime.now
    [CACHE] datetime.now -> datetime.datetime.now (cached)
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
        [CACHE] datetime -> datetime.datetime (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operations_history
    [RESOLVE] Attempting to resolve: ['self', 'operations_history']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_history']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operations_history
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.operations_history
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.operations_history
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: operation_id
        [CACHE] operation_id -> admin_manager.operation_id (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: self._result_to_dict
    [RESOLVE] Attempting to resolve: ['self', '_result_to_dict']
    [RESOLVE] Chain resolution needed for: ['self', '_result_to_dict']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager._result_to_dict
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager._result_to_dict
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager._result_to_dict
      [CHAIN] Step 1 resolved: admin_manager.AdminManager._result_to_dict
    [RESOLVE] RESOLVED to: admin_manager.AdminManager._result_to_dict
            [INTERMEDIATE] Tracking chain steps for: self._result_to_dict
            [INTERMEDIATE] Step 1: self._result_to_dict
      -> Resolved to: admin_manager.AdminManager._result_to_dict
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [ATTRIBUTE] Found attribute access: self._result_to_dict
        [CACHE] self._result_to_dict -> admin_manager.AdminManager._result_to_dict (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: self.active_operations.add
    [RESOLVE] Attempting to resolve: ['self', 'active_operations', 'add']
    [RESOLVE] Chain resolution needed for: ['self', 'active_operations', 'add']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.active_operations
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.active_operations
      [CHAIN] Step 2: Resolving admin_manager.AdminManager.active_operations.add
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.active_operations.add
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.active_operations.add
      [CHAIN] Step 2 resolved: admin_manager.AdminManager.active_operations.add
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.active_operations.add
            [INTERMEDIATE] Tracking chain steps for: self.active_operations.add
            [INTERMEDIATE] Step 1: self.active_operations
    [CACHE] self.active_operations -> admin_manager.AdminManager.active_operations (cached)
            [INTERMEDIATE] Step 1 resolved to: admin_manager.AdminManager.active_operations
            [INTERMEDIATE] Step 2: self.active_operations.add
      -> Resolved to: admin_manager.AdminManager.active_operations.add
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: operation_id
    [RESOLVE] Attempting to resolve: ['operation_id']
      [RESOLVE_SIMPLE] Resolving base: operation_id
      [CACHE] Hit for operation_id: admin_manager.operation_id
    [RESOLVE] RESOLVED to: admin_manager.operation_id
      [ATTRIBUTE] Found attribute access: self.active_operations.add
        [CACHE] self.active_operations.add -> admin_manager.AdminManager.active_operations.add (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_operations
        [CACHE] self.active_operations -> admin_manager.AdminManager.active_operations (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: operation_id
        [CACHE] operation_id -> admin_manager.operation_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operations_history
        [CACHE] self.operations_history -> admin_manager.AdminManager.operations_history (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: operation_id
        [CACHE] operation_id -> admin_manager.operation_id (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.status
    [RESOLVE] Attempting to resolve: ['result', 'status']
    [RESOLVE] Chain resolution needed for: ['result', 'status']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.status
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.status
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.status
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.status
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.status
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationStatus.IN_PROGRESS
    [RESOLVE] Attempting to resolve: ['OperationStatus', 'IN_PROGRESS']
    [RESOLVE] Chain resolution needed for: ['OperationStatus', 'IN_PROGRESS']
      [CHAIN] Resolving base: OperationStatus
      [RESOLVE_SIMPLE] Resolving base: OperationStatus
      [CACHE] Hit for OperationStatus: admin_manager.OperationStatus
      [CHAIN] Base resolved: OperationStatus -> admin_manager.OperationStatus
      [CHAIN] Step 1: Resolving admin_manager.OperationStatus.IN_PROGRESS
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationStatus.IN_PROGRESS
        [ATTRIBUTE] Direct match found: admin_manager.OperationStatus.IN_PROGRESS
      [CHAIN] Step 1 resolved: admin_manager.OperationStatus.IN_PROGRESS
    [RESOLVE] RESOLVED to: admin_manager.OperationStatus.IN_PROGRESS
      -> Not module state
      [NAME] Found name reference: OperationStatus
        [CACHE] OperationStatus -> admin_manager.OperationStatus (cached)
      -> Not module state
      [CALL] Found call: self._execute_specific_operation
    [RESOLVE] Attempting to resolve: ['self', '_execute_specific_operation']
    [RESOLVE] Chain resolution needed for: ['self', '_execute_specific_operation']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager._execute_specific_operation
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager._execute_specific_operation
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager._execute_specific_operation
      [CHAIN] Step 1 resolved: admin_manager.AdminManager._execute_specific_operation
    [RESOLVE] RESOLVED to: admin_manager.AdminManager._execute_specific_operation
            [INTERMEDIATE] Tracking chain steps for: self._execute_specific_operation
            [INTERMEDIATE] Step 1: self._execute_specific_operation
      -> Resolved to: admin_manager.AdminManager._execute_specific_operation
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
        [FUNCTION_ARG] Checking argument: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable parameters not found in any scope
      [LOCAL_RESOLVER] can_resolve(parameters): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(parameters): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(parameters): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(parameters): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(parameters): admin_manager.parameters
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: parameters -> admin_manager.parameters
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.parameters
      [ATTRIBUTE] Found attribute access: self._execute_specific_operation
        [CACHE] self._execute_specific_operation -> admin_manager.AdminManager._execute_specific_operation (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
    [RESOLVE] RESOLVED to: admin_manager.parameters
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.errors
    [RESOLVE] Attempting to resolve: ['result', 'errors']
    [RESOLVE] Chain resolution needed for: ['result', 'errors']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.errors
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.errors
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.errors
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.errors
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.errors
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.success
    [RESOLVE] Attempting to resolve: ['result', 'success']
    [RESOLVE] Chain resolution needed for: ['result', 'success']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.success
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.success
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.success
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.success
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.success
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.status
        [CACHE] result.status -> admin_manager.OperationResult.status (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationStatus.COMPLETED
    [RESOLVE] Attempting to resolve: ['OperationStatus', 'COMPLETED']
    [RESOLVE] Chain resolution needed for: ['OperationStatus', 'COMPLETED']
      [CHAIN] Resolving base: OperationStatus
      [RESOLVE_SIMPLE] Resolving base: OperationStatus
      [CACHE] Hit for OperationStatus: admin_manager.OperationStatus
      [CHAIN] Base resolved: OperationStatus -> admin_manager.OperationStatus
      [CHAIN] Step 1: Resolving admin_manager.OperationStatus.COMPLETED
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationStatus.COMPLETED
        [ATTRIBUTE] Direct match found: admin_manager.OperationStatus.COMPLETED
      [CHAIN] Step 1 resolved: admin_manager.OperationStatus.COMPLETED
    [RESOLVE] RESOLVED to: admin_manager.OperationStatus.COMPLETED
      -> Not module state
      [NAME] Found name reference: OperationStatus
        [CACHE] OperationStatus -> admin_manager.OperationStatus (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.message
    [RESOLVE] Attempting to resolve: ['result', 'message']
    [RESOLVE] Chain resolution needed for: ['result', 'message']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.message
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.message
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.message
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.message
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.message
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: operation_type
        [CACHE] operation_type -> admin_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Exception not found in any scope
      [LOCAL_RESOLVER] can_resolve(Exception): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Exception): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Exception): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(Exception): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(Exception): admin_manager.Exception
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: Exception -> admin_manager.Exception
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.Exception
      -> Not module state
      [CALL] Found call: result.add_error
    [CACHE] result.add_error -> admin_manager.OperationResult.add_error (cached)
            [INTERMEDIATE] Tracking chain steps for: result.add_error
            [INTERMEDIATE] Step 1: result.add_error
      -> Resolved to: admin_manager.OperationResult.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.add_error
        [CACHE] result.add_error -> admin_manager.OperationResult.add_error (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
        [CACHE] str -> admin_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable e not found in any scope
      [LOCAL_RESOLVER] can_resolve(e): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(e): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(e): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(e): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(e): admin_manager.e
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: e -> admin_manager.e
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.e
      -> Not module state
      [CALL] Found call: logging.exception
    [RESOLVE] Attempting to resolve: ['logging', 'exception']
    [RESOLVE] Chain resolution needed for: ['logging', 'exception']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable logging not found in any scope
      [LOCAL_RESOLVER] can_resolve(logging): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(logging): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(logging): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(logging): logging (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: logging -> logging
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.exception
        [ATTRIBUTE] Resolving attribute: logging.exception
        [ATTRIBUTE] Direct match found: logging.exception
      [CHAIN] Step 1 resolved: logging.exception
    [RESOLVE] RESOLVED to: logging.exception
            [INTERMEDIATE] Tracking chain steps for: logging.exception
            [INTERMEDIATE] Step 1: logging.exception
      -> Resolved to: logging.exception
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.exception
        [CACHE] logging.exception -> logging.exception (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [NAME] Found name reference: operation_id
        [CACHE] operation_id -> admin_manager.operation_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.end_time
        [CACHE] result.end_time -> admin_manager.OperationResult.end_time (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: datetime.now
    [CACHE] datetime.now -> datetime.datetime.now (cached)
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
        [CACHE] datetime -> datetime.datetime (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operation_lock
        [CACHE] self.operation_lock -> admin_manager.AdminManager.operation_lock (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [CALL] Found call: self.active_operations.discard
    [RESOLVE] Attempting to resolve: ['self', 'active_operations', 'discard']
    [RESOLVE] Chain resolution needed for: ['self', 'active_operations', 'discard']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.active_operations
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.active_operations
      [CHAIN] Step 2: Resolving admin_manager.AdminManager.active_operations.discard
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.active_operations.discard
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.active_operations.discard
      [CHAIN] Step 2 resolved: admin_manager.AdminManager.active_operations.discard
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.active_operations.discard
            [INTERMEDIATE] Tracking chain steps for: self.active_operations.discard
            [INTERMEDIATE] Step 1: self.active_operations
    [CACHE] self.active_operations -> admin_manager.AdminManager.active_operations (cached)
            [INTERMEDIATE] Step 1 resolved to: admin_manager.AdminManager.active_operations
            [INTERMEDIATE] Step 2: self.active_operations.discard
      -> Resolved to: admin_manager.AdminManager.active_operations.discard
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: operation_id
    [RESOLVE] Attempting to resolve: ['operation_id']
      [RESOLVE_SIMPLE] Resolving base: operation_id
      [CACHE] Hit for operation_id: admin_manager.operation_id
    [RESOLVE] RESOLVED to: admin_manager.operation_id
      [ATTRIBUTE] Found attribute access: self.active_operations.discard
        [CACHE] self.active_operations.discard -> admin_manager.AdminManager.active_operations.discard (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_operations
        [CACHE] self.active_operations -> admin_manager.AdminManager.active_operations (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: operation_id
        [CACHE] operation_id -> admin_manager.operation_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operations_history
        [CACHE] self.operations_history -> admin_manager.AdminManager.operations_history (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: operation_id
        [CACHE] operation_id -> admin_manager.operation_id (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: self._add_audit_entry
    [RESOLVE] Attempting to resolve: ['self', '_add_audit_entry']
    [RESOLVE] Chain resolution needed for: ['self', '_add_audit_entry']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager._add_audit_entry
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager._add_audit_entry
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager._add_audit_entry
      [CHAIN] Step 1 resolved: admin_manager.AdminManager._add_audit_entry
    [RESOLVE] RESOLVED to: admin_manager.AdminManager._add_audit_entry
            [INTERMEDIATE] Tracking chain steps for: self._add_audit_entry
            [INTERMEDIATE] Step 1: self._add_audit_entry
      -> Resolved to: admin_manager.AdminManager._add_audit_entry
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
        [FUNCTION_ARG] Checking argument: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
    [RESOLVE] RESOLVED to: admin_manager.parameters
      [ATTRIBUTE] Found attribute access: self._add_audit_entry
        [CACHE] self._add_audit_entry -> admin_manager.AdminManager._add_audit_entry (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: parameters
        [CACHE] parameters -> admin_manager.parameters (cached)
      -> Not module state
      [CALL] Found call: self._result_to_dict
    [CACHE] self._result_to_dict -> admin_manager.AdminManager._result_to_dict (cached)
            [INTERMEDIATE] Tracking chain steps for: self._result_to_dict
            [INTERMEDIATE] Step 1: self._result_to_dict
      -> Resolved to: admin_manager.AdminManager._result_to_dict
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [ATTRIBUTE] Found attribute access: self._result_to_dict
        [CACHE] self._result_to_dict -> admin_manager.AdminManager._result_to_dict (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager.execute_operation
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager.execute_operation
        Calls: 5
        Instantiations: 1
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager._execute_specific_operation
    [CONTEXT] Entered function: admin_manager.AdminManager._execute_specific_operation (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'result': 'OperationResult', 'parameters': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for result: OperationResult
    [RESOLVE] Attempting to resolve: ['OperationResult']
      [RESOLVE_SIMPLE] Resolving base: OperationResult
      [CACHE] Hit for OperationResult: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [SYMBOL_UPDATE] Function: result -> admin_manager.OperationResult
        [ARG_TYPE] RESOLVED result : admin_manager.OperationResult
      [ASSIGNMENT] Processing: operation_handlers = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: operation_handlers
    [RESOLVE] Attempting to resolve: ['operation_handlers']
      [RESOLVE_SIMPLE] Resolving base: operation_handlers
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable operation_handlers not found in any scope
      [LOCAL_RESOLVER] can_resolve(operation_handlers): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(operation_handlers): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(operation_handlers): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(operation_handlers): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(operation_handlers): admin_manager.operation_handlers
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: operation_handlers -> admin_manager.operation_handlers
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.operation_handlers
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationType.USER_MANAGEMENT
    [RESOLVE] Attempting to resolve: ['OperationType', 'USER_MANAGEMENT']
    [RESOLVE] Chain resolution needed for: ['OperationType', 'USER_MANAGEMENT']
      [CHAIN] Resolving base: OperationType
      [RESOLVE_SIMPLE] Resolving base: OperationType
      [CACHE] Hit for OperationType: admin_manager.OperationType
      [CHAIN] Base resolved: OperationType -> admin_manager.OperationType
      [CHAIN] Step 1: Resolving admin_manager.OperationType.USER_MANAGEMENT
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationType.USER_MANAGEMENT
        [ATTRIBUTE] Direct match found: admin_manager.OperationType.USER_MANAGEMENT
      [CHAIN] Step 1 resolved: admin_manager.OperationType.USER_MANAGEMENT
    [RESOLVE] RESOLVED to: admin_manager.OperationType.USER_MANAGEMENT
      -> Not module state
      [NAME] Found name reference: OperationType
    [RESOLVE] Attempting to resolve: ['OperationType']
      [RESOLVE_SIMPLE] Resolving base: OperationType
      [CACHE] Hit for OperationType: admin_manager.OperationType
    [RESOLVE] RESOLVED to: admin_manager.OperationType
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationType.SYSTEM_CONFIGURATION
    [RESOLVE] Attempting to resolve: ['OperationType', 'SYSTEM_CONFIGURATION']
    [RESOLVE] Chain resolution needed for: ['OperationType', 'SYSTEM_CONFIGURATION']
      [CHAIN] Resolving base: OperationType
      [RESOLVE_SIMPLE] Resolving base: OperationType
      [CACHE] Hit for OperationType: admin_manager.OperationType
      [CHAIN] Base resolved: OperationType -> admin_manager.OperationType
      [CHAIN] Step 1: Resolving admin_manager.OperationType.SYSTEM_CONFIGURATION
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationType.SYSTEM_CONFIGURATION
        [ATTRIBUTE] Direct match found: admin_manager.OperationType.SYSTEM_CONFIGURATION
      [CHAIN] Step 1 resolved: admin_manager.OperationType.SYSTEM_CONFIGURATION
    [RESOLVE] RESOLVED to: admin_manager.OperationType.SYSTEM_CONFIGURATION
      -> Not module state
      [NAME] Found name reference: OperationType
        [CACHE] OperationType -> admin_manager.OperationType (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationType.DATA_MIGRATION
    [RESOLVE] Attempting to resolve: ['OperationType', 'DATA_MIGRATION']
    [RESOLVE] Chain resolution needed for: ['OperationType', 'DATA_MIGRATION']
      [CHAIN] Resolving base: OperationType
      [RESOLVE_SIMPLE] Resolving base: OperationType
      [CACHE] Hit for OperationType: admin_manager.OperationType
      [CHAIN] Base resolved: OperationType -> admin_manager.OperationType
      [CHAIN] Step 1: Resolving admin_manager.OperationType.DATA_MIGRATION
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationType.DATA_MIGRATION
        [ATTRIBUTE] Direct match found: admin_manager.OperationType.DATA_MIGRATION
      [CHAIN] Step 1 resolved: admin_manager.OperationType.DATA_MIGRATION
    [RESOLVE] RESOLVED to: admin_manager.OperationType.DATA_MIGRATION
      -> Not module state
      [NAME] Found name reference: OperationType
        [CACHE] OperationType -> admin_manager.OperationType (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationType.SECURITY_AUDIT
    [RESOLVE] Attempting to resolve: ['OperationType', 'SECURITY_AUDIT']
    [RESOLVE] Chain resolution needed for: ['OperationType', 'SECURITY_AUDIT']
      [CHAIN] Resolving base: OperationType
      [RESOLVE_SIMPLE] Resolving base: OperationType
      [CACHE] Hit for OperationType: admin_manager.OperationType
      [CHAIN] Base resolved: OperationType -> admin_manager.OperationType
      [CHAIN] Step 1: Resolving admin_manager.OperationType.SECURITY_AUDIT
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationType.SECURITY_AUDIT
        [ATTRIBUTE] Direct match found: admin_manager.OperationType.SECURITY_AUDIT
      [CHAIN] Step 1 resolved: admin_manager.OperationType.SECURITY_AUDIT
    [RESOLVE] RESOLVED to: admin_manager.OperationType.SECURITY_AUDIT
      -> Not module state
      [NAME] Found name reference: OperationType
        [CACHE] OperationType -> admin_manager.OperationType (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationType.PERFORMANCE_TUNING
    [RESOLVE] Attempting to resolve: ['OperationType', 'PERFORMANCE_TUNING']
    [RESOLVE] Chain resolution needed for: ['OperationType', 'PERFORMANCE_TUNING']
      [CHAIN] Resolving base: OperationType
      [RESOLVE_SIMPLE] Resolving base: OperationType
      [CACHE] Hit for OperationType: admin_manager.OperationType
      [CHAIN] Base resolved: OperationType -> admin_manager.OperationType
      [CHAIN] Step 1: Resolving admin_manager.OperationType.PERFORMANCE_TUNING
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationType.PERFORMANCE_TUNING
        [ATTRIBUTE] Direct match found: admin_manager.OperationType.PERFORMANCE_TUNING
      [CHAIN] Step 1 resolved: admin_manager.OperationType.PERFORMANCE_TUNING
    [RESOLVE] RESOLVED to: admin_manager.OperationType.PERFORMANCE_TUNING
      -> Not module state
      [NAME] Found name reference: OperationType
        [CACHE] OperationType -> admin_manager.OperationType (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationType.BACKUP_RESTORE
    [RESOLVE] Attempting to resolve: ['OperationType', 'BACKUP_RESTORE']
    [RESOLVE] Chain resolution needed for: ['OperationType', 'BACKUP_RESTORE']
      [CHAIN] Resolving base: OperationType
      [RESOLVE_SIMPLE] Resolving base: OperationType
      [CACHE] Hit for OperationType: admin_manager.OperationType
      [CHAIN] Base resolved: OperationType -> admin_manager.OperationType
      [CHAIN] Step 1: Resolving admin_manager.OperationType.BACKUP_RESTORE
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationType.BACKUP_RESTORE
        [ATTRIBUTE] Direct match found: admin_manager.OperationType.BACKUP_RESTORE
      [CHAIN] Step 1 resolved: admin_manager.OperationType.BACKUP_RESTORE
    [RESOLVE] RESOLVED to: admin_manager.OperationType.BACKUP_RESTORE
      -> Not module state
      [NAME] Found name reference: OperationType
        [CACHE] OperationType -> admin_manager.OperationType (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationType.MONITORING_SETUP
    [RESOLVE] Attempting to resolve: ['OperationType', 'MONITORING_SETUP']
    [RESOLVE] Chain resolution needed for: ['OperationType', 'MONITORING_SETUP']
      [CHAIN] Resolving base: OperationType
      [RESOLVE_SIMPLE] Resolving base: OperationType
      [CACHE] Hit for OperationType: admin_manager.OperationType
      [CHAIN] Base resolved: OperationType -> admin_manager.OperationType
      [CHAIN] Step 1: Resolving admin_manager.OperationType.MONITORING_SETUP
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationType.MONITORING_SETUP
        [ATTRIBUTE] Direct match found: admin_manager.OperationType.MONITORING_SETUP
      [CHAIN] Step 1 resolved: admin_manager.OperationType.MONITORING_SETUP
    [RESOLVE] RESOLVED to: admin_manager.OperationType.MONITORING_SETUP
      -> Not module state
      [NAME] Found name reference: OperationType
        [CACHE] OperationType -> admin_manager.OperationType (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._handle_user_management
    [RESOLVE] Attempting to resolve: ['self', '_handle_user_management']
    [RESOLVE] Chain resolution needed for: ['self', '_handle_user_management']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager._handle_user_management
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager._handle_user_management
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager._handle_user_management
      [CHAIN] Step 1 resolved: admin_manager.AdminManager._handle_user_management
    [RESOLVE] RESOLVED to: admin_manager.AdminManager._handle_user_management
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._handle_system_configuration
    [RESOLVE] Attempting to resolve: ['self', '_handle_system_configuration']
    [RESOLVE] Chain resolution needed for: ['self', '_handle_system_configuration']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager._handle_system_configuration
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager._handle_system_configuration
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager._handle_system_configuration
      [CHAIN] Step 1 resolved: admin_manager.AdminManager._handle_system_configuration
    [RESOLVE] RESOLVED to: admin_manager.AdminManager._handle_system_configuration
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._handle_data_migration
    [RESOLVE] Attempting to resolve: ['self', '_handle_data_migration']
    [RESOLVE] Chain resolution needed for: ['self', '_handle_data_migration']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager._handle_data_migration
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager._handle_data_migration
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager._handle_data_migration
      [CHAIN] Step 1 resolved: admin_manager.AdminManager._handle_data_migration
    [RESOLVE] RESOLVED to: admin_manager.AdminManager._handle_data_migration
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._handle_security_audit
    [RESOLVE] Attempting to resolve: ['self', '_handle_security_audit']
    [RESOLVE] Chain resolution needed for: ['self', '_handle_security_audit']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager._handle_security_audit
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager._handle_security_audit
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager._handle_security_audit
      [CHAIN] Step 1 resolved: admin_manager.AdminManager._handle_security_audit
    [RESOLVE] RESOLVED to: admin_manager.AdminManager._handle_security_audit
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._handle_performance_tuning
    [RESOLVE] Attempting to resolve: ['self', '_handle_performance_tuning']
    [RESOLVE] Chain resolution needed for: ['self', '_handle_performance_tuning']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager._handle_performance_tuning
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager._handle_performance_tuning
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager._handle_performance_tuning
      [CHAIN] Step 1 resolved: admin_manager.AdminManager._handle_performance_tuning
    [RESOLVE] RESOLVED to: admin_manager.AdminManager._handle_performance_tuning
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._handle_backup_restore
    [RESOLVE] Attempting to resolve: ['self', '_handle_backup_restore']
    [RESOLVE] Chain resolution needed for: ['self', '_handle_backup_restore']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager._handle_backup_restore
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager._handle_backup_restore
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager._handle_backup_restore
      [CHAIN] Step 1 resolved: admin_manager.AdminManager._handle_backup_restore
    [RESOLVE] RESOLVED to: admin_manager.AdminManager._handle_backup_restore
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._handle_monitoring_setup
    [RESOLVE] Attempting to resolve: ['self', '_handle_monitoring_setup']
    [RESOLVE] Chain resolution needed for: ['self', '_handle_monitoring_setup']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager._handle_monitoring_setup
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager._handle_monitoring_setup
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager._handle_monitoring_setup
      [CHAIN] Step 1 resolved: admin_manager.AdminManager._handle_monitoring_setup
    [RESOLVE] RESOLVED to: admin_manager.AdminManager._handle_monitoring_setup
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [ASSIGNMENT] Processing: handler = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: operation_handlers.get
    [RESOLVE] Attempting to resolve: ['operation_handlers', 'get']
    [RESOLVE] Chain resolution needed for: ['operation_handlers', 'get']
      [CHAIN] Resolving base: operation_handlers
      [RESOLVE_SIMPLE] Resolving base: operation_handlers
      [CACHE] Hit for operation_handlers: admin_manager.operation_handlers
      [CHAIN] Base resolved: operation_handlers -> admin_manager.operation_handlers
      [CHAIN] Step 1: Resolving admin_manager.operation_handlers.get
        [ATTRIBUTE] Resolving attribute: admin_manager.operation_handlers.get
        [ATTRIBUTE] Direct match found: admin_manager.operation_handlers.get
      [CHAIN] Step 1 resolved: admin_manager.operation_handlers.get
    [RESOLVE] RESOLVED to: admin_manager.operation_handlers.get
      [TYPE_INFERENCE] Call resolved to: admin_manager.operation_handlers.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for handler
      [NAME] Found name reference: handler
    [RESOLVE] Attempting to resolve: ['handler']
      [RESOLVE_SIMPLE] Resolving base: handler
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable handler not found in any scope
      [LOCAL_RESOLVER] can_resolve(handler): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(handler): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(handler): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(handler): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(handler): admin_manager.handler
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: handler -> admin_manager.handler
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.handler
      -> Not module state
      [CALL] Found call: operation_handlers.get
    [RESOLVE] Attempting to resolve: ['operation_handlers', 'get']
    [RESOLVE] Chain resolution needed for: ['operation_handlers', 'get']
      [CHAIN] Resolving base: operation_handlers
      [RESOLVE_SIMPLE] Resolving base: operation_handlers
      [CACHE] Hit for operation_handlers: admin_manager.operation_handlers
      [CHAIN] Base resolved: operation_handlers -> admin_manager.operation_handlers
      [CHAIN] Step 1: Resolving admin_manager.operation_handlers.get
        [ATTRIBUTE] Resolving attribute: admin_manager.operation_handlers.get
        [ATTRIBUTE] Direct match found: admin_manager.operation_handlers.get
      [CHAIN] Step 1 resolved: admin_manager.operation_handlers.get
    [RESOLVE] RESOLVED to: admin_manager.operation_handlers.get
            [INTERMEDIATE] Tracking chain steps for: operation_handlers.get
            [INTERMEDIATE] Step 1: operation_handlers.get
      -> Resolved to: admin_manager.operation_handlers.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: operation_handlers.get
        [CACHE] operation_handlers.get -> admin_manager.operation_handlers.get (cached)
      -> Not module state
      [NAME] Found name reference: operation_handlers
        [CACHE] operation_handlers -> admin_manager.operation_handlers (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.operation_type
    [RESOLVE] Attempting to resolve: ['result', 'operation_type']
    [RESOLVE] Chain resolution needed for: ['result', 'operation_type']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.operation_type
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.operation_type
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.operation_type
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.operation_type
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.operation_type
      -> Not module state
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [NAME] Found name reference: handler
        [CACHE] handler -> admin_manager.handler (cached)
      -> Not module state
      [CALL] Found call: handler
    [CACHE] handler -> admin_manager.handler (cached)
      -> Resolved to: admin_manager.handler
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
        [FUNCTION_ARG] Checking argument: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
    [RESOLVE] RESOLVED to: admin_manager.parameters
      [NAME] Found name reference: handler
        [CACHE] handler -> admin_manager.handler (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
    [RESOLVE] RESOLVED to: admin_manager.parameters
      -> Not module state
      [CALL] Found call: result.add_error
    [RESOLVE] Attempting to resolve: ['result', 'add_error']
    [RESOLVE] Chain resolution needed for: ['result', 'add_error']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.add_error
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.add_error
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.add_error
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.add_error
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.add_error
            [INTERMEDIATE] Tracking chain steps for: result.add_error
            [INTERMEDIATE] Step 1: result.add_error
      -> Resolved to: admin_manager.OperationResult.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.add_error
        [CACHE] result.add_error -> admin_manager.OperationResult.add_error (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.operation_type
        [CACHE] result.operation_type -> admin_manager.OperationResult.operation_type (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager._execute_specific_operation
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager._execute_specific_operation
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager._handle_user_management
    [CONTEXT] Entered function: admin_manager.AdminManager._handle_user_management (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'result': 'OperationResult', 'parameters': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for result: OperationResult
    [RESOLVE] Attempting to resolve: ['OperationResult']
      [RESOLVE_SIMPLE] Resolving base: OperationResult
      [CACHE] Hit for OperationResult: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [SYMBOL_UPDATE] Function: result -> admin_manager.OperationResult
        [ARG_TYPE] RESOLVED result : admin_manager.OperationResult
      [ASSIGNMENT] Processing: action = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
      [TYPE_INFERENCE] Call resolved to: admin_manager.parameters.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for action
      [NAME] Found name reference: action
    [RESOLVE] Attempting to resolve: ['action']
      [RESOLVE_SIMPLE] Resolving base: action
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable action not found in any scope
      [LOCAL_RESOLVER] can_resolve(action): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(action): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(action): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(action): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(action): admin_manager.action
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: action -> admin_manager.action
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.action
      -> Not module state
      [CALL] Found call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
            [INTERMEDIATE] Tracking chain steps for: parameters.get
            [INTERMEDIATE] Step 1: parameters.get
      -> Resolved to: admin_manager.parameters.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: parameters.get
        [CACHE] parameters.get -> admin_manager.parameters.get (cached)
      -> Not module state
      [NAME] Found name reference: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
    [RESOLVE] RESOLVED to: admin_manager.parameters
      -> Not module state
      [NAME] Found name reference: action
        [CACHE] action -> admin_manager.action (cached)
      -> Not module state
      [ASSIGNMENT] Processing: username = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
      [TYPE_INFERENCE] Call resolved to: admin_manager.parameters.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for username
      [NAME] Found name reference: username
    [RESOLVE] Attempting to resolve: ['username']
      [RESOLVE_SIMPLE] Resolving base: username
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable username not found in any scope
      [LOCAL_RESOLVER] can_resolve(username): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(username): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(username): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(username): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(username): admin_manager.username
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: username -> admin_manager.username
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.username
      -> Not module state
      [CALL] Found call: parameters.get
    [CACHE] parameters.get -> admin_manager.parameters.get (cached)
            [INTERMEDIATE] Tracking chain steps for: parameters.get
            [INTERMEDIATE] Step 1: parameters.get
      -> Resolved to: admin_manager.parameters.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: parameters.get
        [CACHE] parameters.get -> admin_manager.parameters.get (cached)
      -> Not module state
      [NAME] Found name reference: parameters
        [CACHE] parameters -> admin_manager.parameters (cached)
      -> Not module state
      [NAME] Found name reference: username
        [CACHE] username -> admin_manager.username (cached)
      -> Not module state
      [CALL] Found call: result.add_error
    [RESOLVE] Attempting to resolve: ['result', 'add_error']
    [RESOLVE] Chain resolution needed for: ['result', 'add_error']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.add_error
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.add_error
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.add_error
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.add_error
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.add_error
            [INTERMEDIATE] Tracking chain steps for: result.add_error
            [INTERMEDIATE] Step 1: result.add_error
      -> Resolved to: admin_manager.OperationResult.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.add_error
        [CACHE] result.add_error -> admin_manager.OperationResult.add_error (cached)
      -> Not module state
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
    [RESOLVE] Attempting to resolve: ['result', 'data']
    [RESOLVE] Chain resolution needed for: ['result', 'data']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.data
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.data
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.data
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.data
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.data
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: username
        [CACHE] username -> admin_manager.username (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: admin_manager.str
    [RESOLVE] RESOLVED to: admin_manager.str
      -> Not module state
      [CALL] Found call: uuid.uuid4
    [RESOLVE] Attempting to resolve: ['uuid', 'uuid4']
    [RESOLVE] Chain resolution needed for: ['uuid', 'uuid4']
      [CHAIN] Resolving base: uuid
      [RESOLVE_SIMPLE] Resolving base: uuid
      [CACHE] Hit for uuid: uuid
      [CHAIN] Base resolved: uuid -> uuid
      [CHAIN] Step 1: Resolving uuid.uuid4
        [ATTRIBUTE] Resolving attribute: uuid.uuid4
        [ATTRIBUTE] Direct match found: uuid.uuid4
      [CHAIN] Step 1 resolved: uuid.uuid4
    [RESOLVE] RESOLVED to: uuid.uuid4
            [INTERMEDIATE] Tracking chain steps for: uuid.uuid4
            [INTERMEDIATE] Step 1: uuid.uuid4
      -> Resolved to: uuid.uuid4
      -> ADDED to calls (external library)
      [ATTRIBUTE] Found attribute access: uuid.uuid4
        [CACHE] uuid.uuid4 -> uuid.uuid4 (cached)
      -> Not module state
      [NAME] Found name reference: uuid
    [RESOLVE] Attempting to resolve: ['uuid']
      [RESOLVE_SIMPLE] Resolving base: uuid
      [CACHE] Hit for uuid: uuid
    [RESOLVE] RESOLVED to: uuid
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
      [NAME] Found name reference: action
        [CACHE] action -> admin_manager.action (cached)
      -> Not module state
      [ASSIGNMENT] Processing: user_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
      [TYPE_INFERENCE] Call resolved to: admin_manager.parameters.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for user_id
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable user_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(user_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(user_id): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(user_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(user_id): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(user_id): admin_manager.user_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: user_id -> admin_manager.user_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.user_id
      -> Not module state
      [CALL] Found call: parameters.get
    [CACHE] parameters.get -> admin_manager.parameters.get (cached)
            [INTERMEDIATE] Tracking chain steps for: parameters.get
            [INTERMEDIATE] Step 1: parameters.get
      -> Resolved to: admin_manager.parameters.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: parameters.get
        [CACHE] parameters.get -> admin_manager.parameters.get (cached)
      -> Not module state
      [NAME] Found name reference: parameters
        [CACHE] parameters -> admin_manager.parameters (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> admin_manager.user_id (cached)
      -> Not module state
      [CALL] Found call: result.add_error
    [CACHE] result.add_error -> admin_manager.OperationResult.add_error (cached)
            [INTERMEDIATE] Tracking chain steps for: result.add_error
            [INTERMEDIATE] Step 1: result.add_error
      -> Resolved to: admin_manager.OperationResult.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.add_error
        [CACHE] result.add_error -> admin_manager.OperationResult.add_error (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> admin_manager.user_id (cached)
      -> Not module state
      [CALL] Found call: result.add_warning
    [RESOLVE] Attempting to resolve: ['result', 'add_warning']
    [RESOLVE] Chain resolution needed for: ['result', 'add_warning']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.add_warning
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.add_warning
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.add_warning
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.add_warning
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.add_warning
            [INTERMEDIATE] Tracking chain steps for: result.add_warning
            [INTERMEDIATE] Step 1: result.add_warning
      -> Resolved to: admin_manager.OperationResult.add_warning
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.add_warning
        [CACHE] result.add_warning -> admin_manager.OperationResult.add_warning (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: action
        [CACHE] action -> admin_manager.action (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
        [CACHE] str -> admin_manager.str (cached)
      -> Not module state
      [CALL] Found call: uuid.uuid4
    [CACHE] uuid.uuid4 -> uuid.uuid4 (cached)
            [INTERMEDIATE] Tracking chain steps for: uuid.uuid4
            [INTERMEDIATE] Step 1: uuid.uuid4
      -> Resolved to: uuid.uuid4
      -> ADDED to calls (external library)
      [ATTRIBUTE] Found attribute access: uuid.uuid4
        [CACHE] uuid.uuid4 -> uuid.uuid4 (cached)
      -> Not module state
      [NAME] Found name reference: uuid
        [CACHE] uuid -> uuid (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
        [CACHE] str -> admin_manager.str (cached)
      -> Not module state
      [CALL] Found call: uuid.uuid4
    [CACHE] uuid.uuid4 -> uuid.uuid4 (cached)
            [INTERMEDIATE] Tracking chain steps for: uuid.uuid4
            [INTERMEDIATE] Step 1: uuid.uuid4
      -> Resolved to: uuid.uuid4
      -> ADDED to calls (external library)
      [ATTRIBUTE] Found attribute access: uuid.uuid4
        [CACHE] uuid.uuid4 -> uuid.uuid4 (cached)
      -> Not module state
      [NAME] Found name reference: uuid
        [CACHE] uuid -> uuid (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
        [CACHE] str -> admin_manager.str (cached)
      -> Not module state
      [CALL] Found call: uuid.uuid4
    [CACHE] uuid.uuid4 -> uuid.uuid4 (cached)
            [INTERMEDIATE] Tracking chain steps for: uuid.uuid4
            [INTERMEDIATE] Step 1: uuid.uuid4
      -> Resolved to: uuid.uuid4
      -> ADDED to calls (external library)
      [ATTRIBUTE] Found attribute access: uuid.uuid4
        [CACHE] uuid.uuid4 -> uuid.uuid4 (cached)
      -> Not module state
      [NAME] Found name reference: uuid
        [CACHE] uuid -> uuid (cached)
      -> Not module state
      [CALL] Found call: result.add_error
    [CACHE] result.add_error -> admin_manager.OperationResult.add_error (cached)
            [INTERMEDIATE] Tracking chain steps for: result.add_error
            [INTERMEDIATE] Step 1: result.add_error
      -> Resolved to: admin_manager.OperationResult.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.add_error
        [CACHE] result.add_error -> admin_manager.OperationResult.add_error (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: action
        [CACHE] action -> admin_manager.action (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager._handle_user_management
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager._handle_user_management
        Calls: 3
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager._handle_system_configuration
    [CONTEXT] Entered function: admin_manager.AdminManager._handle_system_configuration (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'result': 'OperationResult', 'parameters': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for result: OperationResult
    [RESOLVE] Attempting to resolve: ['OperationResult']
      [RESOLVE_SIMPLE] Resolving base: OperationResult
      [CACHE] Hit for OperationResult: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [SYMBOL_UPDATE] Function: result -> admin_manager.OperationResult
        [ARG_TYPE] RESOLVED result : admin_manager.OperationResult
      [ASSIGNMENT] Processing: config_updates = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
      [TYPE_INFERENCE] Call resolved to: admin_manager.parameters.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for config_updates
      [NAME] Found name reference: config_updates
    [RESOLVE] Attempting to resolve: ['config_updates']
      [RESOLVE_SIMPLE] Resolving base: config_updates
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable config_updates not found in any scope
      [LOCAL_RESOLVER] can_resolve(config_updates): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(config_updates): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(config_updates): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(config_updates): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(config_updates): admin_manager.config_updates
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: config_updates -> admin_manager.config_updates
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.config_updates
      -> Not module state
      [CALL] Found call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
            [INTERMEDIATE] Tracking chain steps for: parameters.get
            [INTERMEDIATE] Step 1: parameters.get
      -> Resolved to: admin_manager.parameters.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: parameters.get
        [CACHE] parameters.get -> admin_manager.parameters.get (cached)
      -> Not module state
      [NAME] Found name reference: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
    [RESOLVE] RESOLVED to: admin_manager.parameters
      -> Not module state
      [ASSIGNMENT] Processing: valid_keys = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: set
    [RESOLVE] Attempting to resolve: ['set']
      [RESOLVE_SIMPLE] Resolving base: set
      [CACHE] Hit for set: admin_manager.set
    [RESOLVE] RESOLVED to: admin_manager.set
      [TYPE_INFERENCE] Call resolved to: admin_manager.set
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for valid_keys
      [NAME] Found name reference: valid_keys
    [RESOLVE] Attempting to resolve: ['valid_keys']
      [RESOLVE_SIMPLE] Resolving base: valid_keys
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable valid_keys not found in any scope
      [LOCAL_RESOLVER] can_resolve(valid_keys): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(valid_keys): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(valid_keys): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(valid_keys): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(valid_keys): admin_manager.valid_keys
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: valid_keys -> admin_manager.valid_keys
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.valid_keys
      -> Not module state
      [CALL] Found call: set
      -> IGNORED (built-in function)
      [NAME] Found name reference: set
    [RESOLVE] Attempting to resolve: ['set']
      [RESOLVE_SIMPLE] Resolving base: set
      [CACHE] Hit for set: admin_manager.set
    [RESOLVE] RESOLVED to: admin_manager.set
      -> Not module state
      [CALL] Found call: self.system_config.keys
    [RESOLVE] Attempting to resolve: ['self', 'system_config', 'keys']
    [RESOLVE] Chain resolution needed for: ['self', 'system_config', 'keys']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.system_config
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.system_config
      [CHAIN] Step 2: Resolving admin_manager.AdminManager.system_config.keys
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config.keys
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config.keys
      [CHAIN] Step 2 resolved: admin_manager.AdminManager.system_config.keys
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.system_config.keys
            [INTERMEDIATE] Tracking chain steps for: self.system_config.keys
            [INTERMEDIATE] Step 1: self.system_config
    [RESOLVE] Attempting to resolve: ['self', 'system_config']
    [RESOLVE] Chain resolution needed for: ['self', 'system_config']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.system_config
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.system_config
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.system_config
            [INTERMEDIATE] Step 1 resolved to: admin_manager.AdminManager.system_config
            [INTERMEDIATE] Step 2: self.system_config.keys
      -> Resolved to: admin_manager.AdminManager.system_config.keys
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.system_config.keys
        [CACHE] self.system_config.keys -> admin_manager.AdminManager.system_config.keys (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.system_config
        [CACHE] self.system_config -> admin_manager.AdminManager.system_config (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      -> Not module state
      [ASSIGNMENT] Processing: invalid_keys = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: invalid_keys
    [RESOLVE] Attempting to resolve: ['invalid_keys']
      [RESOLVE_SIMPLE] Resolving base: invalid_keys
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable invalid_keys not found in any scope
      [LOCAL_RESOLVER] can_resolve(invalid_keys): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(invalid_keys): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(invalid_keys): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(invalid_keys): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(invalid_keys): admin_manager.invalid_keys
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: invalid_keys -> admin_manager.invalid_keys
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.invalid_keys
      -> Not module state
      [CALL] Found call: set
      -> IGNORED (built-in function)
      [NAME] Found name reference: set
        [CACHE] set -> admin_manager.set (cached)
      -> Not module state
      [CALL] Found call: config_updates.keys
    [RESOLVE] Attempting to resolve: ['config_updates', 'keys']
    [RESOLVE] Chain resolution needed for: ['config_updates', 'keys']
      [CHAIN] Resolving base: config_updates
      [RESOLVE_SIMPLE] Resolving base: config_updates
      [CACHE] Hit for config_updates: admin_manager.config_updates
      [CHAIN] Base resolved: config_updates -> admin_manager.config_updates
      [CHAIN] Step 1: Resolving admin_manager.config_updates.keys
        [ATTRIBUTE] Resolving attribute: admin_manager.config_updates.keys
        [ATTRIBUTE] Direct match found: admin_manager.config_updates.keys
      [CHAIN] Step 1 resolved: admin_manager.config_updates.keys
    [RESOLVE] RESOLVED to: admin_manager.config_updates.keys
            [INTERMEDIATE] Tracking chain steps for: config_updates.keys
            [INTERMEDIATE] Step 1: config_updates.keys
      -> Resolved to: admin_manager.config_updates.keys
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: config_updates.keys
        [CACHE] config_updates.keys -> admin_manager.config_updates.keys (cached)
      -> Not module state
      [NAME] Found name reference: config_updates
        [CACHE] config_updates -> admin_manager.config_updates (cached)
      -> Not module state
      [NAME] Found name reference: valid_keys
        [CACHE] valid_keys -> admin_manager.valid_keys (cached)
      -> Not module state
      [NAME] Found name reference: invalid_keys
        [CACHE] invalid_keys -> admin_manager.invalid_keys (cached)
      -> Not module state
      [CALL] Found call: result.add_error
    [RESOLVE] Attempting to resolve: ['result', 'add_error']
    [RESOLVE] Chain resolution needed for: ['result', 'add_error']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.add_error
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.add_error
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.add_error
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.add_error
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.add_error
            [INTERMEDIATE] Tracking chain steps for: result.add_error
            [INTERMEDIATE] Step 1: result.add_error
      -> Resolved to: admin_manager.OperationResult.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.add_error
        [CACHE] result.add_error -> admin_manager.OperationResult.add_error (cached)
      -> Not module state
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [NAME] Found name reference: invalid_keys
        [CACHE] invalid_keys -> admin_manager.invalid_keys (cached)
      -> Not module state
      [ASSIGNMENT] Processing: old_config = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.system_config.copy
    [RESOLVE] Attempting to resolve: ['self', 'system_config', 'copy']
    [RESOLVE] Chain resolution needed for: ['self', 'system_config', 'copy']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.system_config
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.system_config
      [CHAIN] Step 2: Resolving admin_manager.AdminManager.system_config.copy
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config.copy
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config.copy
      [CHAIN] Step 2 resolved: admin_manager.AdminManager.system_config.copy
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.system_config.copy
      [TYPE_INFERENCE] Call resolved to: admin_manager.AdminManager.system_config.copy
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for old_config
      [NAME] Found name reference: old_config
    [RESOLVE] Attempting to resolve: ['old_config']
      [RESOLVE_SIMPLE] Resolving base: old_config
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable old_config not found in any scope
      [LOCAL_RESOLVER] can_resolve(old_config): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(old_config): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(old_config): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(old_config): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(old_config): admin_manager.old_config
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: old_config -> admin_manager.old_config
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.old_config
      -> Not module state
      [CALL] Found call: self.system_config.copy
    [RESOLVE] Attempting to resolve: ['self', 'system_config', 'copy']
    [RESOLVE] Chain resolution needed for: ['self', 'system_config', 'copy']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.system_config
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.system_config
      [CHAIN] Step 2: Resolving admin_manager.AdminManager.system_config.copy
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config.copy
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config.copy
      [CHAIN] Step 2 resolved: admin_manager.AdminManager.system_config.copy
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.system_config.copy
            [INTERMEDIATE] Tracking chain steps for: self.system_config.copy
            [INTERMEDIATE] Step 1: self.system_config
    [CACHE] self.system_config -> admin_manager.AdminManager.system_config (cached)
            [INTERMEDIATE] Step 1 resolved to: admin_manager.AdminManager.system_config
            [INTERMEDIATE] Step 2: self.system_config.copy
      -> Resolved to: admin_manager.AdminManager.system_config.copy
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.system_config.copy
        [CACHE] self.system_config.copy -> admin_manager.AdminManager.system_config.copy (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.system_config
        [CACHE] self.system_config -> admin_manager.AdminManager.system_config (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [CALL] Found call: self.system_config.update
    [RESOLVE] Attempting to resolve: ['self', 'system_config', 'update']
    [RESOLVE] Chain resolution needed for: ['self', 'system_config', 'update']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.system_config
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.system_config
      [CHAIN] Step 2: Resolving admin_manager.AdminManager.system_config.update
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config.update
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config.update
      [CHAIN] Step 2 resolved: admin_manager.AdminManager.system_config.update
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.system_config.update
            [INTERMEDIATE] Tracking chain steps for: self.system_config.update
            [INTERMEDIATE] Step 1: self.system_config
    [CACHE] self.system_config -> admin_manager.AdminManager.system_config (cached)
            [INTERMEDIATE] Step 1 resolved to: admin_manager.AdminManager.system_config
            [INTERMEDIATE] Step 2: self.system_config.update
      -> Resolved to: admin_manager.AdminManager.system_config.update
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: config_updates
    [RESOLVE] Attempting to resolve: ['config_updates']
      [RESOLVE_SIMPLE] Resolving base: config_updates
      [CACHE] Hit for config_updates: admin_manager.config_updates
    [RESOLVE] RESOLVED to: admin_manager.config_updates
      [ATTRIBUTE] Found attribute access: self.system_config.update
        [CACHE] self.system_config.update -> admin_manager.AdminManager.system_config.update (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.system_config
        [CACHE] self.system_config -> admin_manager.AdminManager.system_config (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: config_updates
        [CACHE] config_updates -> admin_manager.config_updates (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
    [RESOLVE] Attempting to resolve: ['result', 'data']
    [RESOLVE] Chain resolution needed for: ['result', 'data']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.data
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.data
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.data
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.data
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.data
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: old_config
        [CACHE] old_config -> admin_manager.old_config (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: self.system_config.copy
    [CACHE] self.system_config.copy -> admin_manager.AdminManager.system_config.copy (cached)
            [INTERMEDIATE] Tracking chain steps for: self.system_config.copy
            [INTERMEDIATE] Step 1: self.system_config
    [CACHE] self.system_config -> admin_manager.AdminManager.system_config (cached)
            [INTERMEDIATE] Step 1 resolved to: admin_manager.AdminManager.system_config
            [INTERMEDIATE] Step 2: self.system_config.copy
      -> Resolved to: admin_manager.AdminManager.system_config.copy
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.system_config.copy
        [CACHE] self.system_config.copy -> admin_manager.AdminManager.system_config.copy (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.system_config
        [CACHE] self.system_config -> admin_manager.AdminManager.system_config (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: config_updates
        [CACHE] config_updates -> admin_manager.config_updates (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager._handle_system_configuration
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager._handle_system_configuration
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager._handle_data_migration
    [CONTEXT] Entered function: admin_manager.AdminManager._handle_data_migration (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'result': 'OperationResult', 'parameters': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for result: OperationResult
    [RESOLVE] Attempting to resolve: ['OperationResult']
      [RESOLVE_SIMPLE] Resolving base: OperationResult
      [CACHE] Hit for OperationResult: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [SYMBOL_UPDATE] Function: result -> admin_manager.OperationResult
        [ARG_TYPE] RESOLVED result : admin_manager.OperationResult
      [ASSIGNMENT] Processing: migration_type = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
      [TYPE_INFERENCE] Call resolved to: admin_manager.parameters.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for migration_type
      [NAME] Found name reference: migration_type
    [RESOLVE] Attempting to resolve: ['migration_type']
      [RESOLVE_SIMPLE] Resolving base: migration_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable migration_type not found in any scope
      [LOCAL_RESOLVER] can_resolve(migration_type): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(migration_type): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(migration_type): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(migration_type): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(migration_type): admin_manager.migration_type
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: migration_type -> admin_manager.migration_type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.migration_type
      -> Not module state
      [CALL] Found call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
            [INTERMEDIATE] Tracking chain steps for: parameters.get
            [INTERMEDIATE] Step 1: parameters.get
      -> Resolved to: admin_manager.parameters.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: parameters.get
        [CACHE] parameters.get -> admin_manager.parameters.get (cached)
      -> Not module state
      [NAME] Found name reference: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
    [RESOLVE] RESOLVED to: admin_manager.parameters
      -> Not module state
      [NAME] Found name reference: migration_type
        [CACHE] migration_type -> admin_manager.migration_type (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
    [RESOLVE] Attempting to resolve: ['result', 'data']
    [RESOLVE] Chain resolution needed for: ['result', 'data']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.data
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.data
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.data
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.data
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.data
      -> Not module state
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: migration_type
        [CACHE] migration_type -> admin_manager.migration_type (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: parameters.get
    [CACHE] parameters.get -> admin_manager.parameters.get (cached)
            [INTERMEDIATE] Tracking chain steps for: parameters.get
            [INTERMEDIATE] Step 1: parameters.get
      -> Resolved to: admin_manager.parameters.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: parameters.get
        [CACHE] parameters.get -> admin_manager.parameters.get (cached)
      -> Not module state
      [NAME] Found name reference: parameters
        [CACHE] parameters -> admin_manager.parameters (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: result.add_error
    [RESOLVE] Attempting to resolve: ['result', 'add_error']
    [RESOLVE] Chain resolution needed for: ['result', 'add_error']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.add_error
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.add_error
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.add_error
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.add_error
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.add_error
            [INTERMEDIATE] Tracking chain steps for: result.add_error
            [INTERMEDIATE] Step 1: result.add_error
      -> Resolved to: admin_manager.OperationResult.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.add_error
        [CACHE] result.add_error -> admin_manager.OperationResult.add_error (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: migration_type
        [CACHE] migration_type -> admin_manager.migration_type (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager._handle_data_migration
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager._handle_data_migration
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager._handle_security_audit
    [CONTEXT] Entered function: admin_manager.AdminManager._handle_security_audit (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'result': 'OperationResult', 'parameters': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for result: OperationResult
    [RESOLVE] Attempting to resolve: ['OperationResult']
      [RESOLVE_SIMPLE] Resolving base: OperationResult
      [CACHE] Hit for OperationResult: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [SYMBOL_UPDATE] Function: result -> admin_manager.OperationResult
        [ARG_TYPE] RESOLVED result : admin_manager.OperationResult
      [ASSIGNMENT] Processing: audit_scope = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
      [TYPE_INFERENCE] Call resolved to: admin_manager.parameters.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for audit_scope
      [NAME] Found name reference: audit_scope
    [RESOLVE] Attempting to resolve: ['audit_scope']
      [RESOLVE_SIMPLE] Resolving base: audit_scope
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable audit_scope not found in any scope
      [LOCAL_RESOLVER] can_resolve(audit_scope): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(audit_scope): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(audit_scope): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(audit_scope): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(audit_scope): admin_manager.audit_scope
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: audit_scope -> admin_manager.audit_scope
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.audit_scope
      -> Not module state
      [CALL] Found call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
            [INTERMEDIATE] Tracking chain steps for: parameters.get
            [INTERMEDIATE] Step 1: parameters.get
      -> Resolved to: admin_manager.parameters.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: parameters.get
        [CACHE] parameters.get -> admin_manager.parameters.get (cached)
      -> Not module state
      [NAME] Found name reference: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
    [RESOLVE] RESOLVED to: admin_manager.parameters
      -> Not module state
      [ASSIGNMENT] Processing: audit_findings = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: audit_findings
    [RESOLVE] Attempting to resolve: ['audit_findings']
      [RESOLVE_SIMPLE] Resolving base: audit_findings
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable audit_findings not found in any scope
      [LOCAL_RESOLVER] can_resolve(audit_findings): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(audit_findings): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(audit_findings): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(audit_findings): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(audit_findings): admin_manager.audit_findings
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: audit_findings -> admin_manager.audit_findings
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.audit_findings
      -> Not module state
      [NAME] Found name reference: audit_scope
        [CACHE] audit_scope -> admin_manager.audit_scope (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
    [RESOLVE] Attempting to resolve: ['result', 'data']
    [RESOLVE] Chain resolution needed for: ['result', 'data']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.data
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.data
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.data
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.data
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.data
      -> Not module state
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [NAME] Found name reference: audit_findings
        [CACHE] audit_findings -> admin_manager.audit_findings (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: audit_scope
        [CACHE] audit_scope -> admin_manager.audit_scope (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: audit_findings
        [CACHE] audit_findings -> admin_manager.audit_findings (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: audit_findings
        [CACHE] audit_findings -> admin_manager.audit_findings (cached)
      -> Not module state
      [CALL] Found call: result.add_warning
    [RESOLVE] Attempting to resolve: ['result', 'add_warning']
    [RESOLVE] Chain resolution needed for: ['result', 'add_warning']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.add_warning
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.add_warning
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.add_warning
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.add_warning
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.add_warning
            [INTERMEDIATE] Tracking chain steps for: result.add_warning
            [INTERMEDIATE] Step 1: result.add_warning
      -> Resolved to: admin_manager.OperationResult.add_warning
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.add_warning
        [CACHE] result.add_warning -> admin_manager.OperationResult.add_warning (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager._handle_security_audit
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager._handle_security_audit
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager._handle_performance_tuning
    [CONTEXT] Entered function: admin_manager.AdminManager._handle_performance_tuning (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'result': 'OperationResult', 'parameters': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for result: OperationResult
    [RESOLVE] Attempting to resolve: ['OperationResult']
      [RESOLVE_SIMPLE] Resolving base: OperationResult
      [CACHE] Hit for OperationResult: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [SYMBOL_UPDATE] Function: result -> admin_manager.OperationResult
        [ARG_TYPE] RESOLVED result : admin_manager.OperationResult
      [ASSIGNMENT] Processing: target_component = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
      [TYPE_INFERENCE] Call resolved to: admin_manager.parameters.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for target_component
      [NAME] Found name reference: target_component
    [RESOLVE] Attempting to resolve: ['target_component']
      [RESOLVE_SIMPLE] Resolving base: target_component
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable target_component not found in any scope
      [LOCAL_RESOLVER] can_resolve(target_component): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(target_component): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(target_component): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(target_component): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(target_component): admin_manager.target_component
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: target_component -> admin_manager.target_component
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.target_component
      -> Not module state
      [CALL] Found call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
            [INTERMEDIATE] Tracking chain steps for: parameters.get
            [INTERMEDIATE] Step 1: parameters.get
      -> Resolved to: admin_manager.parameters.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: parameters.get
        [CACHE] parameters.get -> admin_manager.parameters.get (cached)
      -> Not module state
      [NAME] Found name reference: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
    [RESOLVE] RESOLVED to: admin_manager.parameters
      -> Not module state
      [ASSIGNMENT] Processing: performance_metrics = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: performance_metrics
    [RESOLVE] Attempting to resolve: ['performance_metrics']
      [RESOLVE_SIMPLE] Resolving base: performance_metrics
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable performance_metrics not found in any scope
      [LOCAL_RESOLVER] can_resolve(performance_metrics): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(performance_metrics): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(performance_metrics): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(performance_metrics): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(performance_metrics): admin_manager.performance_metrics
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: performance_metrics -> admin_manager.performance_metrics
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.performance_metrics
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
    [RESOLVE] Attempting to resolve: ['result', 'data']
    [RESOLVE] Chain resolution needed for: ['result', 'data']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.data
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.data
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.data
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.data
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.data
      -> Not module state
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [NAME] Found name reference: target_component
        [CACHE] target_component -> admin_manager.target_component (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: performance_metrics
        [CACHE] performance_metrics -> admin_manager.performance_metrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager._handle_performance_tuning
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager._handle_performance_tuning
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager._handle_backup_restore
    [CONTEXT] Entered function: admin_manager.AdminManager._handle_backup_restore (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'result': 'OperationResult', 'parameters': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for result: OperationResult
    [RESOLVE] Attempting to resolve: ['OperationResult']
      [RESOLVE_SIMPLE] Resolving base: OperationResult
      [CACHE] Hit for OperationResult: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [SYMBOL_UPDATE] Function: result -> admin_manager.OperationResult
        [ARG_TYPE] RESOLVED result : admin_manager.OperationResult
      [ASSIGNMENT] Processing: operation = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
      [TYPE_INFERENCE] Call resolved to: admin_manager.parameters.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for operation
      [NAME] Found name reference: operation
    [RESOLVE] Attempting to resolve: ['operation']
      [RESOLVE_SIMPLE] Resolving base: operation
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable operation not found in any scope
      [LOCAL_RESOLVER] can_resolve(operation): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(operation): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(operation): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(operation): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(operation): admin_manager.operation
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: operation -> admin_manager.operation
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.operation
      -> Not module state
      [CALL] Found call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
            [INTERMEDIATE] Tracking chain steps for: parameters.get
            [INTERMEDIATE] Step 1: parameters.get
      -> Resolved to: admin_manager.parameters.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: parameters.get
        [CACHE] parameters.get -> admin_manager.parameters.get (cached)
      -> Not module state
      [NAME] Found name reference: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
    [RESOLVE] RESOLVED to: admin_manager.parameters
      -> Not module state
      [NAME] Found name reference: operation
        [CACHE] operation -> admin_manager.operation (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
    [RESOLVE] Attempting to resolve: ['result', 'data']
    [RESOLVE] Chain resolution needed for: ['result', 'data']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.data
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.data
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.data
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.data
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.data
      -> Not module state
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: admin_manager.str
    [RESOLVE] RESOLVED to: admin_manager.str
      -> Not module state
      [CALL] Found call: uuid.uuid4
    [RESOLVE] Attempting to resolve: ['uuid', 'uuid4']
    [RESOLVE] Chain resolution needed for: ['uuid', 'uuid4']
      [CHAIN] Resolving base: uuid
      [RESOLVE_SIMPLE] Resolving base: uuid
      [CACHE] Hit for uuid: uuid
      [CHAIN] Base resolved: uuid -> uuid
      [CHAIN] Step 1: Resolving uuid.uuid4
        [ATTRIBUTE] Resolving attribute: uuid.uuid4
        [ATTRIBUTE] Direct match found: uuid.uuid4
      [CHAIN] Step 1 resolved: uuid.uuid4
    [RESOLVE] RESOLVED to: uuid.uuid4
            [INTERMEDIATE] Tracking chain steps for: uuid.uuid4
            [INTERMEDIATE] Step 1: uuid.uuid4
      -> Resolved to: uuid.uuid4
      -> ADDED to calls (external library)
      [ATTRIBUTE] Found attribute access: uuid.uuid4
        [CACHE] uuid.uuid4 -> uuid.uuid4 (cached)
      -> Not module state
      [NAME] Found name reference: uuid
    [RESOLVE] Attempting to resolve: ['uuid']
      [RESOLVE_SIMPLE] Resolving base: uuid
      [CACHE] Hit for uuid: uuid
    [RESOLVE] RESOLVED to: uuid
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
      [NAME] Found name reference: operation
        [CACHE] operation -> admin_manager.operation (cached)
      -> Not module state
      [ASSIGNMENT] Processing: backup_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
      [TYPE_INFERENCE] Call resolved to: admin_manager.parameters.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for backup_id
      [NAME] Found name reference: backup_id
    [RESOLVE] Attempting to resolve: ['backup_id']
      [RESOLVE_SIMPLE] Resolving base: backup_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable backup_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(backup_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(backup_id): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(backup_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(backup_id): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(backup_id): admin_manager.backup_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: backup_id -> admin_manager.backup_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.backup_id
      -> Not module state
      [CALL] Found call: parameters.get
    [CACHE] parameters.get -> admin_manager.parameters.get (cached)
            [INTERMEDIATE] Tracking chain steps for: parameters.get
            [INTERMEDIATE] Step 1: parameters.get
      -> Resolved to: admin_manager.parameters.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: parameters.get
        [CACHE] parameters.get -> admin_manager.parameters.get (cached)
      -> Not module state
      [NAME] Found name reference: parameters
        [CACHE] parameters -> admin_manager.parameters (cached)
      -> Not module state
      [NAME] Found name reference: backup_id
        [CACHE] backup_id -> admin_manager.backup_id (cached)
      -> Not module state
      [CALL] Found call: result.add_error
    [RESOLVE] Attempting to resolve: ['result', 'add_error']
    [RESOLVE] Chain resolution needed for: ['result', 'add_error']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.add_error
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.add_error
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.add_error
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.add_error
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.add_error
            [INTERMEDIATE] Tracking chain steps for: result.add_error
            [INTERMEDIATE] Step 1: result.add_error
      -> Resolved to: admin_manager.OperationResult.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.add_error
        [CACHE] result.add_error -> admin_manager.OperationResult.add_error (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: backup_id
        [CACHE] backup_id -> admin_manager.backup_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: datetime.now
    [CACHE] datetime.now -> datetime.datetime.now (cached)
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
        [CACHE] datetime -> datetime.datetime (cached)
      -> Not module state
      [CALL] Found call: result.add_warning
    [RESOLVE] Attempting to resolve: ['result', 'add_warning']
    [RESOLVE] Chain resolution needed for: ['result', 'add_warning']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.add_warning
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.add_warning
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.add_warning
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.add_warning
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.add_warning
            [INTERMEDIATE] Tracking chain steps for: result.add_warning
            [INTERMEDIATE] Step 1: result.add_warning
      -> Resolved to: admin_manager.OperationResult.add_warning
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.add_warning
        [CACHE] result.add_warning -> admin_manager.OperationResult.add_warning (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager._handle_backup_restore
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager._handle_backup_restore
        Calls: 3
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager._handle_monitoring_setup
    [CONTEXT] Entered function: admin_manager.AdminManager._handle_monitoring_setup (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'result': 'OperationResult', 'parameters': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for result: OperationResult
    [RESOLVE] Attempting to resolve: ['OperationResult']
      [RESOLVE_SIMPLE] Resolving base: OperationResult
      [CACHE] Hit for OperationResult: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [SYMBOL_UPDATE] Function: result -> admin_manager.OperationResult
        [ARG_TYPE] RESOLVED result : admin_manager.OperationResult
      [ASSIGNMENT] Processing: monitoring_type = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
      [TYPE_INFERENCE] Call resolved to: admin_manager.parameters.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for monitoring_type
      [NAME] Found name reference: monitoring_type
    [RESOLVE] Attempting to resolve: ['monitoring_type']
      [RESOLVE_SIMPLE] Resolving base: monitoring_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable monitoring_type not found in any scope
      [LOCAL_RESOLVER] can_resolve(monitoring_type): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(monitoring_type): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(monitoring_type): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(monitoring_type): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(monitoring_type): admin_manager.monitoring_type
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: monitoring_type -> admin_manager.monitoring_type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.monitoring_type
      -> Not module state
      [CALL] Found call: parameters.get
    [RESOLVE] Attempting to resolve: ['parameters', 'get']
    [RESOLVE] Chain resolution needed for: ['parameters', 'get']
      [CHAIN] Resolving base: parameters
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
      [CHAIN] Base resolved: parameters -> admin_manager.parameters
      [CHAIN] Step 1: Resolving admin_manager.parameters.get
        [ATTRIBUTE] Resolving attribute: admin_manager.parameters.get
        [ATTRIBUTE] Direct match found: admin_manager.parameters.get
      [CHAIN] Step 1 resolved: admin_manager.parameters.get
    [RESOLVE] RESOLVED to: admin_manager.parameters.get
            [INTERMEDIATE] Tracking chain steps for: parameters.get
            [INTERMEDIATE] Step 1: parameters.get
      -> Resolved to: admin_manager.parameters.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: parameters.get
        [CACHE] parameters.get -> admin_manager.parameters.get (cached)
      -> Not module state
      [NAME] Found name reference: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
    [RESOLVE] RESOLVED to: admin_manager.parameters
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
    [RESOLVE] Attempting to resolve: ['result', 'data']
    [RESOLVE] Chain resolution needed for: ['result', 'data']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.data
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.data
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.data
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.data
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.data
      -> Not module state
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
        [CACHE] result.data -> admin_manager.OperationResult.data (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: monitoring_type
        [CACHE] monitoring_type -> admin_manager.monitoring_type (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager._handle_monitoring_setup
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager._handle_monitoring_setup
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager._result_to_dict
    [CONTEXT] Entered function: admin_manager.AdminManager._result_to_dict (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'result': 'OperationResult'}
        [ARG_TYPE] Processing type annotation for result: OperationResult
    [RESOLVE] Attempting to resolve: ['OperationResult']
      [RESOLVE_SIMPLE] Resolving base: OperationResult
      [CACHE] Hit for OperationResult: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [SYMBOL_UPDATE] Function: result -> admin_manager.OperationResult
        [ARG_TYPE] RESOLVED result : admin_manager.OperationResult
      [ASSIGNMENT] Processing: result_dict = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: result_dict
    [RESOLVE] Attempting to resolve: ['result_dict']
      [RESOLVE_SIMPLE] Resolving base: result_dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable result_dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(result_dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(result_dict): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(result_dict): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(result_dict): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(result_dict): admin_manager.result_dict
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: result_dict -> admin_manager.result_dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.result_dict
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.operation_id
    [RESOLVE] Attempting to resolve: ['result', 'operation_id']
    [RESOLVE] Chain resolution needed for: ['result', 'operation_id']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.operation_id
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.operation_id
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.operation_id
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.operation_id
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.operation_id
      -> Not module state
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.operation_type.name
    [RESOLVE] Attempting to resolve: ['result', 'operation_type', 'name']
    [RESOLVE] Chain resolution needed for: ['result', 'operation_type', 'name']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.operation_type
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.operation_type
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.operation_type
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.operation_type
      [CHAIN] Step 2: Resolving admin_manager.OperationResult.operation_type.name
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.operation_type.name
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.operation_type.name
      [CHAIN] Step 2 resolved: admin_manager.OperationResult.operation_type.name
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.operation_type.name
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.operation_type
    [RESOLVE] Attempting to resolve: ['result', 'operation_type']
    [RESOLVE] Chain resolution needed for: ['result', 'operation_type']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.operation_type
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.operation_type
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.operation_type
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.operation_type
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.operation_type
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.status.name
    [RESOLVE] Attempting to resolve: ['result', 'status', 'name']
    [RESOLVE] Chain resolution needed for: ['result', 'status', 'name']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.status
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.status
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.status
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.status
      [CHAIN] Step 2: Resolving admin_manager.OperationResult.status.name
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.status.name
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.status.name
      [CHAIN] Step 2 resolved: admin_manager.OperationResult.status.name
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.status.name
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.status
    [RESOLVE] Attempting to resolve: ['result', 'status']
    [RESOLVE] Chain resolution needed for: ['result', 'status']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.status
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.status
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.status
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.status
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.status
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.success
    [RESOLVE] Attempting to resolve: ['result', 'success']
    [RESOLVE] Chain resolution needed for: ['result', 'success']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.success
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.success
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.success
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.success
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.success
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.message
    [RESOLVE] Attempting to resolve: ['result', 'message']
    [RESOLVE] Chain resolution needed for: ['result', 'message']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.message
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.message
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.message
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.message
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.message
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: result.start_time.isoformat
    [RESOLVE] Attempting to resolve: ['result', 'start_time', 'isoformat']
    [RESOLVE] Chain resolution needed for: ['result', 'start_time', 'isoformat']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.start_time
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.start_time
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.start_time
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.start_time
      [CHAIN] Step 2: Resolving admin_manager.OperationResult.start_time.isoformat
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.start_time.isoformat
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.start_time.isoformat
      [CHAIN] Step 2 resolved: admin_manager.OperationResult.start_time.isoformat
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.start_time.isoformat
            [INTERMEDIATE] Tracking chain steps for: result.start_time.isoformat
            [INTERMEDIATE] Step 1: result.start_time
    [RESOLVE] Attempting to resolve: ['result', 'start_time']
    [RESOLVE] Chain resolution needed for: ['result', 'start_time']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.start_time
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.start_time
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.start_time
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.start_time
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.start_time
            [INTERMEDIATE] Step 1 resolved to: admin_manager.OperationResult.start_time
            [INTERMEDIATE] Step 2: result.start_time.isoformat
      -> Resolved to: admin_manager.OperationResult.start_time.isoformat
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: result.start_time.isoformat
        [CACHE] result.start_time.isoformat -> admin_manager.OperationResult.start_time.isoformat (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.start_time
        [CACHE] result.start_time -> admin_manager.OperationResult.start_time (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.data
    [RESOLVE] Attempting to resolve: ['result', 'data']
    [RESOLVE] Chain resolution needed for: ['result', 'data']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.data
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.data
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.data
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.data
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.data
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.end_time
    [RESOLVE] Attempting to resolve: ['result', 'end_time']
    [RESOLVE] Chain resolution needed for: ['result', 'end_time']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.end_time
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.end_time
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.end_time
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.end_time
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.end_time
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: result_dict
        [CACHE] result_dict -> admin_manager.result_dict (cached)
      -> Not module state
      [CALL] Found call: result.end_time.isoformat
    [RESOLVE] Attempting to resolve: ['result', 'end_time', 'isoformat']
    [RESOLVE] Chain resolution needed for: ['result', 'end_time', 'isoformat']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.end_time
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.end_time
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.end_time
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.end_time
      [CHAIN] Step 2: Resolving admin_manager.OperationResult.end_time.isoformat
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.end_time.isoformat
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.end_time.isoformat
      [CHAIN] Step 2 resolved: admin_manager.OperationResult.end_time.isoformat
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.end_time.isoformat
            [INTERMEDIATE] Tracking chain steps for: result.end_time.isoformat
            [INTERMEDIATE] Step 1: result.end_time
    [CACHE] result.end_time -> admin_manager.OperationResult.end_time (cached)
            [INTERMEDIATE] Step 1 resolved to: admin_manager.OperationResult.end_time
            [INTERMEDIATE] Step 2: result.end_time.isoformat
      -> Resolved to: admin_manager.OperationResult.end_time.isoformat
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: result.end_time.isoformat
        [CACHE] result.end_time.isoformat -> admin_manager.OperationResult.end_time.isoformat (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.end_time
        [CACHE] result.end_time -> admin_manager.OperationResult.end_time (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ASSIGNMENT] Processing: duration = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: result.get_duration
    [RESOLVE] Attempting to resolve: ['result', 'get_duration']
    [RESOLVE] Chain resolution needed for: ['result', 'get_duration']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.get_duration
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.get_duration
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.get_duration
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.get_duration
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.get_duration
      [TYPE_INFERENCE] Call resolved to: admin_manager.OperationResult.get_duration
        [RETURN_TYPE_RESOLUTION] Resolving return type: timedelta
        [RETURN_TYPE_RESOLUTION] Class 'timedelta' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: timedelta
      [TYPE_INFERENCE] Could not resolve return type 'timedelta' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: timedelta (from return type - unresolved)
      [SYMBOL_UPDATE] Function: duration -> timedelta
        [ASSIGNMENT] RESOLVED Updated symbol table: duration = timedelta
      [NAME] Found name reference: duration
    [RESOLVE] Attempting to resolve: ['duration']
      [RESOLVE_SIMPLE] Resolving base: duration
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found duration in function scope: timedelta
      [LOCAL_RESOLVER] can_resolve(duration): True
      [SYMBOL_LOOKUP] Found duration in function scope: timedelta
      [LOCAL_RESOLVER] resolve(duration): timedelta
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: duration -> timedelta
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: timedelta
      -> Not module state
      [CALL] Found call: result.get_duration
    [RESOLVE] Attempting to resolve: ['result', 'get_duration']
    [RESOLVE] Chain resolution needed for: ['result', 'get_duration']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.get_duration
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.get_duration
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.get_duration
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.get_duration
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.get_duration
            [INTERMEDIATE] Tracking chain steps for: result.get_duration
            [INTERMEDIATE] Step 1: result.get_duration
      -> Resolved to: admin_manager.OperationResult.get_duration
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.get_duration
        [CACHE] result.get_duration -> admin_manager.OperationResult.get_duration (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: duration
        [CACHE] duration -> timedelta (cached)
      -> Not module state
      [NAME] Found name reference: result_dict
        [CACHE] result_dict -> admin_manager.result_dict (cached)
      -> Not module state
      [CALL] Found call: duration.total_seconds
    [RESOLVE] Attempting to resolve: ['duration', 'total_seconds']
    [RESOLVE] Chain resolution needed for: ['duration', 'total_seconds']
      [CHAIN] Resolving base: duration
      [RESOLVE_SIMPLE] Resolving base: duration
      [CACHE] Hit for duration: timedelta
      [CHAIN] Base resolved: duration -> timedelta
      [CHAIN] Step 1: Resolving timedelta.total_seconds
        [ATTRIBUTE] Resolving attribute: timedelta.total_seconds
        [ATTRIBUTE] Direct match found: timedelta.total_seconds
      [CHAIN] Step 1 resolved: timedelta.total_seconds
    [RESOLVE] RESOLVED to: timedelta.total_seconds
            [INTERMEDIATE] Tracking chain steps for: duration.total_seconds
            [INTERMEDIATE] Step 1: duration.total_seconds
      -> Resolved to: timedelta.total_seconds
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: duration.total_seconds
        [CACHE] duration.total_seconds -> timedelta.total_seconds (cached)
      -> Not module state
      [NAME] Found name reference: duration
        [CACHE] duration -> timedelta (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.errors
    [RESOLVE] Attempting to resolve: ['result', 'errors']
    [RESOLVE] Chain resolution needed for: ['result', 'errors']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.errors
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.errors
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.errors
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.errors
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.errors
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: result_dict
        [CACHE] result_dict -> admin_manager.result_dict (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.errors
        [CACHE] result.errors -> admin_manager.OperationResult.errors (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.warnings
    [RESOLVE] Attempting to resolve: ['result', 'warnings']
    [RESOLVE] Chain resolution needed for: ['result', 'warnings']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.warnings
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.warnings
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.warnings
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.warnings
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.warnings
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: result_dict
        [CACHE] result_dict -> admin_manager.result_dict (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.warnings
        [CACHE] result.warnings -> admin_manager.OperationResult.warnings (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: result_dict
        [CACHE] result_dict -> admin_manager.result_dict (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager._result_to_dict
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager._result_to_dict
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager._add_audit_entry
    [CONTEXT] Entered function: admin_manager.AdminManager._add_audit_entry (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'result': 'OperationResult', 'parameters': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for result: OperationResult
    [RESOLVE] Attempting to resolve: ['OperationResult']
      [RESOLVE_SIMPLE] Resolving base: OperationResult
      [CACHE] Hit for OperationResult: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [SYMBOL_UPDATE] Function: result -> admin_manager.OperationResult
        [ARG_TYPE] RESOLVED result : admin_manager.OperationResult
      [ASSIGNMENT] Processing: audit_entry = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: audit_entry
    [RESOLVE] Attempting to resolve: ['audit_entry']
      [RESOLVE_SIMPLE] Resolving base: audit_entry
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable audit_entry not found in any scope
      [LOCAL_RESOLVER] can_resolve(audit_entry): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(audit_entry): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(audit_entry): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(audit_entry): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(audit_entry): admin_manager.audit_entry
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: audit_entry -> admin_manager.audit_entry
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.audit_entry
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.operation_id
    [RESOLVE] Attempting to resolve: ['result', 'operation_id']
    [RESOLVE] Chain resolution needed for: ['result', 'operation_id']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.operation_id
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.operation_id
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.operation_id
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.operation_id
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.operation_id
      -> Not module state
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.operation_type.name
    [RESOLVE] Attempting to resolve: ['result', 'operation_type', 'name']
    [RESOLVE] Chain resolution needed for: ['result', 'operation_type', 'name']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.operation_type
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.operation_type
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.operation_type
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.operation_type
      [CHAIN] Step 2: Resolving admin_manager.OperationResult.operation_type.name
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.operation_type.name
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.operation_type.name
      [CHAIN] Step 2 resolved: admin_manager.OperationResult.operation_type.name
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.operation_type.name
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.operation_type
    [RESOLVE] Attempting to resolve: ['result', 'operation_type']
    [RESOLVE] Chain resolution needed for: ['result', 'operation_type']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.operation_type
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.operation_type
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.operation_type
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.operation_type
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.operation_type
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.status.name
    [RESOLVE] Attempting to resolve: ['result', 'status', 'name']
    [RESOLVE] Chain resolution needed for: ['result', 'status', 'name']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.status
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.status
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.status
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.status
      [CHAIN] Step 2: Resolving admin_manager.OperationResult.status.name
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.status.name
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.status.name
      [CHAIN] Step 2 resolved: admin_manager.OperationResult.status.name
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.status.name
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.status
    [RESOLVE] Attempting to resolve: ['result', 'status']
    [RESOLVE] Chain resolution needed for: ['result', 'status']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.status
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.status
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.status
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.status
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.status
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.success
    [RESOLVE] Attempting to resolve: ['result', 'success']
    [RESOLVE] Chain resolution needed for: ['result', 'success']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.success
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.success
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.success
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.success
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.success
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [NAME] Found name reference: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: admin_manager.parameters
    [RESOLVE] RESOLVED to: admin_manager.parameters
      -> Not module state
      [CALL] Found call: result.get_duration
    [RESOLVE] Attempting to resolve: ['result', 'get_duration']
    [RESOLVE] Chain resolution needed for: ['result', 'get_duration']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.get_duration
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.get_duration
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.get_duration
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.get_duration
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.get_duration
            [INTERMEDIATE] Tracking chain steps for: result.get_duration
            [INTERMEDIATE] Step 1: result.get_duration
      -> Resolved to: admin_manager.OperationResult.get_duration
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.get_duration
        [CACHE] result.get_duration -> admin_manager.OperationResult.get_duration (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: result.get_duration
    [CACHE] result.get_duration -> admin_manager.OperationResult.get_duration (cached)
            [INTERMEDIATE] Tracking chain steps for: result.get_duration
            [INTERMEDIATE] Step 1: result.get_duration
      -> Resolved to: admin_manager.OperationResult.get_duration
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: result.get_duration
        [CACHE] result.get_duration -> admin_manager.OperationResult.get_duration (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: self.audit_log.append
    [RESOLVE] Attempting to resolve: ['self', 'audit_log', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'audit_log', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.audit_log
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.audit_log
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.audit_log
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.audit_log
      [CHAIN] Step 2: Resolving admin_manager.AdminManager.audit_log.append
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.audit_log.append
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.audit_log.append
      [CHAIN] Step 2 resolved: admin_manager.AdminManager.audit_log.append
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.audit_log.append
            [INTERMEDIATE] Tracking chain steps for: self.audit_log.append
            [INTERMEDIATE] Step 1: self.audit_log
    [RESOLVE] Attempting to resolve: ['self', 'audit_log']
    [RESOLVE] Chain resolution needed for: ['self', 'audit_log']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.audit_log
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.audit_log
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.audit_log
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.audit_log
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.audit_log
            [INTERMEDIATE] Step 1 resolved to: admin_manager.AdminManager.audit_log
            [INTERMEDIATE] Step 2: self.audit_log.append
      -> Resolved to: admin_manager.AdminManager.audit_log.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: audit_entry
    [RESOLVE] Attempting to resolve: ['audit_entry']
      [RESOLVE_SIMPLE] Resolving base: audit_entry
      [CACHE] Hit for audit_entry: admin_manager.audit_entry
    [RESOLVE] RESOLVED to: admin_manager.audit_entry
      [ATTRIBUTE] Found attribute access: self.audit_log.append
        [CACHE] self.audit_log.append -> admin_manager.AdminManager.audit_log.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.audit_log
        [CACHE] self.audit_log -> admin_manager.AdminManager.audit_log (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      -> Not module state
      [NAME] Found name reference: audit_entry
        [CACHE] audit_entry -> admin_manager.audit_entry (cached)
      -> Not module state
      [ASSIGNMENT] Processing: cutoff_date = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: cutoff_date
    [RESOLVE] Attempting to resolve: ['cutoff_date']
      [RESOLVE_SIMPLE] Resolving base: cutoff_date
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable cutoff_date not found in any scope
      [LOCAL_RESOLVER] can_resolve(cutoff_date): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(cutoff_date): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(cutoff_date): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(cutoff_date): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(cutoff_date): admin_manager.cutoff_date
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: cutoff_date -> admin_manager.cutoff_date
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.cutoff_date
      -> Not module state
      [CALL] Found call: datetime.now
    [CACHE] datetime.now -> datetime.datetime.now (cached)
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
        [CACHE] datetime -> datetime.datetime (cached)
      -> Not module state
      [CALL] Found call: timedelta
    [RESOLVE] Attempting to resolve: ['timedelta']
      [RESOLVE_SIMPLE] Resolving base: timedelta
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable timedelta not found in any scope
      [LOCAL_RESOLVER] can_resolve(timedelta): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(timedelta): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(timedelta): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(timedelta): datetime.timedelta (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: timedelta -> datetime.timedelta
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: datetime.timedelta
      -> Resolved to: datetime.timedelta
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: timedelta
        [CACHE] timedelta -> datetime.timedelta (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.system_config
    [RESOLVE] Attempting to resolve: ['self', 'system_config']
    [RESOLVE] Chain resolution needed for: ['self', 'system_config']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.system_config
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.system_config
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.system_config
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.audit_log
        [CACHE] self.audit_log -> admin_manager.AdminManager.audit_log (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: entry
    [RESOLVE] Attempting to resolve: ['entry']
      [RESOLVE_SIMPLE] Resolving base: entry
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable entry not found in any scope
      [LOCAL_RESOLVER] can_resolve(entry): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(entry): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(entry): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(entry): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(entry): admin_manager.entry
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: entry -> admin_manager.entry
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.entry
      -> Not module state
      [NAME] Found name reference: entry
        [CACHE] entry -> admin_manager.entry (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.audit_log
        [CACHE] self.audit_log -> admin_manager.AdminManager.audit_log (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [CALL] Found call: datetime.fromisoformat
    [RESOLVE] Attempting to resolve: ['datetime', 'fromisoformat']
    [RESOLVE] Chain resolution needed for: ['datetime', 'fromisoformat']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.fromisoformat
        [ATTRIBUTE] Resolving attribute: datetime.datetime.fromisoformat
        [ATTRIBUTE] Direct match found: datetime.datetime.fromisoformat
      [CHAIN] Step 1 resolved: datetime.datetime.fromisoformat
    [RESOLVE] RESOLVED to: datetime.datetime.fromisoformat
            [INTERMEDIATE] Tracking chain steps for: datetime.fromisoformat
            [INTERMEDIATE] Step 1: datetime.fromisoformat
      -> Resolved to: datetime.datetime.fromisoformat
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.fromisoformat
        [CACHE] datetime.fromisoformat -> datetime.datetime.fromisoformat (cached)
      -> Not module state
      [NAME] Found name reference: datetime
        [CACHE] datetime -> datetime.datetime (cached)
      -> Not module state
      [NAME] Found name reference: entry
        [CACHE] entry -> admin_manager.entry (cached)
      -> Not module state
      [NAME] Found name reference: cutoff_date
        [CACHE] cutoff_date -> admin_manager.cutoff_date (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager._add_audit_entry
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager._add_audit_entry
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager.get_operation_status
    [CONTEXT] Entered function: admin_manager.AdminManager.get_operation_status (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'operation_id': 'str'}
        [ARG_TYPE] Processing type annotation for operation_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: admin_manager.str
    [RESOLVE] RESOLVED to: admin_manager.str
      [SYMBOL_UPDATE] Function: operation_id -> admin_manager.str
        [ARG_TYPE] RESOLVED operation_id : admin_manager.str
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.operations_history.get
    [RESOLVE] Attempting to resolve: ['self', 'operations_history', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_history', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operations_history
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.operations_history
      [CHAIN] Step 2: Resolving admin_manager.AdminManager.operations_history.get
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operations_history.get
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operations_history.get
      [CHAIN] Step 2 resolved: admin_manager.AdminManager.operations_history.get
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.operations_history.get
      [TYPE_INFERENCE] Call resolved to: admin_manager.AdminManager.operations_history.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for result
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [CALL] Found call: self.operations_history.get
    [RESOLVE] Attempting to resolve: ['self', 'operations_history', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_history', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operations_history
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.operations_history
      [CHAIN] Step 2: Resolving admin_manager.AdminManager.operations_history.get
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operations_history.get
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operations_history.get
      [CHAIN] Step 2 resolved: admin_manager.AdminManager.operations_history.get
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.operations_history.get
            [INTERMEDIATE] Tracking chain steps for: self.operations_history.get
            [INTERMEDIATE] Step 1: self.operations_history
    [RESOLVE] Attempting to resolve: ['self', 'operations_history']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_history']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operations_history
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.operations_history
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.operations_history
            [INTERMEDIATE] Step 1 resolved to: admin_manager.AdminManager.operations_history
            [INTERMEDIATE] Step 2: self.operations_history.get
      -> Resolved to: admin_manager.AdminManager.operations_history.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: operation_id
    [RESOLVE] Attempting to resolve: ['operation_id']
      [RESOLVE_SIMPLE] Resolving base: operation_id
      [CACHE] Hit for operation_id: admin_manager.operation_id
    [RESOLVE] RESOLVED to: admin_manager.operation_id
      [ATTRIBUTE] Found attribute access: self.operations_history.get
        [CACHE] self.operations_history.get -> admin_manager.AdminManager.operations_history.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operations_history
        [CACHE] self.operations_history -> admin_manager.AdminManager.operations_history (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      -> Not module state
      [NAME] Found name reference: operation_id
    [RESOLVE] Attempting to resolve: ['operation_id']
      [RESOLVE_SIMPLE] Resolving base: operation_id
      [CACHE] Hit for operation_id: admin_manager.operation_id
    [RESOLVE] RESOLVED to: admin_manager.operation_id
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: self._result_to_dict
    [RESOLVE] Attempting to resolve: ['self', '_result_to_dict']
    [RESOLVE] Chain resolution needed for: ['self', '_result_to_dict']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager._result_to_dict
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager._result_to_dict
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager._result_to_dict
      [CHAIN] Step 1 resolved: admin_manager.AdminManager._result_to_dict
    [RESOLVE] RESOLVED to: admin_manager.AdminManager._result_to_dict
            [INTERMEDIATE] Tracking chain steps for: self._result_to_dict
            [INTERMEDIATE] Step 1: self._result_to_dict
      -> Resolved to: admin_manager.AdminManager._result_to_dict
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      [ATTRIBUTE] Found attribute access: self._result_to_dict
        [CACHE] self._result_to_dict -> admin_manager.AdminManager._result_to_dict (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager.get_operation_status
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager.get_operation_status
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager.get_active_operations
    [CONTEXT] Entered function: admin_manager.AdminManager.get_active_operations (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.operation_lock
    [RESOLVE] Attempting to resolve: ['self', 'operation_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'operation_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.operation_lock
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operation_lock
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operation_lock
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.operation_lock
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.operation_lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      -> Not module state
      [CALL] Found call: list
      -> IGNORED (built-in function)
      [NAME] Found name reference: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable list not found in any scope
      [LOCAL_RESOLVER] can_resolve(list): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(list): False (current_class: admin_manager.AdminManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(list): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(list): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(list): admin_manager.list
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: list -> admin_manager.list
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.list
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_operations
    [RESOLVE] Attempting to resolve: ['self', 'active_operations']
    [RESOLVE] Chain resolution needed for: ['self', 'active_operations']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.active_operations
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.active_operations
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.active_operations
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager.get_active_operations
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager.get_active_operations
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager.get_system_status
    [CONTEXT] Entered function: admin_manager.AdminManager.get_system_status (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [CACHE] Hit for len: admin_manager.len
    [RESOLVE] RESOLVED to: admin_manager.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_operations
    [RESOLVE] Attempting to resolve: ['self', 'active_operations']
    [RESOLVE] Chain resolution needed for: ['self', 'active_operations']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.active_operations
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.active_operations
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.active_operations
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
        [CACHE] len -> admin_manager.len (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operations_history
    [RESOLVE] Attempting to resolve: ['self', 'operations_history']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_history']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operations_history
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.operations_history
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.operations_history
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [CALL] Found call: self.system_config.copy
    [RESOLVE] Attempting to resolve: ['self', 'system_config', 'copy']
    [RESOLVE] Chain resolution needed for: ['self', 'system_config', 'copy']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.system_config
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.system_config
      [CHAIN] Step 2: Resolving admin_manager.AdminManager.system_config.copy
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config.copy
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config.copy
      [CHAIN] Step 2 resolved: admin_manager.AdminManager.system_config.copy
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.system_config.copy
            [INTERMEDIATE] Tracking chain steps for: self.system_config.copy
            [INTERMEDIATE] Step 1: self.system_config
    [RESOLVE] Attempting to resolve: ['self', 'system_config']
    [RESOLVE] Chain resolution needed for: ['self', 'system_config']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.system_config
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.system_config
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.system_config
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.system_config
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.system_config
            [INTERMEDIATE] Step 1 resolved to: admin_manager.AdminManager.system_config
            [INTERMEDIATE] Step 2: self.system_config.copy
      -> Resolved to: admin_manager.AdminManager.system_config.copy
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.system_config.copy
        [CACHE] self.system_config.copy -> admin_manager.AdminManager.system_config.copy (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.system_config
        [CACHE] self.system_config -> admin_manager.AdminManager.system_config (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager.get_system_status
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager.get_system_status
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: admin_manager.AdminManager.cancel_operation
    [CONTEXT] Entered function: admin_manager.AdminManager.cancel_operation (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'operation_id': 'str'}
        [ARG_TYPE] Processing type annotation for operation_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: admin_manager.str
    [RESOLVE] RESOLVED to: admin_manager.str
      [SYMBOL_UPDATE] Function: operation_id -> admin_manager.str
        [ARG_TYPE] RESOLVED operation_id : admin_manager.str
      [ATTRIBUTE] Found attribute access: self.operation_lock
    [RESOLVE] Attempting to resolve: ['self', 'operation_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'operation_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.operation_lock
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operation_lock
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operation_lock
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.operation_lock
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.operation_lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      -> Not module state
      [NAME] Found name reference: operation_id
    [RESOLVE] Attempting to resolve: ['operation_id']
      [RESOLVE_SIMPLE] Resolving base: operation_id
      [CACHE] Hit for operation_id: admin_manager.operation_id
    [RESOLVE] RESOLVED to: admin_manager.operation_id
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_operations
    [RESOLVE] Attempting to resolve: ['self', 'active_operations']
    [RESOLVE] Chain resolution needed for: ['self', 'active_operations']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.active_operations
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.active_operations
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.active_operations
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.operations_history.get
    [RESOLVE] Attempting to resolve: ['self', 'operations_history', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_history', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operations_history
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.operations_history
      [CHAIN] Step 2: Resolving admin_manager.AdminManager.operations_history.get
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operations_history.get
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operations_history.get
      [CHAIN] Step 2 resolved: admin_manager.AdminManager.operations_history.get
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.operations_history.get
      [TYPE_INFERENCE] Call resolved to: admin_manager.AdminManager.operations_history.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for result
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
    [RESOLVE] RESOLVED to: admin_manager.OperationResult
      -> Not module state
      [CALL] Found call: self.operations_history.get
    [RESOLVE] Attempting to resolve: ['self', 'operations_history', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_history', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operations_history
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.operations_history
      [CHAIN] Step 2: Resolving admin_manager.AdminManager.operations_history.get
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operations_history.get
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operations_history.get
      [CHAIN] Step 2 resolved: admin_manager.AdminManager.operations_history.get
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.operations_history.get
            [INTERMEDIATE] Tracking chain steps for: self.operations_history.get
            [INTERMEDIATE] Step 1: self.operations_history
    [RESOLVE] Attempting to resolve: ['self', 'operations_history']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_history']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.operations_history
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.operations_history
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.operations_history
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.operations_history
            [INTERMEDIATE] Step 1 resolved to: admin_manager.AdminManager.operations_history
            [INTERMEDIATE] Step 2: self.operations_history.get
      -> Resolved to: admin_manager.AdminManager.operations_history.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: operation_id
    [RESOLVE] Attempting to resolve: ['operation_id']
      [RESOLVE_SIMPLE] Resolving base: operation_id
      [CACHE] Hit for operation_id: admin_manager.operation_id
    [RESOLVE] RESOLVED to: admin_manager.operation_id
      [ATTRIBUTE] Found attribute access: self.operations_history.get
        [CACHE] self.operations_history.get -> admin_manager.AdminManager.operations_history.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operations_history
        [CACHE] self.operations_history -> admin_manager.AdminManager.operations_history (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: operation_id
        [CACHE] operation_id -> admin_manager.operation_id (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.status
    [RESOLVE] Attempting to resolve: ['result', 'status']
    [RESOLVE] Chain resolution needed for: ['result', 'status']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.status
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.status
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.status
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.status
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.status
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: OperationStatus.CANCELLED
    [RESOLVE] Attempting to resolve: ['OperationStatus', 'CANCELLED']
    [RESOLVE] Chain resolution needed for: ['OperationStatus', 'CANCELLED']
      [CHAIN] Resolving base: OperationStatus
      [RESOLVE_SIMPLE] Resolving base: OperationStatus
      [CACHE] Hit for OperationStatus: admin_manager.OperationStatus
      [CHAIN] Base resolved: OperationStatus -> admin_manager.OperationStatus
      [CHAIN] Step 1: Resolving admin_manager.OperationStatus.CANCELLED
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationStatus.CANCELLED
        [ATTRIBUTE] Direct match found: admin_manager.OperationStatus.CANCELLED
      [CHAIN] Step 1 resolved: admin_manager.OperationStatus.CANCELLED
    [RESOLVE] RESOLVED to: admin_manager.OperationStatus.CANCELLED
      -> Not module state
      [NAME] Found name reference: OperationStatus
    [RESOLVE] Attempting to resolve: ['OperationStatus']
      [RESOLVE_SIMPLE] Resolving base: OperationStatus
      [CACHE] Hit for OperationStatus: admin_manager.OperationStatus
    [RESOLVE] RESOLVED to: admin_manager.OperationStatus
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.end_time
    [RESOLVE] Attempting to resolve: ['result', 'end_time']
    [RESOLVE] Chain resolution needed for: ['result', 'end_time']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.end_time
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.end_time
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.end_time
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.end_time
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.end_time
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.message
    [RESOLVE] Attempting to resolve: ['result', 'message']
    [RESOLVE] Chain resolution needed for: ['result', 'message']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: admin_manager.OperationResult
      [CHAIN] Base resolved: result -> admin_manager.OperationResult
      [CHAIN] Step 1: Resolving admin_manager.OperationResult.message
        [ATTRIBUTE] Resolving attribute: admin_manager.OperationResult.message
        [ATTRIBUTE] Direct match found: admin_manager.OperationResult.message
      [CHAIN] Step 1 resolved: admin_manager.OperationResult.message
    [RESOLVE] RESOLVED to: admin_manager.OperationResult.message
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> admin_manager.OperationResult (cached)
      -> Not module state
      [CALL] Found call: self.active_operations.discard
    [RESOLVE] Attempting to resolve: ['self', 'active_operations', 'discard']
    [RESOLVE] Chain resolution needed for: ['self', 'active_operations', 'discard']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: admin_manager.AdminManager
      [CHAIN] Base resolved: self -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.active_operations
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.active_operations
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.active_operations
      [CHAIN] Step 2: Resolving admin_manager.AdminManager.active_operations.discard
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.active_operations.discard
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.active_operations.discard
      [CHAIN] Step 2 resolved: admin_manager.AdminManager.active_operations.discard
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.active_operations.discard
            [INTERMEDIATE] Tracking chain steps for: self.active_operations.discard
            [INTERMEDIATE] Step 1: self.active_operations
    [CACHE] self.active_operations -> admin_manager.AdminManager.active_operations (cached)
            [INTERMEDIATE] Step 1 resolved to: admin_manager.AdminManager.active_operations
            [INTERMEDIATE] Step 2: self.active_operations.discard
      -> Resolved to: admin_manager.AdminManager.active_operations.discard
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: operation_id
    [RESOLVE] Attempting to resolve: ['operation_id']
      [RESOLVE_SIMPLE] Resolving base: operation_id
      [CACHE] Hit for operation_id: admin_manager.operation_id
    [RESOLVE] RESOLVED to: admin_manager.operation_id
      [ATTRIBUTE] Found attribute access: self.active_operations.discard
        [CACHE] self.active_operations.discard -> admin_manager.AdminManager.active_operations.discard (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_operations
        [CACHE] self.active_operations -> admin_manager.AdminManager.active_operations (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: operation_id
        [CACHE] operation_id -> admin_manager.operation_id (cached)
      -> Not module state
    [CONTEXT] Exited function: admin_manager.AdminManager.cancel_operation
    [FUNCTION_ANALYSIS] Completed analysis of: admin_manager.AdminManager.cancel_operation
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: admin_manager.AdminManager
    [SYMBOL_TABLE] Exited class scope
      [ASSIGNMENT] Processing: manager = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: AdminManager
    [RESOLVE] Attempting to resolve: ['AdminManager']
      [RESOLVE_SIMPLE] Resolving base: AdminManager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable AdminManager not found in any scope
      [LOCAL_RESOLVER] can_resolve(AdminManager): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(AdminManager): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(AdminManager): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(AdminManager): True (fallback, module: admin_manager)
      [MODULE_RESOLVER] resolve(AdminManager): admin_manager.AdminManager
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: AdminManager -> admin_manager.AdminManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      [TYPE_INFERENCE] Call resolved to: admin_manager.AdminManager
      [TYPE_INFERENCE] RESOLVED Inferred type: admin_manager.AdminManager (class instantiation)
      [SYMBOL_UPDATE] Function: manager -> admin_manager.AdminManager
        [ASSIGNMENT] RESOLVED Updated symbol table: manager = admin_manager.AdminManager
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: manager.execute_operation
    [RESOLVE] Attempting to resolve: ['manager', 'execute_operation']
    [RESOLVE] Chain resolution needed for: ['manager', 'execute_operation']
      [CHAIN] Resolving base: manager
      [RESOLVE_SIMPLE] Resolving base: manager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found manager in function scope: admin_manager.AdminManager
      [LOCAL_RESOLVER] can_resolve(manager): True
      [SYMBOL_LOOKUP] Found manager in function scope: admin_manager.AdminManager
      [LOCAL_RESOLVER] resolve(manager): admin_manager.AdminManager
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: manager -> admin_manager.AdminManager
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: manager -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.execute_operation
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.execute_operation
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.execute_operation
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.execute_operation
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.execute_operation
      [TYPE_INFERENCE] Call resolved to: admin_manager.AdminManager.execute_operation
        [RETURN_TYPE_RESOLUTION] Resolving return type: Dict[str, Any]
        [RETURN_TYPE_RESOLUTION] Class 'Dict[str, Any]' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: Dict[str, Any]
      [TYPE_INFERENCE] Could not resolve return type 'Dict[str, Any]' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: Dict[str, Any] (from return type - unresolved)
      [SYMBOL_UPDATE] Function: result -> Dict[str, Any]
        [ASSIGNMENT] RESOLVED Updated symbol table: result = Dict[str, Any]
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: manager.execute_operation
    [RESOLVE] Attempting to resolve: ['manager', 'execute_operation']
    [RESOLVE] Chain resolution needed for: ['manager', 'execute_operation']
      [CHAIN] Resolving base: manager
      [RESOLVE_SIMPLE] Resolving base: manager
      [CACHE] Hit for manager: admin_manager.AdminManager
      [CHAIN] Base resolved: manager -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.execute_operation
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.execute_operation
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.execute_operation
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.execute_operation
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.execute_operation
      [TYPE_INFERENCE] Call resolved to: admin_manager.AdminManager.execute_operation
        [RETURN_TYPE_RESOLUTION] Resolving return type: Dict[str, Any]
        [RETURN_TYPE_RESOLUTION] Class 'Dict[str, Any]' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: Dict[str, Any]
      [TYPE_INFERENCE] Could not resolve return type 'Dict[str, Any]' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: Dict[str, Any] (from return type - unresolved)
      [SYMBOL_UPDATE] Function: result -> Dict[str, Any]
        [ASSIGNMENT] RESOLVED Updated symbol table: result = Dict[str, Any]
      [ASSIGNMENT] Processing: status = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: manager.get_system_status
    [RESOLVE] Attempting to resolve: ['manager', 'get_system_status']
    [RESOLVE] Chain resolution needed for: ['manager', 'get_system_status']
      [CHAIN] Resolving base: manager
      [RESOLVE_SIMPLE] Resolving base: manager
      [CACHE] Hit for manager: admin_manager.AdminManager
      [CHAIN] Base resolved: manager -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.get_system_status
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.get_system_status
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.get_system_status
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.get_system_status
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.get_system_status
      [TYPE_INFERENCE] Call resolved to: admin_manager.AdminManager.get_system_status
        [RETURN_TYPE_RESOLUTION] Resolving return type: Dict[str, Any]
        [RETURN_TYPE_RESOLUTION] Class 'Dict[str, Any]' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: Dict[str, Any]
      [TYPE_INFERENCE] Could not resolve return type 'Dict[str, Any]' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: Dict[str, Any] (from return type - unresolved)
      [SYMBOL_UPDATE] Function: status -> Dict[str, Any]
        [ASSIGNMENT] RESOLVED Updated symbol table: status = Dict[str, Any]
=== Module Analysis Complete ===
  Module analysis complete
=== Analyzing database_manager.py ===
  [RESOLVER] Using implementation: refactored
=== Starting Module Analysis ===
    [FROM_IMPORT] Any -> typing.Any
    [FROM_IMPORT] Optional -> typing.Optional
    [FROM_IMPORT] Dict -> typing.Dict
    [FROM_IMPORT] List -> typing.List
    [FROM_IMPORT] contextmanager -> contextlib.contextmanager
    [IMPORT] threading -> threading
    [IMPORT] time -> time
    [IMPORT] logging -> logging
  [CLASS] Analyzing class: DatabaseConnection
    [CONTEXT] Entered class: database_manager.DatabaseConnection
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.DatabaseConnection.__init__
    [CONTEXT] Entered function: database_manager.DatabaseConnection.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'connection_id': 'str'}
        [ARG_TYPE] Processing type annotation for connection_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: database_manager.DatabaseConnection)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(str): database_manager.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> database_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.str
      [SYMBOL_UPDATE] Function: connection_id -> database_manager.str
        [ARG_TYPE] RESOLVED connection_id : database_manager.str
      [ATTRIBUTE] Found attribute access: self.connection_id
    [RESOLVE] Attempting to resolve: ['self', 'connection_id']
    [RESOLVE] Chain resolution needed for: ['self', 'connection_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: database_manager.DatabaseConnection)
      [SELF_RESOLVER] resolve(self): database_manager.DatabaseConnection
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> database_manager.DatabaseConnection
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.connection_id
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.connection_id
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.connection_id
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Not module state
      [NAME] Found name reference: connection_id
    [RESOLVE] Attempting to resolve: ['connection_id']
      [RESOLVE_SIMPLE] Resolving base: connection_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found connection_id in function scope: database_manager.str
      [LOCAL_RESOLVER] can_resolve(connection_id): True
      [SYMBOL_LOOKUP] Found connection_id in function scope: database_manager.str
      [LOCAL_RESOLVER] resolve(connection_id): database_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: connection_id -> database_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.is_open
    [RESOLVE] Attempting to resolve: ['self', 'is_open']
    [RESOLVE] Chain resolution needed for: ['self', 'is_open']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.is_open
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.is_open
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.is_open
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.in_transaction
    [RESOLVE] Attempting to resolve: ['self', 'in_transaction']
    [RESOLVE] Chain resolution needed for: ['self', 'in_transaction']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.in_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.in_transaction
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.in_transaction
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.in_transaction
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.in_transaction
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.isolation_level
    [RESOLVE] Attempting to resolve: ['self', 'isolation_level']
    [RESOLVE] Chain resolution needed for: ['self', 'isolation_level']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.isolation_level
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.isolation_level
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.isolation_level
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.isolation_level
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.isolation_level
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.query_count
    [RESOLVE] Attempting to resolve: ['self', 'query_count']
    [RESOLVE] Chain resolution needed for: ['self', 'query_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.query_count
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.query_count
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.query_count
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.query_count
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.query_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.last_query_time
    [RESOLVE] Attempting to resolve: ['self', 'last_query_time']
    [RESOLVE] Chain resolution needed for: ['self', 'last_query_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.last_query_time
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.last_query_time
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.last_query_time
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.last_query_time
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.last_query_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable time not found in any scope
      [LOCAL_RESOLVER] can_resolve(time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(time): False (current_class: database_manager.DatabaseConnection)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(time): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(time): time (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: time -> time
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.lock
    [RESOLVE] Attempting to resolve: ['self', 'lock']
    [RESOLVE] Chain resolution needed for: ['self', 'lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.lock
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.lock
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.lock
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.lock
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.lock
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: threading.RLock
    [RESOLVE] Attempting to resolve: ['threading', 'RLock']
    [RESOLVE] Chain resolution needed for: ['threading', 'RLock']
      [CHAIN] Resolving base: threading
      [RESOLVE_SIMPLE] Resolving base: threading
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable threading not found in any scope
      [LOCAL_RESOLVER] can_resolve(threading): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(threading): False (current_class: database_manager.DatabaseConnection)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(threading): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(threading): threading (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: threading -> threading
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: threading -> threading
      [CHAIN] Step 1: Resolving threading.RLock
        [ATTRIBUTE] Resolving attribute: threading.RLock
        [ATTRIBUTE] Direct match found: threading.RLock
      [CHAIN] Step 1 resolved: threading.RLock
    [RESOLVE] RESOLVED to: threading.RLock
            [INTERMEDIATE] Tracking chain steps for: threading.RLock
            [INTERMEDIATE] Step 1: threading.RLock
      -> Resolved to: threading.RLock
      -> ADDED to calls (external library)
      [ATTRIBUTE] Found attribute access: threading.RLock
        [CACHE] threading.RLock -> threading.RLock (cached)
      -> Not module state
      [NAME] Found name reference: threading
    [RESOLVE] Attempting to resolve: ['threading']
      [RESOLVE_SIMPLE] Resolving base: threading
      [CACHE] Hit for threading: threading
    [RESOLVE] RESOLVED to: threading
      -> Not module state
    [CONTEXT] Exited function: database_manager.DatabaseConnection.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.DatabaseConnection.__init__
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.DatabaseConnection.execute
    [CONTEXT] Entered function: database_manager.DatabaseConnection.execute (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'query': 'str', 'params': 'Optional[tuple]'}
        [ARG_TYPE] Processing type annotation for query: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: database_manager.str
    [RESOLVE] RESOLVED to: database_manager.str
      [SYMBOL_UPDATE] Function: query -> database_manager.str
        [ARG_TYPE] RESOLVED query : database_manager.str
      [ATTRIBUTE] Found attribute access: self.lock
    [RESOLVE] Attempting to resolve: ['self', 'lock']
    [RESOLVE] Chain resolution needed for: ['self', 'lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.lock
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.lock
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.lock
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.lock
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.is_open
    [RESOLVE] Attempting to resolve: ['self', 'is_open']
    [RESOLVE] Chain resolution needed for: ['self', 'is_open']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.is_open
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.is_open
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.is_open
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: RuntimeError
    [RESOLVE] Attempting to resolve: ['RuntimeError']
      [RESOLVE_SIMPLE] Resolving base: RuntimeError
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable RuntimeError not found in any scope
      [LOCAL_RESOLVER] can_resolve(RuntimeError): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(RuntimeError): False (current_class: database_manager.DatabaseConnection)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(RuntimeError): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(RuntimeError): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(RuntimeError): database_manager.RuntimeError
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: RuntimeError -> database_manager.RuntimeError
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.RuntimeError
      -> Resolved to: database_manager.RuntimeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: RuntimeError
        [CACHE] RuntimeError -> database_manager.RuntimeError (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.query_count
    [RESOLVE] Attempting to resolve: ['self', 'query_count']
    [RESOLVE] Chain resolution needed for: ['self', 'query_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.query_count
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.query_count
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.query_count
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.query_count
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.query_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.last_query_time
    [RESOLVE] Attempting to resolve: ['self', 'last_query_time']
    [RESOLVE] Chain resolution needed for: ['self', 'last_query_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.last_query_time
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.last_query_time
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.last_query_time
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.last_query_time
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.last_query_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [CALL] Found call: logging.debug
    [RESOLVE] Attempting to resolve: ['logging', 'debug']
    [RESOLVE] Chain resolution needed for: ['logging', 'debug']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable logging not found in any scope
      [LOCAL_RESOLVER] can_resolve(logging): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(logging): False (current_class: database_manager.DatabaseConnection)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(logging): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(logging): logging (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: logging -> logging
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.debug
        [ATTRIBUTE] Resolving attribute: logging.debug
        [ATTRIBUTE] Direct match found: logging.debug
      [CHAIN] Step 1 resolved: logging.debug
    [RESOLVE] RESOLVED to: logging.debug
            [INTERMEDIATE] Tracking chain steps for: logging.debug
            [INTERMEDIATE] Step 1: logging.debug
      -> Resolved to: logging.debug
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.debug
        [CACHE] logging.debug -> logging.debug (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection_id
    [RESOLVE] Attempting to resolve: ['self', 'connection_id']
    [RESOLVE] Chain resolution needed for: ['self', 'connection_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.connection_id
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.connection_id
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.connection_id
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [NAME] Found name reference: query
    [RESOLVE] Attempting to resolve: ['query']
      [RESOLVE_SIMPLE] Resolving base: query
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found query in function scope: database_manager.str
      [LOCAL_RESOLVER] can_resolve(query): True
      [SYMBOL_LOOKUP] Found query in function scope: database_manager.str
      [LOCAL_RESOLVER] resolve(query): database_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: query -> database_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.str
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: query.upper
    [RESOLVE] Attempting to resolve: ['query', 'upper']
    [RESOLVE] Chain resolution needed for: ['query', 'upper']
      [CHAIN] Resolving base: query
      [RESOLVE_SIMPLE] Resolving base: query
      [CACHE] Hit for query: database_manager.str
      [CHAIN] Base resolved: query -> database_manager.str
      [CHAIN] Step 1: Resolving database_manager.str.upper
        [ATTRIBUTE] Resolving attribute: database_manager.str.upper
        [ATTRIBUTE] Direct match found: database_manager.str.upper
      [CHAIN] Step 1 resolved: database_manager.str.upper
    [RESOLVE] RESOLVED to: database_manager.str.upper
            [INTERMEDIATE] Tracking chain steps for: query.upper
            [INTERMEDIATE] Step 1: query.upper
      -> Resolved to: database_manager.str.upper
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: query.upper
        [CACHE] query.upper -> database_manager.str.upper (cached)
      -> Not module state
      [NAME] Found name reference: query
        [CACHE] query -> database_manager.str (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: query.upper
    [CACHE] query.upper -> database_manager.str.upper (cached)
            [INTERMEDIATE] Tracking chain steps for: query.upper
            [INTERMEDIATE] Step 1: query.upper
      -> Resolved to: database_manager.str.upper
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: query.upper
        [CACHE] query.upper -> database_manager.str.upper (cached)
      -> Not module state
      [NAME] Found name reference: query
        [CACHE] query -> database_manager.str (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.DatabaseConnection.execute
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.DatabaseConnection.execute
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.DatabaseConnection.commit
    [CONTEXT] Entered function: database_manager.DatabaseConnection.commit (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.lock
    [RESOLVE] Attempting to resolve: ['self', 'lock']
    [RESOLVE] Chain resolution needed for: ['self', 'lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.lock
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.lock
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.lock
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.lock
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.is_open
    [RESOLVE] Attempting to resolve: ['self', 'is_open']
    [RESOLVE] Chain resolution needed for: ['self', 'is_open']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.is_open
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.is_open
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.is_open
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: RuntimeError
    [RESOLVE] Attempting to resolve: ['RuntimeError']
      [RESOLVE_SIMPLE] Resolving base: RuntimeError
      [CACHE] Hit for RuntimeError: database_manager.RuntimeError
    [RESOLVE] RESOLVED to: database_manager.RuntimeError
      -> Resolved to: database_manager.RuntimeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: RuntimeError
        [CACHE] RuntimeError -> database_manager.RuntimeError (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.in_transaction
    [RESOLVE] Attempting to resolve: ['self', 'in_transaction']
    [RESOLVE] Chain resolution needed for: ['self', 'in_transaction']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.in_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.in_transaction
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.in_transaction
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.in_transaction
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.in_transaction
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: logging.debug
    [RESOLVE] Attempting to resolve: ['logging', 'debug']
    [RESOLVE] Chain resolution needed for: ['logging', 'debug']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.debug
        [ATTRIBUTE] Resolving attribute: logging.debug
        [ATTRIBUTE] Direct match found: logging.debug
      [CHAIN] Step 1 resolved: logging.debug
    [RESOLVE] RESOLVED to: logging.debug
            [INTERMEDIATE] Tracking chain steps for: logging.debug
            [INTERMEDIATE] Step 1: logging.debug
      -> Resolved to: logging.debug
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.debug
        [CACHE] logging.debug -> logging.debug (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection_id
    [RESOLVE] Attempting to resolve: ['self', 'connection_id']
    [RESOLVE] Chain resolution needed for: ['self', 'connection_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.connection_id
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.connection_id
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.connection_id
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.in_transaction
        [CACHE] self.in_transaction -> database_manager.DatabaseConnection.in_transaction (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: logging.warning
    [RESOLVE] Attempting to resolve: ['logging', 'warning']
    [RESOLVE] Chain resolution needed for: ['logging', 'warning']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.warning
        [ATTRIBUTE] Resolving attribute: logging.warning
        [ATTRIBUTE] Direct match found: logging.warning
      [CHAIN] Step 1 resolved: logging.warning
    [RESOLVE] RESOLVED to: logging.warning
            [INTERMEDIATE] Tracking chain steps for: logging.warning
            [INTERMEDIATE] Step 1: logging.warning
      -> Resolved to: logging.warning
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.warning
        [CACHE] logging.warning -> logging.warning (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection_id
        [CACHE] self.connection_id -> database_manager.DatabaseConnection.connection_id (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.DatabaseConnection.commit
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.DatabaseConnection.commit
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.DatabaseConnection.rollback
    [CONTEXT] Entered function: database_manager.DatabaseConnection.rollback (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.lock
    [RESOLVE] Attempting to resolve: ['self', 'lock']
    [RESOLVE] Chain resolution needed for: ['self', 'lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.lock
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.lock
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.lock
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.lock
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.is_open
    [RESOLVE] Attempting to resolve: ['self', 'is_open']
    [RESOLVE] Chain resolution needed for: ['self', 'is_open']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.is_open
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.is_open
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.is_open
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: RuntimeError
    [RESOLVE] Attempting to resolve: ['RuntimeError']
      [RESOLVE_SIMPLE] Resolving base: RuntimeError
      [CACHE] Hit for RuntimeError: database_manager.RuntimeError
    [RESOLVE] RESOLVED to: database_manager.RuntimeError
      -> Resolved to: database_manager.RuntimeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: RuntimeError
        [CACHE] RuntimeError -> database_manager.RuntimeError (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.in_transaction
    [RESOLVE] Attempting to resolve: ['self', 'in_transaction']
    [RESOLVE] Chain resolution needed for: ['self', 'in_transaction']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.in_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.in_transaction
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.in_transaction
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.in_transaction
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.in_transaction
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: logging.debug
    [RESOLVE] Attempting to resolve: ['logging', 'debug']
    [RESOLVE] Chain resolution needed for: ['logging', 'debug']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.debug
        [ATTRIBUTE] Resolving attribute: logging.debug
        [ATTRIBUTE] Direct match found: logging.debug
      [CHAIN] Step 1 resolved: logging.debug
    [RESOLVE] RESOLVED to: logging.debug
            [INTERMEDIATE] Tracking chain steps for: logging.debug
            [INTERMEDIATE] Step 1: logging.debug
      -> Resolved to: logging.debug
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.debug
        [CACHE] logging.debug -> logging.debug (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection_id
    [RESOLVE] Attempting to resolve: ['self', 'connection_id']
    [RESOLVE] Chain resolution needed for: ['self', 'connection_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.connection_id
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.connection_id
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.connection_id
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.in_transaction
        [CACHE] self.in_transaction -> database_manager.DatabaseConnection.in_transaction (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: logging.warning
    [RESOLVE] Attempting to resolve: ['logging', 'warning']
    [RESOLVE] Chain resolution needed for: ['logging', 'warning']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.warning
        [ATTRIBUTE] Resolving attribute: logging.warning
        [ATTRIBUTE] Direct match found: logging.warning
      [CHAIN] Step 1 resolved: logging.warning
    [RESOLVE] RESOLVED to: logging.warning
            [INTERMEDIATE] Tracking chain steps for: logging.warning
            [INTERMEDIATE] Step 1: logging.warning
      -> Resolved to: logging.warning
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.warning
        [CACHE] logging.warning -> logging.warning (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection_id
        [CACHE] self.connection_id -> database_manager.DatabaseConnection.connection_id (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.DatabaseConnection.rollback
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.DatabaseConnection.rollback
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.DatabaseConnection.begin_transaction
    [CONTEXT] Entered function: database_manager.DatabaseConnection.begin_transaction (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'isolation_level': 'Optional[str]'}
      [ATTRIBUTE] Found attribute access: self.lock
    [RESOLVE] Attempting to resolve: ['self', 'lock']
    [RESOLVE] Chain resolution needed for: ['self', 'lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.lock
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.lock
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.lock
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.lock
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.is_open
    [RESOLVE] Attempting to resolve: ['self', 'is_open']
    [RESOLVE] Chain resolution needed for: ['self', 'is_open']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.is_open
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.is_open
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.is_open
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: RuntimeError
    [RESOLVE] Attempting to resolve: ['RuntimeError']
      [RESOLVE_SIMPLE] Resolving base: RuntimeError
      [CACHE] Hit for RuntimeError: database_manager.RuntimeError
    [RESOLVE] RESOLVED to: database_manager.RuntimeError
      -> Resolved to: database_manager.RuntimeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: RuntimeError
        [CACHE] RuntimeError -> database_manager.RuntimeError (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.in_transaction
    [RESOLVE] Attempting to resolve: ['self', 'in_transaction']
    [RESOLVE] Chain resolution needed for: ['self', 'in_transaction']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.in_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.in_transaction
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.in_transaction
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.in_transaction
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.in_transaction
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: RuntimeError
    [CACHE] RuntimeError -> database_manager.RuntimeError (cached)
      -> Resolved to: database_manager.RuntimeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: RuntimeError
        [CACHE] RuntimeError -> database_manager.RuntimeError (cached)
      -> Not module state
      [NAME] Found name reference: isolation_level
    [RESOLVE] Attempting to resolve: ['isolation_level']
      [RESOLVE_SIMPLE] Resolving base: isolation_level
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable isolation_level not found in any scope
      [LOCAL_RESOLVER] can_resolve(isolation_level): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(isolation_level): False (current_class: database_manager.DatabaseConnection)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(isolation_level): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(isolation_level): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(isolation_level): database_manager.isolation_level
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: isolation_level -> database_manager.isolation_level
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.isolation_level
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.isolation_level
    [RESOLVE] Attempting to resolve: ['self', 'isolation_level']
    [RESOLVE] Chain resolution needed for: ['self', 'isolation_level']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.isolation_level
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.isolation_level
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.isolation_level
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.isolation_level
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.isolation_level
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [NAME] Found name reference: isolation_level
        [CACHE] isolation_level -> database_manager.isolation_level (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.in_transaction
        [CACHE] self.in_transaction -> database_manager.DatabaseConnection.in_transaction (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: logging.debug
    [RESOLVE] Attempting to resolve: ['logging', 'debug']
    [RESOLVE] Chain resolution needed for: ['logging', 'debug']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.debug
        [ATTRIBUTE] Resolving attribute: logging.debug
        [ATTRIBUTE] Direct match found: logging.debug
      [CHAIN] Step 1 resolved: logging.debug
    [RESOLVE] RESOLVED to: logging.debug
            [INTERMEDIATE] Tracking chain steps for: logging.debug
            [INTERMEDIATE] Step 1: logging.debug
      -> Resolved to: logging.debug
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.debug
        [CACHE] logging.debug -> logging.debug (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection_id
    [RESOLVE] Attempting to resolve: ['self', 'connection_id']
    [RESOLVE] Chain resolution needed for: ['self', 'connection_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.connection_id
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.connection_id
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.connection_id
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.isolation_level
        [CACHE] self.isolation_level -> database_manager.DatabaseConnection.isolation_level (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.DatabaseConnection.begin_transaction
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.DatabaseConnection.begin_transaction
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.DatabaseConnection.close
    [CONTEXT] Entered function: database_manager.DatabaseConnection.close (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.lock
    [RESOLVE] Attempting to resolve: ['self', 'lock']
    [RESOLVE] Chain resolution needed for: ['self', 'lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.lock
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.lock
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.lock
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.lock
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.is_open
    [RESOLVE] Attempting to resolve: ['self', 'is_open']
    [RESOLVE] Chain resolution needed for: ['self', 'is_open']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.is_open
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.is_open
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.is_open
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.in_transaction
    [RESOLVE] Attempting to resolve: ['self', 'in_transaction']
    [RESOLVE] Chain resolution needed for: ['self', 'in_transaction']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.in_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.in_transaction
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.in_transaction
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.in_transaction
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.in_transaction
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: logging.warning
    [RESOLVE] Attempting to resolve: ['logging', 'warning']
    [RESOLVE] Chain resolution needed for: ['logging', 'warning']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.warning
        [ATTRIBUTE] Resolving attribute: logging.warning
        [ATTRIBUTE] Direct match found: logging.warning
      [CHAIN] Step 1 resolved: logging.warning
    [RESOLVE] RESOLVED to: logging.warning
            [INTERMEDIATE] Tracking chain steps for: logging.warning
            [INTERMEDIATE] Step 1: logging.warning
      -> Resolved to: logging.warning
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.warning
        [CACHE] logging.warning -> logging.warning (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection_id
    [RESOLVE] Attempting to resolve: ['self', 'connection_id']
    [RESOLVE] Chain resolution needed for: ['self', 'connection_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.connection_id
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.connection_id
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.connection_id
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: self.rollback
    [RESOLVE] Attempting to resolve: ['self', 'rollback']
    [RESOLVE] Chain resolution needed for: ['self', 'rollback']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.rollback
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.rollback
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.rollback
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.rollback
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.rollback
            [INTERMEDIATE] Tracking chain steps for: self.rollback
            [INTERMEDIATE] Step 1: self.rollback
      -> Resolved to: database_manager.DatabaseConnection.rollback
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self.rollback
        [CACHE] self.rollback -> database_manager.DatabaseConnection.rollback (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.is_open
        [CACHE] self.is_open -> database_manager.DatabaseConnection.is_open (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: logging.debug
    [RESOLVE] Attempting to resolve: ['logging', 'debug']
    [RESOLVE] Chain resolution needed for: ['logging', 'debug']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.debug
        [ATTRIBUTE] Resolving attribute: logging.debug
        [ATTRIBUTE] Direct match found: logging.debug
      [CHAIN] Step 1 resolved: logging.debug
    [RESOLVE] RESOLVED to: logging.debug
            [INTERMEDIATE] Tracking chain steps for: logging.debug
            [INTERMEDIATE] Step 1: logging.debug
      -> Resolved to: logging.debug
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.debug
        [CACHE] logging.debug -> logging.debug (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection_id
        [CACHE] self.connection_id -> database_manager.DatabaseConnection.connection_id (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.DatabaseConnection.close
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.DatabaseConnection.close
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.DatabaseConnection.is_connected
    [CONTEXT] Entered function: database_manager.DatabaseConnection.is_connected (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.is_open
    [RESOLVE] Attempting to resolve: ['self', 'is_open']
    [RESOLVE] Chain resolution needed for: ['self', 'is_open']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.is_open
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.is_open
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.is_open
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Not module state
    [CONTEXT] Exited function: database_manager.DatabaseConnection.is_connected
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.DatabaseConnection.is_connected
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.DatabaseConnection.get_stats
    [CONTEXT] Entered function: database_manager.DatabaseConnection.get_stats (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.connection_id
    [RESOLVE] Attempting to resolve: ['self', 'connection_id']
    [RESOLVE] Chain resolution needed for: ['self', 'connection_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.connection_id
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.connection_id
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.connection_id
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.connection_id
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.is_open
    [RESOLVE] Attempting to resolve: ['self', 'is_open']
    [RESOLVE] Chain resolution needed for: ['self', 'is_open']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.is_open
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.is_open
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.is_open
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.is_open
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.in_transaction
    [RESOLVE] Attempting to resolve: ['self', 'in_transaction']
    [RESOLVE] Chain resolution needed for: ['self', 'in_transaction']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.in_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.in_transaction
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.in_transaction
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.in_transaction
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.in_transaction
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.isolation_level
    [RESOLVE] Attempting to resolve: ['self', 'isolation_level']
    [RESOLVE] Chain resolution needed for: ['self', 'isolation_level']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.isolation_level
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.isolation_level
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.isolation_level
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.isolation_level
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.isolation_level
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.query_count
    [RESOLVE] Attempting to resolve: ['self', 'query_count']
    [RESOLVE] Chain resolution needed for: ['self', 'query_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.query_count
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.query_count
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.query_count
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.query_count
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.query_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.last_query_time
    [RESOLVE] Attempting to resolve: ['self', 'last_query_time']
    [RESOLVE] Chain resolution needed for: ['self', 'last_query_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.DatabaseConnection
      [CHAIN] Base resolved: self -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.last_query_time
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.last_query_time
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.last_query_time
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.last_query_time
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.last_query_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.DatabaseConnection (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.DatabaseConnection.get_stats
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.DatabaseConnection.get_stats
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: database_manager.DatabaseConnection
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: TransactionManager
    [CONTEXT] Entered class: database_manager.TransactionManager
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.TransactionManager.__init__
    [CONTEXT] Entered function: database_manager.TransactionManager.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'connection': 'DatabaseConnection', 'isolation_level': 'str'}
        [ARG_TYPE] Processing type annotation for connection: DatabaseConnection
    [RESOLVE] Attempting to resolve: ['DatabaseConnection']
      [RESOLVE_SIMPLE] Resolving base: DatabaseConnection
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable DatabaseConnection not found in any scope
      [LOCAL_RESOLVER] can_resolve(DatabaseConnection): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(DatabaseConnection): False (current_class: database_manager.TransactionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(DatabaseConnection): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(DatabaseConnection): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(DatabaseConnection): database_manager.DatabaseConnection
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: DatabaseConnection -> database_manager.DatabaseConnection
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      [SYMBOL_UPDATE] Function: connection -> database_manager.DatabaseConnection
        [ARG_TYPE] RESOLVED connection : database_manager.DatabaseConnection
        [ARG_TYPE] Processing type annotation for isolation_level: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: database_manager.TransactionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(str): database_manager.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> database_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.str
      [SYMBOL_UPDATE] Function: isolation_level -> database_manager.str
        [ARG_TYPE] RESOLVED isolation_level : database_manager.str
      [ATTRIBUTE] Found attribute access: self.connection
    [RESOLVE] Attempting to resolve: ['self', 'connection']
    [RESOLVE] Chain resolution needed for: ['self', 'connection']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: database_manager.TransactionManager)
      [SELF_RESOLVER] resolve(self): database_manager.TransactionManager
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> database_manager.TransactionManager
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      -> Not module state
      [NAME] Found name reference: connection
    [RESOLVE] Attempting to resolve: ['connection']
      [RESOLVE_SIMPLE] Resolving base: connection
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found connection in function scope: database_manager.DatabaseConnection
      [LOCAL_RESOLVER] can_resolve(connection): True
      [SYMBOL_LOOKUP] Found connection in function scope: database_manager.DatabaseConnection
      [LOCAL_RESOLVER] resolve(connection): database_manager.DatabaseConnection
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: connection -> database_manager.DatabaseConnection
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.isolation_level
    [RESOLVE] Attempting to resolve: ['self', 'isolation_level']
    [RESOLVE] Chain resolution needed for: ['self', 'isolation_level']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.isolation_level
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.isolation_level
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.isolation_level
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.isolation_level
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.isolation_level
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [NAME] Found name reference: isolation_level
    [RESOLVE] Attempting to resolve: ['isolation_level']
      [RESOLVE_SIMPLE] Resolving base: isolation_level
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found isolation_level in function scope: database_manager.str
      [LOCAL_RESOLVER] can_resolve(isolation_level): True
      [SYMBOL_LOOKUP] Found isolation_level in function scope: database_manager.str
      [LOCAL_RESOLVER] resolve(isolation_level): database_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: isolation_level -> database_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.transaction_started
    [RESOLVE] Attempting to resolve: ['self', 'transaction_started']
    [RESOLVE] Chain resolution needed for: ['self', 'transaction_started']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.transaction_started
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.transaction_started
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.transaction_started
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.start_time
    [RESOLVE] Attempting to resolve: ['self', 'start_time']
    [RESOLVE] Chain resolution needed for: ['self', 'start_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.start_time
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.start_time
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.start_time
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.start_time
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.start_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [NAME] Found name reference: Optional
    [RESOLVE] Attempting to resolve: ['Optional']
      [RESOLVE_SIMPLE] Resolving base: Optional
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Optional not found in any scope
      [LOCAL_RESOLVER] can_resolve(Optional): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Optional): False (current_class: database_manager.TransactionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Optional): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Optional): typing.Optional (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Optional -> typing.Optional
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Optional
      -> Not module state
      [NAME] Found name reference: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable float not found in any scope
      [LOCAL_RESOLVER] can_resolve(float): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(float): False (current_class: database_manager.TransactionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(float): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(float): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(float): database_manager.float
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: float -> database_manager.float
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.float
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operations_count
    [RESOLVE] Attempting to resolve: ['self', 'operations_count']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.operations_count
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.operations_count
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.operations_count
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.operations_count
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.operations_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.TransactionManager.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.TransactionManager.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.TransactionManager.begin_transaction
    [CONTEXT] Entered function: database_manager.TransactionManager.begin_transaction (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.transaction_started
    [RESOLVE] Attempting to resolve: ['self', 'transaction_started']
    [RESOLVE] Chain resolution needed for: ['self', 'transaction_started']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.transaction_started
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.transaction_started
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.transaction_started
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      -> Not module state
      [CALL] Found call: RuntimeError
    [RESOLVE] Attempting to resolve: ['RuntimeError']
      [RESOLVE_SIMPLE] Resolving base: RuntimeError
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable RuntimeError not found in any scope
      [LOCAL_RESOLVER] can_resolve(RuntimeError): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(RuntimeError): False (current_class: database_manager.TransactionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(RuntimeError): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(RuntimeError): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(RuntimeError): database_manager.RuntimeError
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: RuntimeError -> database_manager.RuntimeError
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.RuntimeError
      -> Resolved to: database_manager.RuntimeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: RuntimeError
        [CACHE] RuntimeError -> database_manager.RuntimeError (cached)
      -> Not module state
      [CALL] Found call: self.connection.begin_transaction
    [RESOLVE] Attempting to resolve: ['self', 'connection', 'begin_transaction']
    [RESOLVE] Chain resolution needed for: ['self', 'connection', 'begin_transaction']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
      [CHAIN] Step 2: Resolving database_manager.TransactionManager.connection.begin_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection.begin_transaction
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection.begin_transaction
      [CHAIN] Step 2 resolved: database_manager.TransactionManager.connection.begin_transaction
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection.begin_transaction
            [INTERMEDIATE] Tracking chain steps for: self.connection.begin_transaction
            [INTERMEDIATE] Step 1: self.connection
    [RESOLVE] Attempting to resolve: ['self', 'connection']
    [RESOLVE] Chain resolution needed for: ['self', 'connection']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection
            [INTERMEDIATE] Step 1 resolved to: database_manager.TransactionManager.connection
            [INTERMEDIATE] Step 2: self.connection.begin_transaction
      -> Resolved to: database_manager.TransactionManager.connection.begin_transaction
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.connection.begin_transaction
        [CACHE] self.connection.begin_transaction -> database_manager.TransactionManager.connection.begin_transaction (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection
        [CACHE] self.connection -> database_manager.TransactionManager.connection (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.isolation_level
    [RESOLVE] Attempting to resolve: ['self', 'isolation_level']
    [RESOLVE] Chain resolution needed for: ['self', 'isolation_level']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.isolation_level
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.isolation_level
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.isolation_level
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.isolation_level
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.isolation_level
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.transaction_started
        [CACHE] self.transaction_started -> database_manager.TransactionManager.transaction_started (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.start_time
    [RESOLVE] Attempting to resolve: ['self', 'start_time']
    [RESOLVE] Chain resolution needed for: ['self', 'start_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.start_time
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.start_time
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.start_time
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.start_time
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.start_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable time not found in any scope
      [LOCAL_RESOLVER] can_resolve(time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(time): False (current_class: database_manager.TransactionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(time): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(time): time (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: time -> time
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operations_count
    [RESOLVE] Attempting to resolve: ['self', 'operations_count']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.operations_count
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.operations_count
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.operations_count
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.operations_count
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.operations_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [CALL] Found call: logging.info
    [RESOLVE] Attempting to resolve: ['logging', 'info']
    [RESOLVE] Chain resolution needed for: ['logging', 'info']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable logging not found in any scope
      [LOCAL_RESOLVER] can_resolve(logging): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(logging): False (current_class: database_manager.TransactionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(logging): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(logging): logging (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: logging -> logging
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.info
        [ATTRIBUTE] Resolving attribute: logging.info
        [ATTRIBUTE] Direct match found: logging.info
      [CHAIN] Step 1 resolved: logging.info
    [RESOLVE] RESOLVED to: logging.info
            [INTERMEDIATE] Tracking chain steps for: logging.info
            [INTERMEDIATE] Step 1: logging.info
      -> Resolved to: logging.info
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.info
        [CACHE] logging.info -> logging.info (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.isolation_level
        [CACHE] self.isolation_level -> database_manager.TransactionManager.isolation_level (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Exception not found in any scope
      [LOCAL_RESOLVER] can_resolve(Exception): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Exception): False (current_class: database_manager.TransactionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Exception): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(Exception): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(Exception): database_manager.Exception
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: Exception -> database_manager.Exception
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.Exception
      -> Not module state
      [CALL] Found call: logging.error
    [RESOLVE] Attempting to resolve: ['logging', 'error']
    [RESOLVE] Chain resolution needed for: ['logging', 'error']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.error
        [ATTRIBUTE] Resolving attribute: logging.error
        [ATTRIBUTE] Direct match found: logging.error
      [CHAIN] Step 1 resolved: logging.error
    [RESOLVE] RESOLVED to: logging.error
            [INTERMEDIATE] Tracking chain steps for: logging.error
            [INTERMEDIATE] Step 1: logging.error
      -> Resolved to: logging.error
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.error
        [CACHE] logging.error -> logging.error (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable e not found in any scope
      [LOCAL_RESOLVER] can_resolve(e): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(e): False (current_class: database_manager.TransactionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(e): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(e): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(e): database_manager.e
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: e -> database_manager.e
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.e
      -> Not module state
    [CONTEXT] Exited function: database_manager.TransactionManager.begin_transaction
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.TransactionManager.begin_transaction
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.TransactionManager.commit_transaction
    [CONTEXT] Entered function: database_manager.TransactionManager.commit_transaction (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.transaction_started
    [RESOLVE] Attempting to resolve: ['self', 'transaction_started']
    [RESOLVE] Chain resolution needed for: ['self', 'transaction_started']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.transaction_started
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.transaction_started
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.transaction_started
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      -> Not module state
      [CALL] Found call: RuntimeError
    [RESOLVE] Attempting to resolve: ['RuntimeError']
      [RESOLVE_SIMPLE] Resolving base: RuntimeError
      [CACHE] Hit for RuntimeError: database_manager.RuntimeError
    [RESOLVE] RESOLVED to: database_manager.RuntimeError
      -> Resolved to: database_manager.RuntimeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: RuntimeError
        [CACHE] RuntimeError -> database_manager.RuntimeError (cached)
      -> Not module state
      [CALL] Found call: self.connection.commit
    [RESOLVE] Attempting to resolve: ['self', 'connection', 'commit']
    [RESOLVE] Chain resolution needed for: ['self', 'connection', 'commit']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
      [CHAIN] Step 2: Resolving database_manager.TransactionManager.connection.commit
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection.commit
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection.commit
      [CHAIN] Step 2 resolved: database_manager.TransactionManager.connection.commit
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection.commit
            [INTERMEDIATE] Tracking chain steps for: self.connection.commit
            [INTERMEDIATE] Step 1: self.connection
    [RESOLVE] Attempting to resolve: ['self', 'connection']
    [RESOLVE] Chain resolution needed for: ['self', 'connection']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection
            [INTERMEDIATE] Step 1 resolved to: database_manager.TransactionManager.connection
            [INTERMEDIATE] Step 2: self.connection.commit
      -> Resolved to: database_manager.TransactionManager.connection.commit
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.connection.commit
        [CACHE] self.connection.commit -> database_manager.TransactionManager.connection.commit (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection
        [CACHE] self.connection -> database_manager.TransactionManager.connection (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [ASSIGNMENT] Processing: duration = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: duration
    [RESOLVE] Attempting to resolve: ['duration']
      [RESOLVE_SIMPLE] Resolving base: duration
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable duration not found in any scope
      [LOCAL_RESOLVER] can_resolve(duration): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(duration): False (current_class: database_manager.TransactionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(duration): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(duration): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(duration): database_manager.duration
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: duration -> database_manager.duration
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.duration
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.start_time
    [RESOLVE] Attempting to resolve: ['self', 'start_time']
    [RESOLVE] Chain resolution needed for: ['self', 'start_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.start_time
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.start_time
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.start_time
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.start_time
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.start_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.start_time
        [CACHE] self.start_time -> database_manager.TransactionManager.start_time (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [CALL] Found call: logging.info
    [RESOLVE] Attempting to resolve: ['logging', 'info']
    [RESOLVE] Chain resolution needed for: ['logging', 'info']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.info
        [ATTRIBUTE] Resolving attribute: logging.info
        [ATTRIBUTE] Direct match found: logging.info
      [CHAIN] Step 1 resolved: logging.info
    [RESOLVE] RESOLVED to: logging.info
            [INTERMEDIATE] Tracking chain steps for: logging.info
            [INTERMEDIATE] Step 1: logging.info
      -> Resolved to: logging.info
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.info
        [CACHE] logging.info -> logging.info (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [NAME] Found name reference: duration
        [CACHE] duration -> database_manager.duration (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operations_count
    [RESOLVE] Attempting to resolve: ['self', 'operations_count']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.operations_count
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.operations_count
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.operations_count
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.operations_count
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.operations_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [CACHE] Hit for Exception: database_manager.Exception
    [RESOLVE] RESOLVED to: database_manager.Exception
      -> Not module state
      [CALL] Found call: logging.error
    [RESOLVE] Attempting to resolve: ['logging', 'error']
    [RESOLVE] Chain resolution needed for: ['logging', 'error']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.error
        [ATTRIBUTE] Resolving attribute: logging.error
        [ATTRIBUTE] Direct match found: logging.error
      [CHAIN] Step 1 resolved: logging.error
    [RESOLVE] RESOLVED to: logging.error
            [INTERMEDIATE] Tracking chain steps for: logging.error
            [INTERMEDIATE] Step 1: logging.error
      -> Resolved to: logging.error
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.error
        [CACHE] logging.error -> logging.error (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [CACHE] Hit for e: database_manager.e
    [RESOLVE] RESOLVED to: database_manager.e
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.transaction_started
        [CACHE] self.transaction_started -> database_manager.TransactionManager.transaction_started (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.start_time
        [CACHE] self.start_time -> database_manager.TransactionManager.start_time (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.TransactionManager.commit_transaction
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.TransactionManager.commit_transaction
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.TransactionManager.rollback_transaction
    [CONTEXT] Entered function: database_manager.TransactionManager.rollback_transaction (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.transaction_started
    [RESOLVE] Attempting to resolve: ['self', 'transaction_started']
    [RESOLVE] Chain resolution needed for: ['self', 'transaction_started']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.transaction_started
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.transaction_started
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.transaction_started
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      -> Not module state
      [CALL] Found call: RuntimeError
    [RESOLVE] Attempting to resolve: ['RuntimeError']
      [RESOLVE_SIMPLE] Resolving base: RuntimeError
      [CACHE] Hit for RuntimeError: database_manager.RuntimeError
    [RESOLVE] RESOLVED to: database_manager.RuntimeError
      -> Resolved to: database_manager.RuntimeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: RuntimeError
        [CACHE] RuntimeError -> database_manager.RuntimeError (cached)
      -> Not module state
      [CALL] Found call: self.connection.rollback
    [RESOLVE] Attempting to resolve: ['self', 'connection', 'rollback']
    [RESOLVE] Chain resolution needed for: ['self', 'connection', 'rollback']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
      [CHAIN] Step 2: Resolving database_manager.TransactionManager.connection.rollback
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection.rollback
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection.rollback
      [CHAIN] Step 2 resolved: database_manager.TransactionManager.connection.rollback
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection.rollback
            [INTERMEDIATE] Tracking chain steps for: self.connection.rollback
            [INTERMEDIATE] Step 1: self.connection
    [RESOLVE] Attempting to resolve: ['self', 'connection']
    [RESOLVE] Chain resolution needed for: ['self', 'connection']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection
            [INTERMEDIATE] Step 1 resolved to: database_manager.TransactionManager.connection
            [INTERMEDIATE] Step 2: self.connection.rollback
      -> Resolved to: database_manager.TransactionManager.connection.rollback
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.connection.rollback
        [CACHE] self.connection.rollback -> database_manager.TransactionManager.connection.rollback (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection
        [CACHE] self.connection -> database_manager.TransactionManager.connection (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [ASSIGNMENT] Processing: duration = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: duration
    [RESOLVE] Attempting to resolve: ['duration']
      [RESOLVE_SIMPLE] Resolving base: duration
      [CACHE] Hit for duration: database_manager.duration
    [RESOLVE] RESOLVED to: database_manager.duration
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.start_time
    [RESOLVE] Attempting to resolve: ['self', 'start_time']
    [RESOLVE] Chain resolution needed for: ['self', 'start_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.start_time
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.start_time
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.start_time
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.start_time
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.start_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.start_time
        [CACHE] self.start_time -> database_manager.TransactionManager.start_time (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [CALL] Found call: logging.warning
    [RESOLVE] Attempting to resolve: ['logging', 'warning']
    [RESOLVE] Chain resolution needed for: ['logging', 'warning']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.warning
        [ATTRIBUTE] Resolving attribute: logging.warning
        [ATTRIBUTE] Direct match found: logging.warning
      [CHAIN] Step 1 resolved: logging.warning
    [RESOLVE] RESOLVED to: logging.warning
            [INTERMEDIATE] Tracking chain steps for: logging.warning
            [INTERMEDIATE] Step 1: logging.warning
      -> Resolved to: logging.warning
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.warning
        [CACHE] logging.warning -> logging.warning (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [NAME] Found name reference: duration
        [CACHE] duration -> database_manager.duration (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operations_count
    [RESOLVE] Attempting to resolve: ['self', 'operations_count']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.operations_count
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.operations_count
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.operations_count
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.operations_count
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.operations_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [CACHE] Hit for Exception: database_manager.Exception
    [RESOLVE] RESOLVED to: database_manager.Exception
      -> Not module state
      [CALL] Found call: logging.error
    [RESOLVE] Attempting to resolve: ['logging', 'error']
    [RESOLVE] Chain resolution needed for: ['logging', 'error']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.error
        [ATTRIBUTE] Resolving attribute: logging.error
        [ATTRIBUTE] Direct match found: logging.error
      [CHAIN] Step 1 resolved: logging.error
    [RESOLVE] RESOLVED to: logging.error
            [INTERMEDIATE] Tracking chain steps for: logging.error
            [INTERMEDIATE] Step 1: logging.error
      -> Resolved to: logging.error
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.error
        [CACHE] logging.error -> logging.error (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [CACHE] Hit for e: database_manager.e
    [RESOLVE] RESOLVED to: database_manager.e
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.transaction_started
        [CACHE] self.transaction_started -> database_manager.TransactionManager.transaction_started (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.start_time
        [CACHE] self.start_time -> database_manager.TransactionManager.start_time (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.TransactionManager.rollback_transaction
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.TransactionManager.rollback_transaction
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.TransactionManager.close_connection
    [CONTEXT] Entered function: database_manager.TransactionManager.close_connection (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.transaction_started
    [RESOLVE] Attempting to resolve: ['self', 'transaction_started']
    [RESOLVE] Chain resolution needed for: ['self', 'transaction_started']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.transaction_started
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.transaction_started
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.transaction_started
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      -> Not module state
      [CALL] Found call: logging.warning
    [RESOLVE] Attempting to resolve: ['logging', 'warning']
    [RESOLVE] Chain resolution needed for: ['logging', 'warning']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.warning
        [ATTRIBUTE] Resolving attribute: logging.warning
        [ATTRIBUTE] Direct match found: logging.warning
      [CHAIN] Step 1 resolved: logging.warning
    [RESOLVE] RESOLVED to: logging.warning
            [INTERMEDIATE] Tracking chain steps for: logging.warning
            [INTERMEDIATE] Step 1: logging.warning
      -> Resolved to: logging.warning
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.warning
        [CACHE] logging.warning -> logging.warning (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [CALL] Found call: self.rollback_transaction
    [RESOLVE] Attempting to resolve: ['self', 'rollback_transaction']
    [RESOLVE] Chain resolution needed for: ['self', 'rollback_transaction']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.rollback_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.rollback_transaction
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.rollback_transaction
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.rollback_transaction
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.rollback_transaction
            [INTERMEDIATE] Tracking chain steps for: self.rollback_transaction
            [INTERMEDIATE] Step 1: self.rollback_transaction
      -> Resolved to: database_manager.TransactionManager.rollback_transaction
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self.rollback_transaction
        [CACHE] self.rollback_transaction -> database_manager.TransactionManager.rollback_transaction (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [CALL] Found call: self.connection.close
    [RESOLVE] Attempting to resolve: ['self', 'connection', 'close']
    [RESOLVE] Chain resolution needed for: ['self', 'connection', 'close']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
      [CHAIN] Step 2: Resolving database_manager.TransactionManager.connection.close
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection.close
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection.close
      [CHAIN] Step 2 resolved: database_manager.TransactionManager.connection.close
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection.close
            [INTERMEDIATE] Tracking chain steps for: self.connection.close
            [INTERMEDIATE] Step 1: self.connection
    [RESOLVE] Attempting to resolve: ['self', 'connection']
    [RESOLVE] Chain resolution needed for: ['self', 'connection']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection
            [INTERMEDIATE] Step 1 resolved to: database_manager.TransactionManager.connection
            [INTERMEDIATE] Step 2: self.connection.close
      -> Resolved to: database_manager.TransactionManager.connection.close
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.connection.close
        [CACHE] self.connection.close -> database_manager.TransactionManager.connection.close (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection
        [CACHE] self.connection -> database_manager.TransactionManager.connection (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [CALL] Found call: logging.info
    [RESOLVE] Attempting to resolve: ['logging', 'info']
    [RESOLVE] Chain resolution needed for: ['logging', 'info']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.info
        [ATTRIBUTE] Resolving attribute: logging.info
        [ATTRIBUTE] Direct match found: logging.info
      [CHAIN] Step 1 resolved: logging.info
    [RESOLVE] RESOLVED to: logging.info
            [INTERMEDIATE] Tracking chain steps for: logging.info
            [INTERMEDIATE] Step 1: logging.info
      -> Resolved to: logging.info
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.info
        [CACHE] logging.info -> logging.info (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.TransactionManager.close_connection
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.TransactionManager.close_connection
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.TransactionManager.execute_in_transaction
    [CONTEXT] Entered function: database_manager.TransactionManager.execute_in_transaction (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'query': 'str', 'params': 'Optional[tuple]'}
        [ARG_TYPE] Processing type annotation for query: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: database_manager.str
    [RESOLVE] RESOLVED to: database_manager.str
      [SYMBOL_UPDATE] Function: query -> database_manager.str
        [ARG_TYPE] RESOLVED query : database_manager.str
      [ATTRIBUTE] Found attribute access: self.transaction_started
    [RESOLVE] Attempting to resolve: ['self', 'transaction_started']
    [RESOLVE] Chain resolution needed for: ['self', 'transaction_started']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.transaction_started
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.transaction_started
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.transaction_started
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      -> Not module state
      [CALL] Found call: RuntimeError
    [RESOLVE] Attempting to resolve: ['RuntimeError']
      [RESOLVE_SIMPLE] Resolving base: RuntimeError
      [CACHE] Hit for RuntimeError: database_manager.RuntimeError
    [RESOLVE] RESOLVED to: database_manager.RuntimeError
      -> Resolved to: database_manager.RuntimeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: RuntimeError
        [CACHE] RuntimeError -> database_manager.RuntimeError (cached)
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.connection.execute
    [RESOLVE] Attempting to resolve: ['self', 'connection', 'execute']
    [RESOLVE] Chain resolution needed for: ['self', 'connection', 'execute']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
      [CHAIN] Step 2: Resolving database_manager.TransactionManager.connection.execute
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection.execute
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection.execute
      [CHAIN] Step 2 resolved: database_manager.TransactionManager.connection.execute
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection.execute
      [TYPE_INFERENCE] Call resolved to: database_manager.TransactionManager.connection.execute
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for result
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable result not found in any scope
      [LOCAL_RESOLVER] can_resolve(result): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(result): False (current_class: database_manager.TransactionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(result): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(result): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(result): database_manager.result
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: result -> database_manager.result
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.result
      -> Not module state
      [CALL] Found call: self.connection.execute
    [RESOLVE] Attempting to resolve: ['self', 'connection', 'execute']
    [RESOLVE] Chain resolution needed for: ['self', 'connection', 'execute']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
      [CHAIN] Step 2: Resolving database_manager.TransactionManager.connection.execute
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection.execute
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection.execute
      [CHAIN] Step 2 resolved: database_manager.TransactionManager.connection.execute
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection.execute
            [INTERMEDIATE] Tracking chain steps for: self.connection.execute
            [INTERMEDIATE] Step 1: self.connection
    [RESOLVE] Attempting to resolve: ['self', 'connection']
    [RESOLVE] Chain resolution needed for: ['self', 'connection']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection
            [INTERMEDIATE] Step 1 resolved to: database_manager.TransactionManager.connection
            [INTERMEDIATE] Step 2: self.connection.execute
      -> Resolved to: database_manager.TransactionManager.connection.execute
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: query
    [RESOLVE] Attempting to resolve: ['query']
      [RESOLVE_SIMPLE] Resolving base: query
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found query in function scope: database_manager.str
      [LOCAL_RESOLVER] can_resolve(query): True
      [SYMBOL_LOOKUP] Found query in function scope: database_manager.str
      [LOCAL_RESOLVER] resolve(query): database_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: query -> database_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.str
        [FUNCTION_ARG] Checking argument: params
    [RESOLVE] Attempting to resolve: ['params']
      [RESOLVE_SIMPLE] Resolving base: params
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable params not found in any scope
      [LOCAL_RESOLVER] can_resolve(params): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(params): False (current_class: database_manager.TransactionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(params): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(params): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(params): database_manager.params
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: params -> database_manager.params
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.params
      [ATTRIBUTE] Found attribute access: self.connection.execute
        [CACHE] self.connection.execute -> database_manager.TransactionManager.connection.execute (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection
        [CACHE] self.connection -> database_manager.TransactionManager.connection (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [NAME] Found name reference: query
    [RESOLVE] Attempting to resolve: ['query']
      [RESOLVE_SIMPLE] Resolving base: query
      [CACHE] Hit for query: database_manager.str
    [RESOLVE] RESOLVED to: database_manager.str
      -> Not module state
      [NAME] Found name reference: params
    [RESOLVE] Attempting to resolve: ['params']
      [RESOLVE_SIMPLE] Resolving base: params
      [CACHE] Hit for params: database_manager.params
    [RESOLVE] RESOLVED to: database_manager.params
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operations_count
    [RESOLVE] Attempting to resolve: ['self', 'operations_count']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.operations_count
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.operations_count
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.operations_count
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.operations_count
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.operations_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> database_manager.result (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.TransactionManager.execute_in_transaction
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.TransactionManager.execute_in_transaction
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.TransactionManager.transaction_context
    [DECORATOR] @contextmanager
      [CODE_STANDARD_VIOLATION] MISSING_RETURN_TYPE: Function database_manager.TransactionManager.transaction_context
      [IMPACT] Cannot infer return type - chained method calls may fail
      [ACTION_REQUIRED] Add appropriate type annotation
      [CODE_QUALITY] Found 1 violations in database_manager.TransactionManager.transaction_context
    [CONTEXT] Entered function: database_manager.TransactionManager.transaction_context (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Found call: self.begin_transaction
    [RESOLVE] Attempting to resolve: ['self', 'begin_transaction']
    [RESOLVE] Chain resolution needed for: ['self', 'begin_transaction']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.begin_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.begin_transaction
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.begin_transaction
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.begin_transaction
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.begin_transaction
            [INTERMEDIATE] Tracking chain steps for: self.begin_transaction
            [INTERMEDIATE] Step 1: self.begin_transaction
      -> Resolved to: database_manager.TransactionManager.begin_transaction
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self.begin_transaction
        [CACHE] self.begin_transaction -> database_manager.TransactionManager.begin_transaction (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [CALL] Found call: self.commit_transaction
    [RESOLVE] Attempting to resolve: ['self', 'commit_transaction']
    [RESOLVE] Chain resolution needed for: ['self', 'commit_transaction']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.commit_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.commit_transaction
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.commit_transaction
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.commit_transaction
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.commit_transaction
            [INTERMEDIATE] Tracking chain steps for: self.commit_transaction
            [INTERMEDIATE] Step 1: self.commit_transaction
      -> Resolved to: database_manager.TransactionManager.commit_transaction
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self.commit_transaction
        [CACHE] self.commit_transaction -> database_manager.TransactionManager.commit_transaction (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [CACHE] Hit for Exception: database_manager.Exception
    [RESOLVE] RESOLVED to: database_manager.Exception
      -> Not module state
      [CALL] Found call: self.rollback_transaction
    [RESOLVE] Attempting to resolve: ['self', 'rollback_transaction']
    [RESOLVE] Chain resolution needed for: ['self', 'rollback_transaction']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.rollback_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.rollback_transaction
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.rollback_transaction
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.rollback_transaction
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.rollback_transaction
            [INTERMEDIATE] Tracking chain steps for: self.rollback_transaction
            [INTERMEDIATE] Step 1: self.rollback_transaction
      -> Resolved to: database_manager.TransactionManager.rollback_transaction
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self.rollback_transaction
        [CACHE] self.rollback_transaction -> database_manager.TransactionManager.rollback_transaction (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.TransactionManager.transaction_context
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.TransactionManager.transaction_context
        Calls: 3
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.TransactionManager.get_transaction_info
    [CONTEXT] Entered function: database_manager.TransactionManager.get_transaction_info (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.transaction_started
    [RESOLVE] Attempting to resolve: ['self', 'transaction_started']
    [RESOLVE] Chain resolution needed for: ['self', 'transaction_started']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.transaction_started
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.transaction_started
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.transaction_started
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.transaction_started
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.isolation_level
    [RESOLVE] Attempting to resolve: ['self', 'isolation_level']
    [RESOLVE] Chain resolution needed for: ['self', 'isolation_level']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.isolation_level
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.isolation_level
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.isolation_level
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.isolation_level
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.isolation_level
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.start_time
    [RESOLVE] Attempting to resolve: ['self', 'start_time']
    [RESOLVE] Chain resolution needed for: ['self', 'start_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.start_time
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.start_time
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.start_time
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.start_time
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.start_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.operations_count
    [RESOLVE] Attempting to resolve: ['self', 'operations_count']
    [RESOLVE] Chain resolution needed for: ['self', 'operations_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.operations_count
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.operations_count
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.operations_count
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.operations_count
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.operations_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
      [CALL] Found call: self.connection.get_stats
    [RESOLVE] Attempting to resolve: ['self', 'connection', 'get_stats']
    [RESOLVE] Chain resolution needed for: ['self', 'connection', 'get_stats']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
      [CHAIN] Step 2: Resolving database_manager.TransactionManager.connection.get_stats
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection.get_stats
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection.get_stats
      [CHAIN] Step 2 resolved: database_manager.TransactionManager.connection.get_stats
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection.get_stats
            [INTERMEDIATE] Tracking chain steps for: self.connection.get_stats
            [INTERMEDIATE] Step 1: self.connection
    [RESOLVE] Attempting to resolve: ['self', 'connection']
    [RESOLVE] Chain resolution needed for: ['self', 'connection']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: database_manager.TransactionManager
      [CHAIN] Base resolved: self -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.connection
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.connection
            [INTERMEDIATE] Step 1 resolved to: database_manager.TransactionManager.connection
            [INTERMEDIATE] Step 2: self.connection.get_stats
      -> Resolved to: database_manager.TransactionManager.connection.get_stats
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.connection.get_stats
        [CACHE] self.connection.get_stats -> database_manager.TransactionManager.connection.get_stats (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.connection
        [CACHE] self.connection -> database_manager.TransactionManager.connection (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> database_manager.TransactionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.TransactionManager.get_transaction_info
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.TransactionManager.get_transaction_info
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: database_manager.TransactionManager
    [SYMBOL_TABLE] Exited class scope
      [ANNOTATED_ASSIGNMENT] _connection_pool : List[DatabaseConnection]
      [ASSIGNMENT] Processing: _pool_lock = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: threading.Lock
    [RESOLVE] Attempting to resolve: ['threading', 'Lock']
    [RESOLVE] Chain resolution needed for: ['threading', 'Lock']
      [CHAIN] Resolving base: threading
      [RESOLVE_SIMPLE] Resolving base: threading
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable threading not found in any scope
      [LOCAL_RESOLVER] can_resolve(threading): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(threading): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(threading): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(threading): threading (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: threading -> threading
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: threading -> threading
      [CHAIN] Step 1: Resolving threading.Lock
        [ATTRIBUTE] Resolving attribute: threading.Lock
        [ATTRIBUTE] Direct match found: threading.Lock
      [CHAIN] Step 1 resolved: threading.Lock
    [RESOLVE] RESOLVED to: threading.Lock
      [TYPE_INFERENCE] Call resolved to: threading.Lock
      [TYPE_INFERENCE] RESOLVED Inferred type: threading.Lock (class instantiation)
      [SYMBOL_UPDATE] Function: _pool_lock -> threading.Lock
        [ASSIGNMENT] RESOLVED Updated symbol table: _pool_lock = threading.Lock
      [ASSIGNMENT] Processing: _connection_counter = ...
        [ASSIGNMENT] Non-call assignment
  [FUNCTION] Analyzing function: get_db_connection
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.get_db_connection
    [CONTEXT] Entered function: database_manager.get_db_connection (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [NAME] Found name reference: _pool_lock
    [RESOLVE] Attempting to resolve: ['_pool_lock']
      [RESOLVE_SIMPLE] Resolving base: _pool_lock
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable _pool_lock not found in any scope
      [LOCAL_RESOLVER] can_resolve(_pool_lock): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(_pool_lock): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(_pool_lock): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(_pool_lock): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(_pool_lock): database_manager._pool_lock
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: _pool_lock -> database_manager._pool_lock
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager._pool_lock
      -> Resolved to state: database_manager._pool_lock
      [SYMBOL_LOOKUP] Variable _pool_lock not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: _connection_counter
    [RESOLVE] Attempting to resolve: ['_connection_counter']
      [RESOLVE_SIMPLE] Resolving base: _connection_counter
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable _connection_counter not found in any scope
      [LOCAL_RESOLVER] can_resolve(_connection_counter): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(_connection_counter): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(_connection_counter): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(_connection_counter): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(_connection_counter): database_manager._connection_counter
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: _connection_counter -> database_manager._connection_counter
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager._connection_counter
      -> Resolved to state: database_manager._connection_counter
      [SYMBOL_LOOKUP] Variable _connection_counter not found in any scope
      -> ADDED to accessed_state
      [ASSIGNMENT] Processing: connection_id = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: connection_id
    [RESOLVE] Attempting to resolve: ['connection_id']
      [RESOLVE_SIMPLE] Resolving base: connection_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable connection_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(connection_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(connection_id): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(connection_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(connection_id): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(connection_id): database_manager.connection_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: connection_id -> database_manager.connection_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.connection_id
      -> Not module state
      [NAME] Found name reference: _connection_counter
        [CACHE] _connection_counter -> database_manager._connection_counter (cached)
      -> Resolved to state: database_manager._connection_counter
      [SYMBOL_LOOKUP] Variable _connection_counter not found in any scope
      -> ADDED to accessed_state
      [ASSIGNMENT] Processing: connection = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: DatabaseConnection
    [RESOLVE] Attempting to resolve: ['DatabaseConnection']
      [RESOLVE_SIMPLE] Resolving base: DatabaseConnection
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable DatabaseConnection not found in any scope
      [LOCAL_RESOLVER] can_resolve(DatabaseConnection): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(DatabaseConnection): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(DatabaseConnection): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(DatabaseConnection): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(DatabaseConnection): database_manager.DatabaseConnection
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: DatabaseConnection -> database_manager.DatabaseConnection
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      [TYPE_INFERENCE] Call resolved to: database_manager.DatabaseConnection
      [TYPE_INFERENCE] RESOLVED Inferred type: database_manager.DatabaseConnection (class instantiation)
      [SYMBOL_UPDATE] Function: connection -> database_manager.DatabaseConnection
        [ASSIGNMENT] RESOLVED Updated symbol table: connection = database_manager.DatabaseConnection
      [NAME] Found name reference: connection
    [RESOLVE] Attempting to resolve: ['connection']
      [RESOLVE_SIMPLE] Resolving base: connection
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found connection in function scope: database_manager.DatabaseConnection
      [LOCAL_RESOLVER] can_resolve(connection): True
      [SYMBOL_LOOKUP] Found connection in function scope: database_manager.DatabaseConnection
      [LOCAL_RESOLVER] resolve(connection): database_manager.DatabaseConnection
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: connection -> database_manager.DatabaseConnection
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Not module state
      [CALL] Found call: DatabaseConnection
    [RESOLVE] Attempting to resolve: ['DatabaseConnection']
      [RESOLVE_SIMPLE] Resolving base: DatabaseConnection
      [CACHE] Hit for DatabaseConnection: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Resolved to: database_manager.DatabaseConnection
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: connection_id
    [RESOLVE] Attempting to resolve: ['connection_id']
      [RESOLVE_SIMPLE] Resolving base: connection_id
      [CACHE] Hit for connection_id: database_manager.connection_id
    [RESOLVE] RESOLVED to: database_manager.connection_id
      [NAME] Found name reference: DatabaseConnection
        [CACHE] DatabaseConnection -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [NAME] Found name reference: connection_id
        [CACHE] connection_id -> database_manager.connection_id (cached)
      -> Not module state
      [CALL] Found call: _connection_pool.append
    [RESOLVE] Attempting to resolve: ['_connection_pool', 'append']
    [RESOLVE] Chain resolution needed for: ['_connection_pool', 'append']
      [CHAIN] Resolving base: _connection_pool
      [RESOLVE_SIMPLE] Resolving base: _connection_pool
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable _connection_pool not found in any scope
      [LOCAL_RESOLVER] can_resolve(_connection_pool): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(_connection_pool): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(_connection_pool): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(_connection_pool): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(_connection_pool): database_manager._connection_pool
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: _connection_pool -> database_manager._connection_pool
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: _connection_pool -> database_manager._connection_pool
      [CHAIN] Step 1: Resolving database_manager._connection_pool.append
        [ATTRIBUTE] Resolving attribute: database_manager._connection_pool.append
        [ATTRIBUTE] Direct match found: database_manager._connection_pool.append
      [CHAIN] Step 1 resolved: database_manager._connection_pool.append
    [RESOLVE] RESOLVED to: database_manager._connection_pool.append
            [INTERMEDIATE] Tracking chain steps for: _connection_pool.append
            [INTERMEDIATE] Step 1: _connection_pool.append
      -> Resolved to: database_manager._connection_pool.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: connection
    [RESOLVE] Attempting to resolve: ['connection']
      [RESOLVE_SIMPLE] Resolving base: connection
      [CACHE] Hit for connection: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      [ATTRIBUTE] Found attribute access: _connection_pool.append
        [CACHE] _connection_pool.append -> database_manager._connection_pool.append (cached)
      -> Not module state
      [NAME] Found name reference: _connection_pool
    [RESOLVE] Attempting to resolve: ['_connection_pool']
      [RESOLVE_SIMPLE] Resolving base: _connection_pool
      [CACHE] Hit for _connection_pool: database_manager._connection_pool
    [RESOLVE] RESOLVED to: database_manager._connection_pool
      -> Resolved to state: database_manager._connection_pool
      [SYMBOL_LOOKUP] Variable _connection_pool not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: connection
        [CACHE] connection -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: logging.debug
    [RESOLVE] Attempting to resolve: ['logging', 'debug']
    [RESOLVE] Chain resolution needed for: ['logging', 'debug']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable logging not found in any scope
      [LOCAL_RESOLVER] can_resolve(logging): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(logging): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(logging): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(logging): logging (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: logging -> logging
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.debug
        [ATTRIBUTE] Resolving attribute: logging.debug
        [ATTRIBUTE] Direct match found: logging.debug
      [CHAIN] Step 1 resolved: logging.debug
    [RESOLVE] RESOLVED to: logging.debug
            [INTERMEDIATE] Tracking chain steps for: logging.debug
            [INTERMEDIATE] Step 1: logging.debug
      -> Resolved to: logging.debug
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.debug
        [CACHE] logging.debug -> logging.debug (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [NAME] Found name reference: connection_id
        [CACHE] connection_id -> database_manager.connection_id (cached)
      -> Not module state
      [NAME] Found name reference: connection
        [CACHE] connection -> database_manager.DatabaseConnection (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.get_db_connection
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.get_db_connection
        Calls: 0
        Instantiations: 1
        State Access: 3
  [FUNCTION] Analyzing function: close_all_connections
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.close_all_connections
    [CONTEXT] Entered function: database_manager.close_all_connections (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [NAME] Found name reference: _pool_lock
    [RESOLVE] Attempting to resolve: ['_pool_lock']
      [RESOLVE_SIMPLE] Resolving base: _pool_lock
      [CACHE] Hit for _pool_lock: database_manager._pool_lock
    [RESOLVE] RESOLVED to: database_manager._pool_lock
      -> Resolved to state: database_manager._pool_lock
      [SYMBOL_LOOKUP] Variable _pool_lock not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: connection
    [RESOLVE] Attempting to resolve: ['connection']
      [RESOLVE_SIMPLE] Resolving base: connection
      [CACHE] Hit for connection: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Not module state
      [NAME] Found name reference: _connection_pool
    [RESOLVE] Attempting to resolve: ['_connection_pool']
      [RESOLVE_SIMPLE] Resolving base: _connection_pool
      [CACHE] Hit for _connection_pool: database_manager._connection_pool
    [RESOLVE] RESOLVED to: database_manager._connection_pool
      -> Resolved to state: database_manager._connection_pool
      [SYMBOL_LOOKUP] Variable _connection_pool not found in any scope
      -> ADDED to accessed_state
      [CALL] Found call: connection.is_connected
    [RESOLVE] Attempting to resolve: ['connection', 'is_connected']
    [RESOLVE] Chain resolution needed for: ['connection', 'is_connected']
      [CHAIN] Resolving base: connection
      [RESOLVE_SIMPLE] Resolving base: connection
      [CACHE] Hit for connection: database_manager.DatabaseConnection
      [CHAIN] Base resolved: connection -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.is_connected
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.is_connected
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.is_connected
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.is_connected
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.is_connected
            [INTERMEDIATE] Tracking chain steps for: connection.is_connected
            [INTERMEDIATE] Step 1: connection.is_connected
      -> Resolved to: database_manager.DatabaseConnection.is_connected
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: connection.is_connected
        [CACHE] connection.is_connected -> database_manager.DatabaseConnection.is_connected (cached)
      -> Not module state
      [NAME] Found name reference: connection
        [CACHE] connection -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: connection.close
    [RESOLVE] Attempting to resolve: ['connection', 'close']
    [RESOLVE] Chain resolution needed for: ['connection', 'close']
      [CHAIN] Resolving base: connection
      [RESOLVE_SIMPLE] Resolving base: connection
      [CACHE] Hit for connection: database_manager.DatabaseConnection
      [CHAIN] Base resolved: connection -> database_manager.DatabaseConnection
      [CHAIN] Step 1: Resolving database_manager.DatabaseConnection.close
        [ATTRIBUTE] Resolving attribute: database_manager.DatabaseConnection.close
        [ATTRIBUTE] Direct match found: database_manager.DatabaseConnection.close
      [CHAIN] Step 1 resolved: database_manager.DatabaseConnection.close
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection.close
            [INTERMEDIATE] Tracking chain steps for: connection.close
            [INTERMEDIATE] Step 1: connection.close
      -> Resolved to: database_manager.DatabaseConnection.close
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: connection.close
        [CACHE] connection.close -> database_manager.DatabaseConnection.close (cached)
      -> Not module state
      [NAME] Found name reference: connection
        [CACHE] connection -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [CALL] Found call: _connection_pool.clear
    [RESOLVE] Attempting to resolve: ['_connection_pool', 'clear']
    [RESOLVE] Chain resolution needed for: ['_connection_pool', 'clear']
      [CHAIN] Resolving base: _connection_pool
      [RESOLVE_SIMPLE] Resolving base: _connection_pool
      [CACHE] Hit for _connection_pool: database_manager._connection_pool
      [CHAIN] Base resolved: _connection_pool -> database_manager._connection_pool
      [CHAIN] Step 1: Resolving database_manager._connection_pool.clear
        [ATTRIBUTE] Resolving attribute: database_manager._connection_pool.clear
        [ATTRIBUTE] Direct match found: database_manager._connection_pool.clear
      [CHAIN] Step 1 resolved: database_manager._connection_pool.clear
    [RESOLVE] RESOLVED to: database_manager._connection_pool.clear
            [INTERMEDIATE] Tracking chain steps for: _connection_pool.clear
            [INTERMEDIATE] Step 1: _connection_pool.clear
      -> Resolved to: database_manager._connection_pool.clear
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: _connection_pool.clear
        [CACHE] _connection_pool.clear -> database_manager._connection_pool.clear (cached)
      -> Not module state
      [NAME] Found name reference: _connection_pool
        [CACHE] _connection_pool -> database_manager._connection_pool (cached)
      -> Resolved to state: database_manager._connection_pool
      [SYMBOL_LOOKUP] Variable _connection_pool not found in any scope
      -> ADDED to accessed_state
      [CALL] Found call: logging.info
    [RESOLVE] Attempting to resolve: ['logging', 'info']
    [RESOLVE] Chain resolution needed for: ['logging', 'info']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.info
        [ATTRIBUTE] Resolving attribute: logging.info
        [ATTRIBUTE] Direct match found: logging.info
      [CHAIN] Step 1 resolved: logging.info
    [RESOLVE] RESOLVED to: logging.info
            [INTERMEDIATE] Tracking chain steps for: logging.info
            [INTERMEDIATE] Step 1: logging.info
      -> Resolved to: logging.info
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.info
        [CACHE] logging.info -> logging.info (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
    [CONTEXT] Exited function: database_manager.close_all_connections
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.close_all_connections
        Calls: 2
        Instantiations: 0
        State Access: 2
  [FUNCTION] Analyzing function: get_pool_stats
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.get_pool_stats
    [CONTEXT] Entered function: database_manager.get_pool_stats (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [NAME] Found name reference: _pool_lock
    [RESOLVE] Attempting to resolve: ['_pool_lock']
      [RESOLVE_SIMPLE] Resolving base: _pool_lock
      [CACHE] Hit for _pool_lock: database_manager._pool_lock
    [RESOLVE] RESOLVED to: database_manager._pool_lock
      -> Resolved to state: database_manager._pool_lock
      [SYMBOL_LOOKUP] Variable _pool_lock not found in any scope
      -> ADDED to accessed_state
      [ASSIGNMENT] Processing: total_connections = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(len): database_manager.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> database_manager.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.len
      [TYPE_INFERENCE] Call resolved to: database_manager.len
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for total_connections
      [NAME] Found name reference: total_connections
    [RESOLVE] Attempting to resolve: ['total_connections']
      [RESOLVE_SIMPLE] Resolving base: total_connections
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable total_connections not found in any scope
      [LOCAL_RESOLVER] can_resolve(total_connections): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(total_connections): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(total_connections): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(total_connections): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(total_connections): database_manager.total_connections
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: total_connections -> database_manager.total_connections
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.total_connections
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [CACHE] Hit for len: database_manager.len
    [RESOLVE] RESOLVED to: database_manager.len
      -> Not module state
      [NAME] Found name reference: _connection_pool
    [RESOLVE] Attempting to resolve: ['_connection_pool']
      [RESOLVE_SIMPLE] Resolving base: _connection_pool
      [CACHE] Hit for _connection_pool: database_manager._connection_pool
    [RESOLVE] RESOLVED to: database_manager._connection_pool
      -> Resolved to state: database_manager._connection_pool
      [SYMBOL_LOOKUP] Variable _connection_pool not found in any scope
      -> ADDED to accessed_state
      [ASSIGNMENT] Processing: active_connections = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: sum
    [RESOLVE] Attempting to resolve: ['sum']
      [RESOLVE_SIMPLE] Resolving base: sum
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable sum not found in any scope
      [LOCAL_RESOLVER] can_resolve(sum): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(sum): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(sum): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(sum): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(sum): database_manager.sum
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: sum -> database_manager.sum
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.sum
      [TYPE_INFERENCE] Call resolved to: database_manager.sum
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for active_connections
      [NAME] Found name reference: active_connections
    [RESOLVE] Attempting to resolve: ['active_connections']
      [RESOLVE_SIMPLE] Resolving base: active_connections
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable active_connections not found in any scope
      [LOCAL_RESOLVER] can_resolve(active_connections): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(active_connections): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(active_connections): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(active_connections): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(active_connections): database_manager.active_connections
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: active_connections -> database_manager.active_connections
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.active_connections
      -> Not module state
      [CALL] Found call: sum
      -> IGNORED (built-in function)
      [NAME] Found name reference: sum
    [RESOLVE] Attempting to resolve: ['sum']
      [RESOLVE_SIMPLE] Resolving base: sum
      [CACHE] Hit for sum: database_manager.sum
    [RESOLVE] RESOLVED to: database_manager.sum
      -> Not module state
      [NAME] Found name reference: conn
    [RESOLVE] Attempting to resolve: ['conn']
      [RESOLVE_SIMPLE] Resolving base: conn
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable conn not found in any scope
      [LOCAL_RESOLVER] can_resolve(conn): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(conn): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(conn): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(conn): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(conn): database_manager.conn
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: conn -> database_manager.conn
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.conn
      -> Resolved to state: database_manager.conn
      [SYMBOL_LOOKUP] Variable conn not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: _connection_pool
        [CACHE] _connection_pool -> database_manager._connection_pool (cached)
      -> Resolved to state: database_manager._connection_pool
      [SYMBOL_LOOKUP] Variable _connection_pool not found in any scope
      -> ADDED to accessed_state
      [CALL] Found call: conn.is_connected
    [RESOLVE] Attempting to resolve: ['conn', 'is_connected']
    [RESOLVE] Chain resolution needed for: ['conn', 'is_connected']
      [CHAIN] Resolving base: conn
      [RESOLVE_SIMPLE] Resolving base: conn
      [CACHE] Hit for conn: database_manager.conn
      [CHAIN] Base resolved: conn -> database_manager.conn
      [CHAIN] Step 1: Resolving database_manager.conn.is_connected
        [ATTRIBUTE] Resolving attribute: database_manager.conn.is_connected
        [ATTRIBUTE] Direct match found: database_manager.conn.is_connected
      [CHAIN] Step 1 resolved: database_manager.conn.is_connected
    [RESOLVE] RESOLVED to: database_manager.conn.is_connected
            [INTERMEDIATE] Tracking chain steps for: conn.is_connected
            [INTERMEDIATE] Step 1: conn.is_connected
      -> Resolved to: database_manager.conn.is_connected
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: conn.is_connected
        [CACHE] conn.is_connected -> database_manager.conn.is_connected (cached)
      -> Not module state
      [NAME] Found name reference: conn
        [CACHE] conn -> database_manager.conn (cached)
      -> Resolved to state: database_manager.conn
      [SYMBOL_LOOKUP] Variable conn not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: total_connections
        [CACHE] total_connections -> database_manager.total_connections (cached)
      -> Not module state
      [NAME] Found name reference: active_connections
        [CACHE] active_connections -> database_manager.active_connections (cached)
      -> Not module state
      [CALL] Found call: conn.get_stats
    [RESOLVE] Attempting to resolve: ['conn', 'get_stats']
    [RESOLVE] Chain resolution needed for: ['conn', 'get_stats']
      [CHAIN] Resolving base: conn
      [RESOLVE_SIMPLE] Resolving base: conn
      [CACHE] Hit for conn: database_manager.conn
      [CHAIN] Base resolved: conn -> database_manager.conn
      [CHAIN] Step 1: Resolving database_manager.conn.get_stats
        [ATTRIBUTE] Resolving attribute: database_manager.conn.get_stats
        [ATTRIBUTE] Direct match found: database_manager.conn.get_stats
      [CHAIN] Step 1 resolved: database_manager.conn.get_stats
    [RESOLVE] RESOLVED to: database_manager.conn.get_stats
            [INTERMEDIATE] Tracking chain steps for: conn.get_stats
            [INTERMEDIATE] Step 1: conn.get_stats
      -> Resolved to: database_manager.conn.get_stats
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: conn.get_stats
        [CACHE] conn.get_stats -> database_manager.conn.get_stats (cached)
      -> Not module state
      [NAME] Found name reference: conn
        [CACHE] conn -> database_manager.conn (cached)
      -> Resolved to state: database_manager.conn
      [SYMBOL_LOOKUP] Variable conn not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: conn
        [CACHE] conn -> database_manager.conn (cached)
      -> Resolved to state: database_manager.conn
      [SYMBOL_LOOKUP] Variable conn not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: _connection_pool
        [CACHE] _connection_pool -> database_manager._connection_pool (cached)
      -> Resolved to state: database_manager._connection_pool
      [SYMBOL_LOOKUP] Variable _connection_pool not found in any scope
      -> ADDED to accessed_state
    [CONTEXT] Exited function: database_manager.get_pool_stats
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.get_pool_stats
        Calls: 0
        Instantiations: 0
        State Access: 3
  [FUNCTION] Analyzing function: create_transaction_manager
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.create_transaction_manager
    [CONTEXT] Entered function: database_manager.create_transaction_manager (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'isolation_level': 'str'}
        [ARG_TYPE] Processing type annotation for isolation_level: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(str): database_manager.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> database_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.str
      [SYMBOL_UPDATE] Function: isolation_level -> database_manager.str
        [ARG_TYPE] RESOLVED isolation_level : database_manager.str
      [ASSIGNMENT] Processing: connection = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: get_db_connection
    [RESOLVE] Attempting to resolve: ['get_db_connection']
      [RESOLVE_SIMPLE] Resolving base: get_db_connection
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable get_db_connection not found in any scope
      [LOCAL_RESOLVER] can_resolve(get_db_connection): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(get_db_connection): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(get_db_connection): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(get_db_connection): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(get_db_connection): database_manager.get_db_connection
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: get_db_connection -> database_manager.get_db_connection
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.get_db_connection
      [TYPE_INFERENCE] Call resolved to: database_manager.get_db_connection
        [RETURN_TYPE_RESOLUTION] Resolving return type: DatabaseConnection
        [RETURN_TYPE_RESOLUTION] Found in current module: database_manager.DatabaseConnection
      [TYPE_INFERENCE] RESOLVED Inferred type: database_manager.DatabaseConnection (from return type)
      [SYMBOL_UPDATE] Function: connection -> database_manager.DatabaseConnection
        [ASSIGNMENT] RESOLVED Updated symbol table: connection = database_manager.DatabaseConnection
      [NAME] Found name reference: connection
    [RESOLVE] Attempting to resolve: ['connection']
      [RESOLVE_SIMPLE] Resolving base: connection
      [CACHE] Hit for connection: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Not module state
      [CALL] Found call: get_db_connection
    [RESOLVE] Attempting to resolve: ['get_db_connection']
      [RESOLVE_SIMPLE] Resolving base: get_db_connection
      [CACHE] Hit for get_db_connection: database_manager.get_db_connection
    [RESOLVE] RESOLVED to: database_manager.get_db_connection
      -> Resolved to: database_manager.get_db_connection
      -> ADDED to calls
      [NAME] Found name reference: get_db_connection
        [CACHE] get_db_connection -> database_manager.get_db_connection (cached)
      -> Not module state
      [CALL] Found call: TransactionManager
    [RESOLVE] Attempting to resolve: ['TransactionManager']
      [RESOLVE_SIMPLE] Resolving base: TransactionManager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable TransactionManager not found in any scope
      [LOCAL_RESOLVER] can_resolve(TransactionManager): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(TransactionManager): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(TransactionManager): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(TransactionManager): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(TransactionManager): database_manager.TransactionManager
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: TransactionManager -> database_manager.TransactionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      -> Resolved to: database_manager.TransactionManager
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: connection
    [RESOLVE] Attempting to resolve: ['connection']
      [RESOLVE_SIMPLE] Resolving base: connection
      [CACHE] Hit for connection: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
        [FUNCTION_ARG] Checking argument: isolation_level
    [RESOLVE] Attempting to resolve: ['isolation_level']
      [RESOLVE_SIMPLE] Resolving base: isolation_level
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found isolation_level in function scope: database_manager.str
      [LOCAL_RESOLVER] can_resolve(isolation_level): True
      [SYMBOL_LOOKUP] Found isolation_level in function scope: database_manager.str
      [LOCAL_RESOLVER] resolve(isolation_level): database_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: isolation_level -> database_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.str
      [NAME] Found name reference: TransactionManager
        [CACHE] TransactionManager -> database_manager.TransactionManager (cached)
      -> Not module state
      [NAME] Found name reference: connection
        [CACHE] connection -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [NAME] Found name reference: isolation_level
    [RESOLVE] Attempting to resolve: ['isolation_level']
      [RESOLVE_SIMPLE] Resolving base: isolation_level
      [CACHE] Hit for isolation_level: database_manager.str
    [RESOLVE] RESOLVED to: database_manager.str
      -> Not module state
    [CONTEXT] Exited function: database_manager.create_transaction_manager
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.create_transaction_manager
        Calls: 1
        Instantiations: 1
        State Access: 0
  [FUNCTION] Analyzing function: database_transaction
    [FUNCTION_ANALYSIS] Starting analysis of: database_manager.database_transaction
    [DECORATOR] @contextmanager
      [CODE_STANDARD_VIOLATION] MISSING_RETURN_TYPE: Function database_manager.database_transaction
      [IMPACT] Cannot infer return type - chained method calls may fail
      [ACTION_REQUIRED] Add appropriate type annotation
      [CODE_QUALITY] Found 1 violations in database_manager.database_transaction
    [CONTEXT] Entered function: database_manager.database_transaction (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'isolation_level': 'str'}
        [ARG_TYPE] Processing type annotation for isolation_level: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: database_manager.str
    [RESOLVE] RESOLVED to: database_manager.str
      [SYMBOL_UPDATE] Function: isolation_level -> database_manager.str
        [ARG_TYPE] RESOLVED isolation_level : database_manager.str
      [ASSIGNMENT] Processing: manager = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: create_transaction_manager
    [RESOLVE] Attempting to resolve: ['create_transaction_manager']
      [RESOLVE_SIMPLE] Resolving base: create_transaction_manager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable create_transaction_manager not found in any scope
      [LOCAL_RESOLVER] can_resolve(create_transaction_manager): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(create_transaction_manager): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(create_transaction_manager): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(create_transaction_manager): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(create_transaction_manager): database_manager.create_transaction_manager
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: create_transaction_manager -> database_manager.create_transaction_manager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.create_transaction_manager
      [TYPE_INFERENCE] Call resolved to: database_manager.create_transaction_manager
        [RETURN_TYPE_RESOLUTION] Resolving return type: TransactionManager
        [RETURN_TYPE_RESOLUTION] Found in current module: database_manager.TransactionManager
      [TYPE_INFERENCE] RESOLVED Inferred type: database_manager.TransactionManager (from return type)
      [SYMBOL_UPDATE] Function: manager -> database_manager.TransactionManager
        [ASSIGNMENT] RESOLVED Updated symbol table: manager = database_manager.TransactionManager
      [NAME] Found name reference: manager
    [RESOLVE] Attempting to resolve: ['manager']
      [RESOLVE_SIMPLE] Resolving base: manager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found manager in function scope: database_manager.TransactionManager
      [LOCAL_RESOLVER] can_resolve(manager): True
      [SYMBOL_LOOKUP] Found manager in function scope: database_manager.TransactionManager
      [LOCAL_RESOLVER] resolve(manager): database_manager.TransactionManager
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: manager -> database_manager.TransactionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      -> Not module state
      [CALL] Found call: create_transaction_manager
    [RESOLVE] Attempting to resolve: ['create_transaction_manager']
      [RESOLVE_SIMPLE] Resolving base: create_transaction_manager
      [CACHE] Hit for create_transaction_manager: database_manager.create_transaction_manager
    [RESOLVE] RESOLVED to: database_manager.create_transaction_manager
      -> Resolved to: database_manager.create_transaction_manager
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: isolation_level
    [RESOLVE] Attempting to resolve: ['isolation_level']
      [RESOLVE_SIMPLE] Resolving base: isolation_level
      [CACHE] Hit for isolation_level: database_manager.str
    [RESOLVE] RESOLVED to: database_manager.str
      [NAME] Found name reference: create_transaction_manager
        [CACHE] create_transaction_manager -> database_manager.create_transaction_manager (cached)
      -> Not module state
      [NAME] Found name reference: isolation_level
    [RESOLVE] Attempting to resolve: ['isolation_level']
      [RESOLVE_SIMPLE] Resolving base: isolation_level
      [CACHE] Hit for isolation_level: database_manager.str
    [RESOLVE] RESOLVED to: database_manager.str
      -> Not module state
      [CALL] Found call: manager.transaction_context
    [RESOLVE] Attempting to resolve: ['manager', 'transaction_context']
    [RESOLVE] Chain resolution needed for: ['manager', 'transaction_context']
      [CHAIN] Resolving base: manager
      [RESOLVE_SIMPLE] Resolving base: manager
      [CACHE] Hit for manager: database_manager.TransactionManager
      [CHAIN] Base resolved: manager -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.transaction_context
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.transaction_context
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.transaction_context
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.transaction_context
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.transaction_context
            [INTERMEDIATE] Tracking chain steps for: manager.transaction_context
            [INTERMEDIATE] Step 1: manager.transaction_context
      -> Resolved to: database_manager.TransactionManager.transaction_context
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: manager.transaction_context
        [CACHE] manager.transaction_context -> database_manager.TransactionManager.transaction_context (cached)
      -> Not module state
      [NAME] Found name reference: manager
        [CACHE] manager -> database_manager.TransactionManager (cached)
      -> Not module state
      [NAME] Found name reference: manager
        [CACHE] manager -> database_manager.TransactionManager (cached)
      -> Not module state
      [CALL] Found call: manager.close_connection
    [RESOLVE] Attempting to resolve: ['manager', 'close_connection']
    [RESOLVE] Chain resolution needed for: ['manager', 'close_connection']
      [CHAIN] Resolving base: manager
      [RESOLVE_SIMPLE] Resolving base: manager
      [CACHE] Hit for manager: database_manager.TransactionManager
      [CHAIN] Base resolved: manager -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.close_connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.close_connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.close_connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.close_connection
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.close_connection
            [INTERMEDIATE] Tracking chain steps for: manager.close_connection
            [INTERMEDIATE] Step 1: manager.close_connection
      -> Resolved to: database_manager.TransactionManager.close_connection
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: manager.close_connection
        [CACHE] manager.close_connection -> database_manager.TransactionManager.close_connection (cached)
      -> Not module state
      [NAME] Found name reference: manager
        [CACHE] manager -> database_manager.TransactionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: database_manager.database_transaction
    [FUNCTION_ANALYSIS] Completed analysis of: database_manager.database_transaction
        Calls: 3
        Instantiations: 0
        State Access: 0
      [ASSIGNMENT] Processing: conn = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: get_db_connection
    [RESOLVE] Attempting to resolve: ['get_db_connection']
      [RESOLVE_SIMPLE] Resolving base: get_db_connection
      [CACHE] Hit for get_db_connection: database_manager.get_db_connection
    [RESOLVE] RESOLVED to: database_manager.get_db_connection
      [TYPE_INFERENCE] Call resolved to: database_manager.get_db_connection
        [RETURN_TYPE_RESOLUTION] Resolving return type: DatabaseConnection
        [RETURN_TYPE_RESOLUTION] Found in current module: database_manager.DatabaseConnection
      [TYPE_INFERENCE] RESOLVED Inferred type: database_manager.DatabaseConnection (from return type)
      [SYMBOL_UPDATE] Function: conn -> database_manager.DatabaseConnection
        [ASSIGNMENT] RESOLVED Updated symbol table: conn = database_manager.DatabaseConnection
      [ASSIGNMENT] Processing: tx_manager = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: TransactionManager
    [RESOLVE] Attempting to resolve: ['TransactionManager']
      [RESOLVE_SIMPLE] Resolving base: TransactionManager
      [CACHE] Hit for TransactionManager: database_manager.TransactionManager
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      [TYPE_INFERENCE] Call resolved to: database_manager.TransactionManager
      [TYPE_INFERENCE] RESOLVED Inferred type: database_manager.TransactionManager (class instantiation)
      [SYMBOL_UPDATE] Function: tx_manager -> database_manager.TransactionManager
        [ASSIGNMENT] RESOLVED Updated symbol table: tx_manager = database_manager.TransactionManager
      [ASSIGNMENT] Processing: stats = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: get_pool_stats
    [RESOLVE] Attempting to resolve: ['get_pool_stats']
      [RESOLVE_SIMPLE] Resolving base: get_pool_stats
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable get_pool_stats not found in any scope
      [LOCAL_RESOLVER] can_resolve(get_pool_stats): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(get_pool_stats): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(get_pool_stats): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(get_pool_stats): True (fallback, module: database_manager)
      [MODULE_RESOLVER] resolve(get_pool_stats): database_manager.get_pool_stats
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: get_pool_stats -> database_manager.get_pool_stats
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.get_pool_stats
      [TYPE_INFERENCE] Call resolved to: database_manager.get_pool_stats
        [RETURN_TYPE_RESOLUTION] Resolving return type: Dict[str, Any]
        [RETURN_TYPE_RESOLUTION] Class 'Dict[str, Any]' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: Dict[str, Any]
      [TYPE_INFERENCE] Could not resolve return type 'Dict[str, Any]' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: Dict[str, Any] (from return type - unresolved)
      [SYMBOL_UPDATE] Function: stats -> Dict[str, Any]
        [ASSIGNMENT] RESOLVED Updated symbol table: stats = Dict[str, Any]
=== Module Analysis Complete ===
  Module analysis complete
=== Analyzing decorators.py ===
  [RESOLVER] Using implementation: refactored
=== Starting Module Analysis ===
    [FROM_IMPORT] Callable -> typing.Callable
    [FROM_IMPORT] Any -> typing.Any
    [FROM_IMPORT] Dict -> typing.Dict
    [FROM_IMPORT] Optional -> typing.Optional
    [FROM_IMPORT] Union -> typing.Union
    [FROM_IMPORT] Type -> typing.Type
    [FROM_IMPORT] List -> typing.List
    [FROM_IMPORT] wraps -> functools.wraps
    [FROM_IMPORT] partial -> functools.partial
    [IMPORT] time -> time
    [IMPORT] logging -> logging
    [FROM_IMPORT] Lock -> threading.Lock
    [FROM_IMPORT] defaultdict -> collections.defaultdict
    [IMPORT] inspect -> inspect
    [FROM_IMPORT] get_db_connection -> database_manager.get_db_connection
    [FROM_IMPORT] TransactionManager -> database_manager.TransactionManager
    [FROM_IMPORT] AdminManager -> admin_manager.AdminManager
    [MODULE_STATE] PERFORMANCE_METRICS : Dict[str, List[float]] = defaultdict(list)
    [MODULE_STATE] AUTH_CACHE : Dict[str, bool] = {}
    [MODULE_STATE] RATE_LIMIT_CACHE : Dict[str, Dict[str, Any]] = defaultdict(dict)
    [MODULE_STATE] TRACE_LOCK = Lock()
  [CLASS] Analyzing class: DecoratorRegistry
    [CONTEXT] Entered class: decorators.DecoratorRegistry
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.DecoratorRegistry.__init__
    [CONTEXT] Entered function: decorators.DecoratorRegistry.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.registered_decorators
    [RESOLVE] Attempting to resolve: ['self', 'registered_decorators']
    [RESOLVE] Chain resolution needed for: ['self', 'registered_decorators']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: decorators.DecoratorRegistry)
      [SELF_RESOLVER] resolve(self): decorators.DecoratorRegistry
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> decorators.DecoratorRegistry
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> decorators.DecoratorRegistry
      [CHAIN] Step 1: Resolving decorators.DecoratorRegistry.registered_decorators
        [ATTRIBUTE] Resolving attribute: decorators.DecoratorRegistry.registered_decorators
        [ATTRIBUTE] Direct match found: decorators.DecoratorRegistry.registered_decorators
      [CHAIN] Step 1 resolved: decorators.DecoratorRegistry.registered_decorators
    [RESOLVE] RESOLVED to: decorators.DecoratorRegistry.registered_decorators
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.DecoratorRegistry
    [RESOLVE] RESOLVED to: decorators.DecoratorRegistry
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: decorators.DecoratorRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: decorators.DecoratorRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(str): decorators.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> decorators.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.str
      -> Not module state
      [NAME] Found name reference: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Callable not found in any scope
      [LOCAL_RESOLVER] can_resolve(Callable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Callable): False (current_class: decorators.DecoratorRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Callable): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Callable): typing.Callable (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Callable -> typing.Callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Callable
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.decorator_chains
    [RESOLVE] Attempting to resolve: ['self', 'decorator_chains']
    [RESOLVE] Chain resolution needed for: ['self', 'decorator_chains']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.DecoratorRegistry
      [CHAIN] Base resolved: self -> decorators.DecoratorRegistry
      [CHAIN] Step 1: Resolving decorators.DecoratorRegistry.decorator_chains
        [ATTRIBUTE] Resolving attribute: decorators.DecoratorRegistry.decorator_chains
        [ATTRIBUTE] Direct match found: decorators.DecoratorRegistry.decorator_chains
      [CHAIN] Step 1 resolved: decorators.DecoratorRegistry.decorator_chains
    [RESOLVE] RESOLVED to: decorators.DecoratorRegistry.decorator_chains
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.DecoratorRegistry (cached)
      -> Not module state
      [NAME] Found name reference: Dict
        [CACHE] Dict -> typing.Dict (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> decorators.str (cached)
      -> Not module state
      [NAME] Found name reference: List
    [RESOLVE] Attempting to resolve: ['List']
      [RESOLVE_SIMPLE] Resolving base: List
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable List not found in any scope
      [LOCAL_RESOLVER] can_resolve(List): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(List): False (current_class: decorators.DecoratorRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(List): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(List): typing.List (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: List -> typing.List
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.List
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> decorators.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_traces
    [RESOLVE] Attempting to resolve: ['self', 'active_traces']
    [RESOLVE] Chain resolution needed for: ['self', 'active_traces']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.DecoratorRegistry
      [CHAIN] Base resolved: self -> decorators.DecoratorRegistry
      [CHAIN] Step 1: Resolving decorators.DecoratorRegistry.active_traces
        [ATTRIBUTE] Resolving attribute: decorators.DecoratorRegistry.active_traces
        [ATTRIBUTE] Direct match found: decorators.DecoratorRegistry.active_traces
      [CHAIN] Step 1 resolved: decorators.DecoratorRegistry.active_traces
    [RESOLVE] RESOLVED to: decorators.DecoratorRegistry.active_traces
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.DecoratorRegistry (cached)
      -> Not module state
      [NAME] Found name reference: List
        [CACHE] List -> typing.List (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> decorators.str (cached)
      -> Not module state
    [CONTEXT] Exited function: decorators.DecoratorRegistry.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.DecoratorRegistry.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.DecoratorRegistry.register_decorator
    [CONTEXT] Entered function: decorators.DecoratorRegistry.register_decorator (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'name': 'str', 'decorator': 'Callable'}
        [ARG_TYPE] Processing type annotation for name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: decorators.str
    [RESOLVE] RESOLVED to: decorators.str
      [SYMBOL_UPDATE] Function: name -> decorators.str
        [ARG_TYPE] RESOLVED name : decorators.str
        [ARG_TYPE] Processing type annotation for decorator: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Function: decorator -> typing.Callable
        [ARG_TYPE] RESOLVED decorator : typing.Callable
      [ATTRIBUTE] Found attribute access: self.registered_decorators
    [RESOLVE] Attempting to resolve: ['self', 'registered_decorators']
    [RESOLVE] Chain resolution needed for: ['self', 'registered_decorators']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.DecoratorRegistry
      [CHAIN] Base resolved: self -> decorators.DecoratorRegistry
      [CHAIN] Step 1: Resolving decorators.DecoratorRegistry.registered_decorators
        [ATTRIBUTE] Resolving attribute: decorators.DecoratorRegistry.registered_decorators
        [ATTRIBUTE] Direct match found: decorators.DecoratorRegistry.registered_decorators
      [CHAIN] Step 1 resolved: decorators.DecoratorRegistry.registered_decorators
    [RESOLVE] RESOLVED to: decorators.DecoratorRegistry.registered_decorators
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.DecoratorRegistry
    [RESOLVE] RESOLVED to: decorators.DecoratorRegistry
      -> Not module state
      [NAME] Found name reference: name
    [RESOLVE] Attempting to resolve: ['name']
      [RESOLVE_SIMPLE] Resolving base: name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found name in function scope: decorators.str
      [LOCAL_RESOLVER] can_resolve(name): True
      [SYMBOL_LOOKUP] Found name in function scope: decorators.str
      [LOCAL_RESOLVER] resolve(name): decorators.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: name -> decorators.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.str
      -> Not module state
      [NAME] Found name reference: decorator
    [RESOLVE] Attempting to resolve: ['decorator']
      [RESOLVE_SIMPLE] Resolving base: decorator
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found decorator in function scope: typing.Callable
      [LOCAL_RESOLVER] can_resolve(decorator): True
      [SYMBOL_LOOKUP] Found decorator in function scope: typing.Callable
      [LOCAL_RESOLVER] resolve(decorator): typing.Callable
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: decorator -> typing.Callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Callable
      -> Not module state
    [CONTEXT] Exited function: decorators.DecoratorRegistry.register_decorator
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.DecoratorRegistry.register_decorator
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.DecoratorRegistry.get_decorator_chain
    [CONTEXT] Entered function: decorators.DecoratorRegistry.get_decorator_chain (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'func_name': 'str'}
        [ARG_TYPE] Processing type annotation for func_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: decorators.str
    [RESOLVE] RESOLVED to: decorators.str
      [SYMBOL_UPDATE] Function: func_name -> decorators.str
        [ARG_TYPE] RESOLVED func_name : decorators.str
      [CALL] Found call: self.decorator_chains.get
    [RESOLVE] Attempting to resolve: ['self', 'decorator_chains', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'decorator_chains', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.DecoratorRegistry
      [CHAIN] Base resolved: self -> decorators.DecoratorRegistry
      [CHAIN] Step 1: Resolving decorators.DecoratorRegistry.decorator_chains
        [ATTRIBUTE] Resolving attribute: decorators.DecoratorRegistry.decorator_chains
        [ATTRIBUTE] Direct match found: decorators.DecoratorRegistry.decorator_chains
      [CHAIN] Step 1 resolved: decorators.DecoratorRegistry.decorator_chains
      [CHAIN] Step 2: Resolving decorators.DecoratorRegistry.decorator_chains.get
        [ATTRIBUTE] Resolving attribute: decorators.DecoratorRegistry.decorator_chains.get
        [ATTRIBUTE] Direct match found: decorators.DecoratorRegistry.decorator_chains.get
      [CHAIN] Step 2 resolved: decorators.DecoratorRegistry.decorator_chains.get
    [RESOLVE] RESOLVED to: decorators.DecoratorRegistry.decorator_chains.get
            [INTERMEDIATE] Tracking chain steps for: self.decorator_chains.get
            [INTERMEDIATE] Step 1: self.decorator_chains
    [RESOLVE] Attempting to resolve: ['self', 'decorator_chains']
    [RESOLVE] Chain resolution needed for: ['self', 'decorator_chains']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.DecoratorRegistry
      [CHAIN] Base resolved: self -> decorators.DecoratorRegistry
      [CHAIN] Step 1: Resolving decorators.DecoratorRegistry.decorator_chains
        [ATTRIBUTE] Resolving attribute: decorators.DecoratorRegistry.decorator_chains
        [ATTRIBUTE] Direct match found: decorators.DecoratorRegistry.decorator_chains
      [CHAIN] Step 1 resolved: decorators.DecoratorRegistry.decorator_chains
    [RESOLVE] RESOLVED to: decorators.DecoratorRegistry.decorator_chains
            [INTERMEDIATE] Step 1 resolved to: decorators.DecoratorRegistry.decorator_chains
            [INTERMEDIATE] Step 2: self.decorator_chains.get
      -> Resolved to: decorators.DecoratorRegistry.decorator_chains.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: func_name
    [RESOLVE] Attempting to resolve: ['func_name']
      [RESOLVE_SIMPLE] Resolving base: func_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found func_name in function scope: decorators.str
      [LOCAL_RESOLVER] can_resolve(func_name): True
      [SYMBOL_LOOKUP] Found func_name in function scope: decorators.str
      [LOCAL_RESOLVER] resolve(func_name): decorators.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: func_name -> decorators.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.str
      [ATTRIBUTE] Found attribute access: self.decorator_chains.get
        [CACHE] self.decorator_chains.get -> decorators.DecoratorRegistry.decorator_chains.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.decorator_chains
        [CACHE] self.decorator_chains -> decorators.DecoratorRegistry.decorator_chains (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.DecoratorRegistry
    [RESOLVE] RESOLVED to: decorators.DecoratorRegistry
      -> Not module state
      [NAME] Found name reference: func_name
    [RESOLVE] Attempting to resolve: ['func_name']
      [RESOLVE_SIMPLE] Resolving base: func_name
      [CACHE] Hit for func_name: decorators.str
    [RESOLVE] RESOLVED to: decorators.str
      -> Not module state
    [CONTEXT] Exited function: decorators.DecoratorRegistry.get_decorator_chain
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.DecoratorRegistry.get_decorator_chain
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: decorators.DecoratorRegistry
    [SYMBOL_TABLE] Exited class scope
      [ASSIGNMENT] Processing: _decorator_registry = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: DecoratorRegistry
    [RESOLVE] Attempting to resolve: ['DecoratorRegistry']
      [RESOLVE_SIMPLE] Resolving base: DecoratorRegistry
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable DecoratorRegistry not found in any scope
      [LOCAL_RESOLVER] can_resolve(DecoratorRegistry): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(DecoratorRegistry): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(DecoratorRegistry): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(DecoratorRegistry): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(DecoratorRegistry): decorators.DecoratorRegistry
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: DecoratorRegistry -> decorators.DecoratorRegistry
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.DecoratorRegistry
      [TYPE_INFERENCE] Call resolved to: decorators.DecoratorRegistry
      [TYPE_INFERENCE] RESOLVED Inferred type: decorators.DecoratorRegistry (class instantiation)
      [SYMBOL_UPDATE] Function: _decorator_registry -> decorators.DecoratorRegistry
        [ASSIGNMENT] RESOLVED Updated symbol table: _decorator_registry = decorators.DecoratorRegistry
  [FUNCTION] Analyzing function: trace
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.trace
    [CONTEXT] Entered function: decorators.trace (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'func': 'Optional[Callable]'}
      [NESTED_FUNCTION] Analyzing nested function: decorator
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'func': 'Optional[Callable]'}
        [ARG_TYPE] Processing type annotation for f: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Callable not found in any scope
      [LOCAL_RESOLVER] can_resolve(Callable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Callable): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Callable): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Callable): typing.Callable (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Callable -> typing.Callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Nested: f -> typing.Callable
        [ARG_TYPE] RESOLVED f : typing.Callable
  [FUNCTION] Analyzing function: wrapper
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.wrapper
    [DECORATOR] @wraps(f)
      [CODE_STANDARD_VIOLATION] MISSING_RETURN_TYPE: Function decorators.wrapper
      [IMPACT] Cannot infer return type - chained method calls may fail
      [ACTION_REQUIRED] Add appropriate type annotation
      [CODE_QUALITY] Found 1 violations in decorators.wrapper
    [CONTEXT] Entered function: decorators.wrapper (depth: 2)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [ASSIGNMENT] Processing: func_name = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: func_name
    [RESOLVE] Attempting to resolve: ['func_name']
      [RESOLVE_SIMPLE] Resolving base: func_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable func_name not found in any scope
      [LOCAL_RESOLVER] can_resolve(func_name): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(func_name): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(func_name): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(func_name): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(func_name): decorators.func_name
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: func_name -> decorators.func_name
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.func_name
      -> Not module state
      [ATTRIBUTE] Found attribute access: f.__module__
    [RESOLVE] Attempting to resolve: ['f', '__module__']
    [RESOLVE] Chain resolution needed for: ['f', '__module__']
      [CHAIN] Resolving base: f
      [RESOLVE_SIMPLE] Resolving base: f
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable f not found in any scope
      [LOCAL_RESOLVER] can_resolve(f): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(f): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(f): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(f): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(f): decorators.f
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: f -> decorators.f
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: f -> decorators.f
      [CHAIN] Step 1: Resolving decorators.f.__module__
        [ATTRIBUTE] Resolving attribute: decorators.f.__module__
        [ATTRIBUTE] Direct match found: decorators.f.__module__
      [CHAIN] Step 1 resolved: decorators.f.__module__
    [RESOLVE] RESOLVED to: decorators.f.__module__
      -> Not module state
      [NAME] Found name reference: f
    [RESOLVE] Attempting to resolve: ['f']
      [RESOLVE_SIMPLE] Resolving base: f
      [CACHE] Hit for f: decorators.f
    [RESOLVE] RESOLVED to: decorators.f
      -> Not module state
      [ATTRIBUTE] Found attribute access: f.__qualname__
    [RESOLVE] Attempting to resolve: ['f', '__qualname__']
    [RESOLVE] Chain resolution needed for: ['f', '__qualname__']
      [CHAIN] Resolving base: f
      [RESOLVE_SIMPLE] Resolving base: f
      [CACHE] Hit for f: decorators.f
      [CHAIN] Base resolved: f -> decorators.f
      [CHAIN] Step 1: Resolving decorators.f.__qualname__
        [ATTRIBUTE] Resolving attribute: decorators.f.__qualname__
        [ATTRIBUTE] Direct match found: decorators.f.__qualname__
      [CHAIN] Step 1 resolved: decorators.f.__qualname__
    [RESOLVE] RESOLVED to: decorators.f.__qualname__
      -> Not module state
      [NAME] Found name reference: f
        [CACHE] f -> decorators.f (cached)
      -> Not module state
      [NAME] Found name reference: TRACE_LOCK
    [RESOLVE] Attempting to resolve: ['TRACE_LOCK']
      [RESOLVE_SIMPLE] Resolving base: TRACE_LOCK
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable TRACE_LOCK not found in any scope
      [LOCAL_RESOLVER] can_resolve(TRACE_LOCK): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(TRACE_LOCK): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(TRACE_LOCK): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(TRACE_LOCK): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(TRACE_LOCK): decorators.TRACE_LOCK
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: TRACE_LOCK -> decorators.TRACE_LOCK
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.TRACE_LOCK
      -> Resolved to state: decorators.TRACE_LOCK
      [SYMBOL_LOOKUP] Variable TRACE_LOCK not found in any scope
      -> ADDED to accessed_state
      [CALL] Found call: _decorator_registry.active_traces.append
    [RESOLVE] Attempting to resolve: ['_decorator_registry', 'active_traces', 'append']
    [RESOLVE] Chain resolution needed for: ['_decorator_registry', 'active_traces', 'append']
      [CHAIN] Resolving base: _decorator_registry
      [RESOLVE_SIMPLE] Resolving base: _decorator_registry
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable _decorator_registry not found in any scope
      [LOCAL_RESOLVER] can_resolve(_decorator_registry): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(_decorator_registry): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(_decorator_registry): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(_decorator_registry): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(_decorator_registry): decorators._decorator_registry
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: _decorator_registry -> decorators._decorator_registry
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: _decorator_registry -> decorators._decorator_registry
      [CHAIN] Step 1: Resolving decorators._decorator_registry.active_traces
        [ATTRIBUTE] Resolving attribute: decorators._decorator_registry.active_traces
        [ATTRIBUTE] Direct match found: decorators._decorator_registry.active_traces
      [CHAIN] Step 1 resolved: decorators._decorator_registry.active_traces
      [CHAIN] Step 2: Resolving decorators._decorator_registry.active_traces.append
        [ATTRIBUTE] Resolving attribute: decorators._decorator_registry.active_traces.append
        [ATTRIBUTE] Direct match found: decorators._decorator_registry.active_traces.append
      [CHAIN] Step 2 resolved: decorators._decorator_registry.active_traces.append
    [RESOLVE] RESOLVED to: decorators._decorator_registry.active_traces.append
            [INTERMEDIATE] Tracking chain steps for: _decorator_registry.active_traces.append
            [INTERMEDIATE] Step 1: _decorator_registry.active_traces
    [RESOLVE] Attempting to resolve: ['_decorator_registry', 'active_traces']
    [RESOLVE] Chain resolution needed for: ['_decorator_registry', 'active_traces']
      [CHAIN] Resolving base: _decorator_registry
      [RESOLVE_SIMPLE] Resolving base: _decorator_registry
      [CACHE] Hit for _decorator_registry: decorators._decorator_registry
      [CHAIN] Base resolved: _decorator_registry -> decorators._decorator_registry
      [CHAIN] Step 1: Resolving decorators._decorator_registry.active_traces
        [ATTRIBUTE] Resolving attribute: decorators._decorator_registry.active_traces
        [ATTRIBUTE] Direct match found: decorators._decorator_registry.active_traces
      [CHAIN] Step 1 resolved: decorators._decorator_registry.active_traces
    [RESOLVE] RESOLVED to: decorators._decorator_registry.active_traces
            [INTERMEDIATE] Step 1 resolved to: decorators._decorator_registry.active_traces
            [INTERMEDIATE] Step 2: _decorator_registry.active_traces.append
      -> Resolved to: decorators._decorator_registry.active_traces.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: func_name
    [RESOLVE] Attempting to resolve: ['func_name']
      [RESOLVE_SIMPLE] Resolving base: func_name
      [CACHE] Hit for func_name: decorators.func_name
    [RESOLVE] RESOLVED to: decorators.func_name
      [ATTRIBUTE] Found attribute access: _decorator_registry.active_traces.append
        [CACHE] _decorator_registry.active_traces.append -> decorators._decorator_registry.active_traces.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: _decorator_registry.active_traces
        [CACHE] _decorator_registry.active_traces -> decorators._decorator_registry.active_traces (cached)
      -> Not module state
      [NAME] Found name reference: _decorator_registry
    [RESOLVE] Attempting to resolve: ['_decorator_registry']
      [RESOLVE_SIMPLE] Resolving base: _decorator_registry
      [CACHE] Hit for _decorator_registry: decorators._decorator_registry
    [RESOLVE] RESOLVED to: decorators._decorator_registry
      -> Resolved to state: decorators._decorator_registry
      [SYMBOL_LOOKUP] Variable _decorator_registry not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: func_name
        [CACHE] func_name -> decorators.func_name (cached)
      -> Not module state
      [ASSIGNMENT] Processing: start_time = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable time not found in any scope
      [LOCAL_RESOLVER] can_resolve(time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(time): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(time): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(time): time (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: time -> time
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
      [TYPE_INFERENCE] Call resolved to: time.time
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for start_time
      [NAME] Found name reference: start_time
    [RESOLVE] Attempting to resolve: ['start_time']
      [RESOLVE_SIMPLE] Resolving base: start_time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable start_time not found in any scope
      [LOCAL_RESOLVER] can_resolve(start_time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(start_time): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(start_time): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(start_time): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(start_time): decorators.start_time
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: start_time -> decorators.start_time
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.start_time
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [NAME] Found name reference: include_args
    [RESOLVE] Attempting to resolve: ['include_args']
      [RESOLVE_SIMPLE] Resolving base: include_args
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable include_args not found in any scope
      [LOCAL_RESOLVER] can_resolve(include_args): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(include_args): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(include_args): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(include_args): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(include_args): decorators.include_args
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: include_args -> decorators.include_args
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.include_args
      -> Not module state
      [CALL] Found call: logging.log
    [RESOLVE] Attempting to resolve: ['logging', 'log']
    [RESOLVE] Chain resolution needed for: ['logging', 'log']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable logging not found in any scope
      [LOCAL_RESOLVER] can_resolve(logging): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(logging): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(logging): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(logging): logging (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: logging -> logging
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.log
        [ATTRIBUTE] Resolving attribute: logging.log
        [ATTRIBUTE] Direct match found: logging.log
      [CHAIN] Step 1 resolved: logging.log
    [RESOLVE] RESOLVED to: logging.log
            [INTERMEDIATE] Tracking chain steps for: logging.log
            [INTERMEDIATE] Step 1: logging.log
      -> Resolved to: logging.log
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.log
        [CACHE] logging.log -> logging.log (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [CALL] Found call: getattr
    [RESOLVE] Attempting to resolve: ['getattr']
      [RESOLVE_SIMPLE] Resolving base: getattr
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable getattr not found in any scope
      [LOCAL_RESOLVER] can_resolve(getattr): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(getattr): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(getattr): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(getattr): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(getattr): decorators.getattr
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: getattr -> decorators.getattr
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.getattr
      -> Resolved to: decorators.getattr
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
        [FUNCTION_ARG] Checking argument: level
    [RESOLVE] Attempting to resolve: ['level']
      [RESOLVE_SIMPLE] Resolving base: level
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable level not found in any scope
      [LOCAL_RESOLVER] can_resolve(level): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(level): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(level): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(level): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(level): decorators.level
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: level -> decorators.level
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.level
      [NAME] Found name reference: getattr
        [CACHE] getattr -> decorators.getattr (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [NAME] Found name reference: level
    [RESOLVE] Attempting to resolve: ['level']
      [RESOLVE_SIMPLE] Resolving base: level
      [CACHE] Hit for level: decorators.level
    [RESOLVE] RESOLVED to: decorators.level
      -> Not module state
      [NAME] Found name reference: func_name
        [CACHE] func_name -> decorators.func_name (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable args not found in any scope
      [LOCAL_RESOLVER] can_resolve(args): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(args): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(args): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(args): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(args): decorators.args
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: args -> decorators.args
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable kwargs not found in any scope
      [LOCAL_RESOLVER] can_resolve(kwargs): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(kwargs): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(kwargs): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(kwargs): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(kwargs): decorators.kwargs
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: kwargs -> decorators.kwargs
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.kwargs
      -> Not module state
      [CALL] Found call: logging.log
    [CACHE] logging.log -> logging.log (cached)
            [INTERMEDIATE] Tracking chain steps for: logging.log
            [INTERMEDIATE] Step 1: logging.log
      -> Resolved to: logging.log
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.log
        [CACHE] logging.log -> logging.log (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [CALL] Found call: getattr
    [CACHE] getattr -> decorators.getattr (cached)
      -> Resolved to: decorators.getattr
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
        [FUNCTION_ARG] Checking argument: level
    [RESOLVE] Attempting to resolve: ['level']
      [RESOLVE_SIMPLE] Resolving base: level
      [CACHE] Hit for level: decorators.level
    [RESOLVE] RESOLVED to: decorators.level
      [NAME] Found name reference: getattr
        [CACHE] getattr -> decorators.getattr (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [NAME] Found name reference: level
        [CACHE] level -> decorators.level (cached)
      -> Not module state
      [NAME] Found name reference: func_name
        [CACHE] func_name -> decorators.func_name (cached)
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: f
    [RESOLVE] Attempting to resolve: ['f']
      [RESOLVE_SIMPLE] Resolving base: f
      [CACHE] Hit for f: decorators.f
    [RESOLVE] RESOLVED to: decorators.f
      [TYPE_INFERENCE] Call resolved to: decorators.f
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for result
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable result not found in any scope
      [LOCAL_RESOLVER] can_resolve(result): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(result): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(result): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(result): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(result): decorators.result
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: result -> decorators.result
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.result
      -> Not module state
      [CALL] Found call: f
    [CACHE] f -> decorators.f (cached)
      -> Resolved to: decorators.f
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: f
        [CACHE] f -> decorators.f (cached)
      -> Not module state
      [NAME] Found name reference: args
        [CACHE] args -> decorators.args (cached)
      -> Not module state
      [NAME] Found name reference: kwargs
        [CACHE] kwargs -> decorators.kwargs (cached)
      -> Not module state
      [NAME] Found name reference: include_result
    [RESOLVE] Attempting to resolve: ['include_result']
      [RESOLVE_SIMPLE] Resolving base: include_result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable include_result not found in any scope
      [LOCAL_RESOLVER] can_resolve(include_result): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(include_result): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(include_result): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(include_result): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(include_result): decorators.include_result
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: include_result -> decorators.include_result
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.include_result
      -> Not module state
      [CALL] Found call: logging.log
    [CACHE] logging.log -> logging.log (cached)
            [INTERMEDIATE] Tracking chain steps for: logging.log
            [INTERMEDIATE] Step 1: logging.log
      -> Resolved to: logging.log
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.log
        [CACHE] logging.log -> logging.log (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [CALL] Found call: getattr
    [CACHE] getattr -> decorators.getattr (cached)
      -> Resolved to: decorators.getattr
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
        [FUNCTION_ARG] Checking argument: level
    [RESOLVE] Attempting to resolve: ['level']
      [RESOLVE_SIMPLE] Resolving base: level
      [CACHE] Hit for level: decorators.level
    [RESOLVE] RESOLVED to: decorators.level
      [NAME] Found name reference: getattr
        [CACHE] getattr -> decorators.getattr (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [NAME] Found name reference: level
        [CACHE] level -> decorators.level (cached)
      -> Not module state
      [NAME] Found name reference: func_name
        [CACHE] func_name -> decorators.func_name (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [CALL] Found call: logging.log
    [CACHE] logging.log -> logging.log (cached)
            [INTERMEDIATE] Tracking chain steps for: logging.log
            [INTERMEDIATE] Step 1: logging.log
      -> Resolved to: logging.log
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.log
        [CACHE] logging.log -> logging.log (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [CALL] Found call: getattr
    [CACHE] getattr -> decorators.getattr (cached)
      -> Resolved to: decorators.getattr
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
        [FUNCTION_ARG] Checking argument: level
    [RESOLVE] Attempting to resolve: ['level']
      [RESOLVE_SIMPLE] Resolving base: level
      [CACHE] Hit for level: decorators.level
    [RESOLVE] RESOLVED to: decorators.level
      [NAME] Found name reference: getattr
        [CACHE] getattr -> decorators.getattr (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [NAME] Found name reference: level
        [CACHE] level -> decorators.level (cached)
      -> Not module state
      [NAME] Found name reference: func_name
        [CACHE] func_name -> decorators.func_name (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Exception not found in any scope
      [LOCAL_RESOLVER] can_resolve(Exception): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Exception): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Exception): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(Exception): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(Exception): decorators.Exception
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: Exception -> decorators.Exception
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.Exception
      -> Not module state
      [CALL] Found call: logging.error
    [RESOLVE] Attempting to resolve: ['logging', 'error']
    [RESOLVE] Chain resolution needed for: ['logging', 'error']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.error
        [ATTRIBUTE] Resolving attribute: logging.error
        [ATTRIBUTE] Direct match found: logging.error
      [CHAIN] Step 1 resolved: logging.error
    [RESOLVE] RESOLVED to: logging.error
            [INTERMEDIATE] Tracking chain steps for: logging.error
            [INTERMEDIATE] Step 1: logging.error
      -> Resolved to: logging.error
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.error
        [CACHE] logging.error -> logging.error (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [NAME] Found name reference: func_name
        [CACHE] func_name -> decorators.func_name (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable e not found in any scope
      [LOCAL_RESOLVER] can_resolve(e): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(e): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(e): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(e): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(e): decorators.e
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: e -> decorators.e
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.e
      -> Not module state
      [ASSIGNMENT] Processing: execution_time = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: execution_time
    [RESOLVE] Attempting to resolve: ['execution_time']
      [RESOLVE_SIMPLE] Resolving base: execution_time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable execution_time not found in any scope
      [LOCAL_RESOLVER] can_resolve(execution_time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(execution_time): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(execution_time): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(execution_time): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(execution_time): decorators.execution_time
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: execution_time -> decorators.execution_time
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.execution_time
      -> Not module state
      [CALL] Found call: time.time
    [CACHE] time.time -> time.time (cached)
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
        [CACHE] time -> time (cached)
      -> Not module state
      [NAME] Found name reference: start_time
        [CACHE] start_time -> decorators.start_time (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [NAME] Found name reference: PERFORMANCE_METRICS
    [RESOLVE] Attempting to resolve: ['PERFORMANCE_METRICS']
      [RESOLVE_SIMPLE] Resolving base: PERFORMANCE_METRICS
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable PERFORMANCE_METRICS not found in any scope
      [LOCAL_RESOLVER] can_resolve(PERFORMANCE_METRICS): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(PERFORMANCE_METRICS): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(PERFORMANCE_METRICS): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(PERFORMANCE_METRICS): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(PERFORMANCE_METRICS): decorators.PERFORMANCE_METRICS
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: PERFORMANCE_METRICS -> decorators.PERFORMANCE_METRICS
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.PERFORMANCE_METRICS
      -> Resolved to state: decorators.PERFORMANCE_METRICS
      [SYMBOL_LOOKUP] Variable PERFORMANCE_METRICS not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: func_name
        [CACHE] func_name -> decorators.func_name (cached)
      -> Not module state
      [NAME] Found name reference: execution_time
        [CACHE] execution_time -> decorators.execution_time (cached)
      -> Not module state
      [NAME] Found name reference: TRACE_LOCK
        [CACHE] TRACE_LOCK -> decorators.TRACE_LOCK (cached)
      -> Resolved to state: decorators.TRACE_LOCK
      [SYMBOL_LOOKUP] Variable TRACE_LOCK not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: func_name
        [CACHE] func_name -> decorators.func_name (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: _decorator_registry.active_traces
        [CACHE] _decorator_registry.active_traces -> decorators._decorator_registry.active_traces (cached)
      -> Not module state
      [NAME] Found name reference: _decorator_registry
        [CACHE] _decorator_registry -> decorators._decorator_registry (cached)
      -> Resolved to state: decorators._decorator_registry
      [SYMBOL_LOOKUP] Variable _decorator_registry not found in any scope
      -> ADDED to accessed_state
      [CALL] Found call: _decorator_registry.active_traces.remove
    [RESOLVE] Attempting to resolve: ['_decorator_registry', 'active_traces', 'remove']
    [RESOLVE] Chain resolution needed for: ['_decorator_registry', 'active_traces', 'remove']
      [CHAIN] Resolving base: _decorator_registry
      [RESOLVE_SIMPLE] Resolving base: _decorator_registry
      [CACHE] Hit for _decorator_registry: decorators._decorator_registry
      [CHAIN] Base resolved: _decorator_registry -> decorators._decorator_registry
      [CHAIN] Step 1: Resolving decorators._decorator_registry.active_traces
        [ATTRIBUTE] Resolving attribute: decorators._decorator_registry.active_traces
        [ATTRIBUTE] Direct match found: decorators._decorator_registry.active_traces
      [CHAIN] Step 1 resolved: decorators._decorator_registry.active_traces
      [CHAIN] Step 2: Resolving decorators._decorator_registry.active_traces.remove
        [ATTRIBUTE] Resolving attribute: decorators._decorator_registry.active_traces.remove
        [ATTRIBUTE] Direct match found: decorators._decorator_registry.active_traces.remove
      [CHAIN] Step 2 resolved: decorators._decorator_registry.active_traces.remove
    [RESOLVE] RESOLVED to: decorators._decorator_registry.active_traces.remove
            [INTERMEDIATE] Tracking chain steps for: _decorator_registry.active_traces.remove
            [INTERMEDIATE] Step 1: _decorator_registry.active_traces
    [CACHE] _decorator_registry.active_traces -> decorators._decorator_registry.active_traces (cached)
            [INTERMEDIATE] Step 1 resolved to: decorators._decorator_registry.active_traces
            [INTERMEDIATE] Step 2: _decorator_registry.active_traces.remove
      -> Resolved to: decorators._decorator_registry.active_traces.remove
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: func_name
    [RESOLVE] Attempting to resolve: ['func_name']
      [RESOLVE_SIMPLE] Resolving base: func_name
      [CACHE] Hit for func_name: decorators.func_name
    [RESOLVE] RESOLVED to: decorators.func_name
      [ATTRIBUTE] Found attribute access: _decorator_registry.active_traces.remove
        [CACHE] _decorator_registry.active_traces.remove -> decorators._decorator_registry.active_traces.remove (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: _decorator_registry.active_traces
        [CACHE] _decorator_registry.active_traces -> decorators._decorator_registry.active_traces (cached)
      -> Not module state
      [NAME] Found name reference: _decorator_registry
        [CACHE] _decorator_registry -> decorators._decorator_registry (cached)
      -> Resolved to state: decorators._decorator_registry
      [SYMBOL_LOOKUP] Variable _decorator_registry not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: func_name
        [CACHE] func_name -> decorators.func_name (cached)
      -> Not module state
    [CONTEXT] Exited function: decorators.wrapper
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.wrapper
        Calls: 0
        Instantiations: 0
        State Access: 3
      [ASSIGNMENT] Processing: wrapper_name = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: wrapper_name
    [RESOLVE] Attempting to resolve: ['wrapper_name']
      [RESOLVE_SIMPLE] Resolving base: wrapper_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable wrapper_name not found in any scope
      [LOCAL_RESOLVER] can_resolve(wrapper_name): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(wrapper_name): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(wrapper_name): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(wrapper_name): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(wrapper_name): decorators.wrapper_name
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: wrapper_name -> decorators.wrapper_name
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.wrapper_name
      -> Not module state
      [ATTRIBUTE] Found attribute access: f.__name__
    [RESOLVE] Attempting to resolve: ['f', '__name__']
    [RESOLVE] Chain resolution needed for: ['f', '__name__']
      [CHAIN] Resolving base: f
      [RESOLVE_SIMPLE] Resolving base: f
      [CACHE] Hit for f: decorators.f
      [CHAIN] Base resolved: f -> decorators.f
      [CHAIN] Step 1: Resolving decorators.f.__name__
        [ATTRIBUTE] Resolving attribute: decorators.f.__name__
        [ATTRIBUTE] Direct match found: decorators.f.__name__
      [CHAIN] Step 1 resolved: decorators.f.__name__
    [RESOLVE] RESOLVED to: decorators.f.__name__
      -> Not module state
      [NAME] Found name reference: f
        [CACHE] f -> decorators.f (cached)
      -> Not module state
      [NAME] Found name reference: wrapper_name
        [CACHE] wrapper_name -> decorators.wrapper_name (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: _decorator_registry.decorator_chains
    [RESOLVE] Attempting to resolve: ['_decorator_registry', 'decorator_chains']
    [RESOLVE] Chain resolution needed for: ['_decorator_registry', 'decorator_chains']
      [CHAIN] Resolving base: _decorator_registry
      [RESOLVE_SIMPLE] Resolving base: _decorator_registry
      [CACHE] Hit for _decorator_registry: decorators._decorator_registry
      [CHAIN] Base resolved: _decorator_registry -> decorators._decorator_registry
      [CHAIN] Step 1: Resolving decorators._decorator_registry.decorator_chains
        [ATTRIBUTE] Resolving attribute: decorators._decorator_registry.decorator_chains
        [ATTRIBUTE] Direct match found: decorators._decorator_registry.decorator_chains
      [CHAIN] Step 1 resolved: decorators._decorator_registry.decorator_chains
    [RESOLVE] RESOLVED to: decorators._decorator_registry.decorator_chains
      -> Not module state
      [NAME] Found name reference: _decorator_registry
        [CACHE] _decorator_registry -> decorators._decorator_registry (cached)
      -> Resolved to state: decorators._decorator_registry
      [SYMBOL_LOOKUP] Variable _decorator_registry not found in any scope
      -> ADDED to accessed_state
      [ATTRIBUTE] Found attribute access: _decorator_registry.decorator_chains
        [CACHE] _decorator_registry.decorator_chains -> decorators._decorator_registry.decorator_chains (cached)
      -> Not module state
      [NAME] Found name reference: _decorator_registry
        [CACHE] _decorator_registry -> decorators._decorator_registry (cached)
      -> Resolved to state: decorators._decorator_registry
      [SYMBOL_LOOKUP] Variable _decorator_registry not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: wrapper_name
        [CACHE] wrapper_name -> decorators.wrapper_name (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [ATTRIBUTE] Found attribute access: _decorator_registry.decorator_chains
        [CACHE] _decorator_registry.decorator_chains -> decorators._decorator_registry.decorator_chains (cached)
      -> Not module state
      [NAME] Found name reference: _decorator_registry
        [CACHE] _decorator_registry -> decorators._decorator_registry (cached)
      -> Resolved to state: decorators._decorator_registry
      [SYMBOL_LOOKUP] Variable _decorator_registry not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: wrapper_name
        [CACHE] wrapper_name -> decorators.wrapper_name (cached)
      -> Not module state
      [NAME] Found name reference: wrapper
    [RESOLVE] Attempting to resolve: ['wrapper']
      [RESOLVE_SIMPLE] Resolving base: wrapper
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable wrapper not found in any scope
      [LOCAL_RESOLVER] can_resolve(wrapper): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(wrapper): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(wrapper): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(wrapper): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(wrapper): decorators.wrapper
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: wrapper -> decorators.wrapper
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.wrapper
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable func not found in any scope
      [LOCAL_RESOLVER] can_resolve(func): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(func): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(func): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(func): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(func): decorators.func
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: func -> decorators.func
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.func
      -> Not module state
      [NAME] Found name reference: decorator
    [RESOLVE] Attempting to resolve: ['decorator']
      [RESOLVE_SIMPLE] Resolving base: decorator
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable decorator not found in any scope
      [LOCAL_RESOLVER] can_resolve(decorator): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(decorator): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(decorator): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(decorator): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(decorator): decorators.decorator
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: decorator -> decorators.decorator
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.decorator
      -> Not module state
      [CALL] Found call: decorator
    [CACHE] decorator -> decorators.decorator (cached)
      -> Resolved to: decorators.decorator
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      [NAME] Found name reference: decorator
        [CACHE] decorator -> decorators.decorator (cached)
      -> Not module state
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
    [CONTEXT] Exited function: decorators.trace
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.trace
        Calls: 0
        Instantiations: 0
        State Access: 1
  [FUNCTION] Analyzing function: monitor_performance
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.monitor_performance
    [CONTEXT] Entered function: decorators.monitor_performance (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'func': 'Optional[Callable]'}
      [NESTED_FUNCTION] Analyzing nested function: decorator
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'func': 'Optional[Callable]'}
        [ARG_TYPE] Processing type annotation for f: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Nested: f -> typing.Callable
        [ARG_TYPE] RESOLVED f : typing.Callable
  [FUNCTION] Analyzing function: wrapper
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.wrapper
    [DECORATOR] @wraps(f)
      [CODE_STANDARD_VIOLATION] MISSING_RETURN_TYPE: Function decorators.wrapper
      [IMPACT] Cannot infer return type - chained method calls may fail
      [ACTION_REQUIRED] Add appropriate type annotation
      [CODE_QUALITY] Found 1 violations in decorators.wrapper
    [CONTEXT] Entered function: decorators.wrapper (depth: 2)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [ASSIGNMENT] Processing: start_time = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
      [TYPE_INFERENCE] Call resolved to: time.time
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for start_time
      [NAME] Found name reference: start_time
    [RESOLVE] Attempting to resolve: ['start_time']
      [RESOLVE_SIMPLE] Resolving base: start_time
      [CACHE] Hit for start_time: decorators.start_time
    [RESOLVE] RESOLVED to: decorators.start_time
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: f
    [RESOLVE] Attempting to resolve: ['f']
      [RESOLVE_SIMPLE] Resolving base: f
      [CACHE] Hit for f: decorators.f
    [RESOLVE] RESOLVED to: decorators.f
      [TYPE_INFERENCE] Call resolved to: decorators.f
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for result
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: decorators.result
    [RESOLVE] RESOLVED to: decorators.result
      -> Not module state
      [CALL] Found call: f
    [RESOLVE] Attempting to resolve: ['f']
      [RESOLVE_SIMPLE] Resolving base: f
      [CACHE] Hit for f: decorators.f
    [RESOLVE] RESOLVED to: decorators.f
      -> Resolved to: decorators.f
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: f
        [CACHE] f -> decorators.f (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: decorators.args
    [RESOLVE] RESOLVED to: decorators.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
    [RESOLVE] RESOLVED to: decorators.kwargs
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [ASSIGNMENT] Processing: execution_time = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: execution_time
    [RESOLVE] Attempting to resolve: ['execution_time']
      [RESOLVE_SIMPLE] Resolving base: execution_time
      [CACHE] Hit for execution_time: decorators.execution_time
    [RESOLVE] RESOLVED to: decorators.execution_time
      -> Not module state
      [CALL] Found call: time.time
    [CACHE] time.time -> time.time (cached)
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
        [CACHE] time -> time (cached)
      -> Not module state
      [NAME] Found name reference: start_time
        [CACHE] start_time -> decorators.start_time (cached)
      -> Not module state
      [ASSIGNMENT] Processing: func_name = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: func_name
    [RESOLVE] Attempting to resolve: ['func_name']
      [RESOLVE_SIMPLE] Resolving base: func_name
      [CACHE] Hit for func_name: decorators.func_name
    [RESOLVE] RESOLVED to: decorators.func_name
      -> Not module state
      [ATTRIBUTE] Found attribute access: f.__module__
    [RESOLVE] Attempting to resolve: ['f', '__module__']
    [RESOLVE] Chain resolution needed for: ['f', '__module__']
      [CHAIN] Resolving base: f
      [RESOLVE_SIMPLE] Resolving base: f
      [CACHE] Hit for f: decorators.f
      [CHAIN] Base resolved: f -> decorators.f
      [CHAIN] Step 1: Resolving decorators.f.__module__
        [ATTRIBUTE] Resolving attribute: decorators.f.__module__
        [ATTRIBUTE] Direct match found: decorators.f.__module__
      [CHAIN] Step 1 resolved: decorators.f.__module__
    [RESOLVE] RESOLVED to: decorators.f.__module__
      -> Not module state
      [NAME] Found name reference: f
        [CACHE] f -> decorators.f (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: f.__qualname__
    [RESOLVE] Attempting to resolve: ['f', '__qualname__']
    [RESOLVE] Chain resolution needed for: ['f', '__qualname__']
      [CHAIN] Resolving base: f
      [RESOLVE_SIMPLE] Resolving base: f
      [CACHE] Hit for f: decorators.f
      [CHAIN] Base resolved: f -> decorators.f
      [CHAIN] Step 1: Resolving decorators.f.__qualname__
        [ATTRIBUTE] Resolving attribute: decorators.f.__qualname__
        [ATTRIBUTE] Direct match found: decorators.f.__qualname__
      [CHAIN] Step 1 resolved: decorators.f.__qualname__
    [RESOLVE] RESOLVED to: decorators.f.__qualname__
      -> Not module state
      [NAME] Found name reference: f
        [CACHE] f -> decorators.f (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [NAME] Found name reference: PERFORMANCE_METRICS
    [RESOLVE] Attempting to resolve: ['PERFORMANCE_METRICS']
      [RESOLVE_SIMPLE] Resolving base: PERFORMANCE_METRICS
      [CACHE] Hit for PERFORMANCE_METRICS: decorators.PERFORMANCE_METRICS
    [RESOLVE] RESOLVED to: decorators.PERFORMANCE_METRICS
      -> Resolved to state: decorators.PERFORMANCE_METRICS
      [SYMBOL_LOOKUP] Variable PERFORMANCE_METRICS not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: func_name
        [CACHE] func_name -> decorators.func_name (cached)
      -> Not module state
      [NAME] Found name reference: execution_time
        [CACHE] execution_time -> decorators.execution_time (cached)
      -> Not module state
      [NAME] Found name reference: execution_time
        [CACHE] execution_time -> decorators.execution_time (cached)
      -> Not module state
      [NAME] Found name reference: threshold_ms
    [RESOLVE] Attempting to resolve: ['threshold_ms']
      [RESOLVE_SIMPLE] Resolving base: threshold_ms
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable threshold_ms not found in any scope
      [LOCAL_RESOLVER] can_resolve(threshold_ms): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(threshold_ms): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(threshold_ms): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(threshold_ms): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(threshold_ms): decorators.threshold_ms
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: threshold_ms -> decorators.threshold_ms
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.threshold_ms
      -> Not module state
      [ASSIGNMENT] Processing: warning_msg = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: warning_msg
    [RESOLVE] Attempting to resolve: ['warning_msg']
      [RESOLVE_SIMPLE] Resolving base: warning_msg
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable warning_msg not found in any scope
      [LOCAL_RESOLVER] can_resolve(warning_msg): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(warning_msg): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(warning_msg): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(warning_msg): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(warning_msg): decorators.warning_msg
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: warning_msg -> decorators.warning_msg
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.warning_msg
      -> Not module state
      [NAME] Found name reference: func_name
        [CACHE] func_name -> decorators.func_name (cached)
      -> Not module state
      [NAME] Found name reference: execution_time
        [CACHE] execution_time -> decorators.execution_time (cached)
      -> Not module state
      [CALL] Found call: logging.warning
    [RESOLVE] Attempting to resolve: ['logging', 'warning']
    [RESOLVE] Chain resolution needed for: ['logging', 'warning']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.warning
        [ATTRIBUTE] Resolving attribute: logging.warning
        [ATTRIBUTE] Direct match found: logging.warning
      [CHAIN] Step 1 resolved: logging.warning
    [RESOLVE] RESOLVED to: logging.warning
            [INTERMEDIATE] Tracking chain steps for: logging.warning
            [INTERMEDIATE] Step 1: logging.warning
      -> Resolved to: logging.warning
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: warning_msg
    [RESOLVE] Attempting to resolve: ['warning_msg']
      [RESOLVE_SIMPLE] Resolving base: warning_msg
      [CACHE] Hit for warning_msg: decorators.warning_msg
    [RESOLVE] RESOLVED to: decorators.warning_msg
      [ATTRIBUTE] Found attribute access: logging.warning
        [CACHE] logging.warning -> logging.warning (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [NAME] Found name reference: warning_msg
        [CACHE] warning_msg -> decorators.warning_msg (cached)
      -> Not module state
      [NAME] Found name reference: alert_callback
    [RESOLVE] Attempting to resolve: ['alert_callback']
      [RESOLVE_SIMPLE] Resolving base: alert_callback
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable alert_callback not found in any scope
      [LOCAL_RESOLVER] can_resolve(alert_callback): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(alert_callback): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(alert_callback): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(alert_callback): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(alert_callback): decorators.alert_callback
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: alert_callback -> decorators.alert_callback
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.alert_callback
      -> Not module state
      [CALL] Found call: alert_callback
    [CACHE] alert_callback -> decorators.alert_callback (cached)
      -> Resolved to: decorators.alert_callback
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: func_name
    [RESOLVE] Attempting to resolve: ['func_name']
      [RESOLVE_SIMPLE] Resolving base: func_name
      [CACHE] Hit for func_name: decorators.func_name
    [RESOLVE] RESOLVED to: decorators.func_name
        [FUNCTION_ARG] Checking argument: execution_time
    [RESOLVE] Attempting to resolve: ['execution_time']
      [RESOLVE_SIMPLE] Resolving base: execution_time
      [CACHE] Hit for execution_time: decorators.execution_time
    [RESOLVE] RESOLVED to: decorators.execution_time
        [FUNCTION_ARG] Checking argument: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: decorators.args
    [RESOLVE] RESOLVED to: decorators.args
        [FUNCTION_ARG] Checking argument: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
    [RESOLVE] RESOLVED to: decorators.kwargs
      [NAME] Found name reference: alert_callback
        [CACHE] alert_callback -> decorators.alert_callback (cached)
      -> Not module state
      [NAME] Found name reference: func_name
        [CACHE] func_name -> decorators.func_name (cached)
      -> Not module state
      [NAME] Found name reference: execution_time
        [CACHE] execution_time -> decorators.execution_time (cached)
      -> Not module state
      [NAME] Found name reference: args
        [CACHE] args -> decorators.args (cached)
      -> Not module state
      [NAME] Found name reference: kwargs
        [CACHE] kwargs -> decorators.kwargs (cached)
      -> Not module state
    [CONTEXT] Exited function: decorators.wrapper
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.wrapper
        Calls: 0
        Instantiations: 0
        State Access: 1
      [NAME] Found name reference: wrapper
    [RESOLVE] Attempting to resolve: ['wrapper']
      [RESOLVE_SIMPLE] Resolving base: wrapper
      [CACHE] Hit for wrapper: decorators.wrapper
    [RESOLVE] RESOLVED to: decorators.wrapper
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      -> Not module state
      [NAME] Found name reference: decorator
    [RESOLVE] Attempting to resolve: ['decorator']
      [RESOLVE_SIMPLE] Resolving base: decorator
      [CACHE] Hit for decorator: decorators.decorator
    [RESOLVE] RESOLVED to: decorators.decorator
      -> Not module state
      [CALL] Found call: decorator
    [CACHE] decorator -> decorators.decorator (cached)
      -> Resolved to: decorators.decorator
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      [NAME] Found name reference: decorator
        [CACHE] decorator -> decorators.decorator (cached)
      -> Not module state
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
    [CONTEXT] Exited function: decorators.monitor_performance
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.monitor_performance
        Calls: 0
        Instantiations: 0
        State Access: 0
  [FUNCTION] Analyzing function: validate_auth
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.validate_auth
    [CONTEXT] Entered function: decorators.validate_auth (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'required_role': 'Optional[str]', 'check_session': 'bool'}
        [ARG_TYPE] Processing type annotation for check_session: bool
    [RESOLVE] Attempting to resolve: ['bool']
      [RESOLVE_SIMPLE] Resolving base: bool
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable bool not found in any scope
      [LOCAL_RESOLVER] can_resolve(bool): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(bool): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(bool): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(bool): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(bool): decorators.bool
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: bool -> decorators.bool
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.bool
      [SYMBOL_UPDATE] Function: check_session -> decorators.bool
        [ARG_TYPE] RESOLVED check_session : decorators.bool
      [NESTED_FUNCTION] Analyzing nested function: decorator
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'required_role': 'Optional[str]', 'check_session': 'bool'}
        [ARG_TYPE] Processing type annotation for func: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Nested: func -> typing.Callable
        [ARG_TYPE] RESOLVED func : typing.Callable
  [FUNCTION] Analyzing function: wrapper
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.wrapper
    [DECORATOR] @wraps(func)
      [CODE_STANDARD_VIOLATION] MISSING_RETURN_TYPE: Function decorators.wrapper
      [IMPACT] Cannot infer return type - chained method calls may fail
      [ACTION_REQUIRED] Add appropriate type annotation
      [CODE_QUALITY] Found 1 violations in decorators.wrapper
    [CONTEXT] Entered function: decorators.wrapper (depth: 2)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
    [FROM_IMPORT] get_current_session -> session_manager.get_current_session
    [FROM_IMPORT] get_current_user -> session_manager.get_current_user
      [NAME] Found name reference: check_session
    [RESOLVE] Attempting to resolve: ['check_session']
      [RESOLVE_SIMPLE] Resolving base: check_session
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable check_session not found in any scope
      [LOCAL_RESOLVER] can_resolve(check_session): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(check_session): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(check_session): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(check_session): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(check_session): decorators.check_session
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: check_session -> decorators.check_session
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.check_session
      -> Not module state
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: get_current_session
    [RESOLVE] Attempting to resolve: ['get_current_session']
      [RESOLVE_SIMPLE] Resolving base: get_current_session
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable get_current_session not found in any scope
      [LOCAL_RESOLVER] can_resolve(get_current_session): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(get_current_session): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(get_current_session): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(get_current_session): session_manager.get_current_session (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: get_current_session -> session_manager.get_current_session
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.get_current_session
      [TYPE_INFERENCE] Call resolved to: session_manager.get_current_session
        [RETURN_TYPE_RESOLUTION] Resolving return type: UserSession
        [RETURN_TYPE_RESOLUTION] Found in other module: session_manager.UserSession
      [TYPE_INFERENCE] RESOLVED Inferred type: session_manager.UserSession (from return type)
      [SYMBOL_UPDATE] Function: session -> session_manager.UserSession
        [ASSIGNMENT] RESOLVED Updated symbol table: session = session_manager.UserSession
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found session in function scope: session_manager.UserSession
      [LOCAL_RESOLVER] can_resolve(session): True
      [SYMBOL_LOOKUP] Found session in function scope: session_manager.UserSession
      [LOCAL_RESOLVER] resolve(session): session_manager.UserSession
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: session -> session_manager.UserSession
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: get_current_session
    [RESOLVE] Attempting to resolve: ['get_current_session']
      [RESOLVE_SIMPLE] Resolving base: get_current_session
      [CACHE] Hit for get_current_session: session_manager.get_current_session
    [RESOLVE] RESOLVED to: session_manager.get_current_session
      -> Resolved to: session_manager.get_current_session
      -> ADDED to calls
      [NAME] Found name reference: get_current_session
        [CACHE] get_current_session -> session_manager.get_current_session (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: session.is_valid
    [RESOLVE] Attempting to resolve: ['session', 'is_valid']
    [RESOLVE] Chain resolution needed for: ['session', 'is_valid']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.is_valid
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.is_valid
        [ATTRIBUTE] Direct match found: session_manager.UserSession.is_valid
      [CHAIN] Step 1 resolved: session_manager.UserSession.is_valid
    [RESOLVE] RESOLVED to: session_manager.UserSession.is_valid
            [INTERMEDIATE] Tracking chain steps for: session.is_valid
            [INTERMEDIATE] Step 1: session.is_valid
      -> Resolved to: session_manager.UserSession.is_valid
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session.is_valid
        [CACHE] session.is_valid -> session_manager.UserSession.is_valid (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: PermissionError
    [RESOLVE] Attempting to resolve: ['PermissionError']
      [RESOLVE_SIMPLE] Resolving base: PermissionError
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable PermissionError not found in any scope
      [LOCAL_RESOLVER] can_resolve(PermissionError): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(PermissionError): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(PermissionError): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(PermissionError): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(PermissionError): decorators.PermissionError
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: PermissionError -> decorators.PermissionError
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.PermissionError
      -> Resolved to: decorators.PermissionError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: PermissionError
        [CACHE] PermissionError -> decorators.PermissionError (cached)
      -> Not module state
      [ASSIGNMENT] Processing: user = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: get_current_user
    [RESOLVE] Attempting to resolve: ['get_current_user']
      [RESOLVE_SIMPLE] Resolving base: get_current_user
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable get_current_user not found in any scope
      [LOCAL_RESOLVER] can_resolve(get_current_user): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(get_current_user): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(get_current_user): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(get_current_user): session_manager.get_current_user (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: get_current_user -> session_manager.get_current_user
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.get_current_user
      [TYPE_INFERENCE] Call resolved to: session_manager.get_current_user
        [RETURN_TYPE_RESOLUTION] Resolving return type: Any
        [RETURN_TYPE_RESOLUTION] Class 'Any' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: Any
      [TYPE_INFERENCE] Could not resolve return type 'Any' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: Any (from return type - unresolved)
      [SYMBOL_UPDATE] Function: user -> Any
        [ASSIGNMENT] RESOLVED Updated symbol table: user = Any
      [NAME] Found name reference: user
    [RESOLVE] Attempting to resolve: ['user']
      [RESOLVE_SIMPLE] Resolving base: user
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found user in function scope: Any
      [LOCAL_RESOLVER] can_resolve(user): True
      [SYMBOL_LOOKUP] Found user in function scope: Any
      [LOCAL_RESOLVER] resolve(user): Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: user -> Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: Any
      -> Not module state
      [CALL] Found call: get_current_user
    [RESOLVE] Attempting to resolve: ['get_current_user']
      [RESOLVE_SIMPLE] Resolving base: get_current_user
      [CACHE] Hit for get_current_user: session_manager.get_current_user
    [RESOLVE] RESOLVED to: session_manager.get_current_user
      -> Resolved to: session_manager.get_current_user
      -> ADDED to calls
      [NAME] Found name reference: get_current_user
        [CACHE] get_current_user -> session_manager.get_current_user (cached)
      -> Not module state
      [NAME] Found name reference: user
        [CACHE] user -> Any (cached)
      -> Not module state
      [CALL] Found call: PermissionError
    [CACHE] PermissionError -> decorators.PermissionError (cached)
      -> Resolved to: decorators.PermissionError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: PermissionError
        [CACHE] PermissionError -> decorators.PermissionError (cached)
      -> Not module state
      [NAME] Found name reference: required_role
    [RESOLVE] Attempting to resolve: ['required_role']
      [RESOLVE_SIMPLE] Resolving base: required_role
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable required_role not found in any scope
      [LOCAL_RESOLVER] can_resolve(required_role): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(required_role): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(required_role): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(required_role): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(required_role): decorators.required_role
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: required_role -> decorators.required_role
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.required_role
      -> Not module state
      [CALL] Found call: user.has_role
    [RESOLVE] Attempting to resolve: ['user', 'has_role']
    [RESOLVE] Chain resolution needed for: ['user', 'has_role']
      [CHAIN] Resolving base: user
      [RESOLVE_SIMPLE] Resolving base: user
      [CACHE] Hit for user: Any
      [CHAIN] Base resolved: user -> Any
      [CHAIN] Step 1: Resolving Any.has_role
        [ATTRIBUTE] Resolving attribute: Any.has_role
        [ATTRIBUTE] Direct match found: Any.has_role
      [CHAIN] Step 1 resolved: Any.has_role
    [RESOLVE] RESOLVED to: Any.has_role
            [INTERMEDIATE] Tracking chain steps for: user.has_role
            [INTERMEDIATE] Step 1: user.has_role
      -> Resolved to: Any.has_role
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: required_role
    [RESOLVE] Attempting to resolve: ['required_role']
      [RESOLVE_SIMPLE] Resolving base: required_role
      [CACHE] Hit for required_role: decorators.required_role
    [RESOLVE] RESOLVED to: decorators.required_role
      [ATTRIBUTE] Found attribute access: user.has_role
        [CACHE] user.has_role -> Any.has_role (cached)
      -> Not module state
      [NAME] Found name reference: user
        [CACHE] user -> Any (cached)
      -> Not module state
      [NAME] Found name reference: required_role
        [CACHE] required_role -> decorators.required_role (cached)
      -> Not module state
      [CALL] Found call: PermissionError
    [CACHE] PermissionError -> decorators.PermissionError (cached)
      -> Resolved to: decorators.PermissionError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: PermissionError
        [CACHE] PermissionError -> decorators.PermissionError (cached)
      -> Not module state
      [NAME] Found name reference: required_role
        [CACHE] required_role -> decorators.required_role (cached)
      -> Not module state
      [ASSIGNMENT] Processing: cache_key = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: cache_key
    [RESOLVE] Attempting to resolve: ['cache_key']
      [RESOLVE_SIMPLE] Resolving base: cache_key
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable cache_key not found in any scope
      [LOCAL_RESOLVER] can_resolve(cache_key): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(cache_key): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(cache_key): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(cache_key): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(cache_key): decorators.cache_key
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: cache_key -> decorators.cache_key
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.cache_key
      -> Not module state
      [ATTRIBUTE] Found attribute access: user.id
    [RESOLVE] Attempting to resolve: ['user', 'id']
    [RESOLVE] Chain resolution needed for: ['user', 'id']
      [CHAIN] Resolving base: user
      [RESOLVE_SIMPLE] Resolving base: user
      [CACHE] Hit for user: Any
      [CHAIN] Base resolved: user -> Any
      [CHAIN] Step 1: Resolving Any.id
        [ATTRIBUTE] Resolving attribute: Any.id
        [ATTRIBUTE] Direct match found: Any.id
      [CHAIN] Step 1 resolved: Any.id
    [RESOLVE] RESOLVED to: Any.id
      -> Not module state
      [NAME] Found name reference: user
        [CACHE] user -> Any (cached)
      -> Not module state
      [NAME] Found name reference: required_role
        [CACHE] required_role -> decorators.required_role (cached)
      -> Not module state
      [NAME] Found name reference: AUTH_CACHE
    [RESOLVE] Attempting to resolve: ['AUTH_CACHE']
      [RESOLVE_SIMPLE] Resolving base: AUTH_CACHE
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable AUTH_CACHE not found in any scope
      [LOCAL_RESOLVER] can_resolve(AUTH_CACHE): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(AUTH_CACHE): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(AUTH_CACHE): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(AUTH_CACHE): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(AUTH_CACHE): decorators.AUTH_CACHE
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: AUTH_CACHE -> decorators.AUTH_CACHE
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.AUTH_CACHE
      -> Resolved to state: decorators.AUTH_CACHE
      [SYMBOL_LOOKUP] Variable AUTH_CACHE not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> decorators.cache_key (cached)
      -> Not module state
      [CALL] Found call: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      -> Resolved to: decorators.func
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: decorators.args
    [RESOLVE] RESOLVED to: decorators.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
    [RESOLVE] RESOLVED to: decorators.kwargs
      -> Not module state
    [CONTEXT] Exited function: decorators.wrapper
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.wrapper
        Calls: 3
        Instantiations: 0
        State Access: 1
      [NAME] Found name reference: wrapper
    [RESOLVE] Attempting to resolve: ['wrapper']
      [RESOLVE_SIMPLE] Resolving base: wrapper
      [CACHE] Hit for wrapper: decorators.wrapper
    [RESOLVE] RESOLVED to: decorators.wrapper
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: decorator
    [RESOLVE] Attempting to resolve: ['decorator']
      [RESOLVE_SIMPLE] Resolving base: decorator
      [CACHE] Hit for decorator: decorators.decorator
    [RESOLVE] RESOLVED to: decorators.decorator
      -> Not module state
    [CONTEXT] Exited function: decorators.validate_auth
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.validate_auth
        Calls: 0
        Instantiations: 0
        State Access: 0
  [FUNCTION] Analyzing function: rate_limit
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.rate_limit
    [CONTEXT] Entered function: decorators.rate_limit (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 4 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'calls': 'int', 'period': 'int', 'per_user': 'bool', 'key_func': 'Optional[Callable]'}
        [ARG_TYPE] Processing type annotation for calls: int
    [RESOLVE] Attempting to resolve: ['int']
      [RESOLVE_SIMPLE] Resolving base: int
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable int not found in any scope
      [LOCAL_RESOLVER] can_resolve(int): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(int): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(int): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(int): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(int): decorators.int
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: int -> decorators.int
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.int
      [SYMBOL_UPDATE] Function: calls -> decorators.int
        [ARG_TYPE] RESOLVED calls : decorators.int
        [ARG_TYPE] Processing type annotation for period: int
        [CACHE] int -> decorators.int (cached)
      [SYMBOL_UPDATE] Function: period -> decorators.int
        [ARG_TYPE] RESOLVED period : decorators.int
        [ARG_TYPE] Processing type annotation for per_user: bool
    [RESOLVE] Attempting to resolve: ['bool']
      [RESOLVE_SIMPLE] Resolving base: bool
      [CACHE] Hit for bool: decorators.bool
    [RESOLVE] RESOLVED to: decorators.bool
      [SYMBOL_UPDATE] Function: per_user -> decorators.bool
        [ARG_TYPE] RESOLVED per_user : decorators.bool
      [NESTED_FUNCTION] Analyzing nested function: decorator
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'calls': 'int', 'period': 'int', 'per_user': 'bool', 'key_func': 'Optional[Callable]'}
        [ARG_TYPE] Processing type annotation for func: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Nested: func -> typing.Callable
        [ARG_TYPE] RESOLVED func : typing.Callable
  [FUNCTION] Analyzing function: wrapper
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.wrapper
    [DECORATOR] @wraps(func)
      [CODE_STANDARD_VIOLATION] MISSING_RETURN_TYPE: Function decorators.wrapper
      [IMPACT] Cannot infer return type - chained method calls may fail
      [ACTION_REQUIRED] Add appropriate type annotation
      [CODE_QUALITY] Found 1 violations in decorators.wrapper
    [CONTEXT] Entered function: decorators.wrapper (depth: 2)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [NAME] Found name reference: key_func
    [RESOLVE] Attempting to resolve: ['key_func']
      [RESOLVE_SIMPLE] Resolving base: key_func
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable key_func not found in any scope
      [LOCAL_RESOLVER] can_resolve(key_func): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(key_func): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(key_func): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(key_func): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(key_func): decorators.key_func
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: key_func -> decorators.key_func
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.key_func
      -> Not module state
      [ASSIGNMENT] Processing: rate_key = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: key_func
    [RESOLVE] Attempting to resolve: ['key_func']
      [RESOLVE_SIMPLE] Resolving base: key_func
      [CACHE] Hit for key_func: decorators.key_func
    [RESOLVE] RESOLVED to: decorators.key_func
      [TYPE_INFERENCE] Call resolved to: decorators.key_func
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for rate_key
      [NAME] Found name reference: rate_key
    [RESOLVE] Attempting to resolve: ['rate_key']
      [RESOLVE_SIMPLE] Resolving base: rate_key
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable rate_key not found in any scope
      [LOCAL_RESOLVER] can_resolve(rate_key): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(rate_key): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(rate_key): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(rate_key): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(rate_key): decorators.rate_key
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: rate_key -> decorators.rate_key
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.rate_key
      -> Not module state
      [CALL] Found call: key_func
    [CACHE] key_func -> decorators.key_func (cached)
      -> Resolved to: decorators.key_func
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: key_func
        [CACHE] key_func -> decorators.key_func (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: decorators.args
    [RESOLVE] RESOLVED to: decorators.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
    [RESOLVE] RESOLVED to: decorators.kwargs
      -> Not module state
      [NAME] Found name reference: per_user
    [RESOLVE] Attempting to resolve: ['per_user']
      [RESOLVE_SIMPLE] Resolving base: per_user
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable per_user not found in any scope
      [LOCAL_RESOLVER] can_resolve(per_user): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(per_user): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(per_user): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(per_user): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(per_user): decorators.per_user
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: per_user -> decorators.per_user
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.per_user
      -> Not module state
    [FROM_IMPORT] get_current_user_id -> session_manager.get_current_user_id
      [ASSIGNMENT] Processing: user_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: get_current_user_id
    [RESOLVE] Attempting to resolve: ['get_current_user_id']
      [RESOLVE_SIMPLE] Resolving base: get_current_user_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable get_current_user_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(get_current_user_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(get_current_user_id): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(get_current_user_id): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(get_current_user_id): session_manager.get_current_user_id (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: get_current_user_id -> session_manager.get_current_user_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.get_current_user_id
      [TYPE_INFERENCE] Call resolved to: session_manager.get_current_user_id
        [RETURN_TYPE_RESOLUTION] Resolving return type: str
        [RETURN_TYPE_RESOLUTION] Class 'str' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: str
      [TYPE_INFERENCE] Could not resolve return type 'str' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: str (from return type - unresolved)
      [SYMBOL_UPDATE] Function: user_id -> str
        [ASSIGNMENT] RESOLVED Updated symbol table: user_id = str
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found user_id in function scope: str
      [LOCAL_RESOLVER] can_resolve(user_id): True
      [SYMBOL_LOOKUP] Found user_id in function scope: str
      [LOCAL_RESOLVER] resolve(user_id): str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: user_id -> str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: str
      -> Not module state
      [CALL] Found call: get_current_user_id
    [RESOLVE] Attempting to resolve: ['get_current_user_id']
      [RESOLVE_SIMPLE] Resolving base: get_current_user_id
      [CACHE] Hit for get_current_user_id: session_manager.get_current_user_id
    [RESOLVE] RESOLVED to: session_manager.get_current_user_id
      -> Resolved to: session_manager.get_current_user_id
      -> ADDED to calls
      [NAME] Found name reference: get_current_user_id
        [CACHE] get_current_user_id -> session_manager.get_current_user_id (cached)
      -> Not module state
      [ASSIGNMENT] Processing: rate_key = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: rate_key
        [CACHE] rate_key -> decorators.rate_key (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: func.__name__
    [RESOLVE] Attempting to resolve: ['func', '__name__']
    [RESOLVE] Chain resolution needed for: ['func', '__name__']
      [CHAIN] Resolving base: func
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
      [CHAIN] Base resolved: func -> decorators.func
      [CHAIN] Step 1: Resolving decorators.func.__name__
        [ATTRIBUTE] Resolving attribute: decorators.func.__name__
        [ATTRIBUTE] Direct match found: decorators.func.__name__
      [CHAIN] Step 1 resolved: decorators.func.__name__
    [RESOLVE] RESOLVED to: decorators.func.__name__
      -> Not module state
      [NAME] Found name reference: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> str (cached)
      -> Not module state
      [ASSIGNMENT] Processing: rate_key = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: rate_key
        [CACHE] rate_key -> decorators.rate_key (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: func.__name__
        [CACHE] func.__name__ -> decorators.func.__name__ (cached)
      -> Not module state
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
      [ASSIGNMENT] Processing: current_time = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
      [TYPE_INFERENCE] Call resolved to: time.time
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for current_time
      [NAME] Found name reference: current_time
    [RESOLVE] Attempting to resolve: ['current_time']
      [RESOLVE_SIMPLE] Resolving base: current_time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable current_time not found in any scope
      [LOCAL_RESOLVER] can_resolve(current_time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(current_time): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(current_time): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(current_time): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(current_time): decorators.current_time
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: current_time -> decorators.current_time
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.current_time
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [NAME] Found name reference: rate_key
        [CACHE] rate_key -> decorators.rate_key (cached)
      -> Not module state
      [NAME] Found name reference: RATE_LIMIT_CACHE
    [RESOLVE] Attempting to resolve: ['RATE_LIMIT_CACHE']
      [RESOLVE_SIMPLE] Resolving base: RATE_LIMIT_CACHE
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable RATE_LIMIT_CACHE not found in any scope
      [LOCAL_RESOLVER] can_resolve(RATE_LIMIT_CACHE): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(RATE_LIMIT_CACHE): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(RATE_LIMIT_CACHE): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(RATE_LIMIT_CACHE): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(RATE_LIMIT_CACHE): decorators.RATE_LIMIT_CACHE
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: RATE_LIMIT_CACHE -> decorators.RATE_LIMIT_CACHE
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.RATE_LIMIT_CACHE
      -> Resolved to state: decorators.RATE_LIMIT_CACHE
      [SYMBOL_LOOKUP] Variable RATE_LIMIT_CACHE not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: RATE_LIMIT_CACHE
        [CACHE] RATE_LIMIT_CACHE -> decorators.RATE_LIMIT_CACHE (cached)
      -> Resolved to state: decorators.RATE_LIMIT_CACHE
      [SYMBOL_LOOKUP] Variable RATE_LIMIT_CACHE not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: rate_key
        [CACHE] rate_key -> decorators.rate_key (cached)
      -> Not module state
      [ASSIGNMENT] Processing: cache_entry = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: cache_entry
    [RESOLVE] Attempting to resolve: ['cache_entry']
      [RESOLVE_SIMPLE] Resolving base: cache_entry
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable cache_entry not found in any scope
      [LOCAL_RESOLVER] can_resolve(cache_entry): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(cache_entry): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(cache_entry): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(cache_entry): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(cache_entry): decorators.cache_entry
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: cache_entry -> decorators.cache_entry
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.cache_entry
      -> Not module state
      [NAME] Found name reference: RATE_LIMIT_CACHE
        [CACHE] RATE_LIMIT_CACHE -> decorators.RATE_LIMIT_CACHE (cached)
      -> Resolved to state: decorators.RATE_LIMIT_CACHE
      [SYMBOL_LOOKUP] Variable RATE_LIMIT_CACHE not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: rate_key
        [CACHE] rate_key -> decorators.rate_key (cached)
      -> Not module state
      [NAME] Found name reference: cache_entry
        [CACHE] cache_entry -> decorators.cache_entry (cached)
      -> Not module state
      [NAME] Found name reference: call_time
    [RESOLVE] Attempting to resolve: ['call_time']
      [RESOLVE_SIMPLE] Resolving base: call_time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable call_time not found in any scope
      [LOCAL_RESOLVER] can_resolve(call_time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(call_time): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(call_time): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(call_time): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(call_time): decorators.call_time
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: call_time -> decorators.call_time
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.call_time
      -> Not module state
      [NAME] Found name reference: call_time
        [CACHE] call_time -> decorators.call_time (cached)
      -> Not module state
      [NAME] Found name reference: cache_entry
        [CACHE] cache_entry -> decorators.cache_entry (cached)
      -> Not module state
      [NAME] Found name reference: current_time
        [CACHE] current_time -> decorators.current_time (cached)
      -> Not module state
      [NAME] Found name reference: call_time
        [CACHE] call_time -> decorators.call_time (cached)
      -> Not module state
      [NAME] Found name reference: period
    [RESOLVE] Attempting to resolve: ['period']
      [RESOLVE_SIMPLE] Resolving base: period
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable period not found in any scope
      [LOCAL_RESOLVER] can_resolve(period): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(period): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(period): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(period): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(period): decorators.period
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: period -> decorators.period
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.period
      -> Not module state
      [NAME] Found name reference: current_time
        [CACHE] current_time -> decorators.current_time (cached)
      -> Not module state
      [NAME] Found name reference: cache_entry
        [CACHE] cache_entry -> decorators.cache_entry (cached)
      -> Not module state
      [CALL] Found call: RuntimeError
    [RESOLVE] Attempting to resolve: ['RuntimeError']
      [RESOLVE_SIMPLE] Resolving base: RuntimeError
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable RuntimeError not found in any scope
      [LOCAL_RESOLVER] can_resolve(RuntimeError): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(RuntimeError): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(RuntimeError): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(RuntimeError): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(RuntimeError): decorators.RuntimeError
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: RuntimeError -> decorators.RuntimeError
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.RuntimeError
      -> Resolved to: decorators.RuntimeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: RuntimeError
        [CACHE] RuntimeError -> decorators.RuntimeError (cached)
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(len): decorators.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> decorators.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.len
      -> Not module state
      [NAME] Found name reference: cache_entry
        [CACHE] cache_entry -> decorators.cache_entry (cached)
      -> Not module state
      [NAME] Found name reference: calls
    [RESOLVE] Attempting to resolve: ['calls']
      [RESOLVE_SIMPLE] Resolving base: calls
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable calls not found in any scope
      [LOCAL_RESOLVER] can_resolve(calls): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(calls): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(calls): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(calls): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(calls): decorators.calls
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: calls -> decorators.calls
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.calls
      -> Not module state
      [NAME] Found name reference: cache_entry
        [CACHE] cache_entry -> decorators.cache_entry (cached)
      -> Not module state
      [NAME] Found name reference: current_time
        [CACHE] current_time -> decorators.current_time (cached)
      -> Not module state
      [NAME] Found name reference: period
        [CACHE] period -> decorators.period (cached)
      -> Not module state
      [CALL] Found call: RuntimeError
    [CACHE] RuntimeError -> decorators.RuntimeError (cached)
      -> Resolved to: decorators.RuntimeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: RuntimeError
        [CACHE] RuntimeError -> decorators.RuntimeError (cached)
      -> Not module state
      [NAME] Found name reference: calls
        [CACHE] calls -> decorators.calls (cached)
      -> Not module state
      [NAME] Found name reference: period
        [CACHE] period -> decorators.period (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [NAME] Found name reference: cache_entry
        [CACHE] cache_entry -> decorators.cache_entry (cached)
      -> Not module state
      [NAME] Found name reference: current_time
        [CACHE] current_time -> decorators.current_time (cached)
      -> Not module state
      [CALL] Found call: func
    [CACHE] func -> decorators.func (cached)
      -> Resolved to: decorators.func
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
      [NAME] Found name reference: args
        [CACHE] args -> decorators.args (cached)
      -> Not module state
      [NAME] Found name reference: kwargs
        [CACHE] kwargs -> decorators.kwargs (cached)
      -> Not module state
    [CONTEXT] Exited function: decorators.wrapper
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.wrapper
        Calls: 1
        Instantiations: 0
        State Access: 1
      [NAME] Found name reference: wrapper
    [RESOLVE] Attempting to resolve: ['wrapper']
      [RESOLVE_SIMPLE] Resolving base: wrapper
      [CACHE] Hit for wrapper: decorators.wrapper
    [RESOLVE] RESOLVED to: decorators.wrapper
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: decorator
    [RESOLVE] Attempting to resolve: ['decorator']
      [RESOLVE_SIMPLE] Resolving base: decorator
      [CACHE] Hit for decorator: decorators.decorator
    [RESOLVE] RESOLVED to: decorators.decorator
      -> Not module state
    [CONTEXT] Exited function: decorators.rate_limit
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.rate_limit
        Calls: 0
        Instantiations: 0
        State Access: 0
  [CLASS] Analyzing class: ClassBasedDecorator
    [CONTEXT] Entered class: decorators.ClassBasedDecorator
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.ClassBasedDecorator.__init__
    [CONTEXT] Entered function: decorators.ClassBasedDecorator.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'config': 'Dict[str, Any]'}
      [ATTRIBUTE] Found attribute access: self.config
    [RESOLVE] Attempting to resolve: ['self', 'config']
    [RESOLVE] Chain resolution needed for: ['self', 'config']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: decorators.ClassBasedDecorator)
      [SELF_RESOLVER] resolve(self): decorators.ClassBasedDecorator
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> decorators.ClassBasedDecorator
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> decorators.ClassBasedDecorator
      [CHAIN] Step 1: Resolving decorators.ClassBasedDecorator.config
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator.config
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator.config
      [CHAIN] Step 1 resolved: decorators.ClassBasedDecorator.config
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator.config
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator
      -> Not module state
      [NAME] Found name reference: config
    [RESOLVE] Attempting to resolve: ['config']
      [RESOLVE_SIMPLE] Resolving base: config
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable config not found in any scope
      [LOCAL_RESOLVER] can_resolve(config): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(config): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(config): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(config): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(config): decorators.config
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: config -> decorators.config
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.config
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.call_count
    [RESOLVE] Attempting to resolve: ['self', 'call_count']
    [RESOLVE] Chain resolution needed for: ['self', 'call_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
      [CHAIN] Base resolved: self -> decorators.ClassBasedDecorator
      [CHAIN] Step 1: Resolving decorators.ClassBasedDecorator.call_count
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator.call_count
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator.call_count
      [CHAIN] Step 1 resolved: decorators.ClassBasedDecorator.call_count
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator.call_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.ClassBasedDecorator (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.last_call_time
    [RESOLVE] Attempting to resolve: ['self', 'last_call_time']
    [RESOLVE] Chain resolution needed for: ['self', 'last_call_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
      [CHAIN] Base resolved: self -> decorators.ClassBasedDecorator
      [CHAIN] Step 1: Resolving decorators.ClassBasedDecorator.last_call_time
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator.last_call_time
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator.last_call_time
      [CHAIN] Step 1 resolved: decorators.ClassBasedDecorator.last_call_time
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator.last_call_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.ClassBasedDecorator (cached)
      -> Not module state
    [CONTEXT] Exited function: decorators.ClassBasedDecorator.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.ClassBasedDecorator.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.ClassBasedDecorator.__call__
    [CONTEXT] Entered function: decorators.ClassBasedDecorator.__call__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'func': 'Callable'}
        [ARG_TYPE] Processing type annotation for func: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Callable not found in any scope
      [LOCAL_RESOLVER] can_resolve(Callable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Callable): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Callable): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Callable): typing.Callable (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Callable -> typing.Callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Function: func -> typing.Callable
        [ARG_TYPE] RESOLVED func : typing.Callable
      [NESTED_FUNCTION] Analyzing nested function: wrapper
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 0 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'func': 'Callable'}
      [ATTRIBUTE] Found attribute access: self.call_count
    [RESOLVE] Attempting to resolve: ['self', 'call_count']
    [RESOLVE] Chain resolution needed for: ['self', 'call_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
      [CHAIN] Base resolved: self -> decorators.ClassBasedDecorator
      [CHAIN] Step 1: Resolving decorators.ClassBasedDecorator.call_count
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator.call_count
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator.call_count
      [CHAIN] Step 1 resolved: decorators.ClassBasedDecorator.call_count
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator.call_count
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.last_call_time
    [RESOLVE] Attempting to resolve: ['self', 'last_call_time']
    [RESOLVE] Chain resolution needed for: ['self', 'last_call_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
      [CHAIN] Base resolved: self -> decorators.ClassBasedDecorator
      [CHAIN] Step 1: Resolving decorators.ClassBasedDecorator.last_call_time
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator.last_call_time
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator.last_call_time
      [CHAIN] Step 1 resolved: decorators.ClassBasedDecorator.last_call_time
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator.last_call_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.ClassBasedDecorator (cached)
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable time not found in any scope
      [LOCAL_RESOLVER] can_resolve(time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(time): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(time): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(time): time (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: time -> time
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [CALL] Found call: self.config.get
    [RESOLVE] Attempting to resolve: ['self', 'config', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'config', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
      [CHAIN] Base resolved: self -> decorators.ClassBasedDecorator
      [CHAIN] Step 1: Resolving decorators.ClassBasedDecorator.config
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator.config
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator.config
      [CHAIN] Step 1 resolved: decorators.ClassBasedDecorator.config
      [CHAIN] Step 2: Resolving decorators.ClassBasedDecorator.config.get
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator.config.get
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator.config.get
      [CHAIN] Step 2 resolved: decorators.ClassBasedDecorator.config.get
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator.config.get
            [INTERMEDIATE] Tracking chain steps for: self.config.get
            [INTERMEDIATE] Step 1: self.config
    [RESOLVE] Attempting to resolve: ['self', 'config']
    [RESOLVE] Chain resolution needed for: ['self', 'config']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
      [CHAIN] Base resolved: self -> decorators.ClassBasedDecorator
      [CHAIN] Step 1: Resolving decorators.ClassBasedDecorator.config
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator.config
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator.config
      [CHAIN] Step 1 resolved: decorators.ClassBasedDecorator.config
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator.config
            [INTERMEDIATE] Step 1 resolved to: decorators.ClassBasedDecorator.config
            [INTERMEDIATE] Step 2: self.config.get
      -> Resolved to: decorators.ClassBasedDecorator.config.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.config.get
        [CACHE] self.config.get -> decorators.ClassBasedDecorator.config.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.config
        [CACHE] self.config -> decorators.ClassBasedDecorator.config (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.ClassBasedDecorator (cached)
      -> Not module state
      [CALL] Found call: logging.info
    [RESOLVE] Attempting to resolve: ['logging', 'info']
    [RESOLVE] Chain resolution needed for: ['logging', 'info']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable logging not found in any scope
      [LOCAL_RESOLVER] can_resolve(logging): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(logging): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(logging): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(logging): logging (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: logging -> logging
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.info
        [ATTRIBUTE] Resolving attribute: logging.info
        [ATTRIBUTE] Direct match found: logging.info
      [CHAIN] Step 1 resolved: logging.info
    [RESOLVE] RESOLVED to: logging.info
            [INTERMEDIATE] Tracking chain steps for: logging.info
            [INTERMEDIATE] Step 1: logging.info
      -> Resolved to: logging.info
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.info
        [CACHE] logging.info -> logging.info (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [ATTRIBUTE] Found attribute access: func.__name__
    [RESOLVE] Attempting to resolve: ['func', '__name__']
    [RESOLVE] Chain resolution needed for: ['func', '__name__']
      [CHAIN] Resolving base: func
      [RESOLVE_SIMPLE] Resolving base: func
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found func in function scope: typing.Callable
      [LOCAL_RESOLVER] can_resolve(func): True
      [SYMBOL_LOOKUP] Found func in function scope: typing.Callable
      [LOCAL_RESOLVER] resolve(func): typing.Callable
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: func -> typing.Callable
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: func -> typing.Callable
      [CHAIN] Step 1: Resolving typing.Callable.__name__
        [ATTRIBUTE] Resolving attribute: typing.Callable.__name__
        [ATTRIBUTE] Direct match found: typing.Callable.__name__
      [CHAIN] Step 1 resolved: typing.Callable.__name__
    [RESOLVE] RESOLVED to: typing.Callable.__name__
      -> Not module state
      [NAME] Found name reference: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.call_count
        [CACHE] self.call_count -> decorators.ClassBasedDecorator.call_count (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.ClassBasedDecorator (cached)
      -> Not module state
      [CALL] Found call: self.config.get
    [CACHE] self.config.get -> decorators.ClassBasedDecorator.config.get (cached)
            [INTERMEDIATE] Tracking chain steps for: self.config.get
            [INTERMEDIATE] Step 1: self.config
    [CACHE] self.config -> decorators.ClassBasedDecorator.config (cached)
            [INTERMEDIATE] Step 1 resolved to: decorators.ClassBasedDecorator.config
            [INTERMEDIATE] Step 2: self.config.get
      -> Resolved to: decorators.ClassBasedDecorator.config.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.config.get
        [CACHE] self.config.get -> decorators.ClassBasedDecorator.config.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.config
        [CACHE] self.config -> decorators.ClassBasedDecorator.config (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.ClassBasedDecorator (cached)
      -> Not module state
      [CALL] Found call: self._validate_arguments
    [RESOLVE] Attempting to resolve: ['self', '_validate_arguments']
    [RESOLVE] Chain resolution needed for: ['self', '_validate_arguments']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
      [CHAIN] Base resolved: self -> decorators.ClassBasedDecorator
      [CHAIN] Step 1: Resolving decorators.ClassBasedDecorator._validate_arguments
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator._validate_arguments
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator._validate_arguments
      [CHAIN] Step 1 resolved: decorators.ClassBasedDecorator._validate_arguments
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator._validate_arguments
            [INTERMEDIATE] Tracking chain steps for: self._validate_arguments
            [INTERMEDIATE] Step 1: self._validate_arguments
      -> Resolved to: decorators.ClassBasedDecorator._validate_arguments
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
        [FUNCTION_ARG] Checking argument: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable args not found in any scope
      [LOCAL_RESOLVER] can_resolve(args): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(args): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(args): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(args): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(args): decorators.args
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: args -> decorators.args
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.args
        [FUNCTION_ARG] Checking argument: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable kwargs not found in any scope
      [LOCAL_RESOLVER] can_resolve(kwargs): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(kwargs): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(kwargs): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(kwargs): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(kwargs): decorators.kwargs
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: kwargs -> decorators.kwargs
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.kwargs
      [ATTRIBUTE] Found attribute access: self._validate_arguments
        [CACHE] self._validate_arguments -> decorators.ClassBasedDecorator._validate_arguments (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.ClassBasedDecorator (cached)
      -> Not module state
      [NAME] Found name reference: func
        [CACHE] func -> typing.Callable (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: decorators.args
    [RESOLVE] RESOLVED to: decorators.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
    [RESOLVE] RESOLVED to: decorators.kwargs
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [TYPE_INFERENCE] Call resolved to: typing.Callable
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for result
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable result not found in any scope
      [LOCAL_RESOLVER] can_resolve(result): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(result): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(result): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(result): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(result): decorators.result
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: result -> decorators.result
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.result
      -> Not module state
      [CALL] Found call: func
    [CACHE] func -> typing.Callable (cached)
      -> Resolved to: typing.Callable
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: func
        [CACHE] func -> typing.Callable (cached)
      -> Not module state
      [NAME] Found name reference: args
        [CACHE] args -> decorators.args (cached)
      -> Not module state
      [NAME] Found name reference: kwargs
        [CACHE] kwargs -> decorators.kwargs (cached)
      -> Not module state
      [CALL] Found call: self.config.get
    [CACHE] self.config.get -> decorators.ClassBasedDecorator.config.get (cached)
            [INTERMEDIATE] Tracking chain steps for: self.config.get
            [INTERMEDIATE] Step 1: self.config
    [CACHE] self.config -> decorators.ClassBasedDecorator.config (cached)
            [INTERMEDIATE] Step 1 resolved to: decorators.ClassBasedDecorator.config
            [INTERMEDIATE] Step 2: self.config.get
      -> Resolved to: decorators.ClassBasedDecorator.config.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.config.get
        [CACHE] self.config.get -> decorators.ClassBasedDecorator.config.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.config
        [CACHE] self.config -> decorators.ClassBasedDecorator.config (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.ClassBasedDecorator (cached)
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self._transform_result
    [RESOLVE] Attempting to resolve: ['self', '_transform_result']
    [RESOLVE] Chain resolution needed for: ['self', '_transform_result']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
      [CHAIN] Base resolved: self -> decorators.ClassBasedDecorator
      [CHAIN] Step 1: Resolving decorators.ClassBasedDecorator._transform_result
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator._transform_result
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator._transform_result
      [CHAIN] Step 1 resolved: decorators.ClassBasedDecorator._transform_result
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator._transform_result
      [TYPE_INFERENCE] Call resolved to: decorators.ClassBasedDecorator._transform_result
        [RETURN_TYPE_RESOLUTION] Resolving return type: Any
        [RETURN_TYPE_RESOLUTION] Class 'Any' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: Any
      [TYPE_INFERENCE] Could not resolve return type 'Any' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: Any (from return type - unresolved)
      [SYMBOL_UPDATE] Nested: result -> Any
        [ASSIGNMENT] RESOLVED Updated symbol table: result = Any
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [CALL] Found call: self._transform_result
    [RESOLVE] Attempting to resolve: ['self', '_transform_result']
    [RESOLVE] Chain resolution needed for: ['self', '_transform_result']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
      [CHAIN] Base resolved: self -> decorators.ClassBasedDecorator
      [CHAIN] Step 1: Resolving decorators.ClassBasedDecorator._transform_result
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator._transform_result
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator._transform_result
      [CHAIN] Step 1 resolved: decorators.ClassBasedDecorator._transform_result
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator._transform_result
            [INTERMEDIATE] Tracking chain steps for: self._transform_result
            [INTERMEDIATE] Step 1: self._transform_result
      -> Resolved to: decorators.ClassBasedDecorator._transform_result
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: decorators.result
    [RESOLVE] RESOLVED to: decorators.result
      [ATTRIBUTE] Found attribute access: self._transform_result
        [CACHE] self._transform_result -> decorators.ClassBasedDecorator._transform_result (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.ClassBasedDecorator (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Exception not found in any scope
      [LOCAL_RESOLVER] can_resolve(Exception): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Exception): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Exception): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(Exception): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(Exception): decorators.Exception
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: Exception -> decorators.Exception
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.Exception
      -> Not module state
      [CALL] Found call: self.config.get
    [CACHE] self.config.get -> decorators.ClassBasedDecorator.config.get (cached)
            [INTERMEDIATE] Tracking chain steps for: self.config.get
            [INTERMEDIATE] Step 1: self.config
    [CACHE] self.config -> decorators.ClassBasedDecorator.config (cached)
            [INTERMEDIATE] Step 1 resolved to: decorators.ClassBasedDecorator.config
            [INTERMEDIATE] Step 2: self.config.get
      -> Resolved to: decorators.ClassBasedDecorator.config.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.config.get
        [CACHE] self.config.get -> decorators.ClassBasedDecorator.config.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.config
        [CACHE] self.config -> decorators.ClassBasedDecorator.config (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.ClassBasedDecorator (cached)
      -> Not module state
      [CALL] Found call: logging.error
    [RESOLVE] Attempting to resolve: ['logging', 'error']
    [RESOLVE] Chain resolution needed for: ['logging', 'error']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.error
        [ATTRIBUTE] Resolving attribute: logging.error
        [ATTRIBUTE] Direct match found: logging.error
      [CHAIN] Step 1 resolved: logging.error
    [RESOLVE] RESOLVED to: logging.error
            [INTERMEDIATE] Tracking chain steps for: logging.error
            [INTERMEDIATE] Step 1: logging.error
      -> Resolved to: logging.error
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.error
        [CACHE] logging.error -> logging.error (cached)
      -> Not module state
      [NAME] Found name reference: logging
        [CACHE] logging -> logging (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: func.__name__
        [CACHE] func.__name__ -> typing.Callable.__name__ (cached)
      -> Not module state
      [NAME] Found name reference: func
        [CACHE] func -> typing.Callable (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable e not found in any scope
      [LOCAL_RESOLVER] can_resolve(e): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(e): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(e): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(e): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(e): decorators.e
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: e -> decorators.e
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.e
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: wrapper
    [RESOLVE] Attempting to resolve: ['wrapper']
      [RESOLVE_SIMPLE] Resolving base: wrapper
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable wrapper not found in any scope
      [LOCAL_RESOLVER] can_resolve(wrapper): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(wrapper): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(wrapper): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(wrapper): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(wrapper): decorators.wrapper
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: wrapper -> decorators.wrapper
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.wrapper
      -> Not module state
    [CONTEXT] Exited function: decorators.ClassBasedDecorator.__call__
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.ClassBasedDecorator.__call__
        Calls: 2
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.ClassBasedDecorator._validate_arguments
    [CONTEXT] Entered function: decorators.ClassBasedDecorator._validate_arguments (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 4 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'func': 'Callable', 'args': 'tuple', 'kwargs': 'dict'}
        [ARG_TYPE] Processing type annotation for func: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Function: func -> typing.Callable
        [ARG_TYPE] RESOLVED func : typing.Callable
        [ARG_TYPE] Processing type annotation for args: tuple
    [RESOLVE] Attempting to resolve: ['tuple']
      [RESOLVE_SIMPLE] Resolving base: tuple
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable tuple not found in any scope
      [LOCAL_RESOLVER] can_resolve(tuple): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(tuple): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(tuple): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(tuple): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(tuple): decorators.tuple
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: tuple -> decorators.tuple
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.tuple
      [SYMBOL_UPDATE] Function: args -> decorators.tuple
        [ARG_TYPE] RESOLVED args : decorators.tuple
        [ARG_TYPE] Processing type annotation for kwargs: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(dict): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(dict): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(dict): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(dict): decorators.dict
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: dict -> decorators.dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.dict
      [SYMBOL_UPDATE] Function: kwargs -> decorators.dict
        [ARG_TYPE] RESOLVED kwargs : decorators.dict
      [ASSIGNMENT] Processing: sig = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: inspect.signature
    [RESOLVE] Attempting to resolve: ['inspect', 'signature']
    [RESOLVE] Chain resolution needed for: ['inspect', 'signature']
      [CHAIN] Resolving base: inspect
      [RESOLVE_SIMPLE] Resolving base: inspect
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable inspect not found in any scope
      [LOCAL_RESOLVER] can_resolve(inspect): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(inspect): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(inspect): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(inspect): inspect (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: inspect -> inspect
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: inspect -> inspect
      [CHAIN] Step 1: Resolving inspect.signature
        [ATTRIBUTE] Resolving attribute: inspect.signature
        [ATTRIBUTE] Direct match found: inspect.signature
      [CHAIN] Step 1 resolved: inspect.signature
    [RESOLVE] RESOLVED to: inspect.signature
      [TYPE_INFERENCE] Call resolved to: inspect.signature
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for sig
      [NAME] Found name reference: sig
    [RESOLVE] Attempting to resolve: ['sig']
      [RESOLVE_SIMPLE] Resolving base: sig
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable sig not found in any scope
      [LOCAL_RESOLVER] can_resolve(sig): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(sig): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(sig): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(sig): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(sig): decorators.sig
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: sig -> decorators.sig
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.sig
      -> Not module state
      [CALL] Found call: inspect.signature
    [RESOLVE] Attempting to resolve: ['inspect', 'signature']
    [RESOLVE] Chain resolution needed for: ['inspect', 'signature']
      [CHAIN] Resolving base: inspect
      [RESOLVE_SIMPLE] Resolving base: inspect
      [CACHE] Hit for inspect: inspect
      [CHAIN] Base resolved: inspect -> inspect
      [CHAIN] Step 1: Resolving inspect.signature
        [ATTRIBUTE] Resolving attribute: inspect.signature
        [ATTRIBUTE] Direct match found: inspect.signature
      [CHAIN] Step 1 resolved: inspect.signature
    [RESOLVE] RESOLVED to: inspect.signature
            [INTERMEDIATE] Tracking chain steps for: inspect.signature
            [INTERMEDIATE] Step 1: inspect.signature
      -> Resolved to: inspect.signature
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [ATTRIBUTE] Found attribute access: inspect.signature
        [CACHE] inspect.signature -> inspect.signature (cached)
      -> Not module state
      [NAME] Found name reference: inspect
    [RESOLVE] Attempting to resolve: ['inspect']
      [RESOLVE_SIMPLE] Resolving base: inspect
      [CACHE] Hit for inspect: inspect
    [RESOLVE] RESOLVED to: inspect
      -> Not module state
      [NAME] Found name reference: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      -> Not module state
      [CALL] Found call: sig.bind
    [RESOLVE] Attempting to resolve: ['sig', 'bind']
    [RESOLVE] Chain resolution needed for: ['sig', 'bind']
      [CHAIN] Resolving base: sig
      [RESOLVE_SIMPLE] Resolving base: sig
      [CACHE] Hit for sig: decorators.sig
      [CHAIN] Base resolved: sig -> decorators.sig
      [CHAIN] Step 1: Resolving decorators.sig.bind
        [ATTRIBUTE] Resolving attribute: decorators.sig.bind
        [ATTRIBUTE] Direct match found: decorators.sig.bind
      [CHAIN] Step 1 resolved: decorators.sig.bind
    [RESOLVE] RESOLVED to: decorators.sig.bind
            [INTERMEDIATE] Tracking chain steps for: sig.bind
            [INTERMEDIATE] Step 1: sig.bind
      -> Resolved to: decorators.sig.bind
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: sig.bind
        [CACHE] sig.bind -> decorators.sig.bind (cached)
      -> Not module state
      [NAME] Found name reference: sig
        [CACHE] sig -> decorators.sig (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: decorators.args
    [RESOLVE] RESOLVED to: decorators.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
    [RESOLVE] RESOLVED to: decorators.kwargs
      -> Not module state
      [NAME] Found name reference: TypeError
    [RESOLVE] Attempting to resolve: ['TypeError']
      [RESOLVE_SIMPLE] Resolving base: TypeError
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable TypeError not found in any scope
      [LOCAL_RESOLVER] can_resolve(TypeError): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(TypeError): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(TypeError): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(TypeError): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(TypeError): decorators.TypeError
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: TypeError -> decorators.TypeError
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.TypeError
      -> Not module state
      [CALL] Found call: ValueError
    [RESOLVE] Attempting to resolve: ['ValueError']
      [RESOLVE_SIMPLE] Resolving base: ValueError
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValueError not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValueError): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValueError): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValueError): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValueError): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(ValueError): decorators.ValueError
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValueError -> decorators.ValueError
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.ValueError
      -> Resolved to: decorators.ValueError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: ValueError
        [CACHE] ValueError -> decorators.ValueError (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [CACHE] Hit for e: decorators.e
    [RESOLVE] RESOLVED to: decorators.e
      -> Not module state
    [CONTEXT] Exited function: decorators.ClassBasedDecorator._validate_arguments
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.ClassBasedDecorator._validate_arguments
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.ClassBasedDecorator._transform_result
    [CONTEXT] Entered function: decorators.ClassBasedDecorator._transform_result (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'result': 'Any'}
        [ARG_TYPE] Processing type annotation for result: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: result -> typing.Any
        [ARG_TYPE] RESOLVED result : typing.Any
      [ASSIGNMENT] Processing: transform_type = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.config.get
    [RESOLVE] Attempting to resolve: ['self', 'config', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'config', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
      [CHAIN] Base resolved: self -> decorators.ClassBasedDecorator
      [CHAIN] Step 1: Resolving decorators.ClassBasedDecorator.config
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator.config
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator.config
      [CHAIN] Step 1 resolved: decorators.ClassBasedDecorator.config
      [CHAIN] Step 2: Resolving decorators.ClassBasedDecorator.config.get
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator.config.get
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator.config.get
      [CHAIN] Step 2 resolved: decorators.ClassBasedDecorator.config.get
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator.config.get
      [TYPE_INFERENCE] Call resolved to: decorators.ClassBasedDecorator.config.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for transform_type
      [NAME] Found name reference: transform_type
    [RESOLVE] Attempting to resolve: ['transform_type']
      [RESOLVE_SIMPLE] Resolving base: transform_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable transform_type not found in any scope
      [LOCAL_RESOLVER] can_resolve(transform_type): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(transform_type): False (current_class: decorators.ClassBasedDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(transform_type): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(transform_type): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(transform_type): decorators.transform_type
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: transform_type -> decorators.transform_type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.transform_type
      -> Not module state
      [CALL] Found call: self.config.get
    [RESOLVE] Attempting to resolve: ['self', 'config', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'config', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
      [CHAIN] Base resolved: self -> decorators.ClassBasedDecorator
      [CHAIN] Step 1: Resolving decorators.ClassBasedDecorator.config
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator.config
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator.config
      [CHAIN] Step 1 resolved: decorators.ClassBasedDecorator.config
      [CHAIN] Step 2: Resolving decorators.ClassBasedDecorator.config.get
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator.config.get
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator.config.get
      [CHAIN] Step 2 resolved: decorators.ClassBasedDecorator.config.get
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator.config.get
            [INTERMEDIATE] Tracking chain steps for: self.config.get
            [INTERMEDIATE] Step 1: self.config
    [RESOLVE] Attempting to resolve: ['self', 'config']
    [RESOLVE] Chain resolution needed for: ['self', 'config']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
      [CHAIN] Base resolved: self -> decorators.ClassBasedDecorator
      [CHAIN] Step 1: Resolving decorators.ClassBasedDecorator.config
        [ATTRIBUTE] Resolving attribute: decorators.ClassBasedDecorator.config
        [ATTRIBUTE] Direct match found: decorators.ClassBasedDecorator.config
      [CHAIN] Step 1 resolved: decorators.ClassBasedDecorator.config
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator.config
            [INTERMEDIATE] Step 1 resolved to: decorators.ClassBasedDecorator.config
            [INTERMEDIATE] Step 2: self.config.get
      -> Resolved to: decorators.ClassBasedDecorator.config.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.config.get
        [CACHE] self.config.get -> decorators.ClassBasedDecorator.config.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.config
        [CACHE] self.config -> decorators.ClassBasedDecorator.config (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.ClassBasedDecorator
    [RESOLVE] RESOLVED to: decorators.ClassBasedDecorator
      -> Not module state
      [NAME] Found name reference: transform_type
        [CACHE] transform_type -> decorators.transform_type (cached)
      -> Not module state
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: decorators.result
    [RESOLVE] RESOLVED to: decorators.result
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [NAME] Found name reference: transform_type
        [CACHE] transform_type -> decorators.transform_type (cached)
      -> Not module state
      [CALL] Found call: logging.info
    [RESOLVE] Attempting to resolve: ['logging', 'info']
    [RESOLVE] Chain resolution needed for: ['logging', 'info']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.info
        [ATTRIBUTE] Resolving attribute: logging.info
        [ATTRIBUTE] Direct match found: logging.info
      [CHAIN] Step 1 resolved: logging.info
    [RESOLVE] RESOLVED to: logging.info
            [INTERMEDIATE] Tracking chain steps for: logging.info
            [INTERMEDIATE] Step 1: logging.info
      -> Resolved to: logging.info
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.info
        [CACHE] logging.info -> logging.info (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
    [CONTEXT] Exited function: decorators.ClassBasedDecorator._transform_result
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.ClassBasedDecorator._transform_result
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: decorators.ClassBasedDecorator
    [SYMBOL_TABLE] Exited class scope
  [FUNCTION] Analyzing function: create_custom_decorator
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.create_custom_decorator
    [CONTEXT] Entered function: decorators.create_custom_decorator (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 4 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'name': 'str', 'pre_hook': 'Optional[Callable]', 'post_hook': 'Optional[Callable]', 'error_hook': 'Optional[Callable]'}
        [ARG_TYPE] Processing type annotation for name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(str): decorators.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> decorators.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.str
      [SYMBOL_UPDATE] Function: name -> decorators.str
        [ARG_TYPE] RESOLVED name : decorators.str
      [NESTED_FUNCTION] Analyzing nested function: decorator
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'name': 'str', 'pre_hook': 'Optional[Callable]', 'post_hook': 'Optional[Callable]', 'error_hook': 'Optional[Callable]'}
        [ARG_TYPE] Processing type annotation for func: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Nested: func -> typing.Callable
        [ARG_TYPE] RESOLVED func : typing.Callable
  [FUNCTION] Analyzing function: wrapper
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.wrapper
    [DECORATOR] @wraps(func)
      [CODE_STANDARD_VIOLATION] MISSING_RETURN_TYPE: Function decorators.wrapper
      [IMPACT] Cannot infer return type - chained method calls may fail
      [ACTION_REQUIRED] Add appropriate type annotation
      [CODE_QUALITY] Found 1 violations in decorators.wrapper
    [CONTEXT] Entered function: decorators.wrapper (depth: 2)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [NAME] Found name reference: pre_hook
    [RESOLVE] Attempting to resolve: ['pre_hook']
      [RESOLVE_SIMPLE] Resolving base: pre_hook
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable pre_hook not found in any scope
      [LOCAL_RESOLVER] can_resolve(pre_hook): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(pre_hook): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(pre_hook): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(pre_hook): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(pre_hook): decorators.pre_hook
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: pre_hook -> decorators.pre_hook
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.pre_hook
      -> Not module state
      [ASSIGNMENT] Processing: pre_result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: pre_hook
    [RESOLVE] Attempting to resolve: ['pre_hook']
      [RESOLVE_SIMPLE] Resolving base: pre_hook
      [CACHE] Hit for pre_hook: decorators.pre_hook
    [RESOLVE] RESOLVED to: decorators.pre_hook
      [TYPE_INFERENCE] Call resolved to: decorators.pre_hook
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for pre_result
      [NAME] Found name reference: pre_result
    [RESOLVE] Attempting to resolve: ['pre_result']
      [RESOLVE_SIMPLE] Resolving base: pre_result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable pre_result not found in any scope
      [LOCAL_RESOLVER] can_resolve(pre_result): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(pre_result): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(pre_result): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(pre_result): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(pre_result): decorators.pre_result
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: pre_result -> decorators.pre_result
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.pre_result
      -> Not module state
      [CALL] Found call: pre_hook
    [CACHE] pre_hook -> decorators.pre_hook (cached)
      -> Resolved to: decorators.pre_hook
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
        [FUNCTION_ARG] Checking argument: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: decorators.args
    [RESOLVE] RESOLVED to: decorators.args
        [FUNCTION_ARG] Checking argument: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
    [RESOLVE] RESOLVED to: decorators.kwargs
      [NAME] Found name reference: pre_hook
        [CACHE] pre_hook -> decorators.pre_hook (cached)
      -> Not module state
      [NAME] Found name reference: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: decorators.args
    [RESOLVE] RESOLVED to: decorators.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
    [RESOLVE] RESOLVED to: decorators.kwargs
      -> Not module state
      [NAME] Found name reference: pre_result
        [CACHE] pre_result -> decorators.pre_result (cached)
      -> Not module state
      [CALL] Found call: RuntimeError
    [RESOLVE] Attempting to resolve: ['RuntimeError']
      [RESOLVE_SIMPLE] Resolving base: RuntimeError
      [CACHE] Hit for RuntimeError: decorators.RuntimeError
    [RESOLVE] RESOLVED to: decorators.RuntimeError
      -> Resolved to: decorators.RuntimeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: RuntimeError
        [CACHE] RuntimeError -> decorators.RuntimeError (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: func.__name__
    [RESOLVE] Attempting to resolve: ['func', '__name__']
    [RESOLVE] Chain resolution needed for: ['func', '__name__']
      [CHAIN] Resolving base: func
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
      [CHAIN] Base resolved: func -> decorators.func
      [CHAIN] Step 1: Resolving decorators.func.__name__
        [ATTRIBUTE] Resolving attribute: decorators.func.__name__
        [ATTRIBUTE] Direct match found: decorators.func.__name__
      [CHAIN] Step 1 resolved: decorators.func.__name__
    [RESOLVE] RESOLVED to: decorators.func.__name__
      -> Not module state
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      [TYPE_INFERENCE] Call resolved to: decorators.func
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for result
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: decorators.result
    [RESOLVE] RESOLVED to: decorators.result
      -> Not module state
      [CALL] Found call: func
    [CACHE] func -> decorators.func (cached)
      -> Resolved to: decorators.func
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
      [NAME] Found name reference: args
        [CACHE] args -> decorators.args (cached)
      -> Not module state
      [NAME] Found name reference: kwargs
        [CACHE] kwargs -> decorators.kwargs (cached)
      -> Not module state
      [NAME] Found name reference: post_hook
    [RESOLVE] Attempting to resolve: ['post_hook']
      [RESOLVE_SIMPLE] Resolving base: post_hook
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable post_hook not found in any scope
      [LOCAL_RESOLVER] can_resolve(post_hook): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(post_hook): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(post_hook): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(post_hook): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(post_hook): decorators.post_hook
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: post_hook -> decorators.post_hook
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.post_hook
      -> Not module state
      [CALL] Found call: post_hook
    [CACHE] post_hook -> decorators.post_hook (cached)
      -> Resolved to: decorators.post_hook
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
        [FUNCTION_ARG] Checking argument: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: decorators.args
    [RESOLVE] RESOLVED to: decorators.args
        [FUNCTION_ARG] Checking argument: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
    [RESOLVE] RESOLVED to: decorators.kwargs
        [FUNCTION_ARG] Checking argument: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: decorators.result
    [RESOLVE] RESOLVED to: decorators.result
      [NAME] Found name reference: post_hook
        [CACHE] post_hook -> decorators.post_hook (cached)
      -> Not module state
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
      [NAME] Found name reference: args
        [CACHE] args -> decorators.args (cached)
      -> Not module state
      [NAME] Found name reference: kwargs
        [CACHE] kwargs -> decorators.kwargs (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [CACHE] Hit for Exception: decorators.Exception
    [RESOLVE] RESOLVED to: decorators.Exception
      -> Not module state
      [NAME] Found name reference: error_hook
    [RESOLVE] Attempting to resolve: ['error_hook']
      [RESOLVE_SIMPLE] Resolving base: error_hook
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable error_hook not found in any scope
      [LOCAL_RESOLVER] can_resolve(error_hook): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(error_hook): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(error_hook): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(error_hook): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(error_hook): decorators.error_hook
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: error_hook -> decorators.error_hook
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.error_hook
      -> Not module state
      [CALL] Found call: error_hook
    [CACHE] error_hook -> decorators.error_hook (cached)
      -> Resolved to: decorators.error_hook
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
        [FUNCTION_ARG] Checking argument: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: decorators.args
    [RESOLVE] RESOLVED to: decorators.args
        [FUNCTION_ARG] Checking argument: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
    [RESOLVE] RESOLVED to: decorators.kwargs
        [FUNCTION_ARG] Checking argument: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [CACHE] Hit for e: decorators.e
    [RESOLVE] RESOLVED to: decorators.e
      [NAME] Found name reference: error_hook
        [CACHE] error_hook -> decorators.error_hook (cached)
      -> Not module state
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
      [NAME] Found name reference: args
        [CACHE] args -> decorators.args (cached)
      -> Not module state
      [NAME] Found name reference: kwargs
        [CACHE] kwargs -> decorators.kwargs (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [CACHE] Hit for e: decorators.e
    [RESOLVE] RESOLVED to: decorators.e
      -> Not module state
    [CONTEXT] Exited function: decorators.wrapper
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.wrapper
        Calls: 0
        Instantiations: 0
        State Access: 0
      [CALL] Found call: _decorator_registry.register_decorator
    [RESOLVE] Attempting to resolve: ['_decorator_registry', 'register_decorator']
    [RESOLVE] Chain resolution needed for: ['_decorator_registry', 'register_decorator']
      [CHAIN] Resolving base: _decorator_registry
      [RESOLVE_SIMPLE] Resolving base: _decorator_registry
      [CACHE] Hit for _decorator_registry: decorators._decorator_registry
      [CHAIN] Base resolved: _decorator_registry -> decorators._decorator_registry
      [CHAIN] Step 1: Resolving decorators._decorator_registry.register_decorator
        [ATTRIBUTE] Resolving attribute: decorators._decorator_registry.register_decorator
        [ATTRIBUTE] Direct match found: decorators._decorator_registry.register_decorator
      [CHAIN] Step 1 resolved: decorators._decorator_registry.register_decorator
    [RESOLVE] RESOLVED to: decorators._decorator_registry.register_decorator
            [INTERMEDIATE] Tracking chain steps for: _decorator_registry.register_decorator
            [INTERMEDIATE] Step 1: _decorator_registry.register_decorator
      -> Resolved to: decorators._decorator_registry.register_decorator
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: name
    [RESOLVE] Attempting to resolve: ['name']
      [RESOLVE_SIMPLE] Resolving base: name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable name not found in any scope
      [LOCAL_RESOLVER] can_resolve(name): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(name): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(name): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(name): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(name): decorators.name
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: name -> decorators.name
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.name
        [FUNCTION_ARG] Checking argument: wrapper
    [RESOLVE] Attempting to resolve: ['wrapper']
      [RESOLVE_SIMPLE] Resolving base: wrapper
      [CACHE] Hit for wrapper: decorators.wrapper
    [RESOLVE] RESOLVED to: decorators.wrapper
      [ATTRIBUTE] Found attribute access: _decorator_registry.register_decorator
        [CACHE] _decorator_registry.register_decorator -> decorators._decorator_registry.register_decorator (cached)
      -> Not module state
      [NAME] Found name reference: _decorator_registry
    [RESOLVE] Attempting to resolve: ['_decorator_registry']
      [RESOLVE_SIMPLE] Resolving base: _decorator_registry
      [CACHE] Hit for _decorator_registry: decorators._decorator_registry
    [RESOLVE] RESOLVED to: decorators._decorator_registry
      -> Resolved to state: decorators._decorator_registry
      [SYMBOL_LOOKUP] Variable _decorator_registry not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: name
    [RESOLVE] Attempting to resolve: ['name']
      [RESOLVE_SIMPLE] Resolving base: name
      [CACHE] Hit for name: decorators.name
    [RESOLVE] RESOLVED to: decorators.name
      -> Not module state
      [NAME] Found name reference: wrapper
    [RESOLVE] Attempting to resolve: ['wrapper']
      [RESOLVE_SIMPLE] Resolving base: wrapper
      [CACHE] Hit for wrapper: decorators.wrapper
    [RESOLVE] RESOLVED to: decorators.wrapper
      -> Not module state
      [NAME] Found name reference: wrapper
        [CACHE] wrapper -> decorators.wrapper (cached)
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: decorator
    [RESOLVE] Attempting to resolve: ['decorator']
      [RESOLVE_SIMPLE] Resolving base: decorator
      [CACHE] Hit for decorator: decorators.decorator
    [RESOLVE] RESOLVED to: decorators.decorator
      -> Not module state
    [CONTEXT] Exited function: decorators.create_custom_decorator
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.create_custom_decorator
        Calls: 0
        Instantiations: 0
        State Access: 1
  [FUNCTION] Analyzing function: multi_decorator
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.multi_decorator
    [CONTEXT] Entered function: decorators.multi_decorator (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [NESTED_FUNCTION] Analyzing nested function: decorator
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_TYPE] Processing type annotation for func: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Nested: func -> typing.Callable
        [ARG_TYPE] RESOLVED func : typing.Callable
      [ASSIGNMENT] Processing: decorated_func = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: decorated_func
    [RESOLVE] Attempting to resolve: ['decorated_func']
      [RESOLVE_SIMPLE] Resolving base: decorated_func
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable decorated_func not found in any scope
      [LOCAL_RESOLVER] can_resolve(decorated_func): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(decorated_func): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(decorated_func): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(decorated_func): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(decorated_func): decorators.decorated_func
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: decorated_func -> decorators.decorated_func
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.decorated_func
      -> Not module state
      [NAME] Found name reference: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      -> Not module state
      [NAME] Found name reference: dec
    [RESOLVE] Attempting to resolve: ['dec']
      [RESOLVE_SIMPLE] Resolving base: dec
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable dec not found in any scope
      [LOCAL_RESOLVER] can_resolve(dec): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(dec): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(dec): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(dec): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(dec): decorators.dec
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: dec -> decorators.dec
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.dec
      -> Not module state
      [CALL] Found call: reversed
    [RESOLVE] Attempting to resolve: ['reversed']
      [RESOLVE_SIMPLE] Resolving base: reversed
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable reversed not found in any scope
      [LOCAL_RESOLVER] can_resolve(reversed): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(reversed): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(reversed): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(reversed): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(reversed): decorators.reversed
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: reversed -> decorators.reversed
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.reversed
      -> Resolved to: decorators.reversed
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: decorators
    [RESOLVE] Attempting to resolve: ['decorators']
      [RESOLVE_SIMPLE] Resolving base: decorators
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable decorators not found in any scope
      [LOCAL_RESOLVER] can_resolve(decorators): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(decorators): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(decorators): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(decorators): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(decorators): decorators.decorators
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: decorators -> decorators.decorators
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.decorators
      [NAME] Found name reference: reversed
        [CACHE] reversed -> decorators.reversed (cached)
      -> Not module state
      [NAME] Found name reference: decorators
    [RESOLVE] Attempting to resolve: ['decorators']
      [RESOLVE_SIMPLE] Resolving base: decorators
      [CACHE] Hit for decorators: decorators.decorators
    [RESOLVE] RESOLVED to: decorators.decorators
      -> Not module state
      [ASSIGNMENT] Processing: decorated_func = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: dec
    [RESOLVE] Attempting to resolve: ['dec']
      [RESOLVE_SIMPLE] Resolving base: dec
      [CACHE] Hit for dec: decorators.dec
    [RESOLVE] RESOLVED to: decorators.dec
      [TYPE_INFERENCE] Call resolved to: decorators.dec
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for decorated_func
      [NAME] Found name reference: decorated_func
        [CACHE] decorated_func -> decorators.decorated_func (cached)
      -> Not module state
      [CALL] Found call: dec
    [CACHE] dec -> decorators.dec (cached)
      -> Resolved to: decorators.dec
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: decorated_func
    [RESOLVE] Attempting to resolve: ['decorated_func']
      [RESOLVE_SIMPLE] Resolving base: decorated_func
      [CACHE] Hit for decorated_func: decorators.decorated_func
    [RESOLVE] RESOLVED to: decorators.decorated_func
      [NAME] Found name reference: dec
        [CACHE] dec -> decorators.dec (cached)
      -> Not module state
      [NAME] Found name reference: decorated_func
        [CACHE] decorated_func -> decorators.decorated_func (cached)
      -> Not module state
      [NAME] Found name reference: decorated_func
        [CACHE] decorated_func -> decorators.decorated_func (cached)
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: decorator
    [RESOLVE] Attempting to resolve: ['decorator']
      [RESOLVE_SIMPLE] Resolving base: decorator
      [CACHE] Hit for decorator: decorators.decorator
    [RESOLVE] RESOLVED to: decorators.decorator
      -> Not module state
    [CONTEXT] Exited function: decorators.multi_decorator
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.multi_decorator
        Calls: 0
        Instantiations: 0
        State Access: 0
  [FUNCTION] Analyzing function: conditional_decorator
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.conditional_decorator
    [CONTEXT] Entered function: decorators.conditional_decorator (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'condition': 'Union[bool, Callable]', 'decorator': 'Callable'}
        [ARG_TYPE] Processing type annotation for decorator: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Function: decorator -> typing.Callable
        [ARG_TYPE] RESOLVED decorator : typing.Callable
      [NESTED_FUNCTION] Analyzing nested function: decorator_wrapper
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'condition': 'Union[bool, Callable]', 'decorator': 'Callable'}
        [ARG_TYPE] Processing type annotation for func: Callable
        [CACHE] Callable -> typing.Callable (cached)
      [SYMBOL_UPDATE] Nested: func -> typing.Callable
        [ARG_TYPE] RESOLVED func : typing.Callable
      [ASSIGNMENT] Processing: should_apply = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: should_apply
    [RESOLVE] Attempting to resolve: ['should_apply']
      [RESOLVE_SIMPLE] Resolving base: should_apply
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable should_apply not found in any scope
      [LOCAL_RESOLVER] can_resolve(should_apply): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(should_apply): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(should_apply): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(should_apply): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(should_apply): decorators.should_apply
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: should_apply -> decorators.should_apply
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.should_apply
      -> Not module state
      [NAME] Found name reference: condition
    [RESOLVE] Attempting to resolve: ['condition']
      [RESOLVE_SIMPLE] Resolving base: condition
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable condition not found in any scope
      [LOCAL_RESOLVER] can_resolve(condition): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(condition): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(condition): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(condition): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(condition): decorators.condition
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: condition -> decorators.condition
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.condition
      -> Not module state
      [CALL] Found call: callable
    [RESOLVE] Attempting to resolve: ['callable']
      [RESOLVE_SIMPLE] Resolving base: callable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable callable not found in any scope
      [LOCAL_RESOLVER] can_resolve(callable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(callable): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(callable): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(callable): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(callable): decorators.callable
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: callable -> decorators.callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.callable
      -> Resolved to: decorators.callable
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: condition
    [RESOLVE] Attempting to resolve: ['condition']
      [RESOLVE_SIMPLE] Resolving base: condition
      [CACHE] Hit for condition: decorators.condition
    [RESOLVE] RESOLVED to: decorators.condition
      [NAME] Found name reference: callable
        [CACHE] callable -> decorators.callable (cached)
      -> Not module state
      [NAME] Found name reference: condition
        [CACHE] condition -> decorators.condition (cached)
      -> Not module state
      [ASSIGNMENT] Processing: should_apply = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: condition
    [RESOLVE] Attempting to resolve: ['condition']
      [RESOLVE_SIMPLE] Resolving base: condition
      [CACHE] Hit for condition: decorators.condition
    [RESOLVE] RESOLVED to: decorators.condition
      [TYPE_INFERENCE] Call resolved to: decorators.condition
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for should_apply
      [NAME] Found name reference: should_apply
        [CACHE] should_apply -> decorators.should_apply (cached)
      -> Not module state
      [CALL] Found call: condition
    [CACHE] condition -> decorators.condition (cached)
      -> Resolved to: decorators.condition
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      [NAME] Found name reference: condition
        [CACHE] condition -> decorators.condition (cached)
      -> Not module state
      [NAME] Found name reference: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      -> Not module state
      [NAME] Found name reference: should_apply
        [CACHE] should_apply -> decorators.should_apply (cached)
      -> Not module state
      [CALL] Found call: decorator
    [RESOLVE] Attempting to resolve: ['decorator']
      [RESOLVE_SIMPLE] Resolving base: decorator
      [CACHE] Hit for decorator: decorators.decorator
    [RESOLVE] RESOLVED to: decorators.decorator
      -> Resolved to: decorators.decorator
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      [NAME] Found name reference: decorator
        [CACHE] decorator -> decorators.decorator (cached)
      -> Not module state
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: decorator_wrapper
    [RESOLVE] Attempting to resolve: ['decorator_wrapper']
      [RESOLVE_SIMPLE] Resolving base: decorator_wrapper
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable decorator_wrapper not found in any scope
      [LOCAL_RESOLVER] can_resolve(decorator_wrapper): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(decorator_wrapper): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(decorator_wrapper): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(decorator_wrapper): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(decorator_wrapper): decorators.decorator_wrapper
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: decorator_wrapper -> decorators.decorator_wrapper
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.decorator_wrapper
      -> Not module state
    [CONTEXT] Exited function: decorators.conditional_decorator
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.conditional_decorator
        Calls: 0
        Instantiations: 0
        State Access: 0
  [FUNCTION] Analyzing function: advanced_cache
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.advanced_cache
    [CONTEXT] Entered function: decorators.advanced_cache (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 4 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'ttl': 'int', 'key_func': 'Optional[Callable]', 'serializer': 'Optional[Callable]', 'validator': 'Optional[Callable]'}
        [ARG_TYPE] Processing type annotation for ttl: int
    [RESOLVE] Attempting to resolve: ['int']
      [RESOLVE_SIMPLE] Resolving base: int
      [CACHE] Hit for int: decorators.int
    [RESOLVE] RESOLVED to: decorators.int
      [SYMBOL_UPDATE] Function: ttl -> decorators.int
        [ARG_TYPE] RESOLVED ttl : decorators.int
      [ANNOTATED_ASSIGNMENT] cache_storage : Dict[str, Dict[str, Any]]
      [NAME] Found name reference: cache_storage
    [RESOLVE] Attempting to resolve: ['cache_storage']
      [RESOLVE_SIMPLE] Resolving base: cache_storage
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable cache_storage not found in any scope
      [LOCAL_RESOLVER] can_resolve(cache_storage): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(cache_storage): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(cache_storage): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(cache_storage): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(cache_storage): decorators.cache_storage
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: cache_storage -> decorators.cache_storage
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.cache_storage
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: decorators.str
    [RESOLVE] RESOLVED to: decorators.str
      -> Not module state
      [NAME] Found name reference: Dict
        [CACHE] Dict -> typing.Dict (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> decorators.str (cached)
      -> Not module state
      [NAME] Found name reference: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [NESTED_FUNCTION] Analyzing nested function: decorator
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'ttl': 'int', 'key_func': 'Optional[Callable]', 'serializer': 'Optional[Callable]', 'validator': 'Optional[Callable]'}
        [ARG_TYPE] Processing type annotation for func: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Nested: func -> typing.Callable
        [ARG_TYPE] RESOLVED func : typing.Callable
  [FUNCTION] Analyzing function: wrapper
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.wrapper
    [DECORATOR] @wraps(func)
      [CODE_STANDARD_VIOLATION] MISSING_RETURN_TYPE: Function decorators.wrapper
      [IMPACT] Cannot infer return type - chained method calls may fail
      [ACTION_REQUIRED] Add appropriate type annotation
      [CODE_QUALITY] Found 1 violations in decorators.wrapper
    [CONTEXT] Entered function: decorators.wrapper (depth: 2)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [NAME] Found name reference: key_func
    [RESOLVE] Attempting to resolve: ['key_func']
      [RESOLVE_SIMPLE] Resolving base: key_func
      [CACHE] Hit for key_func: decorators.key_func
    [RESOLVE] RESOLVED to: decorators.key_func
      -> Not module state
      [ASSIGNMENT] Processing: cache_key = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: key_func
    [RESOLVE] Attempting to resolve: ['key_func']
      [RESOLVE_SIMPLE] Resolving base: key_func
      [CACHE] Hit for key_func: decorators.key_func
    [RESOLVE] RESOLVED to: decorators.key_func
      [TYPE_INFERENCE] Call resolved to: decorators.key_func
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for cache_key
      [NAME] Found name reference: cache_key
    [RESOLVE] Attempting to resolve: ['cache_key']
      [RESOLVE_SIMPLE] Resolving base: cache_key
      [CACHE] Hit for cache_key: decorators.cache_key
    [RESOLVE] RESOLVED to: decorators.cache_key
      -> Not module state
      [CALL] Found call: key_func
    [CACHE] key_func -> decorators.key_func (cached)
      -> Resolved to: decorators.key_func
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: key_func
        [CACHE] key_func -> decorators.key_func (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: decorators.args
    [RESOLVE] RESOLVED to: decorators.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
    [RESOLVE] RESOLVED to: decorators.kwargs
      -> Not module state
      [ASSIGNMENT] Processing: cache_key = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> decorators.cache_key (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: func.__name__
    [RESOLVE] Attempting to resolve: ['func', '__name__']
    [RESOLVE] Chain resolution needed for: ['func', '__name__']
      [CHAIN] Resolving base: func
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
      [CHAIN] Base resolved: func -> decorators.func
      [CHAIN] Step 1: Resolving decorators.func.__name__
        [ATTRIBUTE] Resolving attribute: decorators.func.__name__
        [ATTRIBUTE] Direct match found: decorators.func.__name__
      [CHAIN] Step 1 resolved: decorators.func.__name__
    [RESOLVE] RESOLVED to: decorators.func.__name__
      -> Not module state
      [NAME] Found name reference: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      -> Not module state
      [CALL] Found call: hash
    [RESOLVE] Attempting to resolve: ['hash']
      [RESOLVE_SIMPLE] Resolving base: hash
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable hash not found in any scope
      [LOCAL_RESOLVER] can_resolve(hash): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(hash): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(hash): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(hash): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(hash): decorators.hash
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: hash -> decorators.hash
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.hash
      -> Resolved to: decorators.hash
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: hash
        [CACHE] hash -> decorators.hash (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: decorators.str
    [RESOLVE] RESOLVED to: decorators.str
      -> Not module state
      [NAME] Found name reference: args
        [CACHE] args -> decorators.args (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
        [CACHE] str -> decorators.str (cached)
      -> Not module state
      [CALL] Found call: sorted
      -> IGNORED (built-in function)
      [NAME] Found name reference: sorted
    [RESOLVE] Attempting to resolve: ['sorted']
      [RESOLVE_SIMPLE] Resolving base: sorted
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable sorted not found in any scope
      [LOCAL_RESOLVER] can_resolve(sorted): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(sorted): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(sorted): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(sorted): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(sorted): decorators.sorted
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: sorted -> decorators.sorted
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.sorted
      -> Not module state
      [CALL] Found call: kwargs.items
    [RESOLVE] Attempting to resolve: ['kwargs', 'items']
    [RESOLVE] Chain resolution needed for: ['kwargs', 'items']
      [CHAIN] Resolving base: kwargs
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
      [CHAIN] Base resolved: kwargs -> decorators.kwargs
      [CHAIN] Step 1: Resolving decorators.kwargs.items
        [ATTRIBUTE] Resolving attribute: decorators.kwargs.items
        [ATTRIBUTE] Direct match found: decorators.kwargs.items
      [CHAIN] Step 1 resolved: decorators.kwargs.items
    [RESOLVE] RESOLVED to: decorators.kwargs.items
            [INTERMEDIATE] Tracking chain steps for: kwargs.items
            [INTERMEDIATE] Step 1: kwargs.items
      -> Resolved to: decorators.kwargs.items
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: kwargs.items
        [CACHE] kwargs.items -> decorators.kwargs.items (cached)
      -> Not module state
      [NAME] Found name reference: kwargs
        [CACHE] kwargs -> decorators.kwargs (cached)
      -> Not module state
      [ASSIGNMENT] Processing: current_time = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
      [TYPE_INFERENCE] Call resolved to: time.time
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for current_time
      [NAME] Found name reference: current_time
    [RESOLVE] Attempting to resolve: ['current_time']
      [RESOLVE_SIMPLE] Resolving base: current_time
      [CACHE] Hit for current_time: decorators.current_time
    [RESOLVE] RESOLVED to: decorators.current_time
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> decorators.cache_key (cached)
      -> Not module state
      [NAME] Found name reference: cache_storage
    [RESOLVE] Attempting to resolve: ['cache_storage']
      [RESOLVE_SIMPLE] Resolving base: cache_storage
      [CACHE] Hit for cache_storage: decorators.cache_storage
    [RESOLVE] RESOLVED to: decorators.cache_storage
      -> Not module state
      [ASSIGNMENT] Processing: entry = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: entry
    [RESOLVE] Attempting to resolve: ['entry']
      [RESOLVE_SIMPLE] Resolving base: entry
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable entry not found in any scope
      [LOCAL_RESOLVER] can_resolve(entry): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(entry): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(entry): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(entry): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(entry): decorators.entry
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: entry -> decorators.entry
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.entry
      -> Not module state
      [NAME] Found name reference: cache_storage
        [CACHE] cache_storage -> decorators.cache_storage (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> decorators.cache_key (cached)
      -> Not module state
      [NAME] Found name reference: current_time
        [CACHE] current_time -> decorators.current_time (cached)
      -> Not module state
      [NAME] Found name reference: entry
        [CACHE] entry -> decorators.entry (cached)
      -> Not module state
      [NAME] Found name reference: ttl
    [RESOLVE] Attempting to resolve: ['ttl']
      [RESOLVE_SIMPLE] Resolving base: ttl
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ttl not found in any scope
      [LOCAL_RESOLVER] can_resolve(ttl): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ttl): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ttl): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ttl): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(ttl): decorators.ttl
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ttl -> decorators.ttl
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.ttl
      -> Not module state
      [NAME] Found name reference: validator
    [RESOLVE] Attempting to resolve: ['validator']
      [RESOLVE_SIMPLE] Resolving base: validator
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable validator not found in any scope
      [LOCAL_RESOLVER] can_resolve(validator): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(validator): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(validator): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(validator): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(validator): decorators.validator
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: validator -> decorators.validator
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.validator
      -> Not module state
      [CALL] Found call: validator
    [CACHE] validator -> decorators.validator (cached)
      -> Resolved to: decorators.validator
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: validator
        [CACHE] validator -> decorators.validator (cached)
      -> Not module state
      [NAME] Found name reference: entry
        [CACHE] entry -> decorators.entry (cached)
      -> Not module state
      [NAME] Found name reference: cache_storage
        [CACHE] cache_storage -> decorators.cache_storage (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> decorators.cache_key (cached)
      -> Not module state
      [NAME] Found name reference: entry
        [CACHE] entry -> decorators.entry (cached)
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      [TYPE_INFERENCE] Call resolved to: decorators.func
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for result
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: decorators.result
    [RESOLVE] RESOLVED to: decorators.result
      -> Not module state
      [CALL] Found call: func
    [CACHE] func -> decorators.func (cached)
      -> Resolved to: decorators.func
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
      [NAME] Found name reference: args
        [CACHE] args -> decorators.args (cached)
      -> Not module state
      [NAME] Found name reference: kwargs
        [CACHE] kwargs -> decorators.kwargs (cached)
      -> Not module state
      [ASSIGNMENT] Processing: cached_result = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: cached_result
    [RESOLVE] Attempting to resolve: ['cached_result']
      [RESOLVE_SIMPLE] Resolving base: cached_result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable cached_result not found in any scope
      [LOCAL_RESOLVER] can_resolve(cached_result): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(cached_result): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(cached_result): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(cached_result): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(cached_result): decorators.cached_result
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: cached_result -> decorators.cached_result
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.cached_result
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [NAME] Found name reference: serializer
    [RESOLVE] Attempting to resolve: ['serializer']
      [RESOLVE_SIMPLE] Resolving base: serializer
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable serializer not found in any scope
      [LOCAL_RESOLVER] can_resolve(serializer): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(serializer): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(serializer): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(serializer): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(serializer): decorators.serializer
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: serializer -> decorators.serializer
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.serializer
      -> Not module state
      [ASSIGNMENT] Processing: cached_result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: serializer
    [RESOLVE] Attempting to resolve: ['serializer']
      [RESOLVE_SIMPLE] Resolving base: serializer
      [CACHE] Hit for serializer: decorators.serializer
    [RESOLVE] RESOLVED to: decorators.serializer
      [TYPE_INFERENCE] Call resolved to: decorators.serializer
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for cached_result
      [NAME] Found name reference: cached_result
        [CACHE] cached_result -> decorators.cached_result (cached)
      -> Not module state
      [CALL] Found call: serializer
    [CACHE] serializer -> decorators.serializer (cached)
      -> Resolved to: decorators.serializer
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: decorators.result
    [RESOLVE] RESOLVED to: decorators.result
      [NAME] Found name reference: serializer
        [CACHE] serializer -> decorators.serializer (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [NAME] Found name reference: cache_storage
        [CACHE] cache_storage -> decorators.cache_storage (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> decorators.cache_key (cached)
      -> Not module state
      [NAME] Found name reference: cached_result
        [CACHE] cached_result -> decorators.cached_result (cached)
      -> Not module state
      [NAME] Found name reference: current_time
        [CACHE] current_time -> decorators.current_time (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
    [CONTEXT] Exited function: decorators.wrapper
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.wrapper
        Calls: 0
        Instantiations: 0
        State Access: 0
      [NAME] Found name reference: wrapper
    [RESOLVE] Attempting to resolve: ['wrapper']
      [RESOLVE_SIMPLE] Resolving base: wrapper
      [CACHE] Hit for wrapper: decorators.wrapper
    [RESOLVE] RESOLVED to: decorators.wrapper
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: decorator
    [RESOLVE] Attempting to resolve: ['decorator']
      [RESOLVE_SIMPLE] Resolving base: decorator
      [CACHE] Hit for decorator: decorators.decorator
    [RESOLVE] RESOLVED to: decorators.decorator
      -> Not module state
    [CONTEXT] Exited function: decorators.advanced_cache
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.advanced_cache
        Calls: 0
        Instantiations: 0
        State Access: 0
  [FUNCTION] Analyzing function: create_monitoring_decorator
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.create_monitoring_decorator
    [CONTEXT] Entered function: decorators.create_monitoring_decorator (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'metrics_collector': 'Any'}
        [ARG_TYPE] Processing type annotation for metrics_collector: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: metrics_collector -> typing.Any
        [ARG_TYPE] RESOLVED metrics_collector : typing.Any
      [NESTED_FUNCTION] Analyzing nested function: monitor_decorator
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'metrics_collector': 'Any'}
        [ARG_TYPE] Processing type annotation for func: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Nested: func -> typing.Callable
        [ARG_TYPE] RESOLVED func : typing.Callable
  [FUNCTION] Analyzing function: wrapper
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.wrapper
    [DECORATOR] @wraps(func)
      [CODE_STANDARD_VIOLATION] MISSING_RETURN_TYPE: Function decorators.wrapper
      [IMPACT] Cannot infer return type - chained method calls may fail
      [ACTION_REQUIRED] Add appropriate type annotation
      [CODE_QUALITY] Found 1 violations in decorators.wrapper
    [CONTEXT] Entered function: decorators.wrapper (depth: 2)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [ASSIGNMENT] Processing: monitor_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: metrics_collector.start_monitoring
    [RESOLVE] Attempting to resolve: ['metrics_collector', 'start_monitoring']
    [RESOLVE] Chain resolution needed for: ['metrics_collector', 'start_monitoring']
      [CHAIN] Resolving base: metrics_collector
      [RESOLVE_SIMPLE] Resolving base: metrics_collector
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable metrics_collector not found in any scope
      [LOCAL_RESOLVER] can_resolve(metrics_collector): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(metrics_collector): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(metrics_collector): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(metrics_collector): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(metrics_collector): decorators.metrics_collector
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: metrics_collector -> decorators.metrics_collector
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: metrics_collector -> decorators.metrics_collector
      [CHAIN] Step 1: Resolving decorators.metrics_collector.start_monitoring
        [ATTRIBUTE] Resolving attribute: decorators.metrics_collector.start_monitoring
        [ATTRIBUTE] Direct match found: decorators.metrics_collector.start_monitoring
      [CHAIN] Step 1 resolved: decorators.metrics_collector.start_monitoring
    [RESOLVE] RESOLVED to: decorators.metrics_collector.start_monitoring
      [TYPE_INFERENCE] Call resolved to: decorators.metrics_collector.start_monitoring
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for monitor_id
      [NAME] Found name reference: monitor_id
    [RESOLVE] Attempting to resolve: ['monitor_id']
      [RESOLVE_SIMPLE] Resolving base: monitor_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable monitor_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(monitor_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(monitor_id): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(monitor_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(monitor_id): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(monitor_id): decorators.monitor_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: monitor_id -> decorators.monitor_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.monitor_id
      -> Not module state
      [CALL] Found call: metrics_collector.start_monitoring
    [RESOLVE] Attempting to resolve: ['metrics_collector', 'start_monitoring']
    [RESOLVE] Chain resolution needed for: ['metrics_collector', 'start_monitoring']
      [CHAIN] Resolving base: metrics_collector
      [RESOLVE_SIMPLE] Resolving base: metrics_collector
      [CACHE] Hit for metrics_collector: decorators.metrics_collector
      [CHAIN] Base resolved: metrics_collector -> decorators.metrics_collector
      [CHAIN] Step 1: Resolving decorators.metrics_collector.start_monitoring
        [ATTRIBUTE] Resolving attribute: decorators.metrics_collector.start_monitoring
        [ATTRIBUTE] Direct match found: decorators.metrics_collector.start_monitoring
      [CHAIN] Step 1 resolved: decorators.metrics_collector.start_monitoring
    [RESOLVE] RESOLVED to: decorators.metrics_collector.start_monitoring
            [INTERMEDIATE] Tracking chain steps for: metrics_collector.start_monitoring
            [INTERMEDIATE] Step 1: metrics_collector.start_monitoring
      -> Resolved to: decorators.metrics_collector.start_monitoring
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: metrics_collector.start_monitoring
        [CACHE] metrics_collector.start_monitoring -> decorators.metrics_collector.start_monitoring (cached)
      -> Not module state
      [NAME] Found name reference: metrics_collector
    [RESOLVE] Attempting to resolve: ['metrics_collector']
      [RESOLVE_SIMPLE] Resolving base: metrics_collector
      [CACHE] Hit for metrics_collector: decorators.metrics_collector
    [RESOLVE] RESOLVED to: decorators.metrics_collector
      -> Not module state
      [ATTRIBUTE] Found attribute access: func.__name__
    [RESOLVE] Attempting to resolve: ['func', '__name__']
    [RESOLVE] Chain resolution needed for: ['func', '__name__']
      [CHAIN] Resolving base: func
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
      [CHAIN] Base resolved: func -> decorators.func
      [CHAIN] Step 1: Resolving decorators.func.__name__
        [ATTRIBUTE] Resolving attribute: decorators.func.__name__
        [ATTRIBUTE] Direct match found: decorators.func.__name__
      [CHAIN] Step 1 resolved: decorators.func.__name__
    [RESOLVE] RESOLVED to: decorators.func.__name__
      -> Not module state
      [NAME] Found name reference: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      [TYPE_INFERENCE] Call resolved to: decorators.func
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for result
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: decorators.result
    [RESOLVE] RESOLVED to: decorators.result
      -> Not module state
      [CALL] Found call: func
    [CACHE] func -> decorators.func (cached)
      -> Resolved to: decorators.func
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: decorators.args
    [RESOLVE] RESOLVED to: decorators.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
    [RESOLVE] RESOLVED to: decorators.kwargs
      -> Not module state
      [CALL] Found call: metrics_collector.record_success
    [RESOLVE] Attempting to resolve: ['metrics_collector', 'record_success']
    [RESOLVE] Chain resolution needed for: ['metrics_collector', 'record_success']
      [CHAIN] Resolving base: metrics_collector
      [RESOLVE_SIMPLE] Resolving base: metrics_collector
      [CACHE] Hit for metrics_collector: decorators.metrics_collector
      [CHAIN] Base resolved: metrics_collector -> decorators.metrics_collector
      [CHAIN] Step 1: Resolving decorators.metrics_collector.record_success
        [ATTRIBUTE] Resolving attribute: decorators.metrics_collector.record_success
        [ATTRIBUTE] Direct match found: decorators.metrics_collector.record_success
      [CHAIN] Step 1 resolved: decorators.metrics_collector.record_success
    [RESOLVE] RESOLVED to: decorators.metrics_collector.record_success
            [INTERMEDIATE] Tracking chain steps for: metrics_collector.record_success
            [INTERMEDIATE] Step 1: metrics_collector.record_success
      -> Resolved to: decorators.metrics_collector.record_success
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: monitor_id
    [RESOLVE] Attempting to resolve: ['monitor_id']
      [RESOLVE_SIMPLE] Resolving base: monitor_id
      [CACHE] Hit for monitor_id: decorators.monitor_id
    [RESOLVE] RESOLVED to: decorators.monitor_id
      [ATTRIBUTE] Found attribute access: metrics_collector.record_success
        [CACHE] metrics_collector.record_success -> decorators.metrics_collector.record_success (cached)
      -> Not module state
      [NAME] Found name reference: metrics_collector
        [CACHE] metrics_collector -> decorators.metrics_collector (cached)
      -> Not module state
      [NAME] Found name reference: monitor_id
        [CACHE] monitor_id -> decorators.monitor_id (cached)
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [CACHE] Hit for len: decorators.len
    [RESOLVE] RESOLVED to: decorators.len
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: decorators.str
    [RESOLVE] RESOLVED to: decorators.str
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [CACHE] Hit for Exception: decorators.Exception
    [RESOLVE] RESOLVED to: decorators.Exception
      -> Not module state
      [CALL] Found call: metrics_collector.record_error
    [RESOLVE] Attempting to resolve: ['metrics_collector', 'record_error']
    [RESOLVE] Chain resolution needed for: ['metrics_collector', 'record_error']
      [CHAIN] Resolving base: metrics_collector
      [RESOLVE_SIMPLE] Resolving base: metrics_collector
      [CACHE] Hit for metrics_collector: decorators.metrics_collector
      [CHAIN] Base resolved: metrics_collector -> decorators.metrics_collector
      [CHAIN] Step 1: Resolving decorators.metrics_collector.record_error
        [ATTRIBUTE] Resolving attribute: decorators.metrics_collector.record_error
        [ATTRIBUTE] Direct match found: decorators.metrics_collector.record_error
      [CHAIN] Step 1 resolved: decorators.metrics_collector.record_error
    [RESOLVE] RESOLVED to: decorators.metrics_collector.record_error
            [INTERMEDIATE] Tracking chain steps for: metrics_collector.record_error
            [INTERMEDIATE] Step 1: metrics_collector.record_error
      -> Resolved to: decorators.metrics_collector.record_error
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: monitor_id
    [RESOLVE] Attempting to resolve: ['monitor_id']
      [RESOLVE_SIMPLE] Resolving base: monitor_id
      [CACHE] Hit for monitor_id: decorators.monitor_id
    [RESOLVE] RESOLVED to: decorators.monitor_id
      [ATTRIBUTE] Found attribute access: metrics_collector.record_error
        [CACHE] metrics_collector.record_error -> decorators.metrics_collector.record_error (cached)
      -> Not module state
      [NAME] Found name reference: metrics_collector
        [CACHE] metrics_collector -> decorators.metrics_collector (cached)
      -> Not module state
      [NAME] Found name reference: monitor_id
        [CACHE] monitor_id -> decorators.monitor_id (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
        [CACHE] str -> decorators.str (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [CACHE] Hit for e: decorators.e
    [RESOLVE] RESOLVED to: decorators.e
      -> Not module state
      [CALL] Found call: metrics_collector.end_monitoring
    [RESOLVE] Attempting to resolve: ['metrics_collector', 'end_monitoring']
    [RESOLVE] Chain resolution needed for: ['metrics_collector', 'end_monitoring']
      [CHAIN] Resolving base: metrics_collector
      [RESOLVE_SIMPLE] Resolving base: metrics_collector
      [CACHE] Hit for metrics_collector: decorators.metrics_collector
      [CHAIN] Base resolved: metrics_collector -> decorators.metrics_collector
      [CHAIN] Step 1: Resolving decorators.metrics_collector.end_monitoring
        [ATTRIBUTE] Resolving attribute: decorators.metrics_collector.end_monitoring
        [ATTRIBUTE] Direct match found: decorators.metrics_collector.end_monitoring
      [CHAIN] Step 1 resolved: decorators.metrics_collector.end_monitoring
    [RESOLVE] RESOLVED to: decorators.metrics_collector.end_monitoring
            [INTERMEDIATE] Tracking chain steps for: metrics_collector.end_monitoring
            [INTERMEDIATE] Step 1: metrics_collector.end_monitoring
      -> Resolved to: decorators.metrics_collector.end_monitoring
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: monitor_id
    [RESOLVE] Attempting to resolve: ['monitor_id']
      [RESOLVE_SIMPLE] Resolving base: monitor_id
      [CACHE] Hit for monitor_id: decorators.monitor_id
    [RESOLVE] RESOLVED to: decorators.monitor_id
      [ATTRIBUTE] Found attribute access: metrics_collector.end_monitoring
        [CACHE] metrics_collector.end_monitoring -> decorators.metrics_collector.end_monitoring (cached)
      -> Not module state
      [NAME] Found name reference: metrics_collector
        [CACHE] metrics_collector -> decorators.metrics_collector (cached)
      -> Not module state
      [NAME] Found name reference: monitor_id
        [CACHE] monitor_id -> decorators.monitor_id (cached)
      -> Not module state
    [CONTEXT] Exited function: decorators.wrapper
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.wrapper
        Calls: 0
        Instantiations: 0
        State Access: 0
      [NAME] Found name reference: wrapper
    [RESOLVE] Attempting to resolve: ['wrapper']
      [RESOLVE_SIMPLE] Resolving base: wrapper
      [CACHE] Hit for wrapper: decorators.wrapper
    [RESOLVE] RESOLVED to: decorators.wrapper
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: monitor_decorator
    [RESOLVE] Attempting to resolve: ['monitor_decorator']
      [RESOLVE_SIMPLE] Resolving base: monitor_decorator
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable monitor_decorator not found in any scope
      [LOCAL_RESOLVER] can_resolve(monitor_decorator): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(monitor_decorator): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(monitor_decorator): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(monitor_decorator): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(monitor_decorator): decorators.monitor_decorator
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: monitor_decorator -> decorators.monitor_decorator
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.monitor_decorator
      -> Not module state
    [CONTEXT] Exited function: decorators.create_monitoring_decorator
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.create_monitoring_decorator
        Calls: 0
        Instantiations: 0
        State Access: 0
  [FUNCTION] Analyzing function: transaction_decorator
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.transaction_decorator
    [CONTEXT] Entered function: decorators.transaction_decorator (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'isolation_level': 'str', 'rollback_on': 'Optional[List[Type[Exception]]]'}
        [ARG_TYPE] Processing type annotation for isolation_level: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: decorators.str
    [RESOLVE] RESOLVED to: decorators.str
      [SYMBOL_UPDATE] Function: isolation_level -> decorators.str
        [ARG_TYPE] RESOLVED isolation_level : decorators.str
      [NESTED_FUNCTION] Analyzing nested function: decorator
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'isolation_level': 'str', 'rollback_on': 'Optional[List[Type[Exception]]]'}
        [ARG_TYPE] Processing type annotation for func: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Nested: func -> typing.Callable
        [ARG_TYPE] RESOLVED func : typing.Callable
  [FUNCTION] Analyzing function: wrapper
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.wrapper
    [DECORATOR] @wraps(func)
      [CODE_STANDARD_VIOLATION] MISSING_RETURN_TYPE: Function decorators.wrapper
      [IMPACT] Cannot infer return type - chained method calls may fail
      [ACTION_REQUIRED] Add appropriate type annotation
      [CODE_QUALITY] Found 1 violations in decorators.wrapper
    [CONTEXT] Entered function: decorators.wrapper (depth: 2)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [ASSIGNMENT] Processing: db_conn = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: get_db_connection
    [RESOLVE] Attempting to resolve: ['get_db_connection']
      [RESOLVE_SIMPLE] Resolving base: get_db_connection
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable get_db_connection not found in any scope
      [LOCAL_RESOLVER] can_resolve(get_db_connection): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(get_db_connection): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(get_db_connection): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(get_db_connection): database_manager.get_db_connection (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: get_db_connection -> database_manager.get_db_connection
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.get_db_connection
      [TYPE_INFERENCE] Call resolved to: database_manager.get_db_connection
        [RETURN_TYPE_RESOLUTION] Resolving return type: DatabaseConnection
        [RETURN_TYPE_RESOLUTION] Found in other module: database_manager.DatabaseConnection
      [TYPE_INFERENCE] RESOLVED Inferred type: database_manager.DatabaseConnection (from return type)
      [SYMBOL_UPDATE] Function: db_conn -> database_manager.DatabaseConnection
        [ASSIGNMENT] RESOLVED Updated symbol table: db_conn = database_manager.DatabaseConnection
      [NAME] Found name reference: db_conn
    [RESOLVE] Attempting to resolve: ['db_conn']
      [RESOLVE_SIMPLE] Resolving base: db_conn
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found db_conn in function scope: database_manager.DatabaseConnection
      [LOCAL_RESOLVER] can_resolve(db_conn): True
      [SYMBOL_LOOKUP] Found db_conn in function scope: database_manager.DatabaseConnection
      [LOCAL_RESOLVER] resolve(db_conn): database_manager.DatabaseConnection
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: db_conn -> database_manager.DatabaseConnection
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
      -> Not module state
      [CALL] Found call: get_db_connection
    [RESOLVE] Attempting to resolve: ['get_db_connection']
      [RESOLVE_SIMPLE] Resolving base: get_db_connection
      [CACHE] Hit for get_db_connection: database_manager.get_db_connection
    [RESOLVE] RESOLVED to: database_manager.get_db_connection
      -> Resolved to: database_manager.get_db_connection
      -> ADDED to calls
      [NAME] Found name reference: get_db_connection
        [CACHE] get_db_connection -> database_manager.get_db_connection (cached)
      -> Not module state
      [ASSIGNMENT] Processing: tx_manager = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: TransactionManager
    [RESOLVE] Attempting to resolve: ['TransactionManager']
      [RESOLVE_SIMPLE] Resolving base: TransactionManager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable TransactionManager not found in any scope
      [LOCAL_RESOLVER] can_resolve(TransactionManager): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(TransactionManager): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(TransactionManager): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(TransactionManager): database_manager.TransactionManager (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: TransactionManager -> database_manager.TransactionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      [TYPE_INFERENCE] Call resolved to: database_manager.TransactionManager
      [TYPE_INFERENCE] RESOLVED Inferred type: database_manager.TransactionManager (class instantiation)
      [SYMBOL_UPDATE] Function: tx_manager -> database_manager.TransactionManager
        [ASSIGNMENT] RESOLVED Updated symbol table: tx_manager = database_manager.TransactionManager
      [NAME] Found name reference: tx_manager
    [RESOLVE] Attempting to resolve: ['tx_manager']
      [RESOLVE_SIMPLE] Resolving base: tx_manager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found tx_manager in function scope: database_manager.TransactionManager
      [LOCAL_RESOLVER] can_resolve(tx_manager): True
      [SYMBOL_LOOKUP] Found tx_manager in function scope: database_manager.TransactionManager
      [LOCAL_RESOLVER] resolve(tx_manager): database_manager.TransactionManager
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: tx_manager -> database_manager.TransactionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      -> Not module state
      [CALL] Found call: TransactionManager
    [RESOLVE] Attempting to resolve: ['TransactionManager']
      [RESOLVE_SIMPLE] Resolving base: TransactionManager
      [CACHE] Hit for TransactionManager: database_manager.TransactionManager
    [RESOLVE] RESOLVED to: database_manager.TransactionManager
      -> Resolved to: database_manager.TransactionManager
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: db_conn
    [RESOLVE] Attempting to resolve: ['db_conn']
      [RESOLVE_SIMPLE] Resolving base: db_conn
      [CACHE] Hit for db_conn: database_manager.DatabaseConnection
    [RESOLVE] RESOLVED to: database_manager.DatabaseConnection
        [FUNCTION_ARG] Checking argument: isolation_level
    [RESOLVE] Attempting to resolve: ['isolation_level']
      [RESOLVE_SIMPLE] Resolving base: isolation_level
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable isolation_level not found in any scope
      [LOCAL_RESOLVER] can_resolve(isolation_level): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(isolation_level): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(isolation_level): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(isolation_level): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(isolation_level): decorators.isolation_level
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: isolation_level -> decorators.isolation_level
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.isolation_level
      [NAME] Found name reference: TransactionManager
        [CACHE] TransactionManager -> database_manager.TransactionManager (cached)
      -> Not module state
      [NAME] Found name reference: db_conn
        [CACHE] db_conn -> database_manager.DatabaseConnection (cached)
      -> Not module state
      [NAME] Found name reference: isolation_level
    [RESOLVE] Attempting to resolve: ['isolation_level']
      [RESOLVE_SIMPLE] Resolving base: isolation_level
      [CACHE] Hit for isolation_level: decorators.isolation_level
    [RESOLVE] RESOLVED to: decorators.isolation_level
      -> Not module state
      [CALL] Found call: tx_manager.begin_transaction
    [RESOLVE] Attempting to resolve: ['tx_manager', 'begin_transaction']
    [RESOLVE] Chain resolution needed for: ['tx_manager', 'begin_transaction']
      [CHAIN] Resolving base: tx_manager
      [RESOLVE_SIMPLE] Resolving base: tx_manager
      [CACHE] Hit for tx_manager: database_manager.TransactionManager
      [CHAIN] Base resolved: tx_manager -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.begin_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.begin_transaction
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.begin_transaction
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.begin_transaction
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.begin_transaction
            [INTERMEDIATE] Tracking chain steps for: tx_manager.begin_transaction
            [INTERMEDIATE] Step 1: tx_manager.begin_transaction
      -> Resolved to: database_manager.TransactionManager.begin_transaction
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: tx_manager.begin_transaction
        [CACHE] tx_manager.begin_transaction -> database_manager.TransactionManager.begin_transaction (cached)
      -> Not module state
      [NAME] Found name reference: tx_manager
        [CACHE] tx_manager -> database_manager.TransactionManager (cached)
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      [TYPE_INFERENCE] Call resolved to: decorators.func
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for result
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: decorators.result
    [RESOLVE] RESOLVED to: decorators.result
      -> Not module state
      [CALL] Found call: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: decorators.func
    [RESOLVE] RESOLVED to: decorators.func
      -> Resolved to: decorators.func
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: func
        [CACHE] func -> decorators.func (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: decorators.args
    [RESOLVE] RESOLVED to: decorators.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: decorators.kwargs
    [RESOLVE] RESOLVED to: decorators.kwargs
      -> Not module state
      [CALL] Found call: tx_manager.commit_transaction
    [RESOLVE] Attempting to resolve: ['tx_manager', 'commit_transaction']
    [RESOLVE] Chain resolution needed for: ['tx_manager', 'commit_transaction']
      [CHAIN] Resolving base: tx_manager
      [RESOLVE_SIMPLE] Resolving base: tx_manager
      [CACHE] Hit for tx_manager: database_manager.TransactionManager
      [CHAIN] Base resolved: tx_manager -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.commit_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.commit_transaction
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.commit_transaction
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.commit_transaction
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.commit_transaction
            [INTERMEDIATE] Tracking chain steps for: tx_manager.commit_transaction
            [INTERMEDIATE] Step 1: tx_manager.commit_transaction
      -> Resolved to: database_manager.TransactionManager.commit_transaction
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: tx_manager.commit_transaction
        [CACHE] tx_manager.commit_transaction -> database_manager.TransactionManager.commit_transaction (cached)
      -> Not module state
      [NAME] Found name reference: tx_manager
        [CACHE] tx_manager -> database_manager.TransactionManager (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [CACHE] Hit for Exception: decorators.Exception
    [RESOLVE] RESOLVED to: decorators.Exception
      -> Not module state
      [ASSIGNMENT] Processing: should_rollback = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: should_rollback
    [RESOLVE] Attempting to resolve: ['should_rollback']
      [RESOLVE_SIMPLE] Resolving base: should_rollback
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable should_rollback not found in any scope
      [LOCAL_RESOLVER] can_resolve(should_rollback): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(should_rollback): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(should_rollback): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(should_rollback): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(should_rollback): decorators.should_rollback
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: should_rollback -> decorators.should_rollback
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.should_rollback
      -> Not module state
      [NAME] Found name reference: rollback_on
    [RESOLVE] Attempting to resolve: ['rollback_on']
      [RESOLVE_SIMPLE] Resolving base: rollback_on
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable rollback_on not found in any scope
      [LOCAL_RESOLVER] can_resolve(rollback_on): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(rollback_on): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(rollback_on): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(rollback_on): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(rollback_on): decorators.rollback_on
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: rollback_on -> decorators.rollback_on
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.rollback_on
      -> Not module state
      [ASSIGNMENT] Processing: should_rollback = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: any
    [RESOLVE] Attempting to resolve: ['any']
      [RESOLVE_SIMPLE] Resolving base: any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable any not found in any scope
      [LOCAL_RESOLVER] can_resolve(any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(any): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(any): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(any): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(any): decorators.any
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: any -> decorators.any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.any
      [TYPE_INFERENCE] Call resolved to: decorators.any
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for should_rollback
      [NAME] Found name reference: should_rollback
        [CACHE] should_rollback -> decorators.should_rollback (cached)
      -> Not module state
      [CALL] Found call: any
      -> IGNORED (built-in function)
      [NAME] Found name reference: any
    [RESOLVE] Attempting to resolve: ['any']
      [RESOLVE_SIMPLE] Resolving base: any
      [CACHE] Hit for any: decorators.any
    [RESOLVE] RESOLVED to: decorators.any
      -> Not module state
      [CALL] Found call: isinstance
    [RESOLVE] Attempting to resolve: ['isinstance']
      [RESOLVE_SIMPLE] Resolving base: isinstance
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable isinstance not found in any scope
      [LOCAL_RESOLVER] can_resolve(isinstance): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(isinstance): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(isinstance): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(isinstance): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(isinstance): decorators.isinstance
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: isinstance -> decorators.isinstance
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.isinstance
      -> Resolved to: decorators.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [CACHE] Hit for e: decorators.e
    [RESOLVE] RESOLVED to: decorators.e
        [FUNCTION_ARG] Checking argument: exc_type
    [RESOLVE] Attempting to resolve: ['exc_type']
      [RESOLVE_SIMPLE] Resolving base: exc_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable exc_type not found in any scope
      [LOCAL_RESOLVER] can_resolve(exc_type): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(exc_type): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(exc_type): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(exc_type): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(exc_type): decorators.exc_type
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: exc_type -> decorators.exc_type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.exc_type
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> decorators.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [CACHE] Hit for e: decorators.e
    [RESOLVE] RESOLVED to: decorators.e
      -> Not module state
      [NAME] Found name reference: exc_type
    [RESOLVE] Attempting to resolve: ['exc_type']
      [RESOLVE_SIMPLE] Resolving base: exc_type
      [CACHE] Hit for exc_type: decorators.exc_type
    [RESOLVE] RESOLVED to: decorators.exc_type
      -> Not module state
      [NAME] Found name reference: exc_type
        [CACHE] exc_type -> decorators.exc_type (cached)
      -> Not module state
      [NAME] Found name reference: rollback_on
        [CACHE] rollback_on -> decorators.rollback_on (cached)
      -> Not module state
      [NAME] Found name reference: should_rollback
        [CACHE] should_rollback -> decorators.should_rollback (cached)
      -> Not module state
      [CALL] Found call: tx_manager.rollback_transaction
    [RESOLVE] Attempting to resolve: ['tx_manager', 'rollback_transaction']
    [RESOLVE] Chain resolution needed for: ['tx_manager', 'rollback_transaction']
      [CHAIN] Resolving base: tx_manager
      [RESOLVE_SIMPLE] Resolving base: tx_manager
      [CACHE] Hit for tx_manager: database_manager.TransactionManager
      [CHAIN] Base resolved: tx_manager -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.rollback_transaction
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.rollback_transaction
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.rollback_transaction
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.rollback_transaction
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.rollback_transaction
            [INTERMEDIATE] Tracking chain steps for: tx_manager.rollback_transaction
            [INTERMEDIATE] Step 1: tx_manager.rollback_transaction
      -> Resolved to: database_manager.TransactionManager.rollback_transaction
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: tx_manager.rollback_transaction
        [CACHE] tx_manager.rollback_transaction -> database_manager.TransactionManager.rollback_transaction (cached)
      -> Not module state
      [NAME] Found name reference: tx_manager
        [CACHE] tx_manager -> database_manager.TransactionManager (cached)
      -> Not module state
      [CALL] Found call: tx_manager.commit_transaction
    [CACHE] tx_manager.commit_transaction -> database_manager.TransactionManager.commit_transaction (cached)
            [INTERMEDIATE] Tracking chain steps for: tx_manager.commit_transaction
            [INTERMEDIATE] Step 1: tx_manager.commit_transaction
      -> Resolved to: database_manager.TransactionManager.commit_transaction
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: tx_manager.commit_transaction
        [CACHE] tx_manager.commit_transaction -> database_manager.TransactionManager.commit_transaction (cached)
      -> Not module state
      [NAME] Found name reference: tx_manager
        [CACHE] tx_manager -> database_manager.TransactionManager (cached)
      -> Not module state
      [CALL] Found call: tx_manager.close_connection
    [RESOLVE] Attempting to resolve: ['tx_manager', 'close_connection']
    [RESOLVE] Chain resolution needed for: ['tx_manager', 'close_connection']
      [CHAIN] Resolving base: tx_manager
      [RESOLVE_SIMPLE] Resolving base: tx_manager
      [CACHE] Hit for tx_manager: database_manager.TransactionManager
      [CHAIN] Base resolved: tx_manager -> database_manager.TransactionManager
      [CHAIN] Step 1: Resolving database_manager.TransactionManager.close_connection
        [ATTRIBUTE] Resolving attribute: database_manager.TransactionManager.close_connection
        [ATTRIBUTE] Direct match found: database_manager.TransactionManager.close_connection
      [CHAIN] Step 1 resolved: database_manager.TransactionManager.close_connection
    [RESOLVE] RESOLVED to: database_manager.TransactionManager.close_connection
            [INTERMEDIATE] Tracking chain steps for: tx_manager.close_connection
            [INTERMEDIATE] Step 1: tx_manager.close_connection
      -> Resolved to: database_manager.TransactionManager.close_connection
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: tx_manager.close_connection
        [CACHE] tx_manager.close_connection -> database_manager.TransactionManager.close_connection (cached)
      -> Not module state
      [NAME] Found name reference: tx_manager
        [CACHE] tx_manager -> database_manager.TransactionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: decorators.wrapper
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.wrapper
        Calls: 5
        Instantiations: 1
        State Access: 0
      [NAME] Found name reference: wrapper
    [RESOLVE] Attempting to resolve: ['wrapper']
      [RESOLVE_SIMPLE] Resolving base: wrapper
      [CACHE] Hit for wrapper: decorators.wrapper
    [RESOLVE] RESOLVED to: decorators.wrapper
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: decorator
    [RESOLVE] Attempting to resolve: ['decorator']
      [RESOLVE_SIMPLE] Resolving base: decorator
      [CACHE] Hit for decorator: decorators.decorator
    [RESOLVE] RESOLVED to: decorators.decorator
      -> Not module state
    [CONTEXT] Exited function: decorators.transaction_decorator
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.transaction_decorator
        Calls: 0
        Instantiations: 0
        State Access: 0
  [CLASS] Analyzing class: PropertyDecorator
    [CONTEXT] Entered class: decorators.PropertyDecorator
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.PropertyDecorator.__init__
    [CONTEXT] Entered function: decorators.PropertyDecorator.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 4 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'validator': 'Optional[Callable]', 'transformer': 'Optional[Callable]', 'cache': 'bool'}
        [ARG_TYPE] Processing type annotation for cache: bool
    [RESOLVE] Attempting to resolve: ['bool']
      [RESOLVE_SIMPLE] Resolving base: bool
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable bool not found in any scope
      [LOCAL_RESOLVER] can_resolve(bool): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(bool): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(bool): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(bool): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(bool): decorators.bool
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: bool -> decorators.bool
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.bool
      [SYMBOL_UPDATE] Function: cache -> decorators.bool
        [ARG_TYPE] RESOLVED cache : decorators.bool
      [ATTRIBUTE] Found attribute access: self.validator
    [RESOLVE] Attempting to resolve: ['self', 'validator']
    [RESOLVE] Chain resolution needed for: ['self', 'validator']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: decorators.PropertyDecorator)
      [SELF_RESOLVER] resolve(self): decorators.PropertyDecorator
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> decorators.PropertyDecorator
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> decorators.PropertyDecorator
      [CHAIN] Step 1: Resolving decorators.PropertyDecorator.validator
        [ATTRIBUTE] Resolving attribute: decorators.PropertyDecorator.validator
        [ATTRIBUTE] Direct match found: decorators.PropertyDecorator.validator
      [CHAIN] Step 1 resolved: decorators.PropertyDecorator.validator
    [RESOLVE] RESOLVED to: decorators.PropertyDecorator.validator
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.PropertyDecorator
    [RESOLVE] RESOLVED to: decorators.PropertyDecorator
      -> Not module state
      [NAME] Found name reference: validator
    [RESOLVE] Attempting to resolve: ['validator']
      [RESOLVE_SIMPLE] Resolving base: validator
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable validator not found in any scope
      [LOCAL_RESOLVER] can_resolve(validator): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(validator): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(validator): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(validator): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(validator): decorators.validator
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: validator -> decorators.validator
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.validator
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.transformer
    [RESOLVE] Attempting to resolve: ['self', 'transformer']
    [RESOLVE] Chain resolution needed for: ['self', 'transformer']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.PropertyDecorator
      [CHAIN] Base resolved: self -> decorators.PropertyDecorator
      [CHAIN] Step 1: Resolving decorators.PropertyDecorator.transformer
        [ATTRIBUTE] Resolving attribute: decorators.PropertyDecorator.transformer
        [ATTRIBUTE] Direct match found: decorators.PropertyDecorator.transformer
      [CHAIN] Step 1 resolved: decorators.PropertyDecorator.transformer
    [RESOLVE] RESOLVED to: decorators.PropertyDecorator.transformer
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [NAME] Found name reference: transformer
    [RESOLVE] Attempting to resolve: ['transformer']
      [RESOLVE_SIMPLE] Resolving base: transformer
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable transformer not found in any scope
      [LOCAL_RESOLVER] can_resolve(transformer): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(transformer): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(transformer): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(transformer): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(transformer): decorators.transformer
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: transformer -> decorators.transformer
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.transformer
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache
    [RESOLVE] Attempting to resolve: ['self', 'cache']
    [RESOLVE] Chain resolution needed for: ['self', 'cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.PropertyDecorator
      [CHAIN] Base resolved: self -> decorators.PropertyDecorator
      [CHAIN] Step 1: Resolving decorators.PropertyDecorator.cache
        [ATTRIBUTE] Resolving attribute: decorators.PropertyDecorator.cache
        [ATTRIBUTE] Direct match found: decorators.PropertyDecorator.cache
      [CHAIN] Step 1 resolved: decorators.PropertyDecorator.cache
    [RESOLVE] RESOLVED to: decorators.PropertyDecorator.cache
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [NAME] Found name reference: cache
    [RESOLVE] Attempting to resolve: ['cache']
      [RESOLVE_SIMPLE] Resolving base: cache
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found cache in function scope: decorators.bool
      [LOCAL_RESOLVER] can_resolve(cache): True
      [SYMBOL_LOOKUP] Found cache in function scope: decorators.bool
      [LOCAL_RESOLVER] resolve(cache): decorators.bool
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: cache -> decorators.bool
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.bool
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_storage
    [RESOLVE] Attempting to resolve: ['self', '_cache_storage']
    [RESOLVE] Chain resolution needed for: ['self', '_cache_storage']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.PropertyDecorator
      [CHAIN] Base resolved: self -> decorators.PropertyDecorator
      [CHAIN] Step 1: Resolving decorators.PropertyDecorator._cache_storage
        [ATTRIBUTE] Resolving attribute: decorators.PropertyDecorator._cache_storage
        [ATTRIBUTE] Direct match found: decorators.PropertyDecorator._cache_storage
      [CHAIN] Step 1 resolved: decorators.PropertyDecorator._cache_storage
    [RESOLVE] RESOLVED to: decorators.PropertyDecorator._cache_storage
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: int
    [RESOLVE] Attempting to resolve: ['int']
      [RESOLVE_SIMPLE] Resolving base: int
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable int not found in any scope
      [LOCAL_RESOLVER] can_resolve(int): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(int): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(int): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(int): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(int): decorators.int
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: int -> decorators.int
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.int
      -> Not module state
      [NAME] Found name reference: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
    [CONTEXT] Exited function: decorators.PropertyDecorator.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.PropertyDecorator.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.PropertyDecorator.__call__
    [CONTEXT] Entered function: decorators.PropertyDecorator.__call__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'func': 'Callable'}
        [ARG_TYPE] Processing type annotation for func: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Callable not found in any scope
      [LOCAL_RESOLVER] can_resolve(Callable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Callable): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Callable): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Callable): typing.Callable (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Callable -> typing.Callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Function: func -> typing.Callable
        [ARG_TYPE] RESOLVED func : typing.Callable
      [NESTED_FUNCTION] Analyzing nested function: getter
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'func': 'Callable'}
        [ARG_TYPE] No type hint or recon data for instance
      [ATTRIBUTE] Found attribute access: self.cache
    [RESOLVE] Attempting to resolve: ['self', 'cache']
    [RESOLVE] Chain resolution needed for: ['self', 'cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.PropertyDecorator
      [CHAIN] Base resolved: self -> decorators.PropertyDecorator
      [CHAIN] Step 1: Resolving decorators.PropertyDecorator.cache
        [ATTRIBUTE] Resolving attribute: decorators.PropertyDecorator.cache
        [ATTRIBUTE] Direct match found: decorators.PropertyDecorator.cache
      [CHAIN] Step 1 resolved: decorators.PropertyDecorator.cache
    [RESOLVE] RESOLVED to: decorators.PropertyDecorator.cache
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.PropertyDecorator
    [RESOLVE] RESOLVED to: decorators.PropertyDecorator
      -> Not module state
      [ASSIGNMENT] Processing: instance_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: id
    [RESOLVE] Attempting to resolve: ['id']
      [RESOLVE_SIMPLE] Resolving base: id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable id not found in any scope
      [LOCAL_RESOLVER] can_resolve(id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(id): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(id): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(id): decorators.id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: id -> decorators.id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.id
      [TYPE_INFERENCE] Call resolved to: decorators.id
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for instance_id
      [NAME] Found name reference: instance_id
    [RESOLVE] Attempting to resolve: ['instance_id']
      [RESOLVE_SIMPLE] Resolving base: instance_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable instance_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(instance_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(instance_id): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(instance_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(instance_id): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(instance_id): decorators.instance_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: instance_id -> decorators.instance_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.instance_id
      -> Not module state
      [CALL] Found call: id
    [RESOLVE] Attempting to resolve: ['id']
      [RESOLVE_SIMPLE] Resolving base: id
      [CACHE] Hit for id: decorators.id
    [RESOLVE] RESOLVED to: decorators.id
      -> Resolved to: decorators.id
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: instance
    [RESOLVE] Attempting to resolve: ['instance']
      [RESOLVE_SIMPLE] Resolving base: instance
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable instance not found in any scope
      [LOCAL_RESOLVER] can_resolve(instance): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(instance): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(instance): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(instance): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(instance): decorators.instance
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: instance -> decorators.instance
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.instance
      [NAME] Found name reference: id
        [CACHE] id -> decorators.id (cached)
      -> Not module state
      [NAME] Found name reference: instance
    [RESOLVE] Attempting to resolve: ['instance']
      [RESOLVE_SIMPLE] Resolving base: instance
      [CACHE] Hit for instance: decorators.instance
    [RESOLVE] RESOLVED to: decorators.instance
      -> Not module state
      [NAME] Found name reference: instance_id
        [CACHE] instance_id -> decorators.instance_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_storage
    [RESOLVE] Attempting to resolve: ['self', '_cache_storage']
    [RESOLVE] Chain resolution needed for: ['self', '_cache_storage']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.PropertyDecorator
      [CHAIN] Base resolved: self -> decorators.PropertyDecorator
      [CHAIN] Step 1: Resolving decorators.PropertyDecorator._cache_storage
        [ATTRIBUTE] Resolving attribute: decorators.PropertyDecorator._cache_storage
        [ATTRIBUTE] Direct match found: decorators.PropertyDecorator._cache_storage
      [CHAIN] Step 1 resolved: decorators.PropertyDecorator._cache_storage
    [RESOLVE] RESOLVED to: decorators.PropertyDecorator._cache_storage
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_storage
        [CACHE] self._cache_storage -> decorators.PropertyDecorator._cache_storage (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [NAME] Found name reference: instance_id
        [CACHE] instance_id -> decorators.instance_id (cached)
      -> Not module state
      [ASSIGNMENT] Processing: value = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found func in function scope: typing.Callable
      [LOCAL_RESOLVER] can_resolve(func): True
      [SYMBOL_LOOKUP] Found func in function scope: typing.Callable
      [LOCAL_RESOLVER] resolve(func): typing.Callable
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: func -> typing.Callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Callable
      [TYPE_INFERENCE] Call resolved to: typing.Callable
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for value
      [NAME] Found name reference: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable value not found in any scope
      [LOCAL_RESOLVER] can_resolve(value): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(value): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(value): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(value): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(value): decorators.value
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: value -> decorators.value
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.value
      -> Not module state
      [CALL] Found call: func
    [RESOLVE] Attempting to resolve: ['func']
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      -> Resolved to: typing.Callable
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: instance
    [RESOLVE] Attempting to resolve: ['instance']
      [RESOLVE_SIMPLE] Resolving base: instance
      [CACHE] Hit for instance: decorators.instance
    [RESOLVE] RESOLVED to: decorators.instance
      [NAME] Found name reference: func
        [CACHE] func -> typing.Callable (cached)
      -> Not module state
      [NAME] Found name reference: instance
        [CACHE] instance -> decorators.instance (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.transformer
    [RESOLVE] Attempting to resolve: ['self', 'transformer']
    [RESOLVE] Chain resolution needed for: ['self', 'transformer']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.PropertyDecorator
      [CHAIN] Base resolved: self -> decorators.PropertyDecorator
      [CHAIN] Step 1: Resolving decorators.PropertyDecorator.transformer
        [ATTRIBUTE] Resolving attribute: decorators.PropertyDecorator.transformer
        [ATTRIBUTE] Direct match found: decorators.PropertyDecorator.transformer
      [CHAIN] Step 1 resolved: decorators.PropertyDecorator.transformer
    [RESOLVE] RESOLVED to: decorators.PropertyDecorator.transformer
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [ASSIGNMENT] Processing: value = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.transformer
    [RESOLVE] Attempting to resolve: ['self', 'transformer']
    [RESOLVE] Chain resolution needed for: ['self', 'transformer']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.PropertyDecorator
      [CHAIN] Base resolved: self -> decorators.PropertyDecorator
      [CHAIN] Step 1: Resolving decorators.PropertyDecorator.transformer
        [ATTRIBUTE] Resolving attribute: decorators.PropertyDecorator.transformer
        [ATTRIBUTE] Direct match found: decorators.PropertyDecorator.transformer
      [CHAIN] Step 1 resolved: decorators.PropertyDecorator.transformer
    [RESOLVE] RESOLVED to: decorators.PropertyDecorator.transformer
      [TYPE_INFERENCE] Call resolved to: decorators.PropertyDecorator.transformer
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for value
      [NAME] Found name reference: value
        [CACHE] value -> decorators.value (cached)
      -> Not module state
      [CALL] Found call: self.transformer
    [CACHE] self.transformer -> decorators.PropertyDecorator.transformer (cached)
            [INTERMEDIATE] Tracking chain steps for: self.transformer
            [INTERMEDIATE] Step 1: self.transformer
      -> Resolved to: decorators.PropertyDecorator.transformer
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: decorators.value
    [RESOLVE] RESOLVED to: decorators.value
      [ATTRIBUTE] Found attribute access: self.transformer
        [CACHE] self.transformer -> decorators.PropertyDecorator.transformer (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> decorators.value (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache
        [CACHE] self.cache -> decorators.PropertyDecorator.cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_storage
        [CACHE] self._cache_storage -> decorators.PropertyDecorator._cache_storage (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [CALL] Found call: id
    [CACHE] id -> decorators.id (cached)
      -> Resolved to: decorators.id
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: instance
    [RESOLVE] Attempting to resolve: ['instance']
      [RESOLVE_SIMPLE] Resolving base: instance
      [CACHE] Hit for instance: decorators.instance
    [RESOLVE] RESOLVED to: decorators.instance
      [NAME] Found name reference: id
        [CACHE] id -> decorators.id (cached)
      -> Not module state
      [NAME] Found name reference: instance
        [CACHE] instance -> decorators.instance (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> decorators.value (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> decorators.value (cached)
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NESTED_FUNCTION] Analyzing nested function: setter
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'func': 'Callable'}
        [ARG_TYPE] No type hint or recon data for instance
        [ARG_TYPE] No type hint or recon data for value
      [ATTRIBUTE] Found attribute access: self.validator
    [RESOLVE] Attempting to resolve: ['self', 'validator']
    [RESOLVE] Chain resolution needed for: ['self', 'validator']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: decorators.PropertyDecorator
      [CHAIN] Base resolved: self -> decorators.PropertyDecorator
      [CHAIN] Step 1: Resolving decorators.PropertyDecorator.validator
        [ATTRIBUTE] Resolving attribute: decorators.PropertyDecorator.validator
        [ATTRIBUTE] Direct match found: decorators.PropertyDecorator.validator
      [CHAIN] Step 1 resolved: decorators.PropertyDecorator.validator
    [RESOLVE] RESOLVED to: decorators.PropertyDecorator.validator
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [CALL] Found call: self.validator
    [CACHE] self.validator -> decorators.PropertyDecorator.validator (cached)
            [INTERMEDIATE] Tracking chain steps for: self.validator
            [INTERMEDIATE] Step 1: self.validator
      -> Resolved to: decorators.PropertyDecorator.validator
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: decorators.value
    [RESOLVE] RESOLVED to: decorators.value
      [ATTRIBUTE] Found attribute access: self.validator
        [CACHE] self.validator -> decorators.PropertyDecorator.validator (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> decorators.value (cached)
      -> Not module state
      [CALL] Found call: ValueError
    [RESOLVE] Attempting to resolve: ['ValueError']
      [RESOLVE_SIMPLE] Resolving base: ValueError
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValueError not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValueError): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValueError): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValueError): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValueError): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(ValueError): decorators.ValueError
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValueError -> decorators.ValueError
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.ValueError
      -> Resolved to: decorators.ValueError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: ValueError
        [CACHE] ValueError -> decorators.ValueError (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: func.__name__
    [RESOLVE] Attempting to resolve: ['func', '__name__']
    [RESOLVE] Chain resolution needed for: ['func', '__name__']
      [CHAIN] Resolving base: func
      [RESOLVE_SIMPLE] Resolving base: func
      [CACHE] Hit for func: typing.Callable
      [CHAIN] Base resolved: func -> typing.Callable
      [CHAIN] Step 1: Resolving typing.Callable.__name__
        [ATTRIBUTE] Resolving attribute: typing.Callable.__name__
        [ATTRIBUTE] Direct match found: typing.Callable.__name__
      [CHAIN] Step 1 resolved: typing.Callable.__name__
    [RESOLVE] RESOLVED to: typing.Callable.__name__
      -> Not module state
      [NAME] Found name reference: func
        [CACHE] func -> typing.Callable (cached)
      -> Not module state
      [ASSIGNMENT] Processing: instance_attr = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: instance_attr
    [RESOLVE] Attempting to resolve: ['instance_attr']
      [RESOLVE_SIMPLE] Resolving base: instance_attr
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable instance_attr not found in any scope
      [LOCAL_RESOLVER] can_resolve(instance_attr): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(instance_attr): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(instance_attr): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(instance_attr): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(instance_attr): decorators.instance_attr
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: instance_attr -> decorators.instance_attr
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.instance_attr
      -> Not module state
      [ATTRIBUTE] Found attribute access: func.__name__
        [CACHE] func.__name__ -> typing.Callable.__name__ (cached)
      -> Not module state
      [NAME] Found name reference: func
        [CACHE] func -> typing.Callable (cached)
      -> Not module state
      [CALL] Found call: setattr
    [RESOLVE] Attempting to resolve: ['setattr']
      [RESOLVE_SIMPLE] Resolving base: setattr
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable setattr not found in any scope
      [LOCAL_RESOLVER] can_resolve(setattr): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(setattr): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(setattr): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(setattr): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(setattr): decorators.setattr
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: setattr -> decorators.setattr
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.setattr
      -> Resolved to: decorators.setattr
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: instance
    [RESOLVE] Attempting to resolve: ['instance']
      [RESOLVE_SIMPLE] Resolving base: instance
      [CACHE] Hit for instance: decorators.instance
    [RESOLVE] RESOLVED to: decorators.instance
        [FUNCTION_ARG] Checking argument: instance_attr
    [RESOLVE] Attempting to resolve: ['instance_attr']
      [RESOLVE_SIMPLE] Resolving base: instance_attr
      [CACHE] Hit for instance_attr: decorators.instance_attr
    [RESOLVE] RESOLVED to: decorators.instance_attr
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: decorators.value
    [RESOLVE] RESOLVED to: decorators.value
      [NAME] Found name reference: setattr
        [CACHE] setattr -> decorators.setattr (cached)
      -> Not module state
      [NAME] Found name reference: instance
        [CACHE] instance -> decorators.instance (cached)
      -> Not module state
      [NAME] Found name reference: instance_attr
        [CACHE] instance_attr -> decorators.instance_attr (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> decorators.value (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache
        [CACHE] self.cache -> decorators.PropertyDecorator.cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [ASSIGNMENT] Processing: instance_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: id
    [RESOLVE] Attempting to resolve: ['id']
      [RESOLVE_SIMPLE] Resolving base: id
      [CACHE] Hit for id: decorators.id
    [RESOLVE] RESOLVED to: decorators.id
      [TYPE_INFERENCE] Call resolved to: decorators.id
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for instance_id
      [NAME] Found name reference: instance_id
        [CACHE] instance_id -> decorators.instance_id (cached)
      -> Not module state
      [CALL] Found call: id
    [CACHE] id -> decorators.id (cached)
      -> Resolved to: decorators.id
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: instance
    [RESOLVE] Attempting to resolve: ['instance']
      [RESOLVE_SIMPLE] Resolving base: instance
      [CACHE] Hit for instance: decorators.instance
    [RESOLVE] RESOLVED to: decorators.instance
      [NAME] Found name reference: id
        [CACHE] id -> decorators.id (cached)
      -> Not module state
      [NAME] Found name reference: instance
        [CACHE] instance -> decorators.instance (cached)
      -> Not module state
      [NAME] Found name reference: instance_id
        [CACHE] instance_id -> decorators.instance_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_storage
        [CACHE] self._cache_storage -> decorators.PropertyDecorator._cache_storage (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_storage
        [CACHE] self._cache_storage -> decorators.PropertyDecorator._cache_storage (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> decorators.PropertyDecorator (cached)
      -> Not module state
      [NAME] Found name reference: instance_id
        [CACHE] instance_id -> decorators.instance_id (cached)
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [CALL] Found call: property
    [RESOLVE] Attempting to resolve: ['property']
      [RESOLVE_SIMPLE] Resolving base: property
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable property not found in any scope
      [LOCAL_RESOLVER] can_resolve(property): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(property): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(property): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(property): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(property): decorators.property
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: property -> decorators.property
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.property
      -> Resolved to: decorators.property
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: getter
    [RESOLVE] Attempting to resolve: ['getter']
      [RESOLVE_SIMPLE] Resolving base: getter
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable getter not found in any scope
      [LOCAL_RESOLVER] can_resolve(getter): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(getter): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(getter): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(getter): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(getter): decorators.getter
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: getter -> decorators.getter
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.getter
        [FUNCTION_ARG] Checking argument: setter
    [RESOLVE] Attempting to resolve: ['setter']
      [RESOLVE_SIMPLE] Resolving base: setter
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable setter not found in any scope
      [LOCAL_RESOLVER] can_resolve(setter): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(setter): False (current_class: decorators.PropertyDecorator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(setter): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(setter): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(setter): decorators.setter
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: setter -> decorators.setter
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.setter
      [NAME] Found name reference: property
        [CACHE] property -> decorators.property (cached)
      -> Not module state
      [NAME] Found name reference: getter
    [RESOLVE] Attempting to resolve: ['getter']
      [RESOLVE_SIMPLE] Resolving base: getter
      [CACHE] Hit for getter: decorators.getter
    [RESOLVE] RESOLVED to: decorators.getter
      -> Not module state
      [NAME] Found name reference: setter
    [RESOLVE] Attempting to resolve: ['setter']
      [RESOLVE_SIMPLE] Resolving base: setter
      [CACHE] Hit for setter: decorators.setter
    [RESOLVE] RESOLVED to: decorators.setter
      -> Not module state
    [CONTEXT] Exited function: decorators.PropertyDecorator.__call__
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.PropertyDecorator.__call__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: decorators.PropertyDecorator
    [SYMBOL_TABLE] Exited class scope
  [FUNCTION] Analyzing function: complex_calculation
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.complex_calculation
    [DECORATOR] @trace(level='DEBUG', include_args=True, include_result=True)
    [DECORATOR] @monitor_performance(threshold_ms=500.0)
    [CONTEXT] Entered function: decorators.complex_calculation (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'List[Dict[str, Any]]', 'multiplier': 'float'}
        [ARG_TYPE] Processing type annotation for multiplier: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable float not found in any scope
      [LOCAL_RESOLVER] can_resolve(float): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(float): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(float): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(float): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(float): decorators.float
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: float -> decorators.float
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.float
      [SYMBOL_UPDATE] Function: multiplier -> decorators.float
        [ARG_TYPE] RESOLVED multiplier : decorators.float
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: decorators.result
    [RESOLVE] RESOLVED to: decorators.result
      -> Not module state
      [NAME] Found name reference: item
    [RESOLVE] Attempting to resolve: ['item']
      [RESOLVE_SIMPLE] Resolving base: item
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable item not found in any scope
      [LOCAL_RESOLVER] can_resolve(item): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(item): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(item): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(item): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(item): decorators.item
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: item -> decorators.item
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.item
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable data not found in any scope
      [LOCAL_RESOLVER] can_resolve(data): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(data): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(data): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(data): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(data): decorators.data
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: data -> decorators.data
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.data
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> decorators.item (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
      [CALL] Found call: item.get
    [RESOLVE] Attempting to resolve: ['item', 'get']
    [RESOLVE] Chain resolution needed for: ['item', 'get']
      [CHAIN] Resolving base: item
      [RESOLVE_SIMPLE] Resolving base: item
      [CACHE] Hit for item: decorators.item
      [CHAIN] Base resolved: item -> decorators.item
      [CHAIN] Step 1: Resolving decorators.item.get
        [ATTRIBUTE] Resolving attribute: decorators.item.get
        [ATTRIBUTE] Direct match found: decorators.item.get
      [CHAIN] Step 1 resolved: decorators.item.get
    [RESOLVE] RESOLVED to: decorators.item.get
            [INTERMEDIATE] Tracking chain steps for: item.get
            [INTERMEDIATE] Step 1: item.get
      -> Resolved to: decorators.item.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: item.get
        [CACHE] item.get -> decorators.item.get (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> decorators.item (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> decorators.item (cached)
      -> Not module state
      [NAME] Found name reference: multiplier
    [RESOLVE] Attempting to resolve: ['multiplier']
      [RESOLVE_SIMPLE] Resolving base: multiplier
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found multiplier in function scope: decorators.float
      [LOCAL_RESOLVER] can_resolve(multiplier): True
      [SYMBOL_LOOKUP] Found multiplier in function scope: decorators.float
      [LOCAL_RESOLVER] resolve(multiplier): decorators.float
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: multiplier -> decorators.float
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.float
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> decorators.result (cached)
      -> Not module state
    [CONTEXT] Exited function: decorators.complex_calculation
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.complex_calculation
        Calls: 0
        Instantiations: 0
        State Access: 0
  [FUNCTION] Analyzing function: admin_operation
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.admin_operation
    [DECORATOR] @validate_auth(required_role='admin')
    [DECORATOR] @rate_limit(calls=5, period=300)
    [DECORATOR] @ClassBasedDecorator({'log_calls': True, 'validate_args': True, 'transform_result': True})
    [CONTEXT] Entered function: decorators.admin_operation (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'operation_type': 'str', 'parameters': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for operation_type: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: decorators.str
    [RESOLVE] RESOLVED to: decorators.str
      [SYMBOL_UPDATE] Function: operation_type -> decorators.str
        [ARG_TYPE] RESOLVED operation_type : decorators.str
      [ASSIGNMENT] Processing: admin_mgr = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: AdminManager
    [RESOLVE] Attempting to resolve: ['AdminManager']
      [RESOLVE_SIMPLE] Resolving base: AdminManager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable AdminManager not found in any scope
      [LOCAL_RESOLVER] can_resolve(AdminManager): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(AdminManager): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(AdminManager): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(AdminManager): admin_manager.AdminManager (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: AdminManager -> admin_manager.AdminManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      [TYPE_INFERENCE] Call resolved to: admin_manager.AdminManager
      [TYPE_INFERENCE] RESOLVED Inferred type: admin_manager.AdminManager (class instantiation)
      [SYMBOL_UPDATE] Function: admin_mgr -> admin_manager.AdminManager
        [ASSIGNMENT] RESOLVED Updated symbol table: admin_mgr = admin_manager.AdminManager
      [NAME] Found name reference: admin_mgr
    [RESOLVE] Attempting to resolve: ['admin_mgr']
      [RESOLVE_SIMPLE] Resolving base: admin_mgr
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found admin_mgr in function scope: admin_manager.AdminManager
      [LOCAL_RESOLVER] can_resolve(admin_mgr): True
      [SYMBOL_LOOKUP] Found admin_mgr in function scope: admin_manager.AdminManager
      [LOCAL_RESOLVER] resolve(admin_mgr): admin_manager.AdminManager
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: admin_mgr -> admin_manager.AdminManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      -> Not module state
      [CALL] Found call: AdminManager
    [RESOLVE] Attempting to resolve: ['AdminManager']
      [RESOLVE_SIMPLE] Resolving base: AdminManager
      [CACHE] Hit for AdminManager: admin_manager.AdminManager
    [RESOLVE] RESOLVED to: admin_manager.AdminManager
      -> Resolved to: admin_manager.AdminManager
      -> ADDED to instantiations
      [NAME] Found name reference: AdminManager
        [CACHE] AdminManager -> admin_manager.AdminManager (cached)
      -> Not module state
      [CALL] Found call: admin_mgr.execute_operation
    [RESOLVE] Attempting to resolve: ['admin_mgr', 'execute_operation']
    [RESOLVE] Chain resolution needed for: ['admin_mgr', 'execute_operation']
      [CHAIN] Resolving base: admin_mgr
      [RESOLVE_SIMPLE] Resolving base: admin_mgr
      [CACHE] Hit for admin_mgr: admin_manager.AdminManager
      [CHAIN] Base resolved: admin_mgr -> admin_manager.AdminManager
      [CHAIN] Step 1: Resolving admin_manager.AdminManager.execute_operation
        [ATTRIBUTE] Resolving attribute: admin_manager.AdminManager.execute_operation
        [ATTRIBUTE] Direct match found: admin_manager.AdminManager.execute_operation
      [CHAIN] Step 1 resolved: admin_manager.AdminManager.execute_operation
    [RESOLVE] RESOLVED to: admin_manager.AdminManager.execute_operation
            [INTERMEDIATE] Tracking chain steps for: admin_mgr.execute_operation
            [INTERMEDIATE] Step 1: admin_mgr.execute_operation
      -> Resolved to: admin_manager.AdminManager.execute_operation
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: operation_type
    [RESOLVE] Attempting to resolve: ['operation_type']
      [RESOLVE_SIMPLE] Resolving base: operation_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found operation_type in function scope: decorators.str
      [LOCAL_RESOLVER] can_resolve(operation_type): True
      [SYMBOL_LOOKUP] Found operation_type in function scope: decorators.str
      [LOCAL_RESOLVER] resolve(operation_type): decorators.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: operation_type -> decorators.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.str
        [FUNCTION_ARG] Checking argument: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable parameters not found in any scope
      [LOCAL_RESOLVER] can_resolve(parameters): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(parameters): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(parameters): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(parameters): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(parameters): decorators.parameters
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: parameters -> decorators.parameters
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.parameters
      [ATTRIBUTE] Found attribute access: admin_mgr.execute_operation
        [CACHE] admin_mgr.execute_operation -> admin_manager.AdminManager.execute_operation (cached)
      -> Not module state
      [NAME] Found name reference: admin_mgr
        [CACHE] admin_mgr -> admin_manager.AdminManager (cached)
      -> Not module state
      [NAME] Found name reference: operation_type
    [RESOLVE] Attempting to resolve: ['operation_type']
      [RESOLVE_SIMPLE] Resolving base: operation_type
      [CACHE] Hit for operation_type: decorators.str
    [RESOLVE] RESOLVED to: decorators.str
      -> Not module state
      [NAME] Found name reference: parameters
    [RESOLVE] Attempting to resolve: ['parameters']
      [RESOLVE_SIMPLE] Resolving base: parameters
      [CACHE] Hit for parameters: decorators.parameters
    [RESOLVE] RESOLVED to: decorators.parameters
      -> Not module state
    [CONTEXT] Exited function: decorators.admin_operation
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.admin_operation
        Calls: 1
        Instantiations: 1
        State Access: 0
      [ASSIGNMENT] Processing: performance_monitor = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: create_custom_decorator
    [RESOLVE] Attempting to resolve: ['create_custom_decorator']
      [RESOLVE_SIMPLE] Resolving base: create_custom_decorator
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable create_custom_decorator not found in any scope
      [LOCAL_RESOLVER] can_resolve(create_custom_decorator): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(create_custom_decorator): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(create_custom_decorator): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(create_custom_decorator): True (fallback, module: decorators)
      [MODULE_RESOLVER] resolve(create_custom_decorator): decorators.create_custom_decorator
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: create_custom_decorator -> decorators.create_custom_decorator
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.create_custom_decorator
      [TYPE_INFERENCE] Call resolved to: decorators.create_custom_decorator
        [RETURN_TYPE_RESOLUTION] Resolving return type: Callable
        [RETURN_TYPE_RESOLUTION] Class 'Callable' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: Callable
      [TYPE_INFERENCE] Could not resolve return type 'Callable' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: Callable (from return type - unresolved)
      [SYMBOL_UPDATE] Function: performance_monitor -> Callable
        [ASSIGNMENT] RESOLVED Updated symbol table: performance_monitor = Callable
  [FUNCTION] Analyzing function: cached_expensive_operation
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.cached_expensive_operation
    [DECORATOR] @performance_monitor
    [DECORATOR] @advanced_cache(ttl=600, key_func=lambda x: f'cache_{hash(str(x))}')
    [CONTEXT] Entered function: decorators.cached_expensive_operation (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'input_data': 'Any'}
        [ARG_TYPE] Processing type annotation for input_data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: input_data -> typing.Any
        [ARG_TYPE] RESOLVED input_data : typing.Any
      [CALL] Found call: time.sleep
    [RESOLVE] Attempting to resolve: ['time', 'sleep']
    [RESOLVE] Chain resolution needed for: ['time', 'sleep']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.sleep
        [ATTRIBUTE] Resolving attribute: time.sleep
        [ATTRIBUTE] Direct match found: time.sleep
      [CHAIN] Step 1 resolved: time.sleep
    [RESOLVE] RESOLVED to: time.sleep
            [INTERMEDIATE] Tracking chain steps for: time.sleep
            [INTERMEDIATE] Step 1: time.sleep
      -> Resolved to: time.sleep
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.sleep
        [CACHE] time.sleep -> time.sleep (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [NAME] Found name reference: input_data
    [RESOLVE] Attempting to resolve: ['input_data']
      [RESOLVE_SIMPLE] Resolving base: input_data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found input_data in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(input_data): True
      [SYMBOL_LOOKUP] Found input_data in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(input_data): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: input_data -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
    [CONTEXT] Exited function: decorators.cached_expensive_operation
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.cached_expensive_operation
        Calls: 0
        Instantiations: 0
        State Access: 0
  [FUNCTION] Analyzing function: debug_function
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.debug_function
    [DECORATOR] @conditional_decorator(condition=lambda func: func.__name__.startswith('debug_'), decorator=trace(level='DEBUG'))
    [CONTEXT] Entered function: decorators.debug_function (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
    [CONTEXT] Exited function: decorators.debug_function
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.debug_function
        Calls: 0
        Instantiations: 0
        State Access: 0
  [FUNCTION] Analyzing function: multi_decorated_function
    [FUNCTION_ANALYSIS] Starting analysis of: decorators.multi_decorated_function
    [DECORATOR] @multi_decorator(trace(), monitor_performance(), rate_limit(calls=10, period=60))
    [CONTEXT] Entered function: decorators.multi_decorated_function (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'param': 'str'}
        [ARG_TYPE] Processing type annotation for param: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: decorators.str
    [RESOLVE] RESOLVED to: decorators.str
      [SYMBOL_UPDATE] Function: param -> decorators.str
        [ARG_TYPE] RESOLVED param : decorators.str
      [NAME] Found name reference: param
    [RESOLVE] Attempting to resolve: ['param']
      [RESOLVE_SIMPLE] Resolving base: param
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found param in function scope: decorators.str
      [LOCAL_RESOLVER] can_resolve(param): True
      [SYMBOL_LOOKUP] Found param in function scope: decorators.str
      [LOCAL_RESOLVER] resolve(param): decorators.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: param -> decorators.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: decorators.str
      -> Not module state
    [CONTEXT] Exited function: decorators.multi_decorated_function
    [FUNCTION_ANALYSIS] Completed analysis of: decorators.multi_decorated_function
        Calls: 0
        Instantiations: 0
        State Access: 0
=== Module Analysis Complete ===
  Module analysis complete
=== Analyzing event_validator.py ===
  [RESOLVER] Using implementation: refactored
=== Starting Module Analysis ===
    [FROM_IMPORT] Any -> typing.Any
    [FROM_IMPORT] Dict -> typing.Dict
    [FROM_IMPORT] List -> typing.List
    [FROM_IMPORT] Optional -> typing.Optional
    [FROM_IMPORT] Callable -> typing.Callable
    [FROM_IMPORT] Union -> typing.Union
    [FROM_IMPORT] Protocol -> typing.Protocol
    [FROM_IMPORT] TypeVar -> typing.TypeVar
    [FROM_IMPORT] ABC -> abc.ABC
    [FROM_IMPORT] abstractmethod -> abc.abstractmethod
    [FROM_IMPORT] dataclass -> dataclasses.dataclass
    [FROM_IMPORT] field -> dataclasses.field
    [FROM_IMPORT] Enum -> enum.Enum
    [FROM_IMPORT] auto -> enum.auto
    [IMPORT] re -> re
    [IMPORT] time -> time
    [FROM_IMPORT] wraps -> functools.wraps
    [FROM_IMPORT] trace -> decorators.trace
    [FROM_IMPORT] monitor_performance -> decorators.monitor_performance
    [FROM_IMPORT] validate_auth -> decorators.validate_auth
    [MODULE_STATE] T = TypeVar('T')
  [CLASS] Analyzing class: ValidationLevel
    [CONTEXT] Entered class: event_validator.ValidationLevel
    [SYMBOL_TABLE] Entered class scope
    [CONTEXT] Exited class: event_validator.ValidationLevel
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: ValidationResult
    [CONTEXT] Entered class: event_validator.ValidationResult
    [SYMBOL_TABLE] Entered class scope
    [CONTEXT] Exited class: event_validator.ValidationResult
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: ValidationError
    [CONTEXT] Entered class: event_validator.ValidationError
    [SYMBOL_TABLE] Entered class scope
    [CONTEXT] Exited class: event_validator.ValidationError
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: ValidationReport
    [CONTEXT] Entered class: event_validator.ValidationReport
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationReport.is_valid
    [CONTEXT] Entered function: event_validator.ValidationReport.is_valid (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.result
    [RESOLVE] Attempting to resolve: ['self', 'result']
    [RESOLVE] Chain resolution needed for: ['self', 'result']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: event_validator.ValidationReport)
      [SELF_RESOLVER] resolve(self): event_validator.ValidationReport
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> event_validator.ValidationReport
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.result
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.result
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.result
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.result
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.result
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.VALID
    [RESOLVE] Attempting to resolve: ['ValidationResult', 'VALID']
    [RESOLVE] Chain resolution needed for: ['ValidationResult', 'VALID']
      [CHAIN] Resolving base: ValidationResult
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationResult not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationResult): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationResult): False (current_class: event_validator.ValidationReport)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationResult): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationResult): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationResult): event_validator.ValidationResult
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationResult -> event_validator.ValidationResult
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: ValidationResult -> event_validator.ValidationResult
      [CHAIN] Step 1: Resolving event_validator.ValidationResult.VALID
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationResult.VALID
        [ATTRIBUTE] Direct match found: event_validator.ValidationResult.VALID
      [CHAIN] Step 1 resolved: event_validator.ValidationResult.VALID
    [RESOLVE] RESOLVED to: event_validator.ValidationResult.VALID
      -> Not module state
      [NAME] Found name reference: ValidationResult
    [RESOLVE] Attempting to resolve: ['ValidationResult']
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
    [RESOLVE] RESOLVED to: event_validator.ValidationResult
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.CONDITIONALLY_VALID
    [RESOLVE] Attempting to resolve: ['ValidationResult', 'CONDITIONALLY_VALID']
    [RESOLVE] Chain resolution needed for: ['ValidationResult', 'CONDITIONALLY_VALID']
      [CHAIN] Resolving base: ValidationResult
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
      [CHAIN] Base resolved: ValidationResult -> event_validator.ValidationResult
      [CHAIN] Step 1: Resolving event_validator.ValidationResult.CONDITIONALLY_VALID
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationResult.CONDITIONALLY_VALID
        [ATTRIBUTE] Direct match found: event_validator.ValidationResult.CONDITIONALLY_VALID
      [CHAIN] Step 1 resolved: event_validator.ValidationResult.CONDITIONALLY_VALID
    [RESOLVE] RESOLVED to: event_validator.ValidationResult.CONDITIONALLY_VALID
      -> Not module state
      [NAME] Found name reference: ValidationResult
        [CACHE] ValidationResult -> event_validator.ValidationResult (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationReport.is_valid
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationReport.is_valid
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationReport.has_errors
    [CONTEXT] Entered function: event_validator.ValidationReport.has_errors (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: event_validator.ValidationReport)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(len): event_validator.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> event_validator.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.errors
    [RESOLVE] Attempting to resolve: ['self', 'errors']
    [RESOLVE] Chain resolution needed for: ['self', 'errors']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationReport
      [CHAIN] Base resolved: self -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.errors
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.errors
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.errors
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.errors
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.errors
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationReport.has_errors
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationReport.has_errors
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationReport.has_warnings
    [CONTEXT] Entered function: event_validator.ValidationReport.has_warnings (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [CACHE] Hit for len: event_validator.len
    [RESOLVE] RESOLVED to: event_validator.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.warnings
    [RESOLVE] Attempting to resolve: ['self', 'warnings']
    [RESOLVE] Chain resolution needed for: ['self', 'warnings']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationReport
      [CHAIN] Base resolved: self -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.warnings
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.warnings
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.warnings
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.warnings
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.warnings
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationReport.has_warnings
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationReport.has_warnings
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationReport.get_error_codes
    [CONTEXT] Entered function: event_validator.ValidationReport.get_error_codes (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: error.code
    [RESOLVE] Attempting to resolve: ['error', 'code']
    [RESOLVE] Chain resolution needed for: ['error', 'code']
      [CHAIN] Resolving base: error
      [RESOLVE_SIMPLE] Resolving base: error
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable error not found in any scope
      [LOCAL_RESOLVER] can_resolve(error): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(error): False (current_class: event_validator.ValidationReport)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(error): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(error): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(error): event_validator.error
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: error -> event_validator.error
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: error -> event_validator.error
      [CHAIN] Step 1: Resolving event_validator.error.code
        [ATTRIBUTE] Resolving attribute: event_validator.error.code
        [ATTRIBUTE] Direct match found: event_validator.error.code
      [CHAIN] Step 1 resolved: event_validator.error.code
    [RESOLVE] RESOLVED to: event_validator.error.code
      -> Not module state
      [NAME] Found name reference: error
    [RESOLVE] Attempting to resolve: ['error']
      [RESOLVE_SIMPLE] Resolving base: error
      [CACHE] Hit for error: event_validator.error
    [RESOLVE] RESOLVED to: event_validator.error
      -> Not module state
      [NAME] Found name reference: error
        [CACHE] error -> event_validator.error (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.errors
    [RESOLVE] Attempting to resolve: ['self', 'errors']
    [RESOLVE] Chain resolution needed for: ['self', 'errors']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationReport
      [CHAIN] Base resolved: self -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.errors
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.errors
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.errors
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.errors
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.errors
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationReport.get_error_codes
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationReport.get_error_codes
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationReport.add_error
    [CONTEXT] Entered function: event_validator.ValidationReport.add_error (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 7 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'field': 'str', 'message': 'str', 'code': 'str', 'level': 'ValidationLevel', 'context': 'Dict[str, Any]', 'suggestions': 'List[str]'}
        [ARG_TYPE] Processing type annotation for field: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: event_validator.ValidationReport)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(str): event_validator.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      [SYMBOL_UPDATE] Function: field -> event_validator.str
        [ARG_TYPE] RESOLVED field : event_validator.str
        [ARG_TYPE] Processing type annotation for message: str
        [CACHE] str -> event_validator.str (cached)
      [SYMBOL_UPDATE] Function: message -> event_validator.str
        [ARG_TYPE] RESOLVED message : event_validator.str
        [ARG_TYPE] Processing type annotation for code: str
        [CACHE] str -> event_validator.str (cached)
      [SYMBOL_UPDATE] Function: code -> event_validator.str
        [ARG_TYPE] RESOLVED code : event_validator.str
        [ARG_TYPE] Processing type annotation for level: ValidationLevel
    [RESOLVE] Attempting to resolve: ['ValidationLevel']
      [RESOLVE_SIMPLE] Resolving base: ValidationLevel
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationLevel not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationLevel): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationLevel): False (current_class: event_validator.ValidationReport)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationLevel): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationLevel): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationLevel): event_validator.ValidationLevel
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationLevel -> event_validator.ValidationLevel
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationLevel
      [SYMBOL_UPDATE] Function: level -> event_validator.ValidationLevel
        [ARG_TYPE] RESOLVED level : event_validator.ValidationLevel
      [ASSIGNMENT] Processing: error = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ValidationError
    [RESOLVE] Attempting to resolve: ['ValidationError']
      [RESOLVE_SIMPLE] Resolving base: ValidationError
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationError not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationError): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationError): False (current_class: event_validator.ValidationReport)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationError): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationError): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationError): event_validator.ValidationError
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationError -> event_validator.ValidationError
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationError
      [TYPE_INFERENCE] Call resolved to: event_validator.ValidationError
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.ValidationError (class instantiation)
      [SYMBOL_UPDATE] Function: error -> event_validator.ValidationError
        [ASSIGNMENT] RESOLVED Updated symbol table: error = event_validator.ValidationError
      [NAME] Found name reference: error
    [RESOLVE] Attempting to resolve: ['error']
      [RESOLVE_SIMPLE] Resolving base: error
      [CACHE] Hit for error: event_validator.error
    [RESOLVE] RESOLVED to: event_validator.error
      -> Not module state
      [CALL] Found call: ValidationError
    [RESOLVE] Attempting to resolve: ['ValidationError']
      [RESOLVE_SIMPLE] Resolving base: ValidationError
      [CACHE] Hit for ValidationError: event_validator.ValidationError
    [RESOLVE] RESOLVED to: event_validator.ValidationError
      -> Resolved to: event_validator.ValidationError
      -> ADDED to instantiations
      [NAME] Found name reference: ValidationError
        [CACHE] ValidationError -> event_validator.ValidationError (cached)
      -> Not module state
      [NAME] Found name reference: field
    [RESOLVE] Attempting to resolve: ['field']
      [RESOLVE_SIMPLE] Resolving base: field
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found field in function scope: event_validator.str
      [LOCAL_RESOLVER] can_resolve(field): True
      [SYMBOL_LOOKUP] Found field in function scope: event_validator.str
      [LOCAL_RESOLVER] resolve(field): event_validator.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: field -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [NAME] Found name reference: message
    [RESOLVE] Attempting to resolve: ['message']
      [RESOLVE_SIMPLE] Resolving base: message
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found message in function scope: event_validator.str
      [LOCAL_RESOLVER] can_resolve(message): True
      [SYMBOL_LOOKUP] Found message in function scope: event_validator.str
      [LOCAL_RESOLVER] resolve(message): event_validator.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: message -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [NAME] Found name reference: level
    [RESOLVE] Attempting to resolve: ['level']
      [RESOLVE_SIMPLE] Resolving base: level
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found level in function scope: event_validator.ValidationLevel
      [LOCAL_RESOLVER] can_resolve(level): True
      [SYMBOL_LOOKUP] Found level in function scope: event_validator.ValidationLevel
      [LOCAL_RESOLVER] resolve(level): event_validator.ValidationLevel
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: level -> event_validator.ValidationLevel
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationLevel
      -> Not module state
      [NAME] Found name reference: code
    [RESOLVE] Attempting to resolve: ['code']
      [RESOLVE_SIMPLE] Resolving base: code
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found code in function scope: event_validator.str
      [LOCAL_RESOLVER] can_resolve(code): True
      [SYMBOL_LOOKUP] Found code in function scope: event_validator.str
      [LOCAL_RESOLVER] resolve(code): event_validator.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: code -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [NAME] Found name reference: context
    [RESOLVE] Attempting to resolve: ['context']
      [RESOLVE_SIMPLE] Resolving base: context
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable context not found in any scope
      [LOCAL_RESOLVER] can_resolve(context): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(context): False (current_class: event_validator.ValidationReport)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(context): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(context): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(context): event_validator.context
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: context -> event_validator.context
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.context
      -> Not module state
      [NAME] Found name reference: suggestions
    [RESOLVE] Attempting to resolve: ['suggestions']
      [RESOLVE_SIMPLE] Resolving base: suggestions
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable suggestions not found in any scope
      [LOCAL_RESOLVER] can_resolve(suggestions): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(suggestions): False (current_class: event_validator.ValidationReport)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(suggestions): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(suggestions): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(suggestions): event_validator.suggestions
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: suggestions -> event_validator.suggestions
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.suggestions
      -> Not module state
      [NAME] Found name reference: level
        [CACHE] level -> event_validator.ValidationLevel (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationLevel.WARNING
    [RESOLVE] Attempting to resolve: ['ValidationLevel', 'WARNING']
    [RESOLVE] Chain resolution needed for: ['ValidationLevel', 'WARNING']
      [CHAIN] Resolving base: ValidationLevel
      [RESOLVE_SIMPLE] Resolving base: ValidationLevel
      [CACHE] Hit for ValidationLevel: event_validator.ValidationLevel
      [CHAIN] Base resolved: ValidationLevel -> event_validator.ValidationLevel
      [CHAIN] Step 1: Resolving event_validator.ValidationLevel.WARNING
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationLevel.WARNING
        [ATTRIBUTE] Direct match found: event_validator.ValidationLevel.WARNING
      [CHAIN] Step 1 resolved: event_validator.ValidationLevel.WARNING
    [RESOLVE] RESOLVED to: event_validator.ValidationLevel.WARNING
      -> Not module state
      [NAME] Found name reference: ValidationLevel
        [CACHE] ValidationLevel -> event_validator.ValidationLevel (cached)
      -> Not module state
      [CALL] Found call: self.warnings.append
    [RESOLVE] Attempting to resolve: ['self', 'warnings', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'warnings', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationReport
      [CHAIN] Base resolved: self -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.warnings
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.warnings
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.warnings
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.warnings
      [CHAIN] Step 2: Resolving event_validator.ValidationReport.warnings.append
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.warnings.append
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.warnings.append
      [CHAIN] Step 2 resolved: event_validator.ValidationReport.warnings.append
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.warnings.append
            [INTERMEDIATE] Tracking chain steps for: self.warnings.append
            [INTERMEDIATE] Step 1: self.warnings
    [RESOLVE] Attempting to resolve: ['self', 'warnings']
    [RESOLVE] Chain resolution needed for: ['self', 'warnings']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationReport
      [CHAIN] Base resolved: self -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.warnings
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.warnings
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.warnings
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.warnings
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.warnings
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationReport.warnings
            [INTERMEDIATE] Step 2: self.warnings.append
      -> Resolved to: event_validator.ValidationReport.warnings.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: error
    [RESOLVE] Attempting to resolve: ['error']
      [RESOLVE_SIMPLE] Resolving base: error
      [CACHE] Hit for error: event_validator.error
    [RESOLVE] RESOLVED to: event_validator.error
      [ATTRIBUTE] Found attribute access: self.warnings.append
        [CACHE] self.warnings.append -> event_validator.ValidationReport.warnings.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.warnings
        [CACHE] self.warnings -> event_validator.ValidationReport.warnings (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
      [NAME] Found name reference: error
        [CACHE] error -> event_validator.error (cached)
      -> Not module state
      [CALL] Found call: self.errors.append
    [RESOLVE] Attempting to resolve: ['self', 'errors', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'errors', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationReport
      [CHAIN] Base resolved: self -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.errors
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.errors
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.errors
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.errors
      [CHAIN] Step 2: Resolving event_validator.ValidationReport.errors.append
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.errors.append
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.errors.append
      [CHAIN] Step 2 resolved: event_validator.ValidationReport.errors.append
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.errors.append
            [INTERMEDIATE] Tracking chain steps for: self.errors.append
            [INTERMEDIATE] Step 1: self.errors
    [RESOLVE] Attempting to resolve: ['self', 'errors']
    [RESOLVE] Chain resolution needed for: ['self', 'errors']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationReport
      [CHAIN] Base resolved: self -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.errors
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.errors
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.errors
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.errors
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.errors
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationReport.errors
            [INTERMEDIATE] Step 2: self.errors.append
      -> Resolved to: event_validator.ValidationReport.errors.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: error
    [RESOLVE] Attempting to resolve: ['error']
      [RESOLVE_SIMPLE] Resolving base: error
      [CACHE] Hit for error: event_validator.error
    [RESOLVE] RESOLVED to: event_validator.error
      [ATTRIBUTE] Found attribute access: self.errors.append
        [CACHE] self.errors.append -> event_validator.ValidationReport.errors.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.errors
        [CACHE] self.errors -> event_validator.ValidationReport.errors (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: error
        [CACHE] error -> event_validator.error (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationReport.add_error
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationReport.add_error
        Calls: 0
        Instantiations: 1
        State Access: 0
    [CONTEXT] Exited class: event_validator.ValidationReport
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: ValidationRule
    [CONTEXT] Entered class: event_validator.ValidationRule
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationRule.validate
    [CONTEXT] Entered function: event_validator.ValidationRule.validate (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any', 'context': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: event_validator.ValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
    [CONTEXT] Exited function: event_validator.ValidationRule.validate
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationRule.validate
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationRule.get_rule_name
    [CONTEXT] Entered function: event_validator.ValidationRule.get_rule_name (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
    [CONTEXT] Exited function: event_validator.ValidationRule.get_rule_name
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationRule.get_rule_name
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: event_validator.ValidationRule
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: BaseValidationRule
    [CONTEXT] Entered class: event_validator.BaseValidationRule
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.BaseValidationRule.__init__
    [CONTEXT] Entered function: event_validator.BaseValidationRule.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'rule_name': 'str', 'description': 'str'}
        [ARG_TYPE] Processing type annotation for rule_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: event_validator.BaseValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(str): event_validator.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      [SYMBOL_UPDATE] Function: rule_name -> event_validator.str
        [ARG_TYPE] RESOLVED rule_name : event_validator.str
        [ARG_TYPE] Processing type annotation for description: str
        [CACHE] str -> event_validator.str (cached)
      [SYMBOL_UPDATE] Function: description -> event_validator.str
        [ARG_TYPE] RESOLVED description : event_validator.str
      [ATTRIBUTE] Found attribute access: self.rule_name
    [RESOLVE] Attempting to resolve: ['self', 'rule_name']
    [RESOLVE] Chain resolution needed for: ['self', 'rule_name']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: event_validator.BaseValidationRule)
      [SELF_RESOLVER] resolve(self): event_validator.BaseValidationRule
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> event_validator.BaseValidationRule
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> event_validator.BaseValidationRule
      [CHAIN] Step 1: Resolving event_validator.BaseValidationRule.rule_name
        [ATTRIBUTE] Resolving attribute: event_validator.BaseValidationRule.rule_name
        [ATTRIBUTE] Direct match found: event_validator.BaseValidationRule.rule_name
      [CHAIN] Step 1 resolved: event_validator.BaseValidationRule.rule_name
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule.rule_name
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.BaseValidationRule
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule
      -> Not module state
      [NAME] Found name reference: rule_name
    [RESOLVE] Attempting to resolve: ['rule_name']
      [RESOLVE_SIMPLE] Resolving base: rule_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found rule_name in function scope: event_validator.str
      [LOCAL_RESOLVER] can_resolve(rule_name): True
      [SYMBOL_LOOKUP] Found rule_name in function scope: event_validator.str
      [LOCAL_RESOLVER] resolve(rule_name): event_validator.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: rule_name -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.description
    [RESOLVE] Attempting to resolve: ['self', 'description']
    [RESOLVE] Chain resolution needed for: ['self', 'description']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.BaseValidationRule
      [CHAIN] Base resolved: self -> event_validator.BaseValidationRule
      [CHAIN] Step 1: Resolving event_validator.BaseValidationRule.description
        [ATTRIBUTE] Resolving attribute: event_validator.BaseValidationRule.description
        [ATTRIBUTE] Direct match found: event_validator.BaseValidationRule.description
      [CHAIN] Step 1 resolved: event_validator.BaseValidationRule.description
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule.description
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.BaseValidationRule (cached)
      -> Not module state
      [NAME] Found name reference: description
    [RESOLVE] Attempting to resolve: ['description']
      [RESOLVE_SIMPLE] Resolving base: description
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found description in function scope: event_validator.str
      [LOCAL_RESOLVER] can_resolve(description): True
      [SYMBOL_LOOKUP] Found description in function scope: event_validator.str
      [LOCAL_RESOLVER] resolve(description): event_validator.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: description -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.enabled
    [RESOLVE] Attempting to resolve: ['self', 'enabled']
    [RESOLVE] Chain resolution needed for: ['self', 'enabled']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.BaseValidationRule
      [CHAIN] Base resolved: self -> event_validator.BaseValidationRule
      [CHAIN] Step 1: Resolving event_validator.BaseValidationRule.enabled
        [ATTRIBUTE] Resolving attribute: event_validator.BaseValidationRule.enabled
        [ATTRIBUTE] Direct match found: event_validator.BaseValidationRule.enabled
      [CHAIN] Step 1 resolved: event_validator.BaseValidationRule.enabled
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule.enabled
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.BaseValidationRule (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.priority
    [RESOLVE] Attempting to resolve: ['self', 'priority']
    [RESOLVE] Chain resolution needed for: ['self', 'priority']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.BaseValidationRule
      [CHAIN] Base resolved: self -> event_validator.BaseValidationRule
      [CHAIN] Step 1: Resolving event_validator.BaseValidationRule.priority
        [ATTRIBUTE] Resolving attribute: event_validator.BaseValidationRule.priority
        [ATTRIBUTE] Direct match found: event_validator.BaseValidationRule.priority
      [CHAIN] Step 1 resolved: event_validator.BaseValidationRule.priority
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule.priority
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.BaseValidationRule (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.dependencies
    [RESOLVE] Attempting to resolve: ['self', 'dependencies']
    [RESOLVE] Chain resolution needed for: ['self', 'dependencies']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.BaseValidationRule
      [CHAIN] Base resolved: self -> event_validator.BaseValidationRule
      [CHAIN] Step 1: Resolving event_validator.BaseValidationRule.dependencies
        [ATTRIBUTE] Resolving attribute: event_validator.BaseValidationRule.dependencies
        [ATTRIBUTE] Direct match found: event_validator.BaseValidationRule.dependencies
      [CHAIN] Step 1 resolved: event_validator.BaseValidationRule.dependencies
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule.dependencies
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.BaseValidationRule (cached)
      -> Not module state
      [NAME] Found name reference: List
    [RESOLVE] Attempting to resolve: ['List']
      [RESOLVE_SIMPLE] Resolving base: List
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable List not found in any scope
      [LOCAL_RESOLVER] can_resolve(List): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(List): False (current_class: event_validator.BaseValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(List): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(List): typing.List (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: List -> typing.List
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.List
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> event_validator.str (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.BaseValidationRule.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.BaseValidationRule.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.BaseValidationRule._validate_implementation
    [DECORATOR] @abstractmethod
    [CONTEXT] Entered function: event_validator.BaseValidationRule._validate_implementation (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any', 'context': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: event_validator.BaseValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
    [CONTEXT] Exited function: event_validator.BaseValidationRule._validate_implementation
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.BaseValidationRule._validate_implementation
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.BaseValidationRule.validate
    [DECORATOR] @trace
    [CONTEXT] Entered function: event_validator.BaseValidationRule.validate (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any', 'context': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [ASSIGNMENT] Processing: context = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: context
    [RESOLVE] Attempting to resolve: ['context']
      [RESOLVE_SIMPLE] Resolving base: context
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable context not found in any scope
      [LOCAL_RESOLVER] can_resolve(context): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(context): False (current_class: event_validator.BaseValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(context): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(context): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(context): event_validator.context
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: context -> event_validator.context
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.context
      -> Not module state
      [NAME] Found name reference: context
        [CACHE] context -> event_validator.context (cached)
      -> Not module state
      [ASSIGNMENT] Processing: start_time = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable time not found in any scope
      [LOCAL_RESOLVER] can_resolve(time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(time): False (current_class: event_validator.BaseValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(time): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(time): time (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: time -> time
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
      [TYPE_INFERENCE] Call resolved to: time.time
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for start_time
      [NAME] Found name reference: start_time
    [RESOLVE] Attempting to resolve: ['start_time']
      [RESOLVE_SIMPLE] Resolving base: start_time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable start_time not found in any scope
      [LOCAL_RESOLVER] can_resolve(start_time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(start_time): False (current_class: event_validator.BaseValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(start_time): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(start_time): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(start_time): event_validator.start_time
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: start_time -> event_validator.start_time
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.start_time
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [ASSIGNMENT] Processing: report = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self._validate_implementation
    [RESOLVE] Attempting to resolve: ['self', '_validate_implementation']
    [RESOLVE] Chain resolution needed for: ['self', '_validate_implementation']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.BaseValidationRule
      [CHAIN] Base resolved: self -> event_validator.BaseValidationRule
      [CHAIN] Step 1: Resolving event_validator.BaseValidationRule._validate_implementation
        [ATTRIBUTE] Resolving attribute: event_validator.BaseValidationRule._validate_implementation
        [ATTRIBUTE] Direct match found: event_validator.BaseValidationRule._validate_implementation
      [CHAIN] Step 1 resolved: event_validator.BaseValidationRule._validate_implementation
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule._validate_implementation
      [TYPE_INFERENCE] Call resolved to: event_validator.BaseValidationRule._validate_implementation
        [RETURN_TYPE_RESOLUTION] Resolving return type: ValidationReport
        [RETURN_TYPE_RESOLUTION] Found in current module: event_validator.ValidationReport
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.ValidationReport (from return type)
      [SYMBOL_UPDATE] Function: report -> event_validator.ValidationReport
        [ASSIGNMENT] RESOLVED Updated symbol table: report = event_validator.ValidationReport
      [NAME] Found name reference: report
    [RESOLVE] Attempting to resolve: ['report']
      [RESOLVE_SIMPLE] Resolving base: report
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] can_resolve(report): True
      [SYMBOL_LOOKUP] Found report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] resolve(report): event_validator.ValidationReport
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: report -> event_validator.ValidationReport
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
      [CALL] Found call: self._validate_implementation
    [RESOLVE] Attempting to resolve: ['self', '_validate_implementation']
    [RESOLVE] Chain resolution needed for: ['self', '_validate_implementation']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.BaseValidationRule
      [CHAIN] Base resolved: self -> event_validator.BaseValidationRule
      [CHAIN] Step 1: Resolving event_validator.BaseValidationRule._validate_implementation
        [ATTRIBUTE] Resolving attribute: event_validator.BaseValidationRule._validate_implementation
        [ATTRIBUTE] Direct match found: event_validator.BaseValidationRule._validate_implementation
      [CHAIN] Step 1 resolved: event_validator.BaseValidationRule._validate_implementation
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule._validate_implementation
            [INTERMEDIATE] Tracking chain steps for: self._validate_implementation
            [INTERMEDIATE] Step 1: self._validate_implementation
      -> Resolved to: event_validator.BaseValidationRule._validate_implementation
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(data): True
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(data): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: data -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
        [FUNCTION_ARG] Checking argument: context
    [RESOLVE] Attempting to resolve: ['context']
      [RESOLVE_SIMPLE] Resolving base: context
      [CACHE] Hit for context: event_validator.context
    [RESOLVE] RESOLVED to: event_validator.context
      [ATTRIBUTE] Found attribute access: self._validate_implementation
        [CACHE] self._validate_implementation -> event_validator.BaseValidationRule._validate_implementation (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.BaseValidationRule
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [NAME] Found name reference: context
        [CACHE] context -> event_validator.context (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: report.validation_time
    [RESOLVE] Attempting to resolve: ['report', 'validation_time']
    [RESOLVE] Chain resolution needed for: ['report', 'validation_time']
      [CHAIN] Resolving base: report
      [RESOLVE_SIMPLE] Resolving base: report
      [CACHE] Hit for report: event_validator.ValidationReport
      [CHAIN] Base resolved: report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.validation_time
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.validation_time
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.validation_time
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.validation_time
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.validation_time
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [CALL] Found call: time.time
    [CACHE] time.time -> time.time (cached)
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
        [CACHE] time -> time (cached)
      -> Not module state
      [NAME] Found name reference: start_time
        [CACHE] start_time -> event_validator.start_time (cached)
      -> Not module state
      [CALL] Found call: report.rules_applied.append
    [RESOLVE] Attempting to resolve: ['report', 'rules_applied', 'append']
    [RESOLVE] Chain resolution needed for: ['report', 'rules_applied', 'append']
      [CHAIN] Resolving base: report
      [RESOLVE_SIMPLE] Resolving base: report
      [CACHE] Hit for report: event_validator.ValidationReport
      [CHAIN] Base resolved: report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.rules_applied
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.rules_applied
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.rules_applied
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.rules_applied
      [CHAIN] Step 2: Resolving event_validator.ValidationReport.rules_applied.append
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.rules_applied.append
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.rules_applied.append
      [CHAIN] Step 2 resolved: event_validator.ValidationReport.rules_applied.append
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.rules_applied.append
            [INTERMEDIATE] Tracking chain steps for: report.rules_applied.append
            [INTERMEDIATE] Step 1: report.rules_applied
    [RESOLVE] Attempting to resolve: ['report', 'rules_applied']
    [RESOLVE] Chain resolution needed for: ['report', 'rules_applied']
      [CHAIN] Resolving base: report
      [RESOLVE_SIMPLE] Resolving base: report
      [CACHE] Hit for report: event_validator.ValidationReport
      [CHAIN] Base resolved: report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.rules_applied
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.rules_applied
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.rules_applied
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.rules_applied
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.rules_applied
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationReport.rules_applied
            [INTERMEDIATE] Step 2: report.rules_applied.append
      -> Resolved to: event_validator.ValidationReport.rules_applied.append
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: report.rules_applied.append
        [CACHE] report.rules_applied.append -> event_validator.ValidationReport.rules_applied.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: report.rules_applied
        [CACHE] report.rules_applied -> event_validator.ValidationReport.rules_applied (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.rule_name
    [RESOLVE] Attempting to resolve: ['self', 'rule_name']
    [RESOLVE] Chain resolution needed for: ['self', 'rule_name']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.BaseValidationRule
      [CHAIN] Base resolved: self -> event_validator.BaseValidationRule
      [CHAIN] Step 1: Resolving event_validator.BaseValidationRule.rule_name
        [ATTRIBUTE] Resolving attribute: event_validator.BaseValidationRule.rule_name
        [ATTRIBUTE] Direct match found: event_validator.BaseValidationRule.rule_name
      [CHAIN] Step 1 resolved: event_validator.BaseValidationRule.rule_name
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule.rule_name
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.BaseValidationRule (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Exception not found in any scope
      [LOCAL_RESOLVER] can_resolve(Exception): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Exception): False (current_class: event_validator.BaseValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Exception): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(Exception): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(Exception): event_validator.Exception
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: Exception -> event_validator.Exception
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.Exception
      -> Not module state
      [ASSIGNMENT] Processing: report = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ValidationReport
    [RESOLVE] Attempting to resolve: ['ValidationReport']
      [RESOLVE_SIMPLE] Resolving base: ValidationReport
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationReport not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationReport): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationReport): False (current_class: event_validator.BaseValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationReport): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationReport): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationReport): event_validator.ValidationReport
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationReport -> event_validator.ValidationReport
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      [TYPE_INFERENCE] Call resolved to: event_validator.ValidationReport
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.ValidationReport (class instantiation)
      [SYMBOL_UPDATE] Function: report -> event_validator.ValidationReport
        [ASSIGNMENT] RESOLVED Updated symbol table: report = event_validator.ValidationReport
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [CALL] Found call: ValidationReport
    [RESOLVE] Attempting to resolve: ['ValidationReport']
      [RESOLVE_SIMPLE] Resolving base: ValidationReport
      [CACHE] Hit for ValidationReport: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Resolved to: event_validator.ValidationReport
      -> ADDED to instantiations
      [NAME] Found name reference: ValidationReport
        [CACHE] ValidationReport -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.INVALID
    [RESOLVE] Attempting to resolve: ['ValidationResult', 'INVALID']
    [RESOLVE] Chain resolution needed for: ['ValidationResult', 'INVALID']
      [CHAIN] Resolving base: ValidationResult
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationResult not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationResult): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationResult): False (current_class: event_validator.BaseValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationResult): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationResult): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationResult): event_validator.ValidationResult
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationResult -> event_validator.ValidationResult
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: ValidationResult -> event_validator.ValidationResult
      [CHAIN] Step 1: Resolving event_validator.ValidationResult.INVALID
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationResult.INVALID
        [ATTRIBUTE] Direct match found: event_validator.ValidationResult.INVALID
      [CHAIN] Step 1 resolved: event_validator.ValidationResult.INVALID
    [RESOLVE] RESOLVED to: event_validator.ValidationResult.INVALID
      -> Not module state
      [NAME] Found name reference: ValidationResult
    [RESOLVE] Attempting to resolve: ['ValidationResult']
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
    [RESOLVE] RESOLVED to: event_validator.ValidationResult
      -> Not module state
      [CALL] Found call: report.add_error
    [RESOLVE] Attempting to resolve: ['report', 'add_error']
    [RESOLVE] Chain resolution needed for: ['report', 'add_error']
      [CHAIN] Resolving base: report
      [RESOLVE_SIMPLE] Resolving base: report
      [CACHE] Hit for report: event_validator.ValidationReport
      [CHAIN] Base resolved: report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.add_error
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.add_error
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.add_error
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.add_error
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.add_error
            [INTERMEDIATE] Tracking chain steps for: report.add_error
            [INTERMEDIATE] Step 1: report.add_error
      -> Resolved to: event_validator.ValidationReport.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: report.add_error
        [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.rule_name
        [CACHE] self.rule_name -> event_validator.BaseValidationRule.rule_name (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.BaseValidationRule (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: event_validator.str
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable e not found in any scope
      [LOCAL_RESOLVER] can_resolve(e): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(e): False (current_class: event_validator.BaseValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(e): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(e): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(e): event_validator.e
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: e -> event_validator.e
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.e
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationLevel.CRITICAL
    [RESOLVE] Attempting to resolve: ['ValidationLevel', 'CRITICAL']
    [RESOLVE] Chain resolution needed for: ['ValidationLevel', 'CRITICAL']
      [CHAIN] Resolving base: ValidationLevel
      [RESOLVE_SIMPLE] Resolving base: ValidationLevel
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationLevel not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationLevel): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationLevel): False (current_class: event_validator.BaseValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationLevel): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationLevel): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationLevel): event_validator.ValidationLevel
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationLevel -> event_validator.ValidationLevel
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: ValidationLevel -> event_validator.ValidationLevel
      [CHAIN] Step 1: Resolving event_validator.ValidationLevel.CRITICAL
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationLevel.CRITICAL
        [ATTRIBUTE] Direct match found: event_validator.ValidationLevel.CRITICAL
      [CHAIN] Step 1 resolved: event_validator.ValidationLevel.CRITICAL
    [RESOLVE] RESOLVED to: event_validator.ValidationLevel.CRITICAL
      -> Not module state
      [NAME] Found name reference: ValidationLevel
    [RESOLVE] Attempting to resolve: ['ValidationLevel']
      [RESOLVE_SIMPLE] Resolving base: ValidationLevel
      [CACHE] Hit for ValidationLevel: event_validator.ValidationLevel
    [RESOLVE] RESOLVED to: event_validator.ValidationLevel
      -> Not module state
      [ATTRIBUTE] Found attribute access: report.validation_time
        [CACHE] report.validation_time -> event_validator.ValidationReport.validation_time (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [CALL] Found call: time.time
    [CACHE] time.time -> time.time (cached)
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
        [CACHE] time -> time (cached)
      -> Not module state
      [NAME] Found name reference: start_time
        [CACHE] start_time -> event_validator.start_time (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.BaseValidationRule.validate
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.BaseValidationRule.validate
        Calls: 2
        Instantiations: 1
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.BaseValidationRule.get_rule_name
    [CONTEXT] Entered function: event_validator.BaseValidationRule.get_rule_name (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.rule_name
    [RESOLVE] Attempting to resolve: ['self', 'rule_name']
    [RESOLVE] Chain resolution needed for: ['self', 'rule_name']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.BaseValidationRule
      [CHAIN] Base resolved: self -> event_validator.BaseValidationRule
      [CHAIN] Step 1: Resolving event_validator.BaseValidationRule.rule_name
        [ATTRIBUTE] Resolving attribute: event_validator.BaseValidationRule.rule_name
        [ATTRIBUTE] Direct match found: event_validator.BaseValidationRule.rule_name
      [CHAIN] Step 1 resolved: event_validator.BaseValidationRule.rule_name
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule.rule_name
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.BaseValidationRule
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule
      -> Not module state
    [CONTEXT] Exited function: event_validator.BaseValidationRule.get_rule_name
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.BaseValidationRule.get_rule_name
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: event_validator.BaseValidationRule
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: RequiredFieldRule
    [CONTEXT] Entered class: event_validator.RequiredFieldRule
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.RequiredFieldRule.__init__
    [CONTEXT] Entered function: event_validator.RequiredFieldRule.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'required_fields': 'List[str]'}
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable super not found in any scope
      [LOCAL_RESOLVER] can_resolve(super): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(super): False (current_class: event_validator.RequiredFieldRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(super): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(super): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(super): event_validator.super
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: super -> event_validator.super
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.super
      -> Resolved to: event_validator.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> event_validator.super (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.required_fields
    [RESOLVE] Attempting to resolve: ['self', 'required_fields']
    [RESOLVE] Chain resolution needed for: ['self', 'required_fields']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: event_validator.RequiredFieldRule)
      [SELF_RESOLVER] resolve(self): event_validator.RequiredFieldRule
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> event_validator.RequiredFieldRule
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> event_validator.RequiredFieldRule
      [CHAIN] Step 1: Resolving event_validator.RequiredFieldRule.required_fields
        [ATTRIBUTE] Resolving attribute: event_validator.RequiredFieldRule.required_fields
        [ATTRIBUTE] Direct match found: event_validator.RequiredFieldRule.required_fields
      [CHAIN] Step 1 resolved: event_validator.RequiredFieldRule.required_fields
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule.required_fields
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.RequiredFieldRule
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule
      -> Not module state
      [NAME] Found name reference: required_fields
    [RESOLVE] Attempting to resolve: ['required_fields']
      [RESOLVE_SIMPLE] Resolving base: required_fields
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable required_fields not found in any scope
      [LOCAL_RESOLVER] can_resolve(required_fields): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(required_fields): False (current_class: event_validator.RequiredFieldRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(required_fields): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(required_fields): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(required_fields): event_validator.required_fields
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: required_fields -> event_validator.required_fields
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.required_fields
      -> Not module state
    [CONTEXT] Exited function: event_validator.RequiredFieldRule.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.RequiredFieldRule.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.RequiredFieldRule._validate_implementation
    [CONTEXT] Entered function: event_validator.RequiredFieldRule._validate_implementation (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any', 'context': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: event_validator.RequiredFieldRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [ASSIGNMENT] Processing: report = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ValidationReport
    [RESOLVE] Attempting to resolve: ['ValidationReport']
      [RESOLVE_SIMPLE] Resolving base: ValidationReport
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationReport not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationReport): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationReport): False (current_class: event_validator.RequiredFieldRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationReport): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationReport): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationReport): event_validator.ValidationReport
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationReport -> event_validator.ValidationReport
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      [TYPE_INFERENCE] Call resolved to: event_validator.ValidationReport
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.ValidationReport (class instantiation)
      [SYMBOL_UPDATE] Function: report -> event_validator.ValidationReport
        [ASSIGNMENT] RESOLVED Updated symbol table: report = event_validator.ValidationReport
      [NAME] Found name reference: report
    [RESOLVE] Attempting to resolve: ['report']
      [RESOLVE_SIMPLE] Resolving base: report
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] can_resolve(report): True
      [SYMBOL_LOOKUP] Found report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] resolve(report): event_validator.ValidationReport
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: report -> event_validator.ValidationReport
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
      [CALL] Found call: ValidationReport
    [RESOLVE] Attempting to resolve: ['ValidationReport']
      [RESOLVE_SIMPLE] Resolving base: ValidationReport
      [CACHE] Hit for ValidationReport: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Resolved to: event_validator.ValidationReport
      -> ADDED to instantiations
      [NAME] Found name reference: ValidationReport
        [CACHE] ValidationReport -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.VALID
    [RESOLVE] Attempting to resolve: ['ValidationResult', 'VALID']
    [RESOLVE] Chain resolution needed for: ['ValidationResult', 'VALID']
      [CHAIN] Resolving base: ValidationResult
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationResult not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationResult): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationResult): False (current_class: event_validator.RequiredFieldRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationResult): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationResult): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationResult): event_validator.ValidationResult
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationResult -> event_validator.ValidationResult
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: ValidationResult -> event_validator.ValidationResult
      [CHAIN] Step 1: Resolving event_validator.ValidationResult.VALID
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationResult.VALID
        [ATTRIBUTE] Direct match found: event_validator.ValidationResult.VALID
      [CHAIN] Step 1 resolved: event_validator.ValidationResult.VALID
    [RESOLVE] RESOLVED to: event_validator.ValidationResult.VALID
      -> Not module state
      [NAME] Found name reference: ValidationResult
    [RESOLVE] Attempting to resolve: ['ValidationResult']
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
    [RESOLVE] RESOLVED to: event_validator.ValidationResult
      -> Not module state
      [CALL] Found call: isinstance
    [RESOLVE] Attempting to resolve: ['isinstance']
      [RESOLVE_SIMPLE] Resolving base: isinstance
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable isinstance not found in any scope
      [LOCAL_RESOLVER] can_resolve(isinstance): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(isinstance): False (current_class: event_validator.RequiredFieldRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(isinstance): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(isinstance): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(isinstance): event_validator.isinstance
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: isinstance -> event_validator.isinstance
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.isinstance
      -> Resolved to: event_validator.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(data): True
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(data): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: data -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
        [FUNCTION_ARG] Checking argument: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(dict): False (current_class: event_validator.RequiredFieldRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(dict): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(dict): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(dict): event_validator.dict
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: dict -> event_validator.dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.dict
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> event_validator.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [NAME] Found name reference: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: event_validator.dict
    [RESOLVE] RESOLVED to: event_validator.dict
      -> Not module state
      [ATTRIBUTE] Found attribute access: report.result
    [RESOLVE] Attempting to resolve: ['report', 'result']
    [RESOLVE] Chain resolution needed for: ['report', 'result']
      [CHAIN] Resolving base: report
      [RESOLVE_SIMPLE] Resolving base: report
      [CACHE] Hit for report: event_validator.ValidationReport
      [CHAIN] Base resolved: report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.result
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.result
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.result
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.result
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.result
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.INVALID
    [RESOLVE] Attempting to resolve: ['ValidationResult', 'INVALID']
    [RESOLVE] Chain resolution needed for: ['ValidationResult', 'INVALID']
      [CHAIN] Resolving base: ValidationResult
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
      [CHAIN] Base resolved: ValidationResult -> event_validator.ValidationResult
      [CHAIN] Step 1: Resolving event_validator.ValidationResult.INVALID
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationResult.INVALID
        [ATTRIBUTE] Direct match found: event_validator.ValidationResult.INVALID
      [CHAIN] Step 1 resolved: event_validator.ValidationResult.INVALID
    [RESOLVE] RESOLVED to: event_validator.ValidationResult.INVALID
      -> Not module state
      [NAME] Found name reference: ValidationResult
        [CACHE] ValidationResult -> event_validator.ValidationResult (cached)
      -> Not module state
      [CALL] Found call: report.add_error
    [RESOLVE] Attempting to resolve: ['report', 'add_error']
    [RESOLVE] Chain resolution needed for: ['report', 'add_error']
      [CHAIN] Resolving base: report
      [RESOLVE_SIMPLE] Resolving base: report
      [CACHE] Hit for report: event_validator.ValidationReport
      [CHAIN] Base resolved: report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.add_error
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.add_error
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.add_error
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.add_error
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.add_error
            [INTERMEDIATE] Tracking chain steps for: report.add_error
            [INTERMEDIATE] Step 1: report.add_error
      -> Resolved to: event_validator.ValidationReport.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: report.add_error
        [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: field
    [RESOLVE] Attempting to resolve: ['field']
      [RESOLVE_SIMPLE] Resolving base: field
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable field not found in any scope
      [LOCAL_RESOLVER] can_resolve(field): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(field): False (current_class: event_validator.RequiredFieldRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(field): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(field): dataclasses.field (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: field -> dataclasses.field
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: dataclasses.field
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.required_fields
    [RESOLVE] Attempting to resolve: ['self', 'required_fields']
    [RESOLVE] Chain resolution needed for: ['self', 'required_fields']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.RequiredFieldRule
      [CHAIN] Base resolved: self -> event_validator.RequiredFieldRule
      [CHAIN] Step 1: Resolving event_validator.RequiredFieldRule.required_fields
        [ATTRIBUTE] Resolving attribute: event_validator.RequiredFieldRule.required_fields
        [ATTRIBUTE] Direct match found: event_validator.RequiredFieldRule.required_fields
      [CHAIN] Step 1 resolved: event_validator.RequiredFieldRule.required_fields
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule.required_fields
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.RequiredFieldRule
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: report.result
        [CACHE] report.result -> event_validator.ValidationReport.result (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.INVALID
        [CACHE] ValidationResult.INVALID -> event_validator.ValidationResult.INVALID (cached)
      -> Not module state
      [NAME] Found name reference: ValidationResult
        [CACHE] ValidationResult -> event_validator.ValidationResult (cached)
      -> Not module state
      [CALL] Found call: report.add_error
    [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
            [INTERMEDIATE] Tracking chain steps for: report.add_error
            [INTERMEDIATE] Step 1: report.add_error
      -> Resolved to: event_validator.ValidationReport.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: report.add_error
        [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: report.result
        [CACHE] report.result -> event_validator.ValidationReport.result (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.INVALID
        [CACHE] ValidationResult.INVALID -> event_validator.ValidationResult.INVALID (cached)
      -> Not module state
      [NAME] Found name reference: ValidationResult
        [CACHE] ValidationResult -> event_validator.ValidationResult (cached)
      -> Not module state
      [CALL] Found call: report.add_error
    [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
            [INTERMEDIATE] Tracking chain steps for: report.add_error
            [INTERMEDIATE] Step 1: report.add_error
      -> Resolved to: event_validator.ValidationReport.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: report.add_error
        [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.RequiredFieldRule._validate_implementation
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.RequiredFieldRule._validate_implementation
        Calls: 1
        Instantiations: 1
        State Access: 0
    [CONTEXT] Exited class: event_validator.RequiredFieldRule
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: DataTypeRule
    [CONTEXT] Entered class: event_validator.DataTypeRule
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.DataTypeRule.__init__
    [CONTEXT] Entered function: event_validator.DataTypeRule.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'field_types': 'Dict[str, Union[type, List[type]]]'}
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable super not found in any scope
      [LOCAL_RESOLVER] can_resolve(super): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(super): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(super): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(super): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(super): event_validator.super
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: super -> event_validator.super
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.super
      -> Resolved to: event_validator.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> event_validator.super (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.field_types
    [RESOLVE] Attempting to resolve: ['self', 'field_types']
    [RESOLVE] Chain resolution needed for: ['self', 'field_types']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: event_validator.DataTypeRule)
      [SELF_RESOLVER] resolve(self): event_validator.DataTypeRule
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> event_validator.DataTypeRule
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> event_validator.DataTypeRule
      [CHAIN] Step 1: Resolving event_validator.DataTypeRule.field_types
        [ATTRIBUTE] Resolving attribute: event_validator.DataTypeRule.field_types
        [ATTRIBUTE] Direct match found: event_validator.DataTypeRule.field_types
      [CHAIN] Step 1 resolved: event_validator.DataTypeRule.field_types
    [RESOLVE] RESOLVED to: event_validator.DataTypeRule.field_types
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.DataTypeRule
    [RESOLVE] RESOLVED to: event_validator.DataTypeRule
      -> Not module state
      [NAME] Found name reference: field_types
    [RESOLVE] Attempting to resolve: ['field_types']
      [RESOLVE_SIMPLE] Resolving base: field_types
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable field_types not found in any scope
      [LOCAL_RESOLVER] can_resolve(field_types): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(field_types): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(field_types): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(field_types): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(field_types): event_validator.field_types
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: field_types -> event_validator.field_types
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.field_types
      -> Not module state
    [CONTEXT] Exited function: event_validator.DataTypeRule.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.DataTypeRule.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.DataTypeRule._validate_implementation
    [CONTEXT] Entered function: event_validator.DataTypeRule._validate_implementation (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any', 'context': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [ASSIGNMENT] Processing: report = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ValidationReport
    [RESOLVE] Attempting to resolve: ['ValidationReport']
      [RESOLVE_SIMPLE] Resolving base: ValidationReport
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationReport not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationReport): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationReport): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationReport): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationReport): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationReport): event_validator.ValidationReport
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationReport -> event_validator.ValidationReport
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      [TYPE_INFERENCE] Call resolved to: event_validator.ValidationReport
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.ValidationReport (class instantiation)
      [SYMBOL_UPDATE] Function: report -> event_validator.ValidationReport
        [ASSIGNMENT] RESOLVED Updated symbol table: report = event_validator.ValidationReport
      [NAME] Found name reference: report
    [RESOLVE] Attempting to resolve: ['report']
      [RESOLVE_SIMPLE] Resolving base: report
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] can_resolve(report): True
      [SYMBOL_LOOKUP] Found report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] resolve(report): event_validator.ValidationReport
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: report -> event_validator.ValidationReport
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
      [CALL] Found call: ValidationReport
    [RESOLVE] Attempting to resolve: ['ValidationReport']
      [RESOLVE_SIMPLE] Resolving base: ValidationReport
      [CACHE] Hit for ValidationReport: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Resolved to: event_validator.ValidationReport
      -> ADDED to instantiations
      [NAME] Found name reference: ValidationReport
        [CACHE] ValidationReport -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.VALID
    [RESOLVE] Attempting to resolve: ['ValidationResult', 'VALID']
    [RESOLVE] Chain resolution needed for: ['ValidationResult', 'VALID']
      [CHAIN] Resolving base: ValidationResult
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationResult not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationResult): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationResult): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationResult): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationResult): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationResult): event_validator.ValidationResult
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationResult -> event_validator.ValidationResult
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: ValidationResult -> event_validator.ValidationResult
      [CHAIN] Step 1: Resolving event_validator.ValidationResult.VALID
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationResult.VALID
        [ATTRIBUTE] Direct match found: event_validator.ValidationResult.VALID
      [CHAIN] Step 1 resolved: event_validator.ValidationResult.VALID
    [RESOLVE] RESOLVED to: event_validator.ValidationResult.VALID
      -> Not module state
      [NAME] Found name reference: ValidationResult
    [RESOLVE] Attempting to resolve: ['ValidationResult']
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
    [RESOLVE] RESOLVED to: event_validator.ValidationResult
      -> Not module state
      [CALL] Found call: isinstance
    [RESOLVE] Attempting to resolve: ['isinstance']
      [RESOLVE_SIMPLE] Resolving base: isinstance
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable isinstance not found in any scope
      [LOCAL_RESOLVER] can_resolve(isinstance): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(isinstance): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(isinstance): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(isinstance): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(isinstance): event_validator.isinstance
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: isinstance -> event_validator.isinstance
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.isinstance
      -> Resolved to: event_validator.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(data): True
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(data): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: data -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
        [FUNCTION_ARG] Checking argument: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(dict): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(dict): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(dict): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(dict): event_validator.dict
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: dict -> event_validator.dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.dict
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> event_validator.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [NAME] Found name reference: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: event_validator.dict
    [RESOLVE] RESOLVED to: event_validator.dict
      -> Not module state
      [ATTRIBUTE] Found attribute access: report.result
    [RESOLVE] Attempting to resolve: ['report', 'result']
    [RESOLVE] Chain resolution needed for: ['report', 'result']
      [CHAIN] Resolving base: report
      [RESOLVE_SIMPLE] Resolving base: report
      [CACHE] Hit for report: event_validator.ValidationReport
      [CHAIN] Base resolved: report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.result
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.result
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.result
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.result
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.result
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.INVALID
    [RESOLVE] Attempting to resolve: ['ValidationResult', 'INVALID']
    [RESOLVE] Chain resolution needed for: ['ValidationResult', 'INVALID']
      [CHAIN] Resolving base: ValidationResult
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
      [CHAIN] Base resolved: ValidationResult -> event_validator.ValidationResult
      [CHAIN] Step 1: Resolving event_validator.ValidationResult.INVALID
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationResult.INVALID
        [ATTRIBUTE] Direct match found: event_validator.ValidationResult.INVALID
      [CHAIN] Step 1 resolved: event_validator.ValidationResult.INVALID
    [RESOLVE] RESOLVED to: event_validator.ValidationResult.INVALID
      -> Not module state
      [NAME] Found name reference: ValidationResult
        [CACHE] ValidationResult -> event_validator.ValidationResult (cached)
      -> Not module state
      [CALL] Found call: report.add_error
    [RESOLVE] Attempting to resolve: ['report', 'add_error']
    [RESOLVE] Chain resolution needed for: ['report', 'add_error']
      [CHAIN] Resolving base: report
      [RESOLVE_SIMPLE] Resolving base: report
      [CACHE] Hit for report: event_validator.ValidationReport
      [CHAIN] Base resolved: report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.add_error
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.add_error
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.add_error
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.add_error
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.add_error
            [INTERMEDIATE] Tracking chain steps for: report.add_error
            [INTERMEDIATE] Step 1: report.add_error
      -> Resolved to: event_validator.ValidationReport.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: report.add_error
        [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: field
    [RESOLVE] Attempting to resolve: ['field']
      [RESOLVE_SIMPLE] Resolving base: field
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable field not found in any scope
      [LOCAL_RESOLVER] can_resolve(field): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(field): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(field): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(field): dataclasses.field (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: field -> dataclasses.field
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: dataclasses.field
      -> Not module state
      [NAME] Found name reference: expected_type
    [RESOLVE] Attempting to resolve: ['expected_type']
      [RESOLVE_SIMPLE] Resolving base: expected_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable expected_type not found in any scope
      [LOCAL_RESOLVER] can_resolve(expected_type): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(expected_type): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(expected_type): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(expected_type): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(expected_type): event_validator.expected_type
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: expected_type -> event_validator.expected_type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.expected_type
      -> Not module state
      [CALL] Found call: self.field_types.items
    [RESOLVE] Attempting to resolve: ['self', 'field_types', 'items']
    [RESOLVE] Chain resolution needed for: ['self', 'field_types', 'items']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.DataTypeRule
      [CHAIN] Base resolved: self -> event_validator.DataTypeRule
      [CHAIN] Step 1: Resolving event_validator.DataTypeRule.field_types
        [ATTRIBUTE] Resolving attribute: event_validator.DataTypeRule.field_types
        [ATTRIBUTE] Direct match found: event_validator.DataTypeRule.field_types
      [CHAIN] Step 1 resolved: event_validator.DataTypeRule.field_types
      [CHAIN] Step 2: Resolving event_validator.DataTypeRule.field_types.items
        [ATTRIBUTE] Resolving attribute: event_validator.DataTypeRule.field_types.items
        [ATTRIBUTE] Direct match found: event_validator.DataTypeRule.field_types.items
      [CHAIN] Step 2 resolved: event_validator.DataTypeRule.field_types.items
    [RESOLVE] RESOLVED to: event_validator.DataTypeRule.field_types.items
            [INTERMEDIATE] Tracking chain steps for: self.field_types.items
            [INTERMEDIATE] Step 1: self.field_types
    [RESOLVE] Attempting to resolve: ['self', 'field_types']
    [RESOLVE] Chain resolution needed for: ['self', 'field_types']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.DataTypeRule
      [CHAIN] Base resolved: self -> event_validator.DataTypeRule
      [CHAIN] Step 1: Resolving event_validator.DataTypeRule.field_types
        [ATTRIBUTE] Resolving attribute: event_validator.DataTypeRule.field_types
        [ATTRIBUTE] Direct match found: event_validator.DataTypeRule.field_types
      [CHAIN] Step 1 resolved: event_validator.DataTypeRule.field_types
    [RESOLVE] RESOLVED to: event_validator.DataTypeRule.field_types
            [INTERMEDIATE] Step 1 resolved to: event_validator.DataTypeRule.field_types
            [INTERMEDIATE] Step 2: self.field_types.items
      -> Resolved to: event_validator.DataTypeRule.field_types.items
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.field_types.items
        [CACHE] self.field_types.items -> event_validator.DataTypeRule.field_types.items (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.field_types
        [CACHE] self.field_types -> event_validator.DataTypeRule.field_types (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.DataTypeRule
    [RESOLVE] RESOLVED to: event_validator.DataTypeRule
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [ASSIGNMENT] Processing: value = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable value not found in any scope
      [LOCAL_RESOLVER] can_resolve(value): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(value): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(value): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(value): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(value): event_validator.value
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: value -> event_validator.value
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.value
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> event_validator.isinstance (cached)
      -> Resolved to: event_validator.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: expected_type
    [RESOLVE] Attempting to resolve: ['expected_type']
      [RESOLVE_SIMPLE] Resolving base: expected_type
      [CACHE] Hit for expected_type: event_validator.expected_type
    [RESOLVE] RESOLVED to: event_validator.expected_type
        [FUNCTION_ARG] Checking argument: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable list not found in any scope
      [LOCAL_RESOLVER] can_resolve(list): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(list): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(list): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(list): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(list): event_validator.list
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: list -> event_validator.list
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.list
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> event_validator.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: expected_type
        [CACHE] expected_type -> event_validator.expected_type (cached)
      -> Not module state
      [NAME] Found name reference: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [CACHE] Hit for list: event_validator.list
    [RESOLVE] RESOLVED to: event_validator.list
      -> Not module state
      [CALL] Found call: any
      -> IGNORED (built-in function)
      [NAME] Found name reference: any
    [RESOLVE] Attempting to resolve: ['any']
      [RESOLVE_SIMPLE] Resolving base: any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable any not found in any scope
      [LOCAL_RESOLVER] can_resolve(any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(any): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(any): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(any): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(any): event_validator.any
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: any -> event_validator.any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.any
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> event_validator.isinstance (cached)
      -> Resolved to: event_validator.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: event_validator.value
    [RESOLVE] RESOLVED to: event_validator.value
        [FUNCTION_ARG] Checking argument: t
    [RESOLVE] Attempting to resolve: ['t']
      [RESOLVE_SIMPLE] Resolving base: t
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable t not found in any scope
      [LOCAL_RESOLVER] can_resolve(t): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(t): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(t): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(t): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(t): event_validator.t
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: t -> event_validator.t
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.t
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> event_validator.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> event_validator.value (cached)
      -> Not module state
      [NAME] Found name reference: t
    [RESOLVE] Attempting to resolve: ['t']
      [RESOLVE_SIMPLE] Resolving base: t
      [CACHE] Hit for t: event_validator.t
    [RESOLVE] RESOLVED to: event_validator.t
      -> Not module state
      [NAME] Found name reference: t
        [CACHE] t -> event_validator.t (cached)
      -> Not module state
      [NAME] Found name reference: expected_type
        [CACHE] expected_type -> event_validator.expected_type (cached)
      -> Not module state
      [ASSIGNMENT] Processing: type_names = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: type_names
    [RESOLVE] Attempting to resolve: ['type_names']
      [RESOLVE_SIMPLE] Resolving base: type_names
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable type_names not found in any scope
      [LOCAL_RESOLVER] can_resolve(type_names): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(type_names): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(type_names): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(type_names): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(type_names): event_validator.type_names
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: type_names -> event_validator.type_names
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.type_names
      -> Not module state
      [ATTRIBUTE] Found attribute access: t.__name__
    [RESOLVE] Attempting to resolve: ['t', '__name__']
    [RESOLVE] Chain resolution needed for: ['t', '__name__']
      [CHAIN] Resolving base: t
      [RESOLVE_SIMPLE] Resolving base: t
      [CACHE] Hit for t: event_validator.t
      [CHAIN] Base resolved: t -> event_validator.t
      [CHAIN] Step 1: Resolving event_validator.t.__name__
        [ATTRIBUTE] Resolving attribute: event_validator.t.__name__
        [ATTRIBUTE] Direct match found: event_validator.t.__name__
      [CHAIN] Step 1 resolved: event_validator.t.__name__
    [RESOLVE] RESOLVED to: event_validator.t.__name__
      -> Not module state
      [NAME] Found name reference: t
        [CACHE] t -> event_validator.t (cached)
      -> Not module state
      [NAME] Found name reference: t
        [CACHE] t -> event_validator.t (cached)
      -> Not module state
      [NAME] Found name reference: expected_type
        [CACHE] expected_type -> event_validator.expected_type (cached)
      -> Not module state
      [CALL] Found call: report.add_error
    [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
            [INTERMEDIATE] Tracking chain steps for: report.add_error
            [INTERMEDIATE] Step 1: report.add_error
      -> Resolved to: event_validator.ValidationReport.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: report.add_error
        [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: type_names
        [CACHE] type_names -> event_validator.type_names (cached)
      -> Not module state
      [CALL] Found call: type
    [RESOLVE] Attempting to resolve: ['type']
      [RESOLVE_SIMPLE] Resolving base: type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable type not found in any scope
      [LOCAL_RESOLVER] can_resolve(type): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(type): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(type): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(type): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(type): event_validator.type
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: type -> event_validator.type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.type
      -> Resolved to: event_validator.type
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: event_validator.value
    [RESOLVE] RESOLVED to: event_validator.value
      [NAME] Found name reference: type
        [CACHE] type -> event_validator.type (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> event_validator.value (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationLevel.ERROR
    [RESOLVE] Attempting to resolve: ['ValidationLevel', 'ERROR']
    [RESOLVE] Chain resolution needed for: ['ValidationLevel', 'ERROR']
      [CHAIN] Resolving base: ValidationLevel
      [RESOLVE_SIMPLE] Resolving base: ValidationLevel
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationLevel not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationLevel): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationLevel): False (current_class: event_validator.DataTypeRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationLevel): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationLevel): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationLevel): event_validator.ValidationLevel
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationLevel -> event_validator.ValidationLevel
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: ValidationLevel -> event_validator.ValidationLevel
      [CHAIN] Step 1: Resolving event_validator.ValidationLevel.ERROR
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationLevel.ERROR
        [ATTRIBUTE] Direct match found: event_validator.ValidationLevel.ERROR
      [CHAIN] Step 1 resolved: event_validator.ValidationLevel.ERROR
    [RESOLVE] RESOLVED to: event_validator.ValidationLevel.ERROR
      -> Not module state
      [NAME] Found name reference: ValidationLevel
    [RESOLVE] Attempting to resolve: ['ValidationLevel']
      [RESOLVE_SIMPLE] Resolving base: ValidationLevel
      [CACHE] Hit for ValidationLevel: event_validator.ValidationLevel
    [RESOLVE] RESOLVED to: event_validator.ValidationLevel
      -> Not module state
      [NAME] Found name reference: type_names
        [CACHE] type_names -> event_validator.type_names (cached)
      -> Not module state
      [CALL] Found call: type
    [CACHE] type -> event_validator.type (cached)
      -> Resolved to: event_validator.type
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: event_validator.value
    [RESOLVE] RESOLVED to: event_validator.value
      [NAME] Found name reference: type
        [CACHE] type -> event_validator.type (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> event_validator.value (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: report.result
        [CACHE] report.result -> event_validator.ValidationReport.result (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.INVALID
        [CACHE] ValidationResult.INVALID -> event_validator.ValidationResult.INVALID (cached)
      -> Not module state
      [NAME] Found name reference: ValidationResult
        [CACHE] ValidationResult -> event_validator.ValidationResult (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> event_validator.isinstance (cached)
      -> Resolved to: event_validator.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: event_validator.value
    [RESOLVE] RESOLVED to: event_validator.value
        [FUNCTION_ARG] Checking argument: expected_type
    [RESOLVE] Attempting to resolve: ['expected_type']
      [RESOLVE_SIMPLE] Resolving base: expected_type
      [CACHE] Hit for expected_type: event_validator.expected_type
    [RESOLVE] RESOLVED to: event_validator.expected_type
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> event_validator.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> event_validator.value (cached)
      -> Not module state
      [NAME] Found name reference: expected_type
        [CACHE] expected_type -> event_validator.expected_type (cached)
      -> Not module state
      [CALL] Found call: report.add_error
    [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
            [INTERMEDIATE] Tracking chain steps for: report.add_error
            [INTERMEDIATE] Step 1: report.add_error
      -> Resolved to: event_validator.ValidationReport.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: report.add_error
        [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: expected_type.__name__
    [RESOLVE] Attempting to resolve: ['expected_type', '__name__']
    [RESOLVE] Chain resolution needed for: ['expected_type', '__name__']
      [CHAIN] Resolving base: expected_type
      [RESOLVE_SIMPLE] Resolving base: expected_type
      [CACHE] Hit for expected_type: event_validator.expected_type
      [CHAIN] Base resolved: expected_type -> event_validator.expected_type
      [CHAIN] Step 1: Resolving event_validator.expected_type.__name__
        [ATTRIBUTE] Resolving attribute: event_validator.expected_type.__name__
        [ATTRIBUTE] Direct match found: event_validator.expected_type.__name__
      [CHAIN] Step 1 resolved: event_validator.expected_type.__name__
    [RESOLVE] RESOLVED to: event_validator.expected_type.__name__
      -> Not module state
      [NAME] Found name reference: expected_type
        [CACHE] expected_type -> event_validator.expected_type (cached)
      -> Not module state
      [CALL] Found call: type
    [CACHE] type -> event_validator.type (cached)
      -> Resolved to: event_validator.type
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: event_validator.value
    [RESOLVE] RESOLVED to: event_validator.value
      [NAME] Found name reference: type
        [CACHE] type -> event_validator.type (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> event_validator.value (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationLevel.ERROR
        [CACHE] ValidationLevel.ERROR -> event_validator.ValidationLevel.ERROR (cached)
      -> Not module state
      [NAME] Found name reference: ValidationLevel
        [CACHE] ValidationLevel -> event_validator.ValidationLevel (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: expected_type.__name__
        [CACHE] expected_type.__name__ -> event_validator.expected_type.__name__ (cached)
      -> Not module state
      [NAME] Found name reference: expected_type
        [CACHE] expected_type -> event_validator.expected_type (cached)
      -> Not module state
      [CALL] Found call: type
    [CACHE] type -> event_validator.type (cached)
      -> Resolved to: event_validator.type
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: event_validator.value
    [RESOLVE] RESOLVED to: event_validator.value
      [NAME] Found name reference: type
        [CACHE] type -> event_validator.type (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> event_validator.value (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: report.result
        [CACHE] report.result -> event_validator.ValidationReport.result (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.INVALID
        [CACHE] ValidationResult.INVALID -> event_validator.ValidationResult.INVALID (cached)
      -> Not module state
      [NAME] Found name reference: ValidationResult
        [CACHE] ValidationResult -> event_validator.ValidationResult (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.DataTypeRule._validate_implementation
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.DataTypeRule._validate_implementation
        Calls: 1
        Instantiations: 1
        State Access: 0
    [CONTEXT] Exited class: event_validator.DataTypeRule
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: RegexValidationRule
    [CONTEXT] Entered class: event_validator.RegexValidationRule
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.RegexValidationRule.__init__
    [CONTEXT] Entered function: event_validator.RegexValidationRule.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'field_patterns': 'Dict[str, str]'}
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable super not found in any scope
      [LOCAL_RESOLVER] can_resolve(super): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(super): False (current_class: event_validator.RegexValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(super): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(super): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(super): event_validator.super
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: super -> event_validator.super
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.super
      -> Resolved to: event_validator.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> event_validator.super (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.field_patterns
    [RESOLVE] Attempting to resolve: ['self', 'field_patterns']
    [RESOLVE] Chain resolution needed for: ['self', 'field_patterns']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: event_validator.RegexValidationRule)
      [SELF_RESOLVER] resolve(self): event_validator.RegexValidationRule
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> event_validator.RegexValidationRule
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> event_validator.RegexValidationRule
      [CHAIN] Step 1: Resolving event_validator.RegexValidationRule.field_patterns
        [ATTRIBUTE] Resolving attribute: event_validator.RegexValidationRule.field_patterns
        [ATTRIBUTE] Direct match found: event_validator.RegexValidationRule.field_patterns
      [CHAIN] Step 1 resolved: event_validator.RegexValidationRule.field_patterns
    [RESOLVE] RESOLVED to: event_validator.RegexValidationRule.field_patterns
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.RegexValidationRule
    [RESOLVE] RESOLVED to: event_validator.RegexValidationRule
      -> Not module state
      [NAME] Found name reference: field_patterns
    [RESOLVE] Attempting to resolve: ['field_patterns']
      [RESOLVE_SIMPLE] Resolving base: field_patterns
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable field_patterns not found in any scope
      [LOCAL_RESOLVER] can_resolve(field_patterns): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(field_patterns): False (current_class: event_validator.RegexValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(field_patterns): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(field_patterns): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(field_patterns): event_validator.field_patterns
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: field_patterns -> event_validator.field_patterns
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.field_patterns
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.compiled_patterns
    [RESOLVE] Attempting to resolve: ['self', 'compiled_patterns']
    [RESOLVE] Chain resolution needed for: ['self', 'compiled_patterns']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.RegexValidationRule
      [CHAIN] Base resolved: self -> event_validator.RegexValidationRule
      [CHAIN] Step 1: Resolving event_validator.RegexValidationRule.compiled_patterns
        [ATTRIBUTE] Resolving attribute: event_validator.RegexValidationRule.compiled_patterns
        [ATTRIBUTE] Direct match found: event_validator.RegexValidationRule.compiled_patterns
      [CHAIN] Step 1 resolved: event_validator.RegexValidationRule.compiled_patterns
    [RESOLVE] RESOLVED to: event_validator.RegexValidationRule.compiled_patterns
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.RegexValidationRule (cached)
      -> Not module state
      [NAME] Found name reference: field
    [RESOLVE] Attempting to resolve: ['field']
      [RESOLVE_SIMPLE] Resolving base: field
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable field not found in any scope
      [LOCAL_RESOLVER] can_resolve(field): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(field): False (current_class: event_validator.RegexValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(field): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(field): dataclasses.field (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: field -> dataclasses.field
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: dataclasses.field
      -> Not module state
      [CALL] Found call: re.compile
    [RESOLVE] Attempting to resolve: ['re', 'compile']
    [RESOLVE] Chain resolution needed for: ['re', 'compile']
      [CHAIN] Resolving base: re
      [RESOLVE_SIMPLE] Resolving base: re
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable re not found in any scope
      [LOCAL_RESOLVER] can_resolve(re): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(re): False (current_class: event_validator.RegexValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(re): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(re): re (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: re -> re
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: re -> re
      [CHAIN] Step 1: Resolving re.compile
        [ATTRIBUTE] Resolving attribute: re.compile
        [ATTRIBUTE] Direct match found: re.compile
      [CHAIN] Step 1 resolved: re.compile
    [RESOLVE] RESOLVED to: re.compile
            [INTERMEDIATE] Tracking chain steps for: re.compile
            [INTERMEDIATE] Step 1: re.compile
      -> Resolved to: re.compile
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: pattern
    [RESOLVE] Attempting to resolve: ['pattern']
      [RESOLVE_SIMPLE] Resolving base: pattern
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable pattern not found in any scope
      [LOCAL_RESOLVER] can_resolve(pattern): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(pattern): False (current_class: event_validator.RegexValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(pattern): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(pattern): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(pattern): event_validator.pattern
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: pattern -> event_validator.pattern
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.pattern
      [ATTRIBUTE] Found attribute access: re.compile
        [CACHE] re.compile -> re.compile (cached)
      -> Not module state
      [NAME] Found name reference: re
    [RESOLVE] Attempting to resolve: ['re']
      [RESOLVE_SIMPLE] Resolving base: re
      [CACHE] Hit for re: re
    [RESOLVE] RESOLVED to: re
      -> Not module state
      [NAME] Found name reference: pattern
    [RESOLVE] Attempting to resolve: ['pattern']
      [RESOLVE_SIMPLE] Resolving base: pattern
      [CACHE] Hit for pattern: event_validator.pattern
    [RESOLVE] RESOLVED to: event_validator.pattern
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: pattern
        [CACHE] pattern -> event_validator.pattern (cached)
      -> Not module state
      [CALL] Found call: field_patterns.items
    [RESOLVE] Attempting to resolve: ['field_patterns', 'items']
    [RESOLVE] Chain resolution needed for: ['field_patterns', 'items']
      [CHAIN] Resolving base: field_patterns
      [RESOLVE_SIMPLE] Resolving base: field_patterns
      [CACHE] Hit for field_patterns: event_validator.field_patterns
      [CHAIN] Base resolved: field_patterns -> event_validator.field_patterns
      [CHAIN] Step 1: Resolving event_validator.field_patterns.items
        [ATTRIBUTE] Resolving attribute: event_validator.field_patterns.items
        [ATTRIBUTE] Direct match found: event_validator.field_patterns.items
      [CHAIN] Step 1 resolved: event_validator.field_patterns.items
    [RESOLVE] RESOLVED to: event_validator.field_patterns.items
            [INTERMEDIATE] Tracking chain steps for: field_patterns.items
            [INTERMEDIATE] Step 1: field_patterns.items
      -> Resolved to: event_validator.field_patterns.items
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: field_patterns.items
        [CACHE] field_patterns.items -> event_validator.field_patterns.items (cached)
      -> Not module state
      [NAME] Found name reference: field_patterns
        [CACHE] field_patterns -> event_validator.field_patterns (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.RegexValidationRule.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.RegexValidationRule.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.RegexValidationRule._validate_implementation
    [CONTEXT] Entered function: event_validator.RegexValidationRule._validate_implementation (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any', 'context': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: event_validator.RegexValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [ASSIGNMENT] Processing: report = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ValidationReport
    [RESOLVE] Attempting to resolve: ['ValidationReport']
      [RESOLVE_SIMPLE] Resolving base: ValidationReport
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationReport not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationReport): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationReport): False (current_class: event_validator.RegexValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationReport): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationReport): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationReport): event_validator.ValidationReport
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationReport -> event_validator.ValidationReport
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      [TYPE_INFERENCE] Call resolved to: event_validator.ValidationReport
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.ValidationReport (class instantiation)
      [SYMBOL_UPDATE] Function: report -> event_validator.ValidationReport
        [ASSIGNMENT] RESOLVED Updated symbol table: report = event_validator.ValidationReport
      [NAME] Found name reference: report
    [RESOLVE] Attempting to resolve: ['report']
      [RESOLVE_SIMPLE] Resolving base: report
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] can_resolve(report): True
      [SYMBOL_LOOKUP] Found report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] resolve(report): event_validator.ValidationReport
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: report -> event_validator.ValidationReport
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
      [CALL] Found call: ValidationReport
    [RESOLVE] Attempting to resolve: ['ValidationReport']
      [RESOLVE_SIMPLE] Resolving base: ValidationReport
      [CACHE] Hit for ValidationReport: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Resolved to: event_validator.ValidationReport
      -> ADDED to instantiations
      [NAME] Found name reference: ValidationReport
        [CACHE] ValidationReport -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.VALID
    [RESOLVE] Attempting to resolve: ['ValidationResult', 'VALID']
    [RESOLVE] Chain resolution needed for: ['ValidationResult', 'VALID']
      [CHAIN] Resolving base: ValidationResult
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationResult not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationResult): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationResult): False (current_class: event_validator.RegexValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationResult): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationResult): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationResult): event_validator.ValidationResult
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationResult -> event_validator.ValidationResult
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: ValidationResult -> event_validator.ValidationResult
      [CHAIN] Step 1: Resolving event_validator.ValidationResult.VALID
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationResult.VALID
        [ATTRIBUTE] Direct match found: event_validator.ValidationResult.VALID
      [CHAIN] Step 1 resolved: event_validator.ValidationResult.VALID
    [RESOLVE] RESOLVED to: event_validator.ValidationResult.VALID
      -> Not module state
      [NAME] Found name reference: ValidationResult
    [RESOLVE] Attempting to resolve: ['ValidationResult']
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
    [RESOLVE] RESOLVED to: event_validator.ValidationResult
      -> Not module state
      [CALL] Found call: isinstance
    [RESOLVE] Attempting to resolve: ['isinstance']
      [RESOLVE_SIMPLE] Resolving base: isinstance
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable isinstance not found in any scope
      [LOCAL_RESOLVER] can_resolve(isinstance): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(isinstance): False (current_class: event_validator.RegexValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(isinstance): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(isinstance): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(isinstance): event_validator.isinstance
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: isinstance -> event_validator.isinstance
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.isinstance
      -> Resolved to: event_validator.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(data): True
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(data): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: data -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
        [FUNCTION_ARG] Checking argument: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(dict): False (current_class: event_validator.RegexValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(dict): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(dict): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(dict): event_validator.dict
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: dict -> event_validator.dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.dict
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> event_validator.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [NAME] Found name reference: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: event_validator.dict
    [RESOLVE] RESOLVED to: event_validator.dict
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: field
    [RESOLVE] Attempting to resolve: ['field']
      [RESOLVE_SIMPLE] Resolving base: field
      [CACHE] Hit for field: dataclasses.field
    [RESOLVE] RESOLVED to: dataclasses.field
      -> Not module state
      [NAME] Found name reference: pattern
    [RESOLVE] Attempting to resolve: ['pattern']
      [RESOLVE_SIMPLE] Resolving base: pattern
      [CACHE] Hit for pattern: event_validator.pattern
    [RESOLVE] RESOLVED to: event_validator.pattern
      -> Not module state
      [CALL] Found call: self.compiled_patterns.items
    [RESOLVE] Attempting to resolve: ['self', 'compiled_patterns', 'items']
    [RESOLVE] Chain resolution needed for: ['self', 'compiled_patterns', 'items']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.RegexValidationRule
      [CHAIN] Base resolved: self -> event_validator.RegexValidationRule
      [CHAIN] Step 1: Resolving event_validator.RegexValidationRule.compiled_patterns
        [ATTRIBUTE] Resolving attribute: event_validator.RegexValidationRule.compiled_patterns
        [ATTRIBUTE] Direct match found: event_validator.RegexValidationRule.compiled_patterns
      [CHAIN] Step 1 resolved: event_validator.RegexValidationRule.compiled_patterns
      [CHAIN] Step 2: Resolving event_validator.RegexValidationRule.compiled_patterns.items
        [ATTRIBUTE] Resolving attribute: event_validator.RegexValidationRule.compiled_patterns.items
        [ATTRIBUTE] Direct match found: event_validator.RegexValidationRule.compiled_patterns.items
      [CHAIN] Step 2 resolved: event_validator.RegexValidationRule.compiled_patterns.items
    [RESOLVE] RESOLVED to: event_validator.RegexValidationRule.compiled_patterns.items
            [INTERMEDIATE] Tracking chain steps for: self.compiled_patterns.items
            [INTERMEDIATE] Step 1: self.compiled_patterns
    [RESOLVE] Attempting to resolve: ['self', 'compiled_patterns']
    [RESOLVE] Chain resolution needed for: ['self', 'compiled_patterns']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.RegexValidationRule
      [CHAIN] Base resolved: self -> event_validator.RegexValidationRule
      [CHAIN] Step 1: Resolving event_validator.RegexValidationRule.compiled_patterns
        [ATTRIBUTE] Resolving attribute: event_validator.RegexValidationRule.compiled_patterns
        [ATTRIBUTE] Direct match found: event_validator.RegexValidationRule.compiled_patterns
      [CHAIN] Step 1 resolved: event_validator.RegexValidationRule.compiled_patterns
    [RESOLVE] RESOLVED to: event_validator.RegexValidationRule.compiled_patterns
            [INTERMEDIATE] Step 1 resolved to: event_validator.RegexValidationRule.compiled_patterns
            [INTERMEDIATE] Step 2: self.compiled_patterns.items
      -> Resolved to: event_validator.RegexValidationRule.compiled_patterns.items
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.compiled_patterns.items
        [CACHE] self.compiled_patterns.items -> event_validator.RegexValidationRule.compiled_patterns.items (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.compiled_patterns
        [CACHE] self.compiled_patterns -> event_validator.RegexValidationRule.compiled_patterns (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.RegexValidationRule
    [RESOLVE] RESOLVED to: event_validator.RegexValidationRule
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [ASSIGNMENT] Processing: value = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable value not found in any scope
      [LOCAL_RESOLVER] can_resolve(value): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(value): False (current_class: event_validator.RegexValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(value): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(value): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(value): event_validator.value
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: value -> event_validator.value
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.value
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> event_validator.isinstance (cached)
      -> Resolved to: event_validator.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: event_validator.value
    [RESOLVE] RESOLVED to: event_validator.value
        [FUNCTION_ARG] Checking argument: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: event_validator.RegexValidationRule)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(str): event_validator.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> event_validator.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> event_validator.value (cached)
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: event_validator.str
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [CALL] Found call: report.add_error
    [RESOLVE] Attempting to resolve: ['report', 'add_error']
    [RESOLVE] Chain resolution needed for: ['report', 'add_error']
      [CHAIN] Resolving base: report
      [RESOLVE_SIMPLE] Resolving base: report
      [CACHE] Hit for report: event_validator.ValidationReport
      [CHAIN] Base resolved: report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.add_error
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.add_error
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.add_error
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.add_error
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.add_error
            [INTERMEDIATE] Tracking chain steps for: report.add_error
            [INTERMEDIATE] Step 1: report.add_error
      -> Resolved to: event_validator.ValidationReport.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: report.add_error
        [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: report.result
    [RESOLVE] Attempting to resolve: ['report', 'result']
    [RESOLVE] Chain resolution needed for: ['report', 'result']
      [CHAIN] Resolving base: report
      [RESOLVE_SIMPLE] Resolving base: report
      [CACHE] Hit for report: event_validator.ValidationReport
      [CHAIN] Base resolved: report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.result
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.result
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.result
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.result
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.result
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.INVALID
    [RESOLVE] Attempting to resolve: ['ValidationResult', 'INVALID']
    [RESOLVE] Chain resolution needed for: ['ValidationResult', 'INVALID']
      [CHAIN] Resolving base: ValidationResult
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
      [CHAIN] Base resolved: ValidationResult -> event_validator.ValidationResult
      [CHAIN] Step 1: Resolving event_validator.ValidationResult.INVALID
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationResult.INVALID
        [ATTRIBUTE] Direct match found: event_validator.ValidationResult.INVALID
      [CHAIN] Step 1 resolved: event_validator.ValidationResult.INVALID
    [RESOLVE] RESOLVED to: event_validator.ValidationResult.INVALID
      -> Not module state
      [NAME] Found name reference: ValidationResult
        [CACHE] ValidationResult -> event_validator.ValidationResult (cached)
      -> Not module state
      [CALL] Found call: pattern.match
    [RESOLVE] Attempting to resolve: ['pattern', 'match']
    [RESOLVE] Chain resolution needed for: ['pattern', 'match']
      [CHAIN] Resolving base: pattern
      [RESOLVE_SIMPLE] Resolving base: pattern
      [CACHE] Hit for pattern: event_validator.pattern
      [CHAIN] Base resolved: pattern -> event_validator.pattern
      [CHAIN] Step 1: Resolving event_validator.pattern.match
        [ATTRIBUTE] Resolving attribute: event_validator.pattern.match
        [ATTRIBUTE] Direct match found: event_validator.pattern.match
      [CHAIN] Step 1 resolved: event_validator.pattern.match
    [RESOLVE] RESOLVED to: event_validator.pattern.match
            [INTERMEDIATE] Tracking chain steps for: pattern.match
            [INTERMEDIATE] Step 1: pattern.match
      -> Resolved to: event_validator.pattern.match
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: event_validator.value
    [RESOLVE] RESOLVED to: event_validator.value
      [ATTRIBUTE] Found attribute access: pattern.match
        [CACHE] pattern.match -> event_validator.pattern.match (cached)
      -> Not module state
      [NAME] Found name reference: pattern
        [CACHE] pattern -> event_validator.pattern (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> event_validator.value (cached)
      -> Not module state
      [CALL] Found call: report.add_error
    [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
            [INTERMEDIATE] Tracking chain steps for: report.add_error
            [INTERMEDIATE] Step 1: report.add_error
      -> Resolved to: event_validator.ValidationReport.add_error
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: report.add_error
        [CACHE] report.add_error -> event_validator.ValidationReport.add_error (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.field_patterns
    [RESOLVE] Attempting to resolve: ['self', 'field_patterns']
    [RESOLVE] Chain resolution needed for: ['self', 'field_patterns']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.RegexValidationRule
      [CHAIN] Base resolved: self -> event_validator.RegexValidationRule
      [CHAIN] Step 1: Resolving event_validator.RegexValidationRule.field_patterns
        [ATTRIBUTE] Resolving attribute: event_validator.RegexValidationRule.field_patterns
        [ATTRIBUTE] Direct match found: event_validator.RegexValidationRule.field_patterns
      [CHAIN] Step 1 resolved: event_validator.RegexValidationRule.field_patterns
    [RESOLVE] RESOLVED to: event_validator.RegexValidationRule.field_patterns
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.RegexValidationRule (cached)
      -> Not module state
      [NAME] Found name reference: field
        [CACHE] field -> dataclasses.field (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> event_validator.value (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: report.result
        [CACHE] report.result -> event_validator.ValidationReport.result (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.INVALID
        [CACHE] ValidationResult.INVALID -> event_validator.ValidationResult.INVALID (cached)
      -> Not module state
      [NAME] Found name reference: ValidationResult
        [CACHE] ValidationResult -> event_validator.ValidationResult (cached)
      -> Not module state
      [NAME] Found name reference: report
        [CACHE] report -> event_validator.ValidationReport (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.RegexValidationRule._validate_implementation
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.RegexValidationRule._validate_implementation
        Calls: 1
        Instantiations: 1
        State Access: 0
    [CONTEXT] Exited class: event_validator.RegexValidationRule
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: ValidationEngine
    [CONTEXT] Entered class: event_validator.ValidationEngine
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationEngine.__init__
    [CONTEXT] Entered function: event_validator.ValidationEngine.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.rules
    [RESOLVE] Attempting to resolve: ['self', 'rules']
    [RESOLVE] Chain resolution needed for: ['self', 'rules']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: event_validator.ValidationEngine)
      [SELF_RESOLVER] resolve(self): event_validator.ValidationEngine
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> event_validator.ValidationEngine
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.rules
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.rules
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.rules
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      -> Not module state
      [NAME] Found name reference: List
    [RESOLVE] Attempting to resolve: ['List']
      [RESOLVE_SIMPLE] Resolving base: List
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable List not found in any scope
      [LOCAL_RESOLVER] can_resolve(List): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(List): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(List): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(List): typing.List (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: List -> typing.List
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.List
      -> Not module state
      [NAME] Found name reference: BaseValidationRule
    [RESOLVE] Attempting to resolve: ['BaseValidationRule']
      [RESOLVE_SIMPLE] Resolving base: BaseValidationRule
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable BaseValidationRule not found in any scope
      [LOCAL_RESOLVER] can_resolve(BaseValidationRule): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(BaseValidationRule): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(BaseValidationRule): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(BaseValidationRule): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(BaseValidationRule): event_validator.BaseValidationRule
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: BaseValidationRule -> event_validator.BaseValidationRule
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.global_context
    [RESOLVE] Attempting to resolve: ['self', 'global_context']
    [RESOLVE] Chain resolution needed for: ['self', 'global_context']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.global_context
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.global_context
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.global_context
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.global_context
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.global_context
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(str): event_validator.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [NAME] Found name reference: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_cache
    [RESOLVE] Attempting to resolve: ['self', 'validation_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.validation_cache
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.validation_cache
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.validation_cache
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.validation_cache
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.validation_cache
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
      [NAME] Found name reference: Dict
        [CACHE] Dict -> typing.Dict (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> event_validator.str (cached)
      -> Not module state
      [NAME] Found name reference: ValidationReport
    [RESOLVE] Attempting to resolve: ['ValidationReport']
      [RESOLVE_SIMPLE] Resolving base: ValidationReport
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationReport not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationReport): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationReport): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationReport): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationReport): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationReport): event_validator.ValidationReport
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationReport -> event_validator.ValidationReport
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache_enabled
    [RESOLVE] Attempting to resolve: ['self', 'cache_enabled']
    [RESOLVE] Chain resolution needed for: ['self', 'cache_enabled']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.cache_enabled
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.cache_enabled
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.cache_enabled
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.cache_enabled
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.cache_enabled
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationEngine.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationEngine.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationEngine.add_rule
    [DECORATOR] @trace
    [CONTEXT] Entered function: event_validator.ValidationEngine.add_rule (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'rule': 'BaseValidationRule'}
        [ARG_TYPE] Processing type annotation for rule: BaseValidationRule
    [RESOLVE] Attempting to resolve: ['BaseValidationRule']
      [RESOLVE_SIMPLE] Resolving base: BaseValidationRule
      [CACHE] Hit for BaseValidationRule: event_validator.BaseValidationRule
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule
      [SYMBOL_UPDATE] Function: rule -> event_validator.BaseValidationRule
        [ARG_TYPE] RESOLVED rule : event_validator.BaseValidationRule
      [CALL] Found call: self.rules.append
    [RESOLVE] Attempting to resolve: ['self', 'rules', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'rules', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.rules
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.rules
      [CHAIN] Step 2: Resolving event_validator.ValidationEngine.rules.append
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.rules.append
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.rules.append
      [CHAIN] Step 2 resolved: event_validator.ValidationEngine.rules.append
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.rules.append
            [INTERMEDIATE] Tracking chain steps for: self.rules.append
            [INTERMEDIATE] Step 1: self.rules
    [RESOLVE] Attempting to resolve: ['self', 'rules']
    [RESOLVE] Chain resolution needed for: ['self', 'rules']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.rules
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.rules
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.rules
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationEngine.rules
            [INTERMEDIATE] Step 2: self.rules.append
      -> Resolved to: event_validator.ValidationEngine.rules.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found rule in function scope: event_validator.BaseValidationRule
      [LOCAL_RESOLVER] can_resolve(rule): True
      [SYMBOL_LOOKUP] Found rule in function scope: event_validator.BaseValidationRule
      [LOCAL_RESOLVER] resolve(rule): event_validator.BaseValidationRule
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: rule -> event_validator.BaseValidationRule
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule
      [ATTRIBUTE] Found attribute access: self.rules.append
        [CACHE] self.rules.append -> event_validator.ValidationEngine.rules.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.rules
        [CACHE] self.rules -> event_validator.ValidationEngine.rules (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      -> Not module state
      [NAME] Found name reference: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.BaseValidationRule
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule
      -> Not module state
      [CALL] Found call: self.rules.sort
    [RESOLVE] Attempting to resolve: ['self', 'rules', 'sort']
    [RESOLVE] Chain resolution needed for: ['self', 'rules', 'sort']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.rules
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.rules
      [CHAIN] Step 2: Resolving event_validator.ValidationEngine.rules.sort
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.rules.sort
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.rules.sort
      [CHAIN] Step 2 resolved: event_validator.ValidationEngine.rules.sort
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.rules.sort
            [INTERMEDIATE] Tracking chain steps for: self.rules.sort
            [INTERMEDIATE] Step 1: self.rules
    [CACHE] self.rules -> event_validator.ValidationEngine.rules (cached)
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationEngine.rules
            [INTERMEDIATE] Step 2: self.rules.sort
      -> Resolved to: event_validator.ValidationEngine.rules.sort
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.rules.sort
        [CACHE] self.rules.sort -> event_validator.ValidationEngine.rules.sort (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.rules
        [CACHE] self.rules -> event_validator.ValidationEngine.rules (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: r.priority
    [RESOLVE] Attempting to resolve: ['r', 'priority']
    [RESOLVE] Chain resolution needed for: ['r', 'priority']
      [CHAIN] Resolving base: r
      [RESOLVE_SIMPLE] Resolving base: r
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable r not found in any scope
      [LOCAL_RESOLVER] can_resolve(r): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(r): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(r): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(r): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(r): event_validator.r
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: r -> event_validator.r
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: r -> event_validator.r
      [CHAIN] Step 1: Resolving event_validator.r.priority
        [ATTRIBUTE] Resolving attribute: event_validator.r.priority
        [ATTRIBUTE] Direct match found: event_validator.r.priority
      [CHAIN] Step 1 resolved: event_validator.r.priority
    [RESOLVE] RESOLVED to: event_validator.r.priority
      -> Not module state
      [NAME] Found name reference: r
    [RESOLVE] Attempting to resolve: ['r']
      [RESOLVE_SIMPLE] Resolving base: r
      [CACHE] Hit for r: event_validator.r
    [RESOLVE] RESOLVED to: event_validator.r
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationEngine.add_rule
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationEngine.add_rule
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationEngine.add_rules
    [CONTEXT] Entered function: event_validator.ValidationEngine.add_rules (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'rules': 'List[BaseValidationRule]'}
      [NAME] Found name reference: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.BaseValidationRule
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule
      -> Not module state
      [NAME] Found name reference: rules
    [RESOLVE] Attempting to resolve: ['rules']
      [RESOLVE_SIMPLE] Resolving base: rules
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable rules not found in any scope
      [LOCAL_RESOLVER] can_resolve(rules): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(rules): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(rules): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(rules): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(rules): event_validator.rules
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: rules -> event_validator.rules
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.rules
      -> Not module state
      [CALL] Found call: self.add_rule
    [RESOLVE] Attempting to resolve: ['self', 'add_rule']
    [RESOLVE] Chain resolution needed for: ['self', 'add_rule']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.add_rule
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.add_rule
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.add_rule
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.add_rule
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.add_rule
            [INTERMEDIATE] Tracking chain steps for: self.add_rule
            [INTERMEDIATE] Step 1: self.add_rule
      -> Resolved to: event_validator.ValidationEngine.add_rule
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.BaseValidationRule
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule
      [ATTRIBUTE] Found attribute access: self.add_rule
        [CACHE] self.add_rule -> event_validator.ValidationEngine.add_rule (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      -> Not module state
      [NAME] Found name reference: rule
        [CACHE] rule -> event_validator.BaseValidationRule (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationEngine.add_rules
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationEngine.add_rules
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationEngine.set_global_context
    [CONTEXT] Entered function: event_validator.ValidationEngine.set_global_context (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'context': 'Dict[str, Any]'}
      [CALL] Found call: self.global_context.update
    [RESOLVE] Attempting to resolve: ['self', 'global_context', 'update']
    [RESOLVE] Chain resolution needed for: ['self', 'global_context', 'update']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.global_context
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.global_context
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.global_context
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.global_context
      [CHAIN] Step 2: Resolving event_validator.ValidationEngine.global_context.update
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.global_context.update
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.global_context.update
      [CHAIN] Step 2 resolved: event_validator.ValidationEngine.global_context.update
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.global_context.update
            [INTERMEDIATE] Tracking chain steps for: self.global_context.update
            [INTERMEDIATE] Step 1: self.global_context
    [RESOLVE] Attempting to resolve: ['self', 'global_context']
    [RESOLVE] Chain resolution needed for: ['self', 'global_context']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.global_context
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.global_context
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.global_context
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.global_context
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.global_context
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationEngine.global_context
            [INTERMEDIATE] Step 2: self.global_context.update
      -> Resolved to: event_validator.ValidationEngine.global_context.update
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: context
    [RESOLVE] Attempting to resolve: ['context']
      [RESOLVE_SIMPLE] Resolving base: context
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable context not found in any scope
      [LOCAL_RESOLVER] can_resolve(context): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(context): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(context): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(context): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(context): event_validator.context
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: context -> event_validator.context
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.context
      [ATTRIBUTE] Found attribute access: self.global_context.update
        [CACHE] self.global_context.update -> event_validator.ValidationEngine.global_context.update (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.global_context
        [CACHE] self.global_context -> event_validator.ValidationEngine.global_context (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      -> Not module state
      [NAME] Found name reference: context
    [RESOLVE] Attempting to resolve: ['context']
      [RESOLVE_SIMPLE] Resolving base: context
      [CACHE] Hit for context: event_validator.context
    [RESOLVE] RESOLVED to: event_validator.context
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationEngine.set_global_context
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationEngine.set_global_context
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationEngine.validate
    [DECORATOR] @trace
    [DECORATOR] @monitor_performance
    [CONTEXT] Entered function: event_validator.ValidationEngine.validate (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any', 'context': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [ASSIGNMENT] Processing: full_context = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: full_context
    [RESOLVE] Attempting to resolve: ['full_context']
      [RESOLVE_SIMPLE] Resolving base: full_context
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable full_context not found in any scope
      [LOCAL_RESOLVER] can_resolve(full_context): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(full_context): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(full_context): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(full_context): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(full_context): event_validator.full_context
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: full_context -> event_validator.full_context
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.full_context
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.global_context
    [RESOLVE] Attempting to resolve: ['self', 'global_context']
    [RESOLVE] Chain resolution needed for: ['self', 'global_context']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.global_context
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.global_context
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.global_context
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.global_context
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.global_context
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      -> Not module state
      [NAME] Found name reference: context
    [RESOLVE] Attempting to resolve: ['context']
      [RESOLVE_SIMPLE] Resolving base: context
      [CACHE] Hit for context: event_validator.context
    [RESOLVE] RESOLVED to: event_validator.context
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache_enabled
    [RESOLVE] Attempting to resolve: ['self', 'cache_enabled']
    [RESOLVE] Chain resolution needed for: ['self', 'cache_enabled']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.cache_enabled
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.cache_enabled
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.cache_enabled
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.cache_enabled
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.cache_enabled
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
      [ASSIGNMENT] Processing: cache_key = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self._generate_cache_key
    [RESOLVE] Attempting to resolve: ['self', '_generate_cache_key']
    [RESOLVE] Chain resolution needed for: ['self', '_generate_cache_key']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine._generate_cache_key
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine._generate_cache_key
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine._generate_cache_key
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine._generate_cache_key
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine._generate_cache_key
      [TYPE_INFERENCE] Call resolved to: event_validator.ValidationEngine._generate_cache_key
        [RETURN_TYPE_RESOLUTION] Resolving return type: str
        [RETURN_TYPE_RESOLUTION] Class 'str' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: str
      [TYPE_INFERENCE] Could not resolve return type 'str' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: str (from return type - unresolved)
      [SYMBOL_UPDATE] Function: cache_key -> str
        [ASSIGNMENT] RESOLVED Updated symbol table: cache_key = str
      [NAME] Found name reference: cache_key
    [RESOLVE] Attempting to resolve: ['cache_key']
      [RESOLVE_SIMPLE] Resolving base: cache_key
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found cache_key in function scope: str
      [LOCAL_RESOLVER] can_resolve(cache_key): True
      [SYMBOL_LOOKUP] Found cache_key in function scope: str
      [LOCAL_RESOLVER] resolve(cache_key): str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: cache_key -> str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: str
      -> Not module state
      [CALL] Found call: self._generate_cache_key
    [RESOLVE] Attempting to resolve: ['self', '_generate_cache_key']
    [RESOLVE] Chain resolution needed for: ['self', '_generate_cache_key']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine._generate_cache_key
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine._generate_cache_key
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine._generate_cache_key
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine._generate_cache_key
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine._generate_cache_key
            [INTERMEDIATE] Tracking chain steps for: self._generate_cache_key
            [INTERMEDIATE] Step 1: self._generate_cache_key
      -> Resolved to: event_validator.ValidationEngine._generate_cache_key
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(data): True
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(data): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: data -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
        [FUNCTION_ARG] Checking argument: full_context
    [RESOLVE] Attempting to resolve: ['full_context']
      [RESOLVE_SIMPLE] Resolving base: full_context
      [CACHE] Hit for full_context: event_validator.full_context
    [RESOLVE] RESOLVED to: event_validator.full_context
      [ATTRIBUTE] Found attribute access: self._generate_cache_key
        [CACHE] self._generate_cache_key -> event_validator.ValidationEngine._generate_cache_key (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [NAME] Found name reference: full_context
        [CACHE] full_context -> event_validator.full_context (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_cache
    [RESOLVE] Attempting to resolve: ['self', 'validation_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.validation_cache
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.validation_cache
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.validation_cache
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.validation_cache
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.validation_cache
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
      [ASSIGNMENT] Processing: cached_report = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: cached_report
    [RESOLVE] Attempting to resolve: ['cached_report']
      [RESOLVE_SIMPLE] Resolving base: cached_report
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable cached_report not found in any scope
      [LOCAL_RESOLVER] can_resolve(cached_report): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(cached_report): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(cached_report): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(cached_report): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(cached_report): event_validator.cached_report
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: cached_report -> event_validator.cached_report
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.cached_report
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_cache
        [CACHE] self.validation_cache -> event_validator.ValidationEngine.validation_cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: cached_report.metadata
    [RESOLVE] Attempting to resolve: ['cached_report', 'metadata']
    [RESOLVE] Chain resolution needed for: ['cached_report', 'metadata']
      [CHAIN] Resolving base: cached_report
      [RESOLVE_SIMPLE] Resolving base: cached_report
      [CACHE] Hit for cached_report: event_validator.cached_report
      [CHAIN] Base resolved: cached_report -> event_validator.cached_report
      [CHAIN] Step 1: Resolving event_validator.cached_report.metadata
        [ATTRIBUTE] Resolving attribute: event_validator.cached_report.metadata
        [ATTRIBUTE] Direct match found: event_validator.cached_report.metadata
      [CHAIN] Step 1 resolved: event_validator.cached_report.metadata
    [RESOLVE] RESOLVED to: event_validator.cached_report.metadata
      -> Not module state
      [NAME] Found name reference: cached_report
        [CACHE] cached_report -> event_validator.cached_report (cached)
      -> Not module state
      [NAME] Found name reference: cached_report
        [CACHE] cached_report -> event_validator.cached_report (cached)
      -> Not module state
      [ASSIGNMENT] Processing: comprehensive_report = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ValidationReport
    [RESOLVE] Attempting to resolve: ['ValidationReport']
      [RESOLVE_SIMPLE] Resolving base: ValidationReport
      [CACHE] Hit for ValidationReport: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      [TYPE_INFERENCE] Call resolved to: event_validator.ValidationReport
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.ValidationReport (class instantiation)
      [SYMBOL_UPDATE] Function: comprehensive_report -> event_validator.ValidationReport
        [ASSIGNMENT] RESOLVED Updated symbol table: comprehensive_report = event_validator.ValidationReport
      [NAME] Found name reference: comprehensive_report
    [RESOLVE] Attempting to resolve: ['comprehensive_report']
      [RESOLVE_SIMPLE] Resolving base: comprehensive_report
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found comprehensive_report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] can_resolve(comprehensive_report): True
      [SYMBOL_LOOKUP] Found comprehensive_report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] resolve(comprehensive_report): event_validator.ValidationReport
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: comprehensive_report -> event_validator.ValidationReport
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
      [CALL] Found call: ValidationReport
    [RESOLVE] Attempting to resolve: ['ValidationReport']
      [RESOLVE_SIMPLE] Resolving base: ValidationReport
      [CACHE] Hit for ValidationReport: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Resolved to: event_validator.ValidationReport
      -> ADDED to instantiations
      [NAME] Found name reference: ValidationReport
        [CACHE] ValidationReport -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.VALID
    [RESOLVE] Attempting to resolve: ['ValidationResult', 'VALID']
    [RESOLVE] Chain resolution needed for: ['ValidationResult', 'VALID']
      [CHAIN] Resolving base: ValidationResult
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationResult not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationResult): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationResult): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationResult): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationResult): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationResult): event_validator.ValidationResult
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationResult -> event_validator.ValidationResult
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: ValidationResult -> event_validator.ValidationResult
      [CHAIN] Step 1: Resolving event_validator.ValidationResult.VALID
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationResult.VALID
        [ATTRIBUTE] Direct match found: event_validator.ValidationResult.VALID
      [CHAIN] Step 1 resolved: event_validator.ValidationResult.VALID
    [RESOLVE] RESOLVED to: event_validator.ValidationResult.VALID
      -> Not module state
      [NAME] Found name reference: ValidationResult
    [RESOLVE] Attempting to resolve: ['ValidationResult']
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
    [RESOLVE] RESOLVED to: event_validator.ValidationResult
      -> Not module state
      [ASSIGNMENT] Processing: start_time = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable time not found in any scope
      [LOCAL_RESOLVER] can_resolve(time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(time): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(time): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(time): time (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: time -> time
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
      [TYPE_INFERENCE] Call resolved to: time.time
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for start_time
      [NAME] Found name reference: start_time
    [RESOLVE] Attempting to resolve: ['start_time']
      [RESOLVE_SIMPLE] Resolving base: start_time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable start_time not found in any scope
      [LOCAL_RESOLVER] can_resolve(start_time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(start_time): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(start_time): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(start_time): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(start_time): event_validator.start_time
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: start_time -> event_validator.start_time
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.start_time
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [NAME] Found name reference: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.BaseValidationRule
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.rules
    [RESOLVE] Attempting to resolve: ['self', 'rules']
    [RESOLVE] Chain resolution needed for: ['self', 'rules']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.rules
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.rules
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.rules
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: rule.enabled
    [RESOLVE] Attempting to resolve: ['rule', 'enabled']
    [RESOLVE] Chain resolution needed for: ['rule', 'enabled']
      [CHAIN] Resolving base: rule
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.BaseValidationRule
      [CHAIN] Base resolved: rule -> event_validator.BaseValidationRule
      [CHAIN] Step 1: Resolving event_validator.BaseValidationRule.enabled
        [ATTRIBUTE] Resolving attribute: event_validator.BaseValidationRule.enabled
        [ATTRIBUTE] Direct match found: event_validator.BaseValidationRule.enabled
      [CHAIN] Step 1 resolved: event_validator.BaseValidationRule.enabled
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule.enabled
      -> Not module state
      [NAME] Found name reference: rule
        [CACHE] rule -> event_validator.BaseValidationRule (cached)
      -> Not module state
      [ASSIGNMENT] Processing: rule_report = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: rule.validate
    [RESOLVE] Attempting to resolve: ['rule', 'validate']
    [RESOLVE] Chain resolution needed for: ['rule', 'validate']
      [CHAIN] Resolving base: rule
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.BaseValidationRule
      [CHAIN] Base resolved: rule -> event_validator.BaseValidationRule
      [CHAIN] Step 1: Resolving event_validator.BaseValidationRule.validate
        [ATTRIBUTE] Resolving attribute: event_validator.BaseValidationRule.validate
        [ATTRIBUTE] Direct match found: event_validator.BaseValidationRule.validate
      [CHAIN] Step 1 resolved: event_validator.BaseValidationRule.validate
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule.validate
      [TYPE_INFERENCE] Call resolved to: event_validator.BaseValidationRule.validate
        [RETURN_TYPE_RESOLUTION] Resolving return type: ValidationReport
        [RETURN_TYPE_RESOLUTION] Found in current module: event_validator.ValidationReport
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.ValidationReport (from return type)
      [SYMBOL_UPDATE] Function: rule_report -> event_validator.ValidationReport
        [ASSIGNMENT] RESOLVED Updated symbol table: rule_report = event_validator.ValidationReport
      [NAME] Found name reference: rule_report
    [RESOLVE] Attempting to resolve: ['rule_report']
      [RESOLVE_SIMPLE] Resolving base: rule_report
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found rule_report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] can_resolve(rule_report): True
      [SYMBOL_LOOKUP] Found rule_report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] resolve(rule_report): event_validator.ValidationReport
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: rule_report -> event_validator.ValidationReport
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
      [CALL] Found call: rule.validate
    [RESOLVE] Attempting to resolve: ['rule', 'validate']
    [RESOLVE] Chain resolution needed for: ['rule', 'validate']
      [CHAIN] Resolving base: rule
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.BaseValidationRule
      [CHAIN] Base resolved: rule -> event_validator.BaseValidationRule
      [CHAIN] Step 1: Resolving event_validator.BaseValidationRule.validate
        [ATTRIBUTE] Resolving attribute: event_validator.BaseValidationRule.validate
        [ATTRIBUTE] Direct match found: event_validator.BaseValidationRule.validate
      [CHAIN] Step 1 resolved: event_validator.BaseValidationRule.validate
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule.validate
            [INTERMEDIATE] Tracking chain steps for: rule.validate
            [INTERMEDIATE] Step 1: rule.validate
      -> Resolved to: event_validator.BaseValidationRule.validate
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
        [FUNCTION_ARG] Checking argument: full_context
    [RESOLVE] Attempting to resolve: ['full_context']
      [RESOLVE_SIMPLE] Resolving base: full_context
      [CACHE] Hit for full_context: event_validator.full_context
    [RESOLVE] RESOLVED to: event_validator.full_context
      [ATTRIBUTE] Found attribute access: rule.validate
        [CACHE] rule.validate -> event_validator.BaseValidationRule.validate (cached)
      -> Not module state
      [NAME] Found name reference: rule
        [CACHE] rule -> event_validator.BaseValidationRule (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: full_context
        [CACHE] full_context -> event_validator.full_context (cached)
      -> Not module state
      [CALL] Found call: self._merge_reports
    [RESOLVE] Attempting to resolve: ['self', '_merge_reports']
    [RESOLVE] Chain resolution needed for: ['self', '_merge_reports']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine._merge_reports
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine._merge_reports
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine._merge_reports
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine._merge_reports
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine._merge_reports
            [INTERMEDIATE] Tracking chain steps for: self._merge_reports
            [INTERMEDIATE] Step 1: self._merge_reports
      -> Resolved to: event_validator.ValidationEngine._merge_reports
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: comprehensive_report
    [RESOLVE] Attempting to resolve: ['comprehensive_report']
      [RESOLVE_SIMPLE] Resolving base: comprehensive_report
      [CACHE] Hit for comprehensive_report: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
        [FUNCTION_ARG] Checking argument: rule_report
    [RESOLVE] Attempting to resolve: ['rule_report']
      [RESOLVE_SIMPLE] Resolving base: rule_report
      [CACHE] Hit for rule_report: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      [ATTRIBUTE] Found attribute access: self._merge_reports
        [CACHE] self._merge_reports -> event_validator.ValidationEngine._merge_reports (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
      [NAME] Found name reference: comprehensive_report
        [CACHE] comprehensive_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: rule_report
        [CACHE] rule_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: comprehensive_report.validation_time
    [RESOLVE] Attempting to resolve: ['comprehensive_report', 'validation_time']
    [RESOLVE] Chain resolution needed for: ['comprehensive_report', 'validation_time']
      [CHAIN] Resolving base: comprehensive_report
      [RESOLVE_SIMPLE] Resolving base: comprehensive_report
      [CACHE] Hit for comprehensive_report: event_validator.ValidationReport
      [CHAIN] Base resolved: comprehensive_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.validation_time
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.validation_time
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.validation_time
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.validation_time
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.validation_time
      -> Not module state
      [NAME] Found name reference: comprehensive_report
        [CACHE] comprehensive_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [CALL] Found call: time.time
    [CACHE] time.time -> time.time (cached)
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
        [CACHE] time -> time (cached)
      -> Not module state
      [NAME] Found name reference: start_time
        [CACHE] start_time -> event_validator.start_time (cached)
      -> Not module state
      [CALL] Found call: comprehensive_report.metadata.update
    [RESOLVE] Attempting to resolve: ['comprehensive_report', 'metadata', 'update']
    [RESOLVE] Chain resolution needed for: ['comprehensive_report', 'metadata', 'update']
      [CHAIN] Resolving base: comprehensive_report
      [RESOLVE_SIMPLE] Resolving base: comprehensive_report
      [CACHE] Hit for comprehensive_report: event_validator.ValidationReport
      [CHAIN] Base resolved: comprehensive_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.metadata
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.metadata
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.metadata
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.metadata
      [CHAIN] Step 2: Resolving event_validator.ValidationReport.metadata.update
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.metadata.update
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.metadata.update
      [CHAIN] Step 2 resolved: event_validator.ValidationReport.metadata.update
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.metadata.update
            [INTERMEDIATE] Tracking chain steps for: comprehensive_report.metadata.update
            [INTERMEDIATE] Step 1: comprehensive_report.metadata
    [RESOLVE] Attempting to resolve: ['comprehensive_report', 'metadata']
    [RESOLVE] Chain resolution needed for: ['comprehensive_report', 'metadata']
      [CHAIN] Resolving base: comprehensive_report
      [RESOLVE_SIMPLE] Resolving base: comprehensive_report
      [CACHE] Hit for comprehensive_report: event_validator.ValidationReport
      [CHAIN] Base resolved: comprehensive_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.metadata
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.metadata
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.metadata
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.metadata
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.metadata
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationReport.metadata
            [INTERMEDIATE] Step 2: comprehensive_report.metadata.update
      -> Resolved to: event_validator.ValidationReport.metadata.update
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: comprehensive_report.metadata.update
        [CACHE] comprehensive_report.metadata.update -> event_validator.ValidationReport.metadata.update (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: comprehensive_report.metadata
        [CACHE] comprehensive_report.metadata -> event_validator.ValidationReport.metadata (cached)
      -> Not module state
      [NAME] Found name reference: comprehensive_report
        [CACHE] comprehensive_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(len): event_validator.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> event_validator.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.rules
        [CACHE] self.rules -> event_validator.ValidationEngine.rules (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
      [CALL] Found call: sum
      -> IGNORED (built-in function)
      [NAME] Found name reference: sum
    [RESOLVE] Attempting to resolve: ['sum']
      [RESOLVE_SIMPLE] Resolving base: sum
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable sum not found in any scope
      [LOCAL_RESOLVER] can_resolve(sum): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(sum): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(sum): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(sum): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(sum): event_validator.sum
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: sum -> event_validator.sum
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.sum
      -> Not module state
      [NAME] Found name reference: r
    [RESOLVE] Attempting to resolve: ['r']
      [RESOLVE_SIMPLE] Resolving base: r
      [CACHE] Hit for r: event_validator.r
    [RESOLVE] RESOLVED to: event_validator.r
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.rules
        [CACHE] self.rules -> event_validator.ValidationEngine.rules (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: r.enabled
    [RESOLVE] Attempting to resolve: ['r', 'enabled']
    [RESOLVE] Chain resolution needed for: ['r', 'enabled']
      [CHAIN] Resolving base: r
      [RESOLVE_SIMPLE] Resolving base: r
      [CACHE] Hit for r: event_validator.r
      [CHAIN] Base resolved: r -> event_validator.r
      [CHAIN] Step 1: Resolving event_validator.r.enabled
        [ATTRIBUTE] Resolving attribute: event_validator.r.enabled
        [ATTRIBUTE] Direct match found: event_validator.r.enabled
      [CHAIN] Step 1 resolved: event_validator.r.enabled
    [RESOLVE] RESOLVED to: event_validator.r.enabled
      -> Not module state
      [NAME] Found name reference: r
        [CACHE] r -> event_validator.r (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: comprehensive_report.validation_time
        [CACHE] comprehensive_report.validation_time -> event_validator.ValidationReport.validation_time (cached)
      -> Not module state
      [NAME] Found name reference: comprehensive_report
        [CACHE] comprehensive_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache_enabled
        [CACHE] self.cache_enabled -> event_validator.ValidationEngine.cache_enabled (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_cache
        [CACHE] self.validation_cache -> event_validator.ValidationEngine.validation_cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationEngine (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> str (cached)
      -> Not module state
      [NAME] Found name reference: comprehensive_report
        [CACHE] comprehensive_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [NAME] Found name reference: comprehensive_report
        [CACHE] comprehensive_report -> event_validator.ValidationReport (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationEngine.validate
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationEngine.validate
        Calls: 3
        Instantiations: 1
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationEngine._generate_cache_key
    [CONTEXT] Entered function: event_validator.ValidationEngine._generate_cache_key (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any', 'context': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [ASSIGNMENT] Processing: data_hash = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: hash
    [RESOLVE] Attempting to resolve: ['hash']
      [RESOLVE_SIMPLE] Resolving base: hash
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable hash not found in any scope
      [LOCAL_RESOLVER] can_resolve(hash): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(hash): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(hash): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(hash): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(hash): event_validator.hash
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: hash -> event_validator.hash
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.hash
      [TYPE_INFERENCE] Call resolved to: event_validator.hash
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for data_hash
      [NAME] Found name reference: data_hash
    [RESOLVE] Attempting to resolve: ['data_hash']
      [RESOLVE_SIMPLE] Resolving base: data_hash
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable data_hash not found in any scope
      [LOCAL_RESOLVER] can_resolve(data_hash): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(data_hash): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(data_hash): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(data_hash): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(data_hash): event_validator.data_hash
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: data_hash -> event_validator.data_hash
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.data_hash
      -> Not module state
      [CALL] Found call: hash
    [RESOLVE] Attempting to resolve: ['hash']
      [RESOLVE_SIMPLE] Resolving base: hash
      [CACHE] Hit for hash: event_validator.hash
    [RESOLVE] RESOLVED to: event_validator.hash
      -> Resolved to: event_validator.hash
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: hash
        [CACHE] hash -> event_validator.hash (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: event_validator.str
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [ASSIGNMENT] Processing: context_hash = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: hash
    [RESOLVE] Attempting to resolve: ['hash']
      [RESOLVE_SIMPLE] Resolving base: hash
      [CACHE] Hit for hash: event_validator.hash
    [RESOLVE] RESOLVED to: event_validator.hash
      [TYPE_INFERENCE] Call resolved to: event_validator.hash
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for context_hash
      [NAME] Found name reference: context_hash
    [RESOLVE] Attempting to resolve: ['context_hash']
      [RESOLVE_SIMPLE] Resolving base: context_hash
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable context_hash not found in any scope
      [LOCAL_RESOLVER] can_resolve(context_hash): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(context_hash): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(context_hash): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(context_hash): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(context_hash): event_validator.context_hash
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: context_hash -> event_validator.context_hash
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.context_hash
      -> Not module state
      [CALL] Found call: hash
    [CACHE] hash -> event_validator.hash (cached)
      -> Resolved to: event_validator.hash
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: hash
        [CACHE] hash -> event_validator.hash (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
        [CACHE] str -> event_validator.str (cached)
      -> Not module state
      [CALL] Found call: sorted
      -> IGNORED (built-in function)
      [NAME] Found name reference: sorted
    [RESOLVE] Attempting to resolve: ['sorted']
      [RESOLVE_SIMPLE] Resolving base: sorted
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable sorted not found in any scope
      [LOCAL_RESOLVER] can_resolve(sorted): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(sorted): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(sorted): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(sorted): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(sorted): event_validator.sorted
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: sorted -> event_validator.sorted
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.sorted
      -> Not module state
      [CALL] Found call: context.items
    [RESOLVE] Attempting to resolve: ['context', 'items']
    [RESOLVE] Chain resolution needed for: ['context', 'items']
      [CHAIN] Resolving base: context
      [RESOLVE_SIMPLE] Resolving base: context
      [CACHE] Hit for context: event_validator.context
      [CHAIN] Base resolved: context -> event_validator.context
      [CHAIN] Step 1: Resolving event_validator.context.items
        [ATTRIBUTE] Resolving attribute: event_validator.context.items
        [ATTRIBUTE] Direct match found: event_validator.context.items
      [CHAIN] Step 1 resolved: event_validator.context.items
    [RESOLVE] RESOLVED to: event_validator.context.items
            [INTERMEDIATE] Tracking chain steps for: context.items
            [INTERMEDIATE] Step 1: context.items
      -> Resolved to: event_validator.context.items
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: context.items
        [CACHE] context.items -> event_validator.context.items (cached)
      -> Not module state
      [NAME] Found name reference: context
    [RESOLVE] Attempting to resolve: ['context']
      [RESOLVE_SIMPLE] Resolving base: context
      [CACHE] Hit for context: event_validator.context
    [RESOLVE] RESOLVED to: event_validator.context
      -> Not module state
      [ASSIGNMENT] Processing: rules_hash = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: hash
    [RESOLVE] Attempting to resolve: ['hash']
      [RESOLVE_SIMPLE] Resolving base: hash
      [CACHE] Hit for hash: event_validator.hash
    [RESOLVE] RESOLVED to: event_validator.hash
      [TYPE_INFERENCE] Call resolved to: event_validator.hash
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for rules_hash
      [NAME] Found name reference: rules_hash
    [RESOLVE] Attempting to resolve: ['rules_hash']
      [RESOLVE_SIMPLE] Resolving base: rules_hash
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable rules_hash not found in any scope
      [LOCAL_RESOLVER] can_resolve(rules_hash): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(rules_hash): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(rules_hash): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(rules_hash): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(rules_hash): event_validator.rules_hash
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: rules_hash -> event_validator.rules_hash
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.rules_hash
      -> Not module state
      [CALL] Found call: hash
    [CACHE] hash -> event_validator.hash (cached)
      -> Resolved to: event_validator.hash
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: hash
        [CACHE] hash -> event_validator.hash (cached)
      -> Not module state
      [CALL] Found call: tuple
      -> IGNORED (built-in function)
      [NAME] Found name reference: tuple
    [RESOLVE] Attempting to resolve: ['tuple']
      [RESOLVE_SIMPLE] Resolving base: tuple
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable tuple not found in any scope
      [LOCAL_RESOLVER] can_resolve(tuple): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(tuple): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(tuple): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(tuple): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(tuple): event_validator.tuple
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: tuple -> event_validator.tuple
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.tuple
      -> Not module state
      [ATTRIBUTE] Found attribute access: r.rule_name
    [RESOLVE] Attempting to resolve: ['r', 'rule_name']
    [RESOLVE] Chain resolution needed for: ['r', 'rule_name']
      [CHAIN] Resolving base: r
      [RESOLVE_SIMPLE] Resolving base: r
      [CACHE] Hit for r: event_validator.r
      [CHAIN] Base resolved: r -> event_validator.r
      [CHAIN] Step 1: Resolving event_validator.r.rule_name
        [ATTRIBUTE] Resolving attribute: event_validator.r.rule_name
        [ATTRIBUTE] Direct match found: event_validator.r.rule_name
      [CHAIN] Step 1 resolved: event_validator.r.rule_name
    [RESOLVE] RESOLVED to: event_validator.r.rule_name
      -> Not module state
      [NAME] Found name reference: r
    [RESOLVE] Attempting to resolve: ['r']
      [RESOLVE_SIMPLE] Resolving base: r
      [CACHE] Hit for r: event_validator.r
    [RESOLVE] RESOLVED to: event_validator.r
      -> Not module state
      [NAME] Found name reference: r
        [CACHE] r -> event_validator.r (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.rules
    [RESOLVE] Attempting to resolve: ['self', 'rules']
    [RESOLVE] Chain resolution needed for: ['self', 'rules']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
      [CHAIN] Base resolved: self -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.rules
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.rules
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.rules
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      -> Not module state
      [ATTRIBUTE] Found attribute access: r.enabled
    [RESOLVE] Attempting to resolve: ['r', 'enabled']
    [RESOLVE] Chain resolution needed for: ['r', 'enabled']
      [CHAIN] Resolving base: r
      [RESOLVE_SIMPLE] Resolving base: r
      [CACHE] Hit for r: event_validator.r
      [CHAIN] Base resolved: r -> event_validator.r
      [CHAIN] Step 1: Resolving event_validator.r.enabled
        [ATTRIBUTE] Resolving attribute: event_validator.r.enabled
        [ATTRIBUTE] Direct match found: event_validator.r.enabled
      [CHAIN] Step 1 resolved: event_validator.r.enabled
    [RESOLVE] RESOLVED to: event_validator.r.enabled
      -> Not module state
      [NAME] Found name reference: r
        [CACHE] r -> event_validator.r (cached)
      -> Not module state
      [NAME] Found name reference: data_hash
        [CACHE] data_hash -> event_validator.data_hash (cached)
      -> Not module state
      [NAME] Found name reference: context_hash
        [CACHE] context_hash -> event_validator.context_hash (cached)
      -> Not module state
      [NAME] Found name reference: rules_hash
        [CACHE] rules_hash -> event_validator.rules_hash (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationEngine._generate_cache_key
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationEngine._generate_cache_key
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationEngine._merge_reports
    [CONTEXT] Entered function: event_validator.ValidationEngine._merge_reports (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'main_report': 'ValidationReport', 'rule_report': 'ValidationReport'}
        [ARG_TYPE] Processing type annotation for main_report: ValidationReport
    [RESOLVE] Attempting to resolve: ['ValidationReport']
      [RESOLVE_SIMPLE] Resolving base: ValidationReport
      [CACHE] Hit for ValidationReport: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      [SYMBOL_UPDATE] Function: main_report -> event_validator.ValidationReport
        [ARG_TYPE] RESOLVED main_report : event_validator.ValidationReport
        [ARG_TYPE] Processing type annotation for rule_report: ValidationReport
        [CACHE] ValidationReport -> event_validator.ValidationReport (cached)
      [SYMBOL_UPDATE] Function: rule_report -> event_validator.ValidationReport
        [ARG_TYPE] RESOLVED rule_report : event_validator.ValidationReport
      [CALL] Found call: main_report.errors.extend
    [RESOLVE] Attempting to resolve: ['main_report', 'errors', 'extend']
    [RESOLVE] Chain resolution needed for: ['main_report', 'errors', 'extend']
      [CHAIN] Resolving base: main_report
      [RESOLVE_SIMPLE] Resolving base: main_report
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found main_report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] can_resolve(main_report): True
      [SYMBOL_LOOKUP] Found main_report in function scope: event_validator.ValidationReport
      [LOCAL_RESOLVER] resolve(main_report): event_validator.ValidationReport
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: main_report -> event_validator.ValidationReport
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: main_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.errors
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.errors
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.errors
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.errors
      [CHAIN] Step 2: Resolving event_validator.ValidationReport.errors.extend
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.errors.extend
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.errors.extend
      [CHAIN] Step 2 resolved: event_validator.ValidationReport.errors.extend
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.errors.extend
            [INTERMEDIATE] Tracking chain steps for: main_report.errors.extend
            [INTERMEDIATE] Step 1: main_report.errors
    [RESOLVE] Attempting to resolve: ['main_report', 'errors']
    [RESOLVE] Chain resolution needed for: ['main_report', 'errors']
      [CHAIN] Resolving base: main_report
      [RESOLVE_SIMPLE] Resolving base: main_report
      [CACHE] Hit for main_report: event_validator.ValidationReport
      [CHAIN] Base resolved: main_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.errors
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.errors
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.errors
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.errors
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.errors
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationReport.errors
            [INTERMEDIATE] Step 2: main_report.errors.extend
      -> Resolved to: event_validator.ValidationReport.errors.extend
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: main_report.errors.extend
        [CACHE] main_report.errors.extend -> event_validator.ValidationReport.errors.extend (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: main_report.errors
        [CACHE] main_report.errors -> event_validator.ValidationReport.errors (cached)
      -> Not module state
      [NAME] Found name reference: main_report
    [RESOLVE] Attempting to resolve: ['main_report']
      [RESOLVE_SIMPLE] Resolving base: main_report
      [CACHE] Hit for main_report: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
      [ATTRIBUTE] Found attribute access: rule_report.errors
    [RESOLVE] Attempting to resolve: ['rule_report', 'errors']
    [RESOLVE] Chain resolution needed for: ['rule_report', 'errors']
      [CHAIN] Resolving base: rule_report
      [RESOLVE_SIMPLE] Resolving base: rule_report
      [CACHE] Hit for rule_report: event_validator.ValidationReport
      [CHAIN] Base resolved: rule_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.errors
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.errors
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.errors
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.errors
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.errors
      -> Not module state
      [NAME] Found name reference: rule_report
    [RESOLVE] Attempting to resolve: ['rule_report']
      [RESOLVE_SIMPLE] Resolving base: rule_report
      [CACHE] Hit for rule_report: event_validator.ValidationReport
    [RESOLVE] RESOLVED to: event_validator.ValidationReport
      -> Not module state
      [CALL] Found call: main_report.warnings.extend
    [RESOLVE] Attempting to resolve: ['main_report', 'warnings', 'extend']
    [RESOLVE] Chain resolution needed for: ['main_report', 'warnings', 'extend']
      [CHAIN] Resolving base: main_report
      [RESOLVE_SIMPLE] Resolving base: main_report
      [CACHE] Hit for main_report: event_validator.ValidationReport
      [CHAIN] Base resolved: main_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.warnings
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.warnings
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.warnings
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.warnings
      [CHAIN] Step 2: Resolving event_validator.ValidationReport.warnings.extend
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.warnings.extend
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.warnings.extend
      [CHAIN] Step 2 resolved: event_validator.ValidationReport.warnings.extend
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.warnings.extend
            [INTERMEDIATE] Tracking chain steps for: main_report.warnings.extend
            [INTERMEDIATE] Step 1: main_report.warnings
    [RESOLVE] Attempting to resolve: ['main_report', 'warnings']
    [RESOLVE] Chain resolution needed for: ['main_report', 'warnings']
      [CHAIN] Resolving base: main_report
      [RESOLVE_SIMPLE] Resolving base: main_report
      [CACHE] Hit for main_report: event_validator.ValidationReport
      [CHAIN] Base resolved: main_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.warnings
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.warnings
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.warnings
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.warnings
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.warnings
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationReport.warnings
            [INTERMEDIATE] Step 2: main_report.warnings.extend
      -> Resolved to: event_validator.ValidationReport.warnings.extend
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: main_report.warnings.extend
        [CACHE] main_report.warnings.extend -> event_validator.ValidationReport.warnings.extend (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: main_report.warnings
        [CACHE] main_report.warnings -> event_validator.ValidationReport.warnings (cached)
      -> Not module state
      [NAME] Found name reference: main_report
        [CACHE] main_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: rule_report.warnings
    [RESOLVE] Attempting to resolve: ['rule_report', 'warnings']
    [RESOLVE] Chain resolution needed for: ['rule_report', 'warnings']
      [CHAIN] Resolving base: rule_report
      [RESOLVE_SIMPLE] Resolving base: rule_report
      [CACHE] Hit for rule_report: event_validator.ValidationReport
      [CHAIN] Base resolved: rule_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.warnings
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.warnings
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.warnings
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.warnings
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.warnings
      -> Not module state
      [NAME] Found name reference: rule_report
        [CACHE] rule_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [CALL] Found call: main_report.rules_applied.extend
    [RESOLVE] Attempting to resolve: ['main_report', 'rules_applied', 'extend']
    [RESOLVE] Chain resolution needed for: ['main_report', 'rules_applied', 'extend']
      [CHAIN] Resolving base: main_report
      [RESOLVE_SIMPLE] Resolving base: main_report
      [CACHE] Hit for main_report: event_validator.ValidationReport
      [CHAIN] Base resolved: main_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.rules_applied
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.rules_applied
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.rules_applied
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.rules_applied
      [CHAIN] Step 2: Resolving event_validator.ValidationReport.rules_applied.extend
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.rules_applied.extend
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.rules_applied.extend
      [CHAIN] Step 2 resolved: event_validator.ValidationReport.rules_applied.extend
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.rules_applied.extend
            [INTERMEDIATE] Tracking chain steps for: main_report.rules_applied.extend
            [INTERMEDIATE] Step 1: main_report.rules_applied
    [RESOLVE] Attempting to resolve: ['main_report', 'rules_applied']
    [RESOLVE] Chain resolution needed for: ['main_report', 'rules_applied']
      [CHAIN] Resolving base: main_report
      [RESOLVE_SIMPLE] Resolving base: main_report
      [CACHE] Hit for main_report: event_validator.ValidationReport
      [CHAIN] Base resolved: main_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.rules_applied
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.rules_applied
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.rules_applied
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.rules_applied
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.rules_applied
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationReport.rules_applied
            [INTERMEDIATE] Step 2: main_report.rules_applied.extend
      -> Resolved to: event_validator.ValidationReport.rules_applied.extend
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: main_report.rules_applied.extend
        [CACHE] main_report.rules_applied.extend -> event_validator.ValidationReport.rules_applied.extend (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: main_report.rules_applied
        [CACHE] main_report.rules_applied -> event_validator.ValidationReport.rules_applied (cached)
      -> Not module state
      [NAME] Found name reference: main_report
        [CACHE] main_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: rule_report.rules_applied
    [RESOLVE] Attempting to resolve: ['rule_report', 'rules_applied']
    [RESOLVE] Chain resolution needed for: ['rule_report', 'rules_applied']
      [CHAIN] Resolving base: rule_report
      [RESOLVE_SIMPLE] Resolving base: rule_report
      [CACHE] Hit for rule_report: event_validator.ValidationReport
      [CHAIN] Base resolved: rule_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.rules_applied
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.rules_applied
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.rules_applied
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.rules_applied
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.rules_applied
      -> Not module state
      [NAME] Found name reference: rule_report
        [CACHE] rule_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: rule_report.result
    [RESOLVE] Attempting to resolve: ['rule_report', 'result']
    [RESOLVE] Chain resolution needed for: ['rule_report', 'result']
      [CHAIN] Resolving base: rule_report
      [RESOLVE_SIMPLE] Resolving base: rule_report
      [CACHE] Hit for rule_report: event_validator.ValidationReport
      [CHAIN] Base resolved: rule_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.result
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.result
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.result
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.result
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.result
      -> Not module state
      [NAME] Found name reference: rule_report
        [CACHE] rule_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.INVALID
    [RESOLVE] Attempting to resolve: ['ValidationResult', 'INVALID']
    [RESOLVE] Chain resolution needed for: ['ValidationResult', 'INVALID']
      [CHAIN] Resolving base: ValidationResult
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
      [CHAIN] Base resolved: ValidationResult -> event_validator.ValidationResult
      [CHAIN] Step 1: Resolving event_validator.ValidationResult.INVALID
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationResult.INVALID
        [ATTRIBUTE] Direct match found: event_validator.ValidationResult.INVALID
      [CHAIN] Step 1 resolved: event_validator.ValidationResult.INVALID
    [RESOLVE] RESOLVED to: event_validator.ValidationResult.INVALID
      -> Not module state
      [NAME] Found name reference: ValidationResult
    [RESOLVE] Attempting to resolve: ['ValidationResult']
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
    [RESOLVE] RESOLVED to: event_validator.ValidationResult
      -> Not module state
      [ATTRIBUTE] Found attribute access: main_report.result
    [RESOLVE] Attempting to resolve: ['main_report', 'result']
    [RESOLVE] Chain resolution needed for: ['main_report', 'result']
      [CHAIN] Resolving base: main_report
      [RESOLVE_SIMPLE] Resolving base: main_report
      [CACHE] Hit for main_report: event_validator.ValidationReport
      [CHAIN] Base resolved: main_report -> event_validator.ValidationReport
      [CHAIN] Step 1: Resolving event_validator.ValidationReport.result
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationReport.result
        [ATTRIBUTE] Direct match found: event_validator.ValidationReport.result
      [CHAIN] Step 1 resolved: event_validator.ValidationReport.result
    [RESOLVE] RESOLVED to: event_validator.ValidationReport.result
      -> Not module state
      [NAME] Found name reference: main_report
        [CACHE] main_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.INVALID
        [CACHE] ValidationResult.INVALID -> event_validator.ValidationResult.INVALID (cached)
      -> Not module state
      [NAME] Found name reference: ValidationResult
        [CACHE] ValidationResult -> event_validator.ValidationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: rule_report.result
        [CACHE] rule_report.result -> event_validator.ValidationReport.result (cached)
      -> Not module state
      [NAME] Found name reference: rule_report
        [CACHE] rule_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.REQUIRES_REVIEW
    [RESOLVE] Attempting to resolve: ['ValidationResult', 'REQUIRES_REVIEW']
    [RESOLVE] Chain resolution needed for: ['ValidationResult', 'REQUIRES_REVIEW']
      [CHAIN] Resolving base: ValidationResult
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
      [CHAIN] Base resolved: ValidationResult -> event_validator.ValidationResult
      [CHAIN] Step 1: Resolving event_validator.ValidationResult.REQUIRES_REVIEW
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationResult.REQUIRES_REVIEW
        [ATTRIBUTE] Direct match found: event_validator.ValidationResult.REQUIRES_REVIEW
      [CHAIN] Step 1 resolved: event_validator.ValidationResult.REQUIRES_REVIEW
    [RESOLVE] RESOLVED to: event_validator.ValidationResult.REQUIRES_REVIEW
      -> Not module state
      [NAME] Found name reference: ValidationResult
        [CACHE] ValidationResult -> event_validator.ValidationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: main_report.result
        [CACHE] main_report.result -> event_validator.ValidationReport.result (cached)
      -> Not module state
      [NAME] Found name reference: main_report
        [CACHE] main_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.VALID
    [RESOLVE] Attempting to resolve: ['ValidationResult', 'VALID']
    [RESOLVE] Chain resolution needed for: ['ValidationResult', 'VALID']
      [CHAIN] Resolving base: ValidationResult
      [RESOLVE_SIMPLE] Resolving base: ValidationResult
      [CACHE] Hit for ValidationResult: event_validator.ValidationResult
      [CHAIN] Base resolved: ValidationResult -> event_validator.ValidationResult
      [CHAIN] Step 1: Resolving event_validator.ValidationResult.VALID
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationResult.VALID
        [ATTRIBUTE] Direct match found: event_validator.ValidationResult.VALID
      [CHAIN] Step 1 resolved: event_validator.ValidationResult.VALID
    [RESOLVE] RESOLVED to: event_validator.ValidationResult.VALID
      -> Not module state
      [NAME] Found name reference: ValidationResult
        [CACHE] ValidationResult -> event_validator.ValidationResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: main_report.result
        [CACHE] main_report.result -> event_validator.ValidationReport.result (cached)
      -> Not module state
      [NAME] Found name reference: main_report
        [CACHE] main_report -> event_validator.ValidationReport (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: ValidationResult.REQUIRES_REVIEW
        [CACHE] ValidationResult.REQUIRES_REVIEW -> event_validator.ValidationResult.REQUIRES_REVIEW (cached)
      -> Not module state
      [NAME] Found name reference: ValidationResult
        [CACHE] ValidationResult -> event_validator.ValidationResult (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationEngine._merge_reports
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationEngine._merge_reports
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationEngine.create_rule_builder
    [CONTEXT] Entered function: event_validator.ValidationEngine.create_rule_builder (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Found call: ValidationRuleBuilder
    [RESOLVE] Attempting to resolve: ['ValidationRuleBuilder']
      [RESOLVE_SIMPLE] Resolving base: ValidationRuleBuilder
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationRuleBuilder not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationRuleBuilder): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationRuleBuilder): False (current_class: event_validator.ValidationEngine)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationRuleBuilder): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationRuleBuilder): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationRuleBuilder): event_validator.ValidationRuleBuilder
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationRuleBuilder -> event_validator.ValidationRuleBuilder
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder
      -> Resolved to: event_validator.ValidationRuleBuilder
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      [NAME] Found name reference: ValidationRuleBuilder
        [CACHE] ValidationRuleBuilder -> event_validator.ValidationRuleBuilder (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationEngine
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationEngine.create_rule_builder
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationEngine.create_rule_builder
        Calls: 0
        Instantiations: 1
        State Access: 0
    [CONTEXT] Exited class: event_validator.ValidationEngine
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: ValidationRuleBuilder
    [CONTEXT] Entered class: event_validator.ValidationRuleBuilder
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationRuleBuilder.__init__
    [CONTEXT] Entered function: event_validator.ValidationRuleBuilder.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'engine': 'ValidationEngine'}
        [ARG_TYPE] Processing type annotation for engine: ValidationEngine
    [RESOLVE] Attempting to resolve: ['ValidationEngine']
      [RESOLVE_SIMPLE] Resolving base: ValidationEngine
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationEngine not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationEngine): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationEngine): False (current_class: event_validator.ValidationRuleBuilder)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationEngine): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationEngine): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationEngine): event_validator.ValidationEngine
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationEngine -> event_validator.ValidationEngine
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      [SYMBOL_UPDATE] Function: engine -> event_validator.ValidationEngine
        [ARG_TYPE] RESOLVED engine : event_validator.ValidationEngine
      [ATTRIBUTE] Found attribute access: self.engine
    [RESOLVE] Attempting to resolve: ['self', 'engine']
    [RESOLVE] Chain resolution needed for: ['self', 'engine']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: event_validator.ValidationRuleBuilder)
      [SELF_RESOLVER] resolve(self): event_validator.ValidationRuleBuilder
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> event_validator.ValidationRuleBuilder
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> event_validator.ValidationRuleBuilder
      [CHAIN] Step 1: Resolving event_validator.ValidationRuleBuilder.engine
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.engine
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.engine
      [CHAIN] Step 1 resolved: event_validator.ValidationRuleBuilder.engine
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder.engine
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder
      -> Not module state
      [NAME] Found name reference: engine
    [RESOLVE] Attempting to resolve: ['engine']
      [RESOLVE_SIMPLE] Resolving base: engine
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found engine in function scope: event_validator.ValidationEngine
      [LOCAL_RESOLVER] can_resolve(engine): True
      [SYMBOL_LOOKUP] Found engine in function scope: event_validator.ValidationEngine
      [LOCAL_RESOLVER] resolve(engine): event_validator.ValidationEngine
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: engine -> event_validator.ValidationEngine
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_rules
    [RESOLVE] Attempting to resolve: ['self', 'current_rules']
    [RESOLVE] Chain resolution needed for: ['self', 'current_rules']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
      [CHAIN] Base resolved: self -> event_validator.ValidationRuleBuilder
      [CHAIN] Step 1: Resolving event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.current_rules
      [CHAIN] Step 1 resolved: event_validator.ValidationRuleBuilder.current_rules
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder.current_rules
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationRuleBuilder (cached)
      -> Not module state
      [NAME] Found name reference: List
    [RESOLVE] Attempting to resolve: ['List']
      [RESOLVE_SIMPLE] Resolving base: List
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable List not found in any scope
      [LOCAL_RESOLVER] can_resolve(List): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(List): False (current_class: event_validator.ValidationRuleBuilder)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(List): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(List): typing.List (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: List -> typing.List
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.List
      -> Not module state
      [NAME] Found name reference: BaseValidationRule
    [RESOLVE] Attempting to resolve: ['BaseValidationRule']
      [RESOLVE_SIMPLE] Resolving base: BaseValidationRule
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable BaseValidationRule not found in any scope
      [LOCAL_RESOLVER] can_resolve(BaseValidationRule): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(BaseValidationRule): False (current_class: event_validator.ValidationRuleBuilder)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(BaseValidationRule): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(BaseValidationRule): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(BaseValidationRule): event_validator.BaseValidationRule
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: BaseValidationRule -> event_validator.BaseValidationRule
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.BaseValidationRule
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationRuleBuilder.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationRuleBuilder.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationRuleBuilder.require_fields
    [CONTEXT] Entered function: event_validator.ValidationRuleBuilder.require_fields (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ASSIGNMENT] Processing: rule = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: RequiredFieldRule
    [RESOLVE] Attempting to resolve: ['RequiredFieldRule']
      [RESOLVE_SIMPLE] Resolving base: RequiredFieldRule
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable RequiredFieldRule not found in any scope
      [LOCAL_RESOLVER] can_resolve(RequiredFieldRule): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(RequiredFieldRule): False (current_class: event_validator.ValidationRuleBuilder)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(RequiredFieldRule): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(RequiredFieldRule): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(RequiredFieldRule): event_validator.RequiredFieldRule
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: RequiredFieldRule -> event_validator.RequiredFieldRule
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule
      [TYPE_INFERENCE] Call resolved to: event_validator.RequiredFieldRule
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.RequiredFieldRule (class instantiation)
      [SYMBOL_UPDATE] Function: rule -> event_validator.RequiredFieldRule
        [ASSIGNMENT] RESOLVED Updated symbol table: rule = event_validator.RequiredFieldRule
      [NAME] Found name reference: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found rule in function scope: event_validator.RequiredFieldRule
      [LOCAL_RESOLVER] can_resolve(rule): True
      [SYMBOL_LOOKUP] Found rule in function scope: event_validator.RequiredFieldRule
      [LOCAL_RESOLVER] resolve(rule): event_validator.RequiredFieldRule
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: rule -> event_validator.RequiredFieldRule
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule
      -> Not module state
      [CALL] Found call: RequiredFieldRule
    [RESOLVE] Attempting to resolve: ['RequiredFieldRule']
      [RESOLVE_SIMPLE] Resolving base: RequiredFieldRule
      [CACHE] Hit for RequiredFieldRule: event_validator.RequiredFieldRule
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule
      -> Resolved to: event_validator.RequiredFieldRule
      -> ADDED to instantiations
      [NAME] Found name reference: RequiredFieldRule
        [CACHE] RequiredFieldRule -> event_validator.RequiredFieldRule (cached)
      -> Not module state
      [CALL] Found call: list
      -> IGNORED (built-in function)
      [NAME] Found name reference: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable list not found in any scope
      [LOCAL_RESOLVER] can_resolve(list): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(list): False (current_class: event_validator.ValidationRuleBuilder)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(list): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(list): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(list): event_validator.list
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: list -> event_validator.list
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.list
      -> Not module state
      [NAME] Found name reference: fields
    [RESOLVE] Attempting to resolve: ['fields']
      [RESOLVE_SIMPLE] Resolving base: fields
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable fields not found in any scope
      [LOCAL_RESOLVER] can_resolve(fields): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(fields): False (current_class: event_validator.ValidationRuleBuilder)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(fields): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(fields): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(fields): event_validator.fields
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: fields -> event_validator.fields
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.fields
      -> Not module state
      [CALL] Found call: self.current_rules.append
    [RESOLVE] Attempting to resolve: ['self', 'current_rules', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'current_rules', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
      [CHAIN] Base resolved: self -> event_validator.ValidationRuleBuilder
      [CHAIN] Step 1: Resolving event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.current_rules
      [CHAIN] Step 1 resolved: event_validator.ValidationRuleBuilder.current_rules
      [CHAIN] Step 2: Resolving event_validator.ValidationRuleBuilder.current_rules.append
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.current_rules.append
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.current_rules.append
      [CHAIN] Step 2 resolved: event_validator.ValidationRuleBuilder.current_rules.append
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder.current_rules.append
            [INTERMEDIATE] Tracking chain steps for: self.current_rules.append
            [INTERMEDIATE] Step 1: self.current_rules
    [RESOLVE] Attempting to resolve: ['self', 'current_rules']
    [RESOLVE] Chain resolution needed for: ['self', 'current_rules']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
      [CHAIN] Base resolved: self -> event_validator.ValidationRuleBuilder
      [CHAIN] Step 1: Resolving event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.current_rules
      [CHAIN] Step 1 resolved: event_validator.ValidationRuleBuilder.current_rules
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder.current_rules
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationRuleBuilder.current_rules
            [INTERMEDIATE] Step 2: self.current_rules.append
      -> Resolved to: event_validator.ValidationRuleBuilder.current_rules.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.RequiredFieldRule
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule
      [ATTRIBUTE] Found attribute access: self.current_rules.append
        [CACHE] self.current_rules.append -> event_validator.ValidationRuleBuilder.current_rules.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_rules
        [CACHE] self.current_rules -> event_validator.ValidationRuleBuilder.current_rules (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder
      -> Not module state
      [NAME] Found name reference: rule
        [CACHE] rule -> event_validator.RequiredFieldRule (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationRuleBuilder (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationRuleBuilder.require_fields
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationRuleBuilder.require_fields
        Calls: 0
        Instantiations: 1
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationRuleBuilder.field_types
    [CONTEXT] Entered function: event_validator.ValidationRuleBuilder.field_types (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ASSIGNMENT] Processing: rule = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: DataTypeRule
    [RESOLVE] Attempting to resolve: ['DataTypeRule']
      [RESOLVE_SIMPLE] Resolving base: DataTypeRule
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable DataTypeRule not found in any scope
      [LOCAL_RESOLVER] can_resolve(DataTypeRule): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(DataTypeRule): False (current_class: event_validator.ValidationRuleBuilder)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(DataTypeRule): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(DataTypeRule): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(DataTypeRule): event_validator.DataTypeRule
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: DataTypeRule -> event_validator.DataTypeRule
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.DataTypeRule
      [TYPE_INFERENCE] Call resolved to: event_validator.DataTypeRule
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.DataTypeRule (class instantiation)
      [SYMBOL_UPDATE] Function: rule -> event_validator.DataTypeRule
        [ASSIGNMENT] RESOLVED Updated symbol table: rule = event_validator.DataTypeRule
      [NAME] Found name reference: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.RequiredFieldRule
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule
      -> Not module state
      [CALL] Found call: DataTypeRule
    [RESOLVE] Attempting to resolve: ['DataTypeRule']
      [RESOLVE_SIMPLE] Resolving base: DataTypeRule
      [CACHE] Hit for DataTypeRule: event_validator.DataTypeRule
    [RESOLVE] RESOLVED to: event_validator.DataTypeRule
      -> Resolved to: event_validator.DataTypeRule
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: field_types
    [RESOLVE] Attempting to resolve: ['field_types']
      [RESOLVE_SIMPLE] Resolving base: field_types
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable field_types not found in any scope
      [LOCAL_RESOLVER] can_resolve(field_types): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(field_types): False (current_class: event_validator.ValidationRuleBuilder)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(field_types): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(field_types): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(field_types): event_validator.field_types
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: field_types -> event_validator.field_types
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.field_types
      [NAME] Found name reference: DataTypeRule
        [CACHE] DataTypeRule -> event_validator.DataTypeRule (cached)
      -> Not module state
      [NAME] Found name reference: field_types
    [RESOLVE] Attempting to resolve: ['field_types']
      [RESOLVE_SIMPLE] Resolving base: field_types
      [CACHE] Hit for field_types: event_validator.field_types
    [RESOLVE] RESOLVED to: event_validator.field_types
      -> Not module state
      [CALL] Found call: self.current_rules.append
    [RESOLVE] Attempting to resolve: ['self', 'current_rules', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'current_rules', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
      [CHAIN] Base resolved: self -> event_validator.ValidationRuleBuilder
      [CHAIN] Step 1: Resolving event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.current_rules
      [CHAIN] Step 1 resolved: event_validator.ValidationRuleBuilder.current_rules
      [CHAIN] Step 2: Resolving event_validator.ValidationRuleBuilder.current_rules.append
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.current_rules.append
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.current_rules.append
      [CHAIN] Step 2 resolved: event_validator.ValidationRuleBuilder.current_rules.append
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder.current_rules.append
            [INTERMEDIATE] Tracking chain steps for: self.current_rules.append
            [INTERMEDIATE] Step 1: self.current_rules
    [RESOLVE] Attempting to resolve: ['self', 'current_rules']
    [RESOLVE] Chain resolution needed for: ['self', 'current_rules']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
      [CHAIN] Base resolved: self -> event_validator.ValidationRuleBuilder
      [CHAIN] Step 1: Resolving event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.current_rules
      [CHAIN] Step 1 resolved: event_validator.ValidationRuleBuilder.current_rules
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder.current_rules
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationRuleBuilder.current_rules
            [INTERMEDIATE] Step 2: self.current_rules.append
      -> Resolved to: event_validator.ValidationRuleBuilder.current_rules.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.RequiredFieldRule
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule
      [ATTRIBUTE] Found attribute access: self.current_rules.append
        [CACHE] self.current_rules.append -> event_validator.ValidationRuleBuilder.current_rules.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_rules
        [CACHE] self.current_rules -> event_validator.ValidationRuleBuilder.current_rules (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder
      -> Not module state
      [NAME] Found name reference: rule
        [CACHE] rule -> event_validator.RequiredFieldRule (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationRuleBuilder (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationRuleBuilder.field_types
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationRuleBuilder.field_types
        Calls: 0
        Instantiations: 1
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationRuleBuilder.field_patterns
    [CONTEXT] Entered function: event_validator.ValidationRuleBuilder.field_patterns (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ASSIGNMENT] Processing: rule = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: RegexValidationRule
    [RESOLVE] Attempting to resolve: ['RegexValidationRule']
      [RESOLVE_SIMPLE] Resolving base: RegexValidationRule
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable RegexValidationRule not found in any scope
      [LOCAL_RESOLVER] can_resolve(RegexValidationRule): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(RegexValidationRule): False (current_class: event_validator.ValidationRuleBuilder)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(RegexValidationRule): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(RegexValidationRule): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(RegexValidationRule): event_validator.RegexValidationRule
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: RegexValidationRule -> event_validator.RegexValidationRule
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.RegexValidationRule
      [TYPE_INFERENCE] Call resolved to: event_validator.RegexValidationRule
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.RegexValidationRule (class instantiation)
      [SYMBOL_UPDATE] Function: rule -> event_validator.RegexValidationRule
        [ASSIGNMENT] RESOLVED Updated symbol table: rule = event_validator.RegexValidationRule
      [NAME] Found name reference: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.RequiredFieldRule
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule
      -> Not module state
      [CALL] Found call: RegexValidationRule
    [RESOLVE] Attempting to resolve: ['RegexValidationRule']
      [RESOLVE_SIMPLE] Resolving base: RegexValidationRule
      [CACHE] Hit for RegexValidationRule: event_validator.RegexValidationRule
    [RESOLVE] RESOLVED to: event_validator.RegexValidationRule
      -> Resolved to: event_validator.RegexValidationRule
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: field_patterns
    [RESOLVE] Attempting to resolve: ['field_patterns']
      [RESOLVE_SIMPLE] Resolving base: field_patterns
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable field_patterns not found in any scope
      [LOCAL_RESOLVER] can_resolve(field_patterns): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(field_patterns): False (current_class: event_validator.ValidationRuleBuilder)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(field_patterns): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(field_patterns): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(field_patterns): event_validator.field_patterns
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: field_patterns -> event_validator.field_patterns
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.field_patterns
      [NAME] Found name reference: RegexValidationRule
        [CACHE] RegexValidationRule -> event_validator.RegexValidationRule (cached)
      -> Not module state
      [NAME] Found name reference: field_patterns
    [RESOLVE] Attempting to resolve: ['field_patterns']
      [RESOLVE_SIMPLE] Resolving base: field_patterns
      [CACHE] Hit for field_patterns: event_validator.field_patterns
    [RESOLVE] RESOLVED to: event_validator.field_patterns
      -> Not module state
      [CALL] Found call: self.current_rules.append
    [RESOLVE] Attempting to resolve: ['self', 'current_rules', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'current_rules', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
      [CHAIN] Base resolved: self -> event_validator.ValidationRuleBuilder
      [CHAIN] Step 1: Resolving event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.current_rules
      [CHAIN] Step 1 resolved: event_validator.ValidationRuleBuilder.current_rules
      [CHAIN] Step 2: Resolving event_validator.ValidationRuleBuilder.current_rules.append
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.current_rules.append
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.current_rules.append
      [CHAIN] Step 2 resolved: event_validator.ValidationRuleBuilder.current_rules.append
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder.current_rules.append
            [INTERMEDIATE] Tracking chain steps for: self.current_rules.append
            [INTERMEDIATE] Step 1: self.current_rules
    [RESOLVE] Attempting to resolve: ['self', 'current_rules']
    [RESOLVE] Chain resolution needed for: ['self', 'current_rules']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
      [CHAIN] Base resolved: self -> event_validator.ValidationRuleBuilder
      [CHAIN] Step 1: Resolving event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.current_rules
      [CHAIN] Step 1 resolved: event_validator.ValidationRuleBuilder.current_rules
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder.current_rules
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationRuleBuilder.current_rules
            [INTERMEDIATE] Step 2: self.current_rules.append
      -> Resolved to: event_validator.ValidationRuleBuilder.current_rules.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.RequiredFieldRule
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule
      [ATTRIBUTE] Found attribute access: self.current_rules.append
        [CACHE] self.current_rules.append -> event_validator.ValidationRuleBuilder.current_rules.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_rules
        [CACHE] self.current_rules -> event_validator.ValidationRuleBuilder.current_rules (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder
      -> Not module state
      [NAME] Found name reference: rule
        [CACHE] rule -> event_validator.RequiredFieldRule (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationRuleBuilder (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationRuleBuilder.field_patterns
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationRuleBuilder.field_patterns
        Calls: 0
        Instantiations: 1
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.ValidationRuleBuilder.build
    [CONTEXT] Entered function: event_validator.ValidationRuleBuilder.build (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [NAME] Found name reference: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.RequiredFieldRule
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_rules
    [RESOLVE] Attempting to resolve: ['self', 'current_rules']
    [RESOLVE] Chain resolution needed for: ['self', 'current_rules']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
      [CHAIN] Base resolved: self -> event_validator.ValidationRuleBuilder
      [CHAIN] Step 1: Resolving event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.current_rules
      [CHAIN] Step 1 resolved: event_validator.ValidationRuleBuilder.current_rules
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder.current_rules
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder
      -> Not module state
      [CALL] Found call: self.engine.add_rule
    [RESOLVE] Attempting to resolve: ['self', 'engine', 'add_rule']
    [RESOLVE] Chain resolution needed for: ['self', 'engine', 'add_rule']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
      [CHAIN] Base resolved: self -> event_validator.ValidationRuleBuilder
      [CHAIN] Step 1: Resolving event_validator.ValidationRuleBuilder.engine
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.engine
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.engine
      [CHAIN] Step 1 resolved: event_validator.ValidationRuleBuilder.engine
      [CHAIN] Step 2: Resolving event_validator.ValidationRuleBuilder.engine.add_rule
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.engine.add_rule
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.engine.add_rule
      [CHAIN] Step 2 resolved: event_validator.ValidationRuleBuilder.engine.add_rule
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder.engine.add_rule
            [INTERMEDIATE] Tracking chain steps for: self.engine.add_rule
            [INTERMEDIATE] Step 1: self.engine
    [RESOLVE] Attempting to resolve: ['self', 'engine']
    [RESOLVE] Chain resolution needed for: ['self', 'engine']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
      [CHAIN] Base resolved: self -> event_validator.ValidationRuleBuilder
      [CHAIN] Step 1: Resolving event_validator.ValidationRuleBuilder.engine
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.engine
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.engine
      [CHAIN] Step 1 resolved: event_validator.ValidationRuleBuilder.engine
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder.engine
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationRuleBuilder.engine
            [INTERMEDIATE] Step 2: self.engine.add_rule
      -> Resolved to: event_validator.ValidationRuleBuilder.engine.add_rule
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: event_validator.RequiredFieldRule
    [RESOLVE] RESOLVED to: event_validator.RequiredFieldRule
      [ATTRIBUTE] Found attribute access: self.engine.add_rule
        [CACHE] self.engine.add_rule -> event_validator.ValidationRuleBuilder.engine.add_rule (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.engine
        [CACHE] self.engine -> event_validator.ValidationRuleBuilder.engine (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationRuleBuilder (cached)
      -> Not module state
      [NAME] Found name reference: rule
        [CACHE] rule -> event_validator.RequiredFieldRule (cached)
      -> Not module state
      [CALL] Found call: self.current_rules.clear
    [RESOLVE] Attempting to resolve: ['self', 'current_rules', 'clear']
    [RESOLVE] Chain resolution needed for: ['self', 'current_rules', 'clear']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.ValidationRuleBuilder
      [CHAIN] Base resolved: self -> event_validator.ValidationRuleBuilder
      [CHAIN] Step 1: Resolving event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.current_rules
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.current_rules
      [CHAIN] Step 1 resolved: event_validator.ValidationRuleBuilder.current_rules
      [CHAIN] Step 2: Resolving event_validator.ValidationRuleBuilder.current_rules.clear
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationRuleBuilder.current_rules.clear
        [ATTRIBUTE] Direct match found: event_validator.ValidationRuleBuilder.current_rules.clear
      [CHAIN] Step 2 resolved: event_validator.ValidationRuleBuilder.current_rules.clear
    [RESOLVE] RESOLVED to: event_validator.ValidationRuleBuilder.current_rules.clear
            [INTERMEDIATE] Tracking chain steps for: self.current_rules.clear
            [INTERMEDIATE] Step 1: self.current_rules
    [CACHE] self.current_rules -> event_validator.ValidationRuleBuilder.current_rules (cached)
            [INTERMEDIATE] Step 1 resolved to: event_validator.ValidationRuleBuilder.current_rules
            [INTERMEDIATE] Step 2: self.current_rules.clear
      -> Resolved to: event_validator.ValidationRuleBuilder.current_rules.clear
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.current_rules.clear
        [CACHE] self.current_rules.clear -> event_validator.ValidationRuleBuilder.current_rules.clear (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_rules
        [CACHE] self.current_rules -> event_validator.ValidationRuleBuilder.current_rules (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationRuleBuilder (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.engine
        [CACHE] self.engine -> event_validator.ValidationRuleBuilder.engine (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.ValidationRuleBuilder (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.ValidationRuleBuilder.build
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.ValidationRuleBuilder.build
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: event_validator.ValidationRuleBuilder
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: EventValidator
    [CONTEXT] Entered class: event_validator.EventValidator
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.EventValidator.__init__
    [CONTEXT] Entered function: event_validator.EventValidator.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.validation_engine
    [RESOLVE] Attempting to resolve: ['self', 'validation_engine']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_engine']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: event_validator.EventValidator)
      [SELF_RESOLVER] resolve(self): event_validator.EventValidator
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> event_validator.EventValidator
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine
      [CHAIN] Step 1 resolved: event_validator.EventValidator.validation_engine
    [RESOLVE] RESOLVED to: event_validator.EventValidator.validation_engine
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
    [RESOLVE] RESOLVED to: event_validator.EventValidator
      -> Not module state
      [CALL] Found call: ValidationEngine
    [RESOLVE] Attempting to resolve: ['ValidationEngine']
      [RESOLVE_SIMPLE] Resolving base: ValidationEngine
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValidationEngine not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValidationEngine): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValidationEngine): False (current_class: event_validator.EventValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValidationEngine): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValidationEngine): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(ValidationEngine): event_validator.ValidationEngine
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValidationEngine -> event_validator.ValidationEngine
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      -> Resolved to: event_validator.ValidationEngine
      -> ADDED to instantiations
      [NAME] Found name reference: ValidationEngine
        [CACHE] ValidationEngine -> event_validator.ValidationEngine (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.event_schemas
    [RESOLVE] Attempting to resolve: ['self', 'event_schemas']
    [RESOLVE] Chain resolution needed for: ['self', 'event_schemas']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.event_schemas
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.event_schemas
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.event_schemas
      [CHAIN] Step 1 resolved: event_validator.EventValidator.event_schemas
    [RESOLVE] RESOLVED to: event_validator.EventValidator.event_schemas
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.EventValidator (cached)
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: event_validator.EventValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: event_validator.EventValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(str): event_validator.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [NAME] Found name reference: ValidationEngine
        [CACHE] ValidationEngine -> event_validator.ValidationEngine (cached)
      -> Not module state
      [CALL] Found call: self._setup_default_validations
    [RESOLVE] Attempting to resolve: ['self', '_setup_default_validations']
    [RESOLVE] Chain resolution needed for: ['self', '_setup_default_validations']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator._setup_default_validations
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator._setup_default_validations
        [ATTRIBUTE] Direct match found: event_validator.EventValidator._setup_default_validations
      [CHAIN] Step 1 resolved: event_validator.EventValidator._setup_default_validations
    [RESOLVE] RESOLVED to: event_validator.EventValidator._setup_default_validations
            [INTERMEDIATE] Tracking chain steps for: self._setup_default_validations
            [INTERMEDIATE] Step 1: self._setup_default_validations
      -> Resolved to: event_validator.EventValidator._setup_default_validations
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self._setup_default_validations
        [CACHE] self._setup_default_validations -> event_validator.EventValidator._setup_default_validations (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.EventValidator (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.EventValidator.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.EventValidator.__init__
        Calls: 1
        Instantiations: 1
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.EventValidator._setup_default_validations
    [CONTEXT] Entered function: event_validator.EventValidator._setup_default_validations (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Could not extract name parts from call
      [CALL] Could not extract name parts from call
      [CALL] Could not extract name parts from call
      [CALL] Found call: self.validation_engine.create_rule_builder
    [RESOLVE] Attempting to resolve: ['self', 'validation_engine', 'create_rule_builder']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_engine', 'create_rule_builder']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine
      [CHAIN] Step 1 resolved: event_validator.EventValidator.validation_engine
      [CHAIN] Step 2: Resolving event_validator.EventValidator.validation_engine.create_rule_builder
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine.create_rule_builder
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine.create_rule_builder
      [CHAIN] Step 2 resolved: event_validator.EventValidator.validation_engine.create_rule_builder
    [RESOLVE] RESOLVED to: event_validator.EventValidator.validation_engine.create_rule_builder
            [INTERMEDIATE] Tracking chain steps for: self.validation_engine.create_rule_builder
            [INTERMEDIATE] Step 1: self.validation_engine
    [RESOLVE] Attempting to resolve: ['self', 'validation_engine']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_engine']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine
      [CHAIN] Step 1 resolved: event_validator.EventValidator.validation_engine
    [RESOLVE] RESOLVED to: event_validator.EventValidator.validation_engine
            [INTERMEDIATE] Step 1 resolved to: event_validator.EventValidator.validation_engine
            [INTERMEDIATE] Step 2: self.validation_engine.create_rule_builder
      -> Resolved to: event_validator.EventValidator.validation_engine.create_rule_builder
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.validation_engine.create_rule_builder
        [CACHE] self.validation_engine.create_rule_builder -> event_validator.EventValidator.validation_engine.create_rule_builder (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_engine
        [CACHE] self.validation_engine -> event_validator.EventValidator.validation_engine (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
    [RESOLVE] RESOLVED to: event_validator.EventValidator
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: event_validator.str
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [NAME] Found name reference: int
    [RESOLVE] Attempting to resolve: ['int']
      [RESOLVE_SIMPLE] Resolving base: int
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable int not found in any scope
      [LOCAL_RESOLVER] can_resolve(int): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(int): False (current_class: event_validator.EventValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(int): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(int): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(int): event_validator.int
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: int -> event_validator.int
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.int
      -> Not module state
      [NAME] Found name reference: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable float not found in any scope
      [LOCAL_RESOLVER] can_resolve(float): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(float): False (current_class: event_validator.EventValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(float): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(float): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(float): event_validator.float
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: float -> event_validator.float
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.float
      -> Not module state
      [NAME] Found name reference: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(dict): False (current_class: event_validator.EventValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(dict): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(dict): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(dict): event_validator.dict
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: dict -> event_validator.dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.dict
      -> Not module state
      [ASSIGNMENT] Processing: message_engine = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ValidationEngine
    [RESOLVE] Attempting to resolve: ['ValidationEngine']
      [RESOLVE_SIMPLE] Resolving base: ValidationEngine
      [CACHE] Hit for ValidationEngine: event_validator.ValidationEngine
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      [TYPE_INFERENCE] Call resolved to: event_validator.ValidationEngine
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.ValidationEngine (class instantiation)
      [SYMBOL_UPDATE] Function: message_engine -> event_validator.ValidationEngine
        [ASSIGNMENT] RESOLVED Updated symbol table: message_engine = event_validator.ValidationEngine
      [NAME] Found name reference: message_engine
    [RESOLVE] Attempting to resolve: ['message_engine']
      [RESOLVE_SIMPLE] Resolving base: message_engine
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found message_engine in function scope: event_validator.ValidationEngine
      [LOCAL_RESOLVER] can_resolve(message_engine): True
      [SYMBOL_LOOKUP] Found message_engine in function scope: event_validator.ValidationEngine
      [LOCAL_RESOLVER] resolve(message_engine): event_validator.ValidationEngine
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: message_engine -> event_validator.ValidationEngine
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      -> Not module state
      [CALL] Found call: ValidationEngine
    [RESOLVE] Attempting to resolve: ['ValidationEngine']
      [RESOLVE_SIMPLE] Resolving base: ValidationEngine
      [CACHE] Hit for ValidationEngine: event_validator.ValidationEngine
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      -> Resolved to: event_validator.ValidationEngine
      -> ADDED to instantiations
      [NAME] Found name reference: ValidationEngine
        [CACHE] ValidationEngine -> event_validator.ValidationEngine (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Could not extract name parts from call
      [CALL] Could not extract name parts from call
      [CALL] Could not extract name parts from call
      [CALL] Found call: message_engine.create_rule_builder
    [RESOLVE] Attempting to resolve: ['message_engine', 'create_rule_builder']
    [RESOLVE] Chain resolution needed for: ['message_engine', 'create_rule_builder']
      [CHAIN] Resolving base: message_engine
      [RESOLVE_SIMPLE] Resolving base: message_engine
      [CACHE] Hit for message_engine: event_validator.ValidationEngine
      [CHAIN] Base resolved: message_engine -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.create_rule_builder
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.create_rule_builder
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.create_rule_builder
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.create_rule_builder
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.create_rule_builder
            [INTERMEDIATE] Tracking chain steps for: message_engine.create_rule_builder
            [INTERMEDIATE] Step 1: message_engine.create_rule_builder
      -> Resolved to: event_validator.ValidationEngine.create_rule_builder
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: message_engine.create_rule_builder
        [CACHE] message_engine.create_rule_builder -> event_validator.ValidationEngine.create_rule_builder (cached)
      -> Not module state
      [NAME] Found name reference: message_engine
        [CACHE] message_engine -> event_validator.ValidationEngine (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> event_validator.str (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> event_validator.str (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> event_validator.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.event_schemas
    [RESOLVE] Attempting to resolve: ['self', 'event_schemas']
    [RESOLVE] Chain resolution needed for: ['self', 'event_schemas']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.event_schemas
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.event_schemas
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.event_schemas
      [CHAIN] Step 1 resolved: event_validator.EventValidator.event_schemas
    [RESOLVE] RESOLVED to: event_validator.EventValidator.event_schemas
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.EventValidator (cached)
      -> Not module state
      [NAME] Found name reference: message_engine
        [CACHE] message_engine -> event_validator.ValidationEngine (cached)
      -> Not module state
      [ASSIGNMENT] Processing: room_engine = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ValidationEngine
    [RESOLVE] Attempting to resolve: ['ValidationEngine']
      [RESOLVE_SIMPLE] Resolving base: ValidationEngine
      [CACHE] Hit for ValidationEngine: event_validator.ValidationEngine
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      [TYPE_INFERENCE] Call resolved to: event_validator.ValidationEngine
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.ValidationEngine (class instantiation)
      [SYMBOL_UPDATE] Function: room_engine -> event_validator.ValidationEngine
        [ASSIGNMENT] RESOLVED Updated symbol table: room_engine = event_validator.ValidationEngine
      [NAME] Found name reference: room_engine
    [RESOLVE] Attempting to resolve: ['room_engine']
      [RESOLVE_SIMPLE] Resolving base: room_engine
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found room_engine in function scope: event_validator.ValidationEngine
      [LOCAL_RESOLVER] can_resolve(room_engine): True
      [SYMBOL_LOOKUP] Found room_engine in function scope: event_validator.ValidationEngine
      [LOCAL_RESOLVER] resolve(room_engine): event_validator.ValidationEngine
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: room_engine -> event_validator.ValidationEngine
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine
      -> Not module state
      [CALL] Found call: ValidationEngine
    [CACHE] ValidationEngine -> event_validator.ValidationEngine (cached)
      -> Resolved to: event_validator.ValidationEngine
      -> ADDED to instantiations
      [NAME] Found name reference: ValidationEngine
        [CACHE] ValidationEngine -> event_validator.ValidationEngine (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Could not extract name parts from call
      [CALL] Could not extract name parts from call
      [CALL] Could not extract name parts from call
      [CALL] Found call: room_engine.create_rule_builder
    [RESOLVE] Attempting to resolve: ['room_engine', 'create_rule_builder']
    [RESOLVE] Chain resolution needed for: ['room_engine', 'create_rule_builder']
      [CHAIN] Resolving base: room_engine
      [RESOLVE_SIMPLE] Resolving base: room_engine
      [CACHE] Hit for room_engine: event_validator.ValidationEngine
      [CHAIN] Base resolved: room_engine -> event_validator.ValidationEngine
      [CHAIN] Step 1: Resolving event_validator.ValidationEngine.create_rule_builder
        [ATTRIBUTE] Resolving attribute: event_validator.ValidationEngine.create_rule_builder
        [ATTRIBUTE] Direct match found: event_validator.ValidationEngine.create_rule_builder
      [CHAIN] Step 1 resolved: event_validator.ValidationEngine.create_rule_builder
    [RESOLVE] RESOLVED to: event_validator.ValidationEngine.create_rule_builder
            [INTERMEDIATE] Tracking chain steps for: room_engine.create_rule_builder
            [INTERMEDIATE] Step 1: room_engine.create_rule_builder
      -> Resolved to: event_validator.ValidationEngine.create_rule_builder
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: room_engine.create_rule_builder
        [CACHE] room_engine.create_rule_builder -> event_validator.ValidationEngine.create_rule_builder (cached)
      -> Not module state
      [NAME] Found name reference: room_engine
        [CACHE] room_engine -> event_validator.ValidationEngine (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> event_validator.str (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> event_validator.str (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> event_validator.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.event_schemas
        [CACHE] self.event_schemas -> event_validator.EventValidator.event_schemas (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.EventValidator (cached)
      -> Not module state
      [NAME] Found name reference: room_engine
        [CACHE] room_engine -> event_validator.ValidationEngine (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.EventValidator._setup_default_validations
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.EventValidator._setup_default_validations
        Calls: 1
        Instantiations: 1
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.EventValidator.validate_event
    [DECORATOR] @trace
    [CONTEXT] Entered function: event_validator.EventValidator.validate_event (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'event_data': 'Dict[str, Any]'}
      [ASSIGNMENT] Processing: base_report = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.validation_engine.validate
    [RESOLVE] Attempting to resolve: ['self', 'validation_engine', 'validate']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_engine', 'validate']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine
      [CHAIN] Step 1 resolved: event_validator.EventValidator.validation_engine
      [CHAIN] Step 2: Resolving event_validator.EventValidator.validation_engine.validate
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine.validate
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine.validate
      [CHAIN] Step 2 resolved: event_validator.EventValidator.validation_engine.validate
    [RESOLVE] RESOLVED to: event_validator.EventValidator.validation_engine.validate
      [TYPE_INFERENCE] Call resolved to: event_validator.EventValidator.validation_engine.validate
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for base_report
      [NAME] Found name reference: base_report
    [RESOLVE] Attempting to resolve: ['base_report']
      [RESOLVE_SIMPLE] Resolving base: base_report
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable base_report not found in any scope
      [LOCAL_RESOLVER] can_resolve(base_report): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(base_report): False (current_class: event_validator.EventValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(base_report): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(base_report): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(base_report): event_validator.base_report
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: base_report -> event_validator.base_report
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.base_report
      -> Not module state
      [CALL] Found call: self.validation_engine.validate
    [RESOLVE] Attempting to resolve: ['self', 'validation_engine', 'validate']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_engine', 'validate']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine
      [CHAIN] Step 1 resolved: event_validator.EventValidator.validation_engine
      [CHAIN] Step 2: Resolving event_validator.EventValidator.validation_engine.validate
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine.validate
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine.validate
      [CHAIN] Step 2 resolved: event_validator.EventValidator.validation_engine.validate
    [RESOLVE] RESOLVED to: event_validator.EventValidator.validation_engine.validate
            [INTERMEDIATE] Tracking chain steps for: self.validation_engine.validate
            [INTERMEDIATE] Step 1: self.validation_engine
    [RESOLVE] Attempting to resolve: ['self', 'validation_engine']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_engine']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine
      [CHAIN] Step 1 resolved: event_validator.EventValidator.validation_engine
    [RESOLVE] RESOLVED to: event_validator.EventValidator.validation_engine
            [INTERMEDIATE] Step 1 resolved to: event_validator.EventValidator.validation_engine
            [INTERMEDIATE] Step 2: self.validation_engine.validate
      -> Resolved to: event_validator.EventValidator.validation_engine.validate
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: event_data
    [RESOLVE] Attempting to resolve: ['event_data']
      [RESOLVE_SIMPLE] Resolving base: event_data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable event_data not found in any scope
      [LOCAL_RESOLVER] can_resolve(event_data): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(event_data): False (current_class: event_validator.EventValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(event_data): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(event_data): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(event_data): event_validator.event_data
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: event_data -> event_validator.event_data
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.event_data
      [ATTRIBUTE] Found attribute access: self.validation_engine.validate
        [CACHE] self.validation_engine.validate -> event_validator.EventValidator.validation_engine.validate (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_engine
        [CACHE] self.validation_engine -> event_validator.EventValidator.validation_engine (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
    [RESOLVE] RESOLVED to: event_validator.EventValidator
      -> Not module state
      [NAME] Found name reference: event_data
    [RESOLVE] Attempting to resolve: ['event_data']
      [RESOLVE_SIMPLE] Resolving base: event_data
      [CACHE] Hit for event_data: event_validator.event_data
    [RESOLVE] RESOLVED to: event_validator.event_data
      -> Not module state
      [CALL] Found call: base_report.is_valid
    [RESOLVE] Attempting to resolve: ['base_report', 'is_valid']
    [RESOLVE] Chain resolution needed for: ['base_report', 'is_valid']
      [CHAIN] Resolving base: base_report
      [RESOLVE_SIMPLE] Resolving base: base_report
      [CACHE] Hit for base_report: event_validator.base_report
      [CHAIN] Base resolved: base_report -> event_validator.base_report
      [CHAIN] Step 1: Resolving event_validator.base_report.is_valid
        [ATTRIBUTE] Resolving attribute: event_validator.base_report.is_valid
        [ATTRIBUTE] Direct match found: event_validator.base_report.is_valid
      [CHAIN] Step 1 resolved: event_validator.base_report.is_valid
    [RESOLVE] RESOLVED to: event_validator.base_report.is_valid
            [INTERMEDIATE] Tracking chain steps for: base_report.is_valid
            [INTERMEDIATE] Step 1: base_report.is_valid
      -> Resolved to: event_validator.base_report.is_valid
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: base_report.is_valid
        [CACHE] base_report.is_valid -> event_validator.base_report.is_valid (cached)
      -> Not module state
      [NAME] Found name reference: base_report
        [CACHE] base_report -> event_validator.base_report (cached)
      -> Not module state
      [NAME] Found name reference: base_report
        [CACHE] base_report -> event_validator.base_report (cached)
      -> Not module state
      [ASSIGNMENT] Processing: event_type = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: event_data.get
    [RESOLVE] Attempting to resolve: ['event_data', 'get']
    [RESOLVE] Chain resolution needed for: ['event_data', 'get']
      [CHAIN] Resolving base: event_data
      [RESOLVE_SIMPLE] Resolving base: event_data
      [CACHE] Hit for event_data: event_validator.event_data
      [CHAIN] Base resolved: event_data -> event_validator.event_data
      [CHAIN] Step 1: Resolving event_validator.event_data.get
        [ATTRIBUTE] Resolving attribute: event_validator.event_data.get
        [ATTRIBUTE] Direct match found: event_validator.event_data.get
      [CHAIN] Step 1 resolved: event_validator.event_data.get
    [RESOLVE] RESOLVED to: event_validator.event_data.get
      [TYPE_INFERENCE] Call resolved to: event_validator.event_data.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for event_type
      [NAME] Found name reference: event_type
    [RESOLVE] Attempting to resolve: ['event_type']
      [RESOLVE_SIMPLE] Resolving base: event_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable event_type not found in any scope
      [LOCAL_RESOLVER] can_resolve(event_type): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(event_type): False (current_class: event_validator.EventValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(event_type): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(event_type): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(event_type): event_validator.event_type
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: event_type -> event_validator.event_type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.event_type
      -> Not module state
      [CALL] Found call: event_data.get
    [RESOLVE] Attempting to resolve: ['event_data', 'get']
    [RESOLVE] Chain resolution needed for: ['event_data', 'get']
      [CHAIN] Resolving base: event_data
      [RESOLVE_SIMPLE] Resolving base: event_data
      [CACHE] Hit for event_data: event_validator.event_data
      [CHAIN] Base resolved: event_data -> event_validator.event_data
      [CHAIN] Step 1: Resolving event_validator.event_data.get
        [ATTRIBUTE] Resolving attribute: event_validator.event_data.get
        [ATTRIBUTE] Direct match found: event_validator.event_data.get
      [CHAIN] Step 1 resolved: event_validator.event_data.get
    [RESOLVE] RESOLVED to: event_validator.event_data.get
            [INTERMEDIATE] Tracking chain steps for: event_data.get
            [INTERMEDIATE] Step 1: event_data.get
      -> Resolved to: event_validator.event_data.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: event_data.get
        [CACHE] event_data.get -> event_validator.event_data.get (cached)
      -> Not module state
      [NAME] Found name reference: event_data
        [CACHE] event_data -> event_validator.event_data (cached)
      -> Not module state
      [NAME] Found name reference: event_type
        [CACHE] event_type -> event_validator.event_type (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.event_schemas
    [RESOLVE] Attempting to resolve: ['self', 'event_schemas']
    [RESOLVE] Chain resolution needed for: ['self', 'event_schemas']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.event_schemas
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.event_schemas
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.event_schemas
      [CHAIN] Step 1 resolved: event_validator.EventValidator.event_schemas
    [RESOLVE] RESOLVED to: event_validator.EventValidator.event_schemas
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.EventValidator (cached)
      -> Not module state
      [ASSIGNMENT] Processing: type_engine = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: type_engine
    [RESOLVE] Attempting to resolve: ['type_engine']
      [RESOLVE_SIMPLE] Resolving base: type_engine
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable type_engine not found in any scope
      [LOCAL_RESOLVER] can_resolve(type_engine): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(type_engine): False (current_class: event_validator.EventValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(type_engine): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(type_engine): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(type_engine): event_validator.type_engine
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: type_engine -> event_validator.type_engine
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.type_engine
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.event_schemas
        [CACHE] self.event_schemas -> event_validator.EventValidator.event_schemas (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.EventValidator (cached)
      -> Not module state
      [NAME] Found name reference: event_type
        [CACHE] event_type -> event_validator.event_type (cached)
      -> Not module state
      [ASSIGNMENT] Processing: type_report = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: type_engine.validate
    [RESOLVE] Attempting to resolve: ['type_engine', 'validate']
    [RESOLVE] Chain resolution needed for: ['type_engine', 'validate']
      [CHAIN] Resolving base: type_engine
      [RESOLVE_SIMPLE] Resolving base: type_engine
      [CACHE] Hit for type_engine: event_validator.type_engine
      [CHAIN] Base resolved: type_engine -> event_validator.type_engine
      [CHAIN] Step 1: Resolving event_validator.type_engine.validate
        [ATTRIBUTE] Resolving attribute: event_validator.type_engine.validate
        [ATTRIBUTE] Direct match found: event_validator.type_engine.validate
      [CHAIN] Step 1 resolved: event_validator.type_engine.validate
    [RESOLVE] RESOLVED to: event_validator.type_engine.validate
      [TYPE_INFERENCE] Call resolved to: event_validator.type_engine.validate
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for type_report
      [NAME] Found name reference: type_report
    [RESOLVE] Attempting to resolve: ['type_report']
      [RESOLVE_SIMPLE] Resolving base: type_report
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable type_report not found in any scope
      [LOCAL_RESOLVER] can_resolve(type_report): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(type_report): False (current_class: event_validator.EventValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(type_report): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(type_report): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(type_report): event_validator.type_report
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: type_report -> event_validator.type_report
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.type_report
      -> Not module state
      [CALL] Found call: type_engine.validate
    [RESOLVE] Attempting to resolve: ['type_engine', 'validate']
    [RESOLVE] Chain resolution needed for: ['type_engine', 'validate']
      [CHAIN] Resolving base: type_engine
      [RESOLVE_SIMPLE] Resolving base: type_engine
      [CACHE] Hit for type_engine: event_validator.type_engine
      [CHAIN] Base resolved: type_engine -> event_validator.type_engine
      [CHAIN] Step 1: Resolving event_validator.type_engine.validate
        [ATTRIBUTE] Resolving attribute: event_validator.type_engine.validate
        [ATTRIBUTE] Direct match found: event_validator.type_engine.validate
      [CHAIN] Step 1 resolved: event_validator.type_engine.validate
    [RESOLVE] RESOLVED to: event_validator.type_engine.validate
            [INTERMEDIATE] Tracking chain steps for: type_engine.validate
            [INTERMEDIATE] Step 1: type_engine.validate
      -> Resolved to: event_validator.type_engine.validate
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: type_engine.validate
        [CACHE] type_engine.validate -> event_validator.type_engine.validate (cached)
      -> Not module state
      [NAME] Found name reference: type_engine
        [CACHE] type_engine -> event_validator.type_engine (cached)
      -> Not module state
      [CALL] Found call: event_data.get
    [CACHE] event_data.get -> event_validator.event_data.get (cached)
            [INTERMEDIATE] Tracking chain steps for: event_data.get
            [INTERMEDIATE] Step 1: event_data.get
      -> Resolved to: event_validator.event_data.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: event_data.get
        [CACHE] event_data.get -> event_validator.event_data.get (cached)
      -> Not module state
      [NAME] Found name reference: event_data
        [CACHE] event_data -> event_validator.event_data (cached)
      -> Not module state
      [CALL] Found call: self.validation_engine._merge_reports
    [RESOLVE] Attempting to resolve: ['self', 'validation_engine', '_merge_reports']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_engine', '_merge_reports']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine
      [CHAIN] Step 1 resolved: event_validator.EventValidator.validation_engine
      [CHAIN] Step 2: Resolving event_validator.EventValidator.validation_engine._merge_reports
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine._merge_reports
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine._merge_reports
      [CHAIN] Step 2 resolved: event_validator.EventValidator.validation_engine._merge_reports
    [RESOLVE] RESOLVED to: event_validator.EventValidator.validation_engine._merge_reports
            [INTERMEDIATE] Tracking chain steps for: self.validation_engine._merge_reports
            [INTERMEDIATE] Step 1: self.validation_engine
    [CACHE] self.validation_engine -> event_validator.EventValidator.validation_engine (cached)
            [INTERMEDIATE] Step 1 resolved to: event_validator.EventValidator.validation_engine
            [INTERMEDIATE] Step 2: self.validation_engine._merge_reports
      -> Resolved to: event_validator.EventValidator.validation_engine._merge_reports
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: base_report
    [RESOLVE] Attempting to resolve: ['base_report']
      [RESOLVE_SIMPLE] Resolving base: base_report
      [CACHE] Hit for base_report: event_validator.base_report
    [RESOLVE] RESOLVED to: event_validator.base_report
        [FUNCTION_ARG] Checking argument: type_report
    [RESOLVE] Attempting to resolve: ['type_report']
      [RESOLVE_SIMPLE] Resolving base: type_report
      [CACHE] Hit for type_report: event_validator.type_report
    [RESOLVE] RESOLVED to: event_validator.type_report
      [ATTRIBUTE] Found attribute access: self.validation_engine._merge_reports
        [CACHE] self.validation_engine._merge_reports -> event_validator.EventValidator.validation_engine._merge_reports (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_engine
        [CACHE] self.validation_engine -> event_validator.EventValidator.validation_engine (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.EventValidator (cached)
      -> Not module state
      [NAME] Found name reference: base_report
        [CACHE] base_report -> event_validator.base_report (cached)
      -> Not module state
      [NAME] Found name reference: type_report
        [CACHE] type_report -> event_validator.type_report (cached)
      -> Not module state
      [NAME] Found name reference: base_report
        [CACHE] base_report -> event_validator.base_report (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.EventValidator.validate_event
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.EventValidator.validate_event
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.EventValidator.validate_result
    [CONTEXT] Entered function: event_validator.EventValidator.validate_result (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'result': 'Any'}
        [ARG_TYPE] Processing type annotation for result: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: event_validator.EventValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: result -> typing.Any
        [ARG_TYPE] RESOLVED result : typing.Any
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found result in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(result): True
      [SYMBOL_LOOKUP] Found result in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(result): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: result -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> typing.Any (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.EventValidator.validate_result
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.EventValidator.validate_result
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.EventValidator.get_validation_details
    [CONTEXT] Entered function: event_validator.EventValidator.get_validation_details (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: event_validator.EventValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(len): event_validator.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> event_validator.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_engine.rules
    [RESOLVE] Attempting to resolve: ['self', 'validation_engine', 'rules']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_engine', 'rules']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine
      [CHAIN] Step 1 resolved: event_validator.EventValidator.validation_engine
      [CHAIN] Step 2: Resolving event_validator.EventValidator.validation_engine.rules
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine.rules
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine.rules
      [CHAIN] Step 2 resolved: event_validator.EventValidator.validation_engine.rules
    [RESOLVE] RESOLVED to: event_validator.EventValidator.validation_engine.rules
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_engine
    [RESOLVE] Attempting to resolve: ['self', 'validation_engine']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_engine']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine
      [CHAIN] Step 1 resolved: event_validator.EventValidator.validation_engine
    [RESOLVE] RESOLVED to: event_validator.EventValidator.validation_engine
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
    [RESOLVE] RESOLVED to: event_validator.EventValidator
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
        [CACHE] len -> event_validator.len (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.event_schemas
    [RESOLVE] Attempting to resolve: ['self', 'event_schemas']
    [RESOLVE] Chain resolution needed for: ['self', 'event_schemas']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.event_schemas
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.event_schemas
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.event_schemas
      [CHAIN] Step 1 resolved: event_validator.EventValidator.event_schemas
    [RESOLVE] RESOLVED to: event_validator.EventValidator.event_schemas
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.EventValidator (cached)
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
        [CACHE] len -> event_validator.len (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_engine.validation_cache
    [RESOLVE] Attempting to resolve: ['self', 'validation_engine', 'validation_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_engine', 'validation_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.EventValidator
      [CHAIN] Base resolved: self -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine
      [CHAIN] Step 1 resolved: event_validator.EventValidator.validation_engine
      [CHAIN] Step 2: Resolving event_validator.EventValidator.validation_engine.validation_cache
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validation_engine.validation_cache
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validation_engine.validation_cache
      [CHAIN] Step 2 resolved: event_validator.EventValidator.validation_engine.validation_cache
    [RESOLVE] RESOLVED to: event_validator.EventValidator.validation_engine.validation_cache
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_engine
        [CACHE] self.validation_engine -> event_validator.EventValidator.validation_engine (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.EventValidator (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.EventValidator.get_validation_details
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.EventValidator.get_validation_details
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: event_validator.EventValidator
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: MessageValidator
    [CONTEXT] Entered class: event_validator.MessageValidator
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.MessageValidator.__init__
    [CONTEXT] Entered function: event_validator.MessageValidator.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.content_filters
    [RESOLVE] Attempting to resolve: ['self', 'content_filters']
    [RESOLVE] Chain resolution needed for: ['self', 'content_filters']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: event_validator.MessageValidator)
      [SELF_RESOLVER] resolve(self): event_validator.MessageValidator
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> event_validator.MessageValidator
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.content_filters
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.content_filters
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.content_filters
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.content_filters
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.content_filters
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
    [RESOLVE] RESOLVED to: event_validator.MessageValidator
      -> Not module state
      [NAME] Found name reference: List
    [RESOLVE] Attempting to resolve: ['List']
      [RESOLVE_SIMPLE] Resolving base: List
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable List not found in any scope
      [LOCAL_RESOLVER] can_resolve(List): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(List): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(List): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(List): typing.List (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: List -> typing.List
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.List
      -> Not module state
      [NAME] Found name reference: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Callable not found in any scope
      [LOCAL_RESOLVER] can_resolve(Callable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Callable): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Callable): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Callable): typing.Callable (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Callable -> typing.Callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Callable
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(str): event_validator.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [NAME] Found name reference: bool
    [RESOLVE] Attempting to resolve: ['bool']
      [RESOLVE_SIMPLE] Resolving base: bool
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable bool not found in any scope
      [LOCAL_RESOLVER] can_resolve(bool): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(bool): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(bool): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(bool): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(bool): event_validator.bool
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: bool -> event_validator.bool
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.bool
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.banned_patterns
    [RESOLVE] Attempting to resolve: ['self', 'banned_patterns']
    [RESOLVE] Chain resolution needed for: ['self', 'banned_patterns']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.banned_patterns
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.banned_patterns
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.banned_patterns
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.banned_patterns
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.banned_patterns
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.MessageValidator (cached)
      -> Not module state
      [NAME] Found name reference: List
        [CACHE] List -> typing.List (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: re.Pattern
    [RESOLVE] Attempting to resolve: ['re', 'Pattern']
    [RESOLVE] Chain resolution needed for: ['re', 'Pattern']
      [CHAIN] Resolving base: re
      [RESOLVE_SIMPLE] Resolving base: re
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable re not found in any scope
      [LOCAL_RESOLVER] can_resolve(re): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(re): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(re): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(re): re (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: re -> re
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: re -> re
      [CHAIN] Step 1: Resolving re.Pattern
        [ATTRIBUTE] Resolving attribute: re.Pattern
        [ATTRIBUTE] Direct match found: re.Pattern
      [CHAIN] Step 1 resolved: re.Pattern
    [RESOLVE] RESOLVED to: re.Pattern
      -> Not module state
      [NAME] Found name reference: re
    [RESOLVE] Attempting to resolve: ['re']
      [RESOLVE_SIMPLE] Resolving base: re
      [CACHE] Hit for re: re
    [RESOLVE] RESOLVED to: re
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_cache
    [RESOLVE] Attempting to resolve: ['self', 'validation_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.validation_cache
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.validation_cache
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.validation_cache
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.validation_cache
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.validation_cache
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.MessageValidator (cached)
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> event_validator.str (cached)
      -> Not module state
      [NAME] Found name reference: bool
        [CACHE] bool -> event_validator.bool (cached)
      -> Not module state
      [CALL] Found call: self._setup_default_filters
    [RESOLVE] Attempting to resolve: ['self', '_setup_default_filters']
    [RESOLVE] Chain resolution needed for: ['self', '_setup_default_filters']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator._setup_default_filters
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator._setup_default_filters
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator._setup_default_filters
      [CHAIN] Step 1 resolved: event_validator.MessageValidator._setup_default_filters
    [RESOLVE] RESOLVED to: event_validator.MessageValidator._setup_default_filters
            [INTERMEDIATE] Tracking chain steps for: self._setup_default_filters
            [INTERMEDIATE] Step 1: self._setup_default_filters
      -> Resolved to: event_validator.MessageValidator._setup_default_filters
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self._setup_default_filters
        [CACHE] self._setup_default_filters -> event_validator.MessageValidator._setup_default_filters (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.MessageValidator (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.MessageValidator.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.MessageValidator.__init__
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.MessageValidator._setup_default_filters
    [CONTEXT] Entered function: event_validator.MessageValidator._setup_default_filters (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Found call: self.content_filters.append
    [RESOLVE] Attempting to resolve: ['self', 'content_filters', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'content_filters', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.content_filters
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.content_filters
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.content_filters
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.content_filters
      [CHAIN] Step 2: Resolving event_validator.MessageValidator.content_filters.append
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.content_filters.append
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.content_filters.append
      [CHAIN] Step 2 resolved: event_validator.MessageValidator.content_filters.append
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.content_filters.append
            [INTERMEDIATE] Tracking chain steps for: self.content_filters.append
            [INTERMEDIATE] Step 1: self.content_filters
    [RESOLVE] Attempting to resolve: ['self', 'content_filters']
    [RESOLVE] Chain resolution needed for: ['self', 'content_filters']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.content_filters
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.content_filters
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.content_filters
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.content_filters
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.content_filters
            [INTERMEDIATE] Step 1 resolved to: event_validator.MessageValidator.content_filters
            [INTERMEDIATE] Step 2: self.content_filters.append
      -> Resolved to: event_validator.MessageValidator.content_filters.append
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.content_filters.append
        [CACHE] self.content_filters.append -> event_validator.MessageValidator.content_filters.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.content_filters
        [CACHE] self.content_filters -> event_validator.MessageValidator.content_filters (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
    [RESOLVE] RESOLVED to: event_validator.MessageValidator
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(len): event_validator.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> event_validator.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.len
      -> Not module state
      [CALL] Found call: msg.strip
    [RESOLVE] Attempting to resolve: ['msg', 'strip']
    [RESOLVE] Chain resolution needed for: ['msg', 'strip']
      [CHAIN] Resolving base: msg
      [RESOLVE_SIMPLE] Resolving base: msg
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable msg not found in any scope
      [LOCAL_RESOLVER] can_resolve(msg): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(msg): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(msg): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(msg): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(msg): event_validator.msg
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: msg -> event_validator.msg
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: msg -> event_validator.msg
      [CHAIN] Step 1: Resolving event_validator.msg.strip
        [ATTRIBUTE] Resolving attribute: event_validator.msg.strip
        [ATTRIBUTE] Direct match found: event_validator.msg.strip
      [CHAIN] Step 1 resolved: event_validator.msg.strip
    [RESOLVE] RESOLVED to: event_validator.msg.strip
            [INTERMEDIATE] Tracking chain steps for: msg.strip
            [INTERMEDIATE] Step 1: msg.strip
      -> Resolved to: event_validator.msg.strip
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: msg.strip
        [CACHE] msg.strip -> event_validator.msg.strip (cached)
      -> Not module state
      [NAME] Found name reference: msg
    [RESOLVE] Attempting to resolve: ['msg']
      [RESOLVE_SIMPLE] Resolving base: msg
      [CACHE] Hit for msg: event_validator.msg
    [RESOLVE] RESOLVED to: event_validator.msg
      -> Not module state
      [ASSIGNMENT] Processing: banned_words = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: banned_words
    [RESOLVE] Attempting to resolve: ['banned_words']
      [RESOLVE_SIMPLE] Resolving base: banned_words
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable banned_words not found in any scope
      [LOCAL_RESOLVER] can_resolve(banned_words): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(banned_words): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(banned_words): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(banned_words): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(banned_words): event_validator.banned_words
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: banned_words -> event_validator.banned_words
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.banned_words
      -> Not module state
      [NAME] Found name reference: word
    [RESOLVE] Attempting to resolve: ['word']
      [RESOLVE_SIMPLE] Resolving base: word
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable word not found in any scope
      [LOCAL_RESOLVER] can_resolve(word): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(word): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(word): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(word): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(word): event_validator.word
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: word -> event_validator.word
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.word
      -> Not module state
      [NAME] Found name reference: banned_words
        [CACHE] banned_words -> event_validator.banned_words (cached)
      -> Not module state
      [ASSIGNMENT] Processing: pattern = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: re.compile
    [RESOLVE] Attempting to resolve: ['re', 'compile']
    [RESOLVE] Chain resolution needed for: ['re', 'compile']
      [CHAIN] Resolving base: re
      [RESOLVE_SIMPLE] Resolving base: re
      [CACHE] Hit for re: re
      [CHAIN] Base resolved: re -> re
      [CHAIN] Step 1: Resolving re.compile
        [ATTRIBUTE] Resolving attribute: re.compile
        [ATTRIBUTE] Direct match found: re.compile
      [CHAIN] Step 1 resolved: re.compile
    [RESOLVE] RESOLVED to: re.compile
      [TYPE_INFERENCE] Call resolved to: re.compile
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for pattern
      [NAME] Found name reference: pattern
    [RESOLVE] Attempting to resolve: ['pattern']
      [RESOLVE_SIMPLE] Resolving base: pattern
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable pattern not found in any scope
      [LOCAL_RESOLVER] can_resolve(pattern): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(pattern): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(pattern): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(pattern): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(pattern): event_validator.pattern
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: pattern -> event_validator.pattern
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.pattern
      -> Not module state
      [CALL] Found call: re.compile
    [RESOLVE] Attempting to resolve: ['re', 'compile']
    [RESOLVE] Chain resolution needed for: ['re', 'compile']
      [CHAIN] Resolving base: re
      [RESOLVE_SIMPLE] Resolving base: re
      [CACHE] Hit for re: re
      [CHAIN] Base resolved: re -> re
      [CHAIN] Step 1: Resolving re.compile
        [ATTRIBUTE] Resolving attribute: re.compile
        [ATTRIBUTE] Direct match found: re.compile
      [CHAIN] Step 1 resolved: re.compile
    [RESOLVE] RESOLVED to: re.compile
            [INTERMEDIATE] Tracking chain steps for: re.compile
            [INTERMEDIATE] Step 1: re.compile
      -> Resolved to: re.compile
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: re.compile
        [CACHE] re.compile -> re.compile (cached)
      -> Not module state
      [NAME] Found name reference: re
    [RESOLVE] Attempting to resolve: ['re']
      [RESOLVE_SIMPLE] Resolving base: re
      [CACHE] Hit for re: re
    [RESOLVE] RESOLVED to: re
      -> Not module state
      [CALL] Found call: re.escape
    [RESOLVE] Attempting to resolve: ['re', 'escape']
    [RESOLVE] Chain resolution needed for: ['re', 'escape']
      [CHAIN] Resolving base: re
      [RESOLVE_SIMPLE] Resolving base: re
      [CACHE] Hit for re: re
      [CHAIN] Base resolved: re -> re
      [CHAIN] Step 1: Resolving re.escape
        [ATTRIBUTE] Resolving attribute: re.escape
        [ATTRIBUTE] Direct match found: re.escape
      [CHAIN] Step 1 resolved: re.escape
    [RESOLVE] RESOLVED to: re.escape
            [INTERMEDIATE] Tracking chain steps for: re.escape
            [INTERMEDIATE] Step 1: re.escape
      -> Resolved to: re.escape
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: word
    [RESOLVE] Attempting to resolve: ['word']
      [RESOLVE_SIMPLE] Resolving base: word
      [CACHE] Hit for word: event_validator.word
    [RESOLVE] RESOLVED to: event_validator.word
      [ATTRIBUTE] Found attribute access: re.escape
        [CACHE] re.escape -> re.escape (cached)
      -> Not module state
      [NAME] Found name reference: re
        [CACHE] re -> re (cached)
      -> Not module state
      [NAME] Found name reference: word
        [CACHE] word -> event_validator.word (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: re.IGNORECASE
    [RESOLVE] Attempting to resolve: ['re', 'IGNORECASE']
    [RESOLVE] Chain resolution needed for: ['re', 'IGNORECASE']
      [CHAIN] Resolving base: re
      [RESOLVE_SIMPLE] Resolving base: re
      [CACHE] Hit for re: re
      [CHAIN] Base resolved: re -> re
      [CHAIN] Step 1: Resolving re.IGNORECASE
        [ATTRIBUTE] Resolving attribute: re.IGNORECASE
        [ATTRIBUTE] Direct match found: re.IGNORECASE
      [CHAIN] Step 1 resolved: re.IGNORECASE
    [RESOLVE] RESOLVED to: re.IGNORECASE
      -> Not module state
      [NAME] Found name reference: re
        [CACHE] re -> re (cached)
      -> Not module state
      [CALL] Found call: self.banned_patterns.append
    [RESOLVE] Attempting to resolve: ['self', 'banned_patterns', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'banned_patterns', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.banned_patterns
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.banned_patterns
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.banned_patterns
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.banned_patterns
      [CHAIN] Step 2: Resolving event_validator.MessageValidator.banned_patterns.append
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.banned_patterns.append
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.banned_patterns.append
      [CHAIN] Step 2 resolved: event_validator.MessageValidator.banned_patterns.append
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.banned_patterns.append
            [INTERMEDIATE] Tracking chain steps for: self.banned_patterns.append
            [INTERMEDIATE] Step 1: self.banned_patterns
    [RESOLVE] Attempting to resolve: ['self', 'banned_patterns']
    [RESOLVE] Chain resolution needed for: ['self', 'banned_patterns']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.banned_patterns
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.banned_patterns
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.banned_patterns
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.banned_patterns
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.banned_patterns
            [INTERMEDIATE] Step 1 resolved to: event_validator.MessageValidator.banned_patterns
            [INTERMEDIATE] Step 2: self.banned_patterns.append
      -> Resolved to: event_validator.MessageValidator.banned_patterns.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: pattern
    [RESOLVE] Attempting to resolve: ['pattern']
      [RESOLVE_SIMPLE] Resolving base: pattern
      [CACHE] Hit for pattern: event_validator.pattern
    [RESOLVE] RESOLVED to: event_validator.pattern
      [ATTRIBUTE] Found attribute access: self.banned_patterns.append
        [CACHE] self.banned_patterns.append -> event_validator.MessageValidator.banned_patterns.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.banned_patterns
        [CACHE] self.banned_patterns -> event_validator.MessageValidator.banned_patterns (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.MessageValidator (cached)
      -> Not module state
      [NAME] Found name reference: pattern
        [CACHE] pattern -> event_validator.pattern (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.MessageValidator._setup_default_filters
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.MessageValidator._setup_default_filters
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.MessageValidator.validate_message
    [DECORATOR] @trace
    [CONTEXT] Entered function: event_validator.MessageValidator.validate_message (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'message': 'str'}
        [ARG_TYPE] Processing type annotation for message: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: event_validator.str
    [RESOLVE] RESOLVED to: event_validator.str
      [SYMBOL_UPDATE] Function: message -> event_validator.str
        [ARG_TYPE] RESOLVED message : event_validator.str
      [ASSIGNMENT] Processing: message_hash = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: hash
    [RESOLVE] Attempting to resolve: ['hash']
      [RESOLVE_SIMPLE] Resolving base: hash
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable hash not found in any scope
      [LOCAL_RESOLVER] can_resolve(hash): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(hash): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(hash): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(hash): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(hash): event_validator.hash
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: hash -> event_validator.hash
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.hash
      [TYPE_INFERENCE] Call resolved to: event_validator.hash
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for message_hash
      [NAME] Found name reference: message_hash
    [RESOLVE] Attempting to resolve: ['message_hash']
      [RESOLVE_SIMPLE] Resolving base: message_hash
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable message_hash not found in any scope
      [LOCAL_RESOLVER] can_resolve(message_hash): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(message_hash): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(message_hash): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(message_hash): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(message_hash): event_validator.message_hash
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: message_hash -> event_validator.message_hash
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.message_hash
      -> Not module state
      [CALL] Found call: hash
    [RESOLVE] Attempting to resolve: ['hash']
      [RESOLVE_SIMPLE] Resolving base: hash
      [CACHE] Hit for hash: event_validator.hash
    [RESOLVE] RESOLVED to: event_validator.hash
      -> Resolved to: event_validator.hash
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: message
    [RESOLVE] Attempting to resolve: ['message']
      [RESOLVE_SIMPLE] Resolving base: message
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found message in function scope: event_validator.str
      [LOCAL_RESOLVER] can_resolve(message): True
      [SYMBOL_LOOKUP] Found message in function scope: event_validator.str
      [LOCAL_RESOLVER] resolve(message): event_validator.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: message -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      [NAME] Found name reference: hash
        [CACHE] hash -> event_validator.hash (cached)
      -> Not module state
      [NAME] Found name reference: message
    [RESOLVE] Attempting to resolve: ['message']
      [RESOLVE_SIMPLE] Resolving base: message
      [CACHE] Hit for message: event_validator.str
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [NAME] Found name reference: message_hash
        [CACHE] message_hash -> event_validator.message_hash (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_cache
    [RESOLVE] Attempting to resolve: ['self', 'validation_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.validation_cache
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.validation_cache
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.validation_cache
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.validation_cache
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.validation_cache
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
    [RESOLVE] RESOLVED to: event_validator.MessageValidator
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_cache
        [CACHE] self.validation_cache -> event_validator.MessageValidator.validation_cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.MessageValidator (cached)
      -> Not module state
      [NAME] Found name reference: message_hash
        [CACHE] message_hash -> event_validator.message_hash (cached)
      -> Not module state
      [NAME] Found name reference: filter_func
    [RESOLVE] Attempting to resolve: ['filter_func']
      [RESOLVE_SIMPLE] Resolving base: filter_func
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable filter_func not found in any scope
      [LOCAL_RESOLVER] can_resolve(filter_func): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(filter_func): False (current_class: event_validator.MessageValidator)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(filter_func): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(filter_func): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(filter_func): event_validator.filter_func
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: filter_func -> event_validator.filter_func
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.filter_func
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.content_filters
    [RESOLVE] Attempting to resolve: ['self', 'content_filters']
    [RESOLVE] Chain resolution needed for: ['self', 'content_filters']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.content_filters
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.content_filters
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.content_filters
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.content_filters
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.content_filters
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.MessageValidator (cached)
      -> Not module state
      [CALL] Found call: filter_func
    [CACHE] filter_func -> event_validator.filter_func (cached)
      -> Resolved to: event_validator.filter_func
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: message
    [RESOLVE] Attempting to resolve: ['message']
      [RESOLVE_SIMPLE] Resolving base: message
      [CACHE] Hit for message: event_validator.str
    [RESOLVE] RESOLVED to: event_validator.str
      [NAME] Found name reference: filter_func
        [CACHE] filter_func -> event_validator.filter_func (cached)
      -> Not module state
      [NAME] Found name reference: message
        [CACHE] message -> event_validator.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_cache
        [CACHE] self.validation_cache -> event_validator.MessageValidator.validation_cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.MessageValidator (cached)
      -> Not module state
      [NAME] Found name reference: message_hash
        [CACHE] message_hash -> event_validator.message_hash (cached)
      -> Not module state
      [NAME] Found name reference: pattern
    [RESOLVE] Attempting to resolve: ['pattern']
      [RESOLVE_SIMPLE] Resolving base: pattern
      [CACHE] Hit for pattern: event_validator.pattern
    [RESOLVE] RESOLVED to: event_validator.pattern
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.banned_patterns
    [RESOLVE] Attempting to resolve: ['self', 'banned_patterns']
    [RESOLVE] Chain resolution needed for: ['self', 'banned_patterns']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.banned_patterns
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.banned_patterns
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.banned_patterns
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.banned_patterns
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.banned_patterns
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.MessageValidator (cached)
      -> Not module state
      [CALL] Found call: pattern.search
    [RESOLVE] Attempting to resolve: ['pattern', 'search']
    [RESOLVE] Chain resolution needed for: ['pattern', 'search']
      [CHAIN] Resolving base: pattern
      [RESOLVE_SIMPLE] Resolving base: pattern
      [CACHE] Hit for pattern: event_validator.pattern
      [CHAIN] Base resolved: pattern -> event_validator.pattern
      [CHAIN] Step 1: Resolving event_validator.pattern.search
        [ATTRIBUTE] Resolving attribute: event_validator.pattern.search
        [ATTRIBUTE] Direct match found: event_validator.pattern.search
      [CHAIN] Step 1 resolved: event_validator.pattern.search
    [RESOLVE] RESOLVED to: event_validator.pattern.search
            [INTERMEDIATE] Tracking chain steps for: pattern.search
            [INTERMEDIATE] Step 1: pattern.search
      -> Resolved to: event_validator.pattern.search
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: message
    [RESOLVE] Attempting to resolve: ['message']
      [RESOLVE_SIMPLE] Resolving base: message
      [CACHE] Hit for message: event_validator.str
    [RESOLVE] RESOLVED to: event_validator.str
      [ATTRIBUTE] Found attribute access: pattern.search
        [CACHE] pattern.search -> event_validator.pattern.search (cached)
      -> Not module state
      [NAME] Found name reference: pattern
        [CACHE] pattern -> event_validator.pattern (cached)
      -> Not module state
      [NAME] Found name reference: message
        [CACHE] message -> event_validator.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_cache
        [CACHE] self.validation_cache -> event_validator.MessageValidator.validation_cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.MessageValidator (cached)
      -> Not module state
      [NAME] Found name reference: message_hash
        [CACHE] message_hash -> event_validator.message_hash (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_cache
        [CACHE] self.validation_cache -> event_validator.MessageValidator.validation_cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.MessageValidator (cached)
      -> Not module state
      [NAME] Found name reference: message_hash
        [CACHE] message_hash -> event_validator.message_hash (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.MessageValidator.validate_message
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.MessageValidator.validate_message
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.MessageValidator.get_validation_details
    [CONTEXT] Entered function: event_validator.MessageValidator.get_validation_details (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [CACHE] Hit for len: event_validator.len
    [RESOLVE] RESOLVED to: event_validator.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.content_filters
    [RESOLVE] Attempting to resolve: ['self', 'content_filters']
    [RESOLVE] Chain resolution needed for: ['self', 'content_filters']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.content_filters
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.content_filters
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.content_filters
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.content_filters
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.content_filters
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
    [RESOLVE] RESOLVED to: event_validator.MessageValidator
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
        [CACHE] len -> event_validator.len (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.banned_patterns
    [RESOLVE] Attempting to resolve: ['self', 'banned_patterns']
    [RESOLVE] Chain resolution needed for: ['self', 'banned_patterns']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.banned_patterns
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.banned_patterns
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.banned_patterns
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.banned_patterns
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.banned_patterns
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.MessageValidator (cached)
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
        [CACHE] len -> event_validator.len (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_cache
    [RESOLVE] Attempting to resolve: ['self', 'validation_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: event_validator.MessageValidator
      [CHAIN] Base resolved: self -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.validation_cache
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.validation_cache
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.validation_cache
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.validation_cache
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.validation_cache
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> event_validator.MessageValidator (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.MessageValidator.get_validation_details
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.MessageValidator.get_validation_details
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: event_validator.MessageValidator
    [SYMBOL_TABLE] Exited class scope
      [ASSIGNMENT] Processing: event_validator = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: EventValidator
    [RESOLVE] Attempting to resolve: ['EventValidator']
      [RESOLVE_SIMPLE] Resolving base: EventValidator
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable EventValidator not found in any scope
      [LOCAL_RESOLVER] can_resolve(EventValidator): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(EventValidator): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(EventValidator): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(EventValidator): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(EventValidator): event_validator.EventValidator
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: EventValidator -> event_validator.EventValidator
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.EventValidator
      [TYPE_INFERENCE] Call resolved to: event_validator.EventValidator
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.EventValidator (class instantiation)
      [SYMBOL_UPDATE] Function: event_validator -> event_validator.EventValidator
        [ASSIGNMENT] RESOLVED Updated symbol table: event_validator = event_validator.EventValidator
      [ASSIGNMENT] Processing: message_validator = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: MessageValidator
    [RESOLVE] Attempting to resolve: ['MessageValidator']
      [RESOLVE_SIMPLE] Resolving base: MessageValidator
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable MessageValidator not found in any scope
      [LOCAL_RESOLVER] can_resolve(MessageValidator): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(MessageValidator): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(MessageValidator): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(MessageValidator): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(MessageValidator): event_validator.MessageValidator
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: MessageValidator -> event_validator.MessageValidator
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.MessageValidator
      [TYPE_INFERENCE] Call resolved to: event_validator.MessageValidator
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.MessageValidator (class instantiation)
      [SYMBOL_UPDATE] Function: message_validator -> event_validator.MessageValidator
        [ASSIGNMENT] RESOLVED Updated symbol table: message_validator = event_validator.MessageValidator
      [ASSIGNMENT] Processing: test_event_data = ...
        [ASSIGNMENT] Non-call assignment
      [ASSIGNMENT] Processing: event_validation_result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: event_validator.validate_event
    [RESOLVE] Attempting to resolve: ['event_validator', 'validate_event']
    [RESOLVE] Chain resolution needed for: ['event_validator', 'validate_event']
      [CHAIN] Resolving base: event_validator
      [RESOLVE_SIMPLE] Resolving base: event_validator
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found event_validator in function scope: event_validator.EventValidator
      [LOCAL_RESOLVER] can_resolve(event_validator): True
      [SYMBOL_LOOKUP] Found event_validator in function scope: event_validator.EventValidator
      [LOCAL_RESOLVER] resolve(event_validator): event_validator.EventValidator
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: event_validator -> event_validator.EventValidator
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: event_validator -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.validate_event
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validate_event
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validate_event
      [CHAIN] Step 1 resolved: event_validator.EventValidator.validate_event
    [RESOLVE] RESOLVED to: event_validator.EventValidator.validate_event
      [TYPE_INFERENCE] Call resolved to: event_validator.EventValidator.validate_event
        [RETURN_TYPE_RESOLUTION] Resolving return type: ValidationReport
        [RETURN_TYPE_RESOLUTION] Found in current module: event_validator.ValidationReport
      [TYPE_INFERENCE] RESOLVED Inferred type: event_validator.ValidationReport (from return type)
      [SYMBOL_UPDATE] Function: event_validation_result -> event_validator.ValidationReport
        [ASSIGNMENT] RESOLVED Updated symbol table: event_validation_result = event_validator.ValidationReport
      [ASSIGNMENT] Processing: message_validation_result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: message_validator.validate_message
    [RESOLVE] Attempting to resolve: ['message_validator', 'validate_message']
    [RESOLVE] Chain resolution needed for: ['message_validator', 'validate_message']
      [CHAIN] Resolving base: message_validator
      [RESOLVE_SIMPLE] Resolving base: message_validator
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found message_validator in function scope: event_validator.MessageValidator
      [LOCAL_RESOLVER] can_resolve(message_validator): True
      [SYMBOL_LOOKUP] Found message_validator in function scope: event_validator.MessageValidator
      [LOCAL_RESOLVER] resolve(message_validator): event_validator.MessageValidator
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: message_validator -> event_validator.MessageValidator
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: message_validator -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.validate_message
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.validate_message
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.validate_message
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.validate_message
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.validate_message
      [TYPE_INFERENCE] Call resolved to: event_validator.MessageValidator.validate_message
        [RETURN_TYPE_RESOLUTION] Resolving return type: bool
        [RETURN_TYPE_RESOLUTION] Class 'bool' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: bool
      [TYPE_INFERENCE] Could not resolve return type 'bool' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: bool (from return type - unresolved)
      [SYMBOL_UPDATE] Function: message_validation_result -> bool
        [ASSIGNMENT] RESOLVED Updated symbol table: message_validation_result = bool
  [FUNCTION] Analyzing function: validate_complete_action
    [FUNCTION_ANALYSIS] Starting analysis of: event_validator.validate_complete_action
    [CONTEXT] Entered function: event_validator.validate_complete_action (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'event_data': 'Dict[str, Any]', 'message_content': 'str'}
        [ARG_TYPE] Processing type annotation for message_content: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(str): event_validator.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      [SYMBOL_UPDATE] Function: message_content -> event_validator.str
        [ARG_TYPE] RESOLVED message_content : event_validator.str
      [ASSIGNMENT] Processing: results = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: results
    [RESOLVE] Attempting to resolve: ['results']
      [RESOLVE_SIMPLE] Resolving base: results
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable results not found in any scope
      [LOCAL_RESOLVER] can_resolve(results): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(results): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(results): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(results): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(results): event_validator.results
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: results -> event_validator.results
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.results
      -> Not module state
      [NAME] Found name reference: results
        [CACHE] results -> event_validator.results (cached)
      -> Not module state
      [CALL] Found call: event_validator.validate_event
    [RESOLVE] Attempting to resolve: ['event_validator', 'validate_event']
    [RESOLVE] Chain resolution needed for: ['event_validator', 'validate_event']
      [CHAIN] Resolving base: event_validator
      [RESOLVE_SIMPLE] Resolving base: event_validator
      [CACHE] Hit for event_validator: event_validator.EventValidator
      [CHAIN] Base resolved: event_validator -> event_validator.EventValidator
      [CHAIN] Step 1: Resolving event_validator.EventValidator.validate_event
        [ATTRIBUTE] Resolving attribute: event_validator.EventValidator.validate_event
        [ATTRIBUTE] Direct match found: event_validator.EventValidator.validate_event
      [CHAIN] Step 1 resolved: event_validator.EventValidator.validate_event
    [RESOLVE] RESOLVED to: event_validator.EventValidator.validate_event
            [INTERMEDIATE] Tracking chain steps for: event_validator.validate_event
            [INTERMEDIATE] Step 1: event_validator.validate_event
      -> Resolved to: event_validator.EventValidator.validate_event
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: event_data
    [RESOLVE] Attempting to resolve: ['event_data']
      [RESOLVE_SIMPLE] Resolving base: event_data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable event_data not found in any scope
      [LOCAL_RESOLVER] can_resolve(event_data): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(event_data): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(event_data): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(event_data): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(event_data): event_validator.event_data
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: event_data -> event_validator.event_data
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.event_data
      [ATTRIBUTE] Found attribute access: event_validator.validate_event
        [CACHE] event_validator.validate_event -> event_validator.EventValidator.validate_event (cached)
      -> Not module state
      [NAME] Found name reference: event_validator
    [RESOLVE] Attempting to resolve: ['event_validator']
      [RESOLVE_SIMPLE] Resolving base: event_validator
      [CACHE] Hit for event_validator: event_validator.EventValidator
    [RESOLVE] RESOLVED to: event_validator.EventValidator
      -> Not module state
      [NAME] Found name reference: event_data
    [RESOLVE] Attempting to resolve: ['event_data']
      [RESOLVE_SIMPLE] Resolving base: event_data
      [CACHE] Hit for event_data: event_validator.event_data
    [RESOLVE] RESOLVED to: event_validator.event_data
      -> Not module state
      [ASSIGNMENT] Processing: message_valid = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: message_validator.validate_message
    [RESOLVE] Attempting to resolve: ['message_validator', 'validate_message']
    [RESOLVE] Chain resolution needed for: ['message_validator', 'validate_message']
      [CHAIN] Resolving base: message_validator
      [RESOLVE_SIMPLE] Resolving base: message_validator
      [CACHE] Hit for message_validator: event_validator.MessageValidator
      [CHAIN] Base resolved: message_validator -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.validate_message
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.validate_message
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.validate_message
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.validate_message
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.validate_message
      [TYPE_INFERENCE] Call resolved to: event_validator.MessageValidator.validate_message
        [RETURN_TYPE_RESOLUTION] Resolving return type: bool
        [RETURN_TYPE_RESOLUTION] Class 'bool' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: bool
      [TYPE_INFERENCE] Could not resolve return type 'bool' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: bool (from return type - unresolved)
      [SYMBOL_UPDATE] Function: message_valid -> bool
        [ASSIGNMENT] RESOLVED Updated symbol table: message_valid = bool
      [NAME] Found name reference: message_valid
    [RESOLVE] Attempting to resolve: ['message_valid']
      [RESOLVE_SIMPLE] Resolving base: message_valid
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found message_valid in function scope: bool
      [LOCAL_RESOLVER] can_resolve(message_valid): True
      [SYMBOL_LOOKUP] Found message_valid in function scope: bool
      [LOCAL_RESOLVER] resolve(message_valid): bool
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: message_valid -> bool
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: bool
      -> Not module state
      [CALL] Found call: message_validator.validate_message
    [RESOLVE] Attempting to resolve: ['message_validator', 'validate_message']
    [RESOLVE] Chain resolution needed for: ['message_validator', 'validate_message']
      [CHAIN] Resolving base: message_validator
      [RESOLVE_SIMPLE] Resolving base: message_validator
      [CACHE] Hit for message_validator: event_validator.MessageValidator
      [CHAIN] Base resolved: message_validator -> event_validator.MessageValidator
      [CHAIN] Step 1: Resolving event_validator.MessageValidator.validate_message
        [ATTRIBUTE] Resolving attribute: event_validator.MessageValidator.validate_message
        [ATTRIBUTE] Direct match found: event_validator.MessageValidator.validate_message
      [CHAIN] Step 1 resolved: event_validator.MessageValidator.validate_message
    [RESOLVE] RESOLVED to: event_validator.MessageValidator.validate_message
            [INTERMEDIATE] Tracking chain steps for: message_validator.validate_message
            [INTERMEDIATE] Step 1: message_validator.validate_message
      -> Resolved to: event_validator.MessageValidator.validate_message
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: message_content
    [RESOLVE] Attempting to resolve: ['message_content']
      [RESOLVE_SIMPLE] Resolving base: message_content
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found message_content in function scope: event_validator.str
      [LOCAL_RESOLVER] can_resolve(message_content): True
      [SYMBOL_LOOKUP] Found message_content in function scope: event_validator.str
      [LOCAL_RESOLVER] resolve(message_content): event_validator.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: message_content -> event_validator.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.str
      [ATTRIBUTE] Found attribute access: message_validator.validate_message
        [CACHE] message_validator.validate_message -> event_validator.MessageValidator.validate_message (cached)
      -> Not module state
      [NAME] Found name reference: message_validator
    [RESOLVE] Attempting to resolve: ['message_validator']
      [RESOLVE_SIMPLE] Resolving base: message_validator
      [CACHE] Hit for message_validator: event_validator.MessageValidator
    [RESOLVE] RESOLVED to: event_validator.MessageValidator
      -> Not module state
      [NAME] Found name reference: message_content
    [RESOLVE] Attempting to resolve: ['message_content']
      [RESOLVE_SIMPLE] Resolving base: message_content
      [CACHE] Hit for message_content: event_validator.str
    [RESOLVE] RESOLVED to: event_validator.str
      -> Not module state
      [NAME] Found name reference: results
        [CACHE] results -> event_validator.results (cached)
      -> Not module state
      [NAME] Found name reference: message_valid
        [CACHE] message_valid -> bool (cached)
      -> Not module state
      [NAME] Found name reference: results
        [CACHE] results -> event_validator.results (cached)
      -> Not module state
    [CONTEXT] Exited function: event_validator.validate_complete_action
    [FUNCTION_ANALYSIS] Completed analysis of: event_validator.validate_complete_action
        Calls: 2
        Instantiations: 0
        State Access: 0
      [ASSIGNMENT] Processing: complete_validation = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: validate_complete_action
    [RESOLVE] Attempting to resolve: ['validate_complete_action']
      [RESOLVE_SIMPLE] Resolving base: validate_complete_action
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable validate_complete_action not found in any scope
      [LOCAL_RESOLVER] can_resolve(validate_complete_action): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(validate_complete_action): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(validate_complete_action): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(validate_complete_action): True (fallback, module: event_validator)
      [MODULE_RESOLVER] resolve(validate_complete_action): event_validator.validate_complete_action
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: validate_complete_action -> event_validator.validate_complete_action
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.validate_complete_action
      [TYPE_INFERENCE] Call resolved to: event_validator.validate_complete_action
        [RETURN_TYPE_RESOLUTION] Resolving return type: Dict[str, Any]
        [RETURN_TYPE_RESOLUTION] Class 'Dict[str, Any]' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: Dict[str, Any]
      [TYPE_INFERENCE] Could not resolve return type 'Dict[str, Any]' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: Dict[str, Any] (from return type - unresolved)
      [SYMBOL_UPDATE] Function: complete_validation -> Dict[str, Any]
        [ASSIGNMENT] RESOLVED Updated symbol table: complete_validation = Dict[str, Any]
=== Module Analysis Complete ===
  Module analysis complete
=== Analyzing inheritence_complex.py ===
  [RESOLVER] Using implementation: refactored
=== Starting Module Analysis ===
    [FROM_IMPORT] Any -> typing.Any
    [FROM_IMPORT] Dict -> typing.Dict
    [FROM_IMPORT] List -> typing.List
    [FROM_IMPORT] Optional -> typing.Optional
    [FROM_IMPORT] Union -> typing.Union
    [FROM_IMPORT] Protocol -> typing.Protocol
    [FROM_IMPORT] TypeVar -> typing.TypeVar
    [FROM_IMPORT] Generic -> typing.Generic
    [FROM_IMPORT] ABC -> abc.ABC
    [FROM_IMPORT] abstractmethod -> abc.abstractmethod
    [IMPORT] asyncio -> asyncio
    [FROM_IMPORT] dataclass -> dataclasses.dataclass
    [FROM_IMPORT] field -> dataclasses.field
    [FROM_IMPORT] Enum -> enum.Enum
    [FROM_IMPORT] auto -> enum.auto
    [FROM_IMPORT] contextmanager -> contextlib.contextmanager
    [FROM_IMPORT] trace -> decorators.trace
    [FROM_IMPORT] monitor_performance -> decorators.monitor_performance
    [FROM_IMPORT] validate_auth -> decorators.validate_auth
    [FROM_IMPORT] BaseProxy -> proxy_handler.BaseProxy
    [FROM_IMPORT] DataProxy -> proxy_handler.DataProxy
    [FROM_IMPORT] SessionManager -> session_manager.SessionManager
    [MODULE_STATE] T = TypeVar('T')
    [MODULE_STATE] U = TypeVar('U')
  [CLASS] Analyzing class: Priority
    [CONTEXT] Entered class: inheritence_complex.Priority
    [SYMBOL_TABLE] Entered class scope
    [CONTEXT] Exited class: inheritence_complex.Priority
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: ProcessingResult
    [CONTEXT] Entered class: inheritence_complex.ProcessingResult
    [SYMBOL_TABLE] Entered class scope
    [CONTEXT] Exited class: inheritence_complex.ProcessingResult
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: AbstractProcessor
    [CONTEXT] Entered class: inheritence_complex.AbstractProcessor
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.AbstractProcessor.__init__
    [CONTEXT] Entered function: inheritence_complex.AbstractProcessor.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'processor_id': 'str'}
        [ARG_TYPE] Processing type annotation for processor_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: inheritence_complex.AbstractProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(str): inheritence_complex.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: processor_id -> inheritence_complex.str
        [ARG_TYPE] RESOLVED processor_id : inheritence_complex.str
      [ATTRIBUTE] Found attribute access: self.processor_id
    [RESOLVE] Attempting to resolve: ['self', 'processor_id']
    [RESOLVE] Chain resolution needed for: ['self', 'processor_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: inheritence_complex.AbstractProcessor)
      [SELF_RESOLVER] resolve(self): inheritence_complex.AbstractProcessor
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> inheritence_complex.AbstractProcessor
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> inheritence_complex.AbstractProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AbstractProcessor.processor_id
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AbstractProcessor.processor_id
        [ATTRIBUTE] Direct match found: inheritence_complex.AbstractProcessor.processor_id
      [CHAIN] Step 1 resolved: inheritence_complex.AbstractProcessor.processor_id
    [RESOLVE] RESOLVED to: inheritence_complex.AbstractProcessor.processor_id
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AbstractProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.AbstractProcessor
      -> Not module state
      [NAME] Found name reference: processor_id
    [RESOLVE] Attempting to resolve: ['processor_id']
      [RESOLVE_SIMPLE] Resolving base: processor_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found processor_id in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] can_resolve(processor_id): True
      [SYMBOL_LOOKUP] Found processor_id in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] resolve(processor_id): inheritence_complex.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: processor_id -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.processed_count
    [RESOLVE] Attempting to resolve: ['self', 'processed_count']
    [RESOLVE] Chain resolution needed for: ['self', 'processed_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AbstractProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AbstractProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AbstractProcessor.processed_count
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AbstractProcessor.processed_count
        [ATTRIBUTE] Direct match found: inheritence_complex.AbstractProcessor.processed_count
      [CHAIN] Step 1 resolved: inheritence_complex.AbstractProcessor.processed_count
    [RESOLVE] RESOLVED to: inheritence_complex.AbstractProcessor.processed_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AbstractProcessor (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.error_count
    [RESOLVE] Attempting to resolve: ['self', 'error_count']
    [RESOLVE] Chain resolution needed for: ['self', 'error_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AbstractProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AbstractProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AbstractProcessor.error_count
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AbstractProcessor.error_count
        [ATTRIBUTE] Direct match found: inheritence_complex.AbstractProcessor.error_count
      [CHAIN] Step 1 resolved: inheritence_complex.AbstractProcessor.error_count
    [RESOLVE] RESOLVED to: inheritence_complex.AbstractProcessor.error_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AbstractProcessor (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.AbstractProcessor.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.AbstractProcessor.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.AbstractProcessor.process_data
    [DECORATOR] @abstractmethod
    [CONTEXT] Entered function: inheritence_complex.AbstractProcessor.process_data (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: inheritence_complex.AbstractProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
    [CONTEXT] Exited function: inheritence_complex.AbstractProcessor.process_data
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.AbstractProcessor.process_data
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.AbstractProcessor.validate_input
    [DECORATOR] @abstractmethod
    [CONTEXT] Entered function: inheritence_complex.AbstractProcessor.validate_input (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
    [CONTEXT] Exited function: inheritence_complex.AbstractProcessor.validate_input
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.AbstractProcessor.validate_input
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.AbstractProcessor.get_statistics
    [CONTEXT] Entered function: inheritence_complex.AbstractProcessor.get_statistics (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.processed_count
    [RESOLVE] Attempting to resolve: ['self', 'processed_count']
    [RESOLVE] Chain resolution needed for: ['self', 'processed_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AbstractProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AbstractProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AbstractProcessor.processed_count
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AbstractProcessor.processed_count
        [ATTRIBUTE] Direct match found: inheritence_complex.AbstractProcessor.processed_count
      [CHAIN] Step 1 resolved: inheritence_complex.AbstractProcessor.processed_count
    [RESOLVE] RESOLVED to: inheritence_complex.AbstractProcessor.processed_count
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AbstractProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.AbstractProcessor
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.error_count
    [RESOLVE] Attempting to resolve: ['self', 'error_count']
    [RESOLVE] Chain resolution needed for: ['self', 'error_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AbstractProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AbstractProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AbstractProcessor.error_count
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AbstractProcessor.error_count
        [ATTRIBUTE] Direct match found: inheritence_complex.AbstractProcessor.error_count
      [CHAIN] Step 1 resolved: inheritence_complex.AbstractProcessor.error_count
    [RESOLVE] RESOLVED to: inheritence_complex.AbstractProcessor.error_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AbstractProcessor (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.processed_count
        [CACHE] self.processed_count -> inheritence_complex.AbstractProcessor.processed_count (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AbstractProcessor (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.error_count
        [CACHE] self.error_count -> inheritence_complex.AbstractProcessor.error_count (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AbstractProcessor (cached)
      -> Not module state
      [CALL] Found call: max
      -> IGNORED (built-in function)
      [NAME] Found name reference: max
    [RESOLVE] Attempting to resolve: ['max']
      [RESOLVE_SIMPLE] Resolving base: max
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable max not found in any scope
      [LOCAL_RESOLVER] can_resolve(max): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(max): False (current_class: inheritence_complex.AbstractProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(max): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(max): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(max): inheritence_complex.max
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: max -> inheritence_complex.max
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.max
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.processed_count
        [CACHE] self.processed_count -> inheritence_complex.AbstractProcessor.processed_count (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AbstractProcessor (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.AbstractProcessor.get_statistics
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.AbstractProcessor.get_statistics
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.AbstractProcessor.log_operation
    [DECORATOR] @trace
    [CONTEXT] Entered function: inheritence_complex.AbstractProcessor.log_operation (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'operation': 'str', 'details': 'Optional[Dict[str, Any]]'}
        [ARG_TYPE] Processing type annotation for operation: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: operation -> inheritence_complex.str
        [ARG_TYPE] RESOLVED operation : inheritence_complex.str
      [CALL] Found call: print
      -> IGNORED (built-in function)
      [NAME] Found name reference: print
    [RESOLVE] Attempting to resolve: ['print']
      [RESOLVE_SIMPLE] Resolving base: print
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable print not found in any scope
      [LOCAL_RESOLVER] can_resolve(print): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(print): False (current_class: inheritence_complex.AbstractProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(print): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(print): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(print): inheritence_complex.print
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: print -> inheritence_complex.print
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.print
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.processor_id
    [RESOLVE] Attempting to resolve: ['self', 'processor_id']
    [RESOLVE] Chain resolution needed for: ['self', 'processor_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AbstractProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AbstractProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AbstractProcessor.processor_id
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AbstractProcessor.processor_id
        [ATTRIBUTE] Direct match found: inheritence_complex.AbstractProcessor.processor_id
      [CHAIN] Step 1 resolved: inheritence_complex.AbstractProcessor.processor_id
    [RESOLVE] RESOLVED to: inheritence_complex.AbstractProcessor.processor_id
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AbstractProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.AbstractProcessor
      -> Not module state
      [NAME] Found name reference: operation
    [RESOLVE] Attempting to resolve: ['operation']
      [RESOLVE_SIMPLE] Resolving base: operation
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found operation in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] can_resolve(operation): True
      [SYMBOL_LOOKUP] Found operation in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] resolve(operation): inheritence_complex.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: operation -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [NAME] Found name reference: details
    [RESOLVE] Attempting to resolve: ['details']
      [RESOLVE_SIMPLE] Resolving base: details
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable details not found in any scope
      [LOCAL_RESOLVER] can_resolve(details): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(details): False (current_class: inheritence_complex.AbstractProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(details): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(details): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(details): inheritence_complex.details
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: details -> inheritence_complex.details
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.details
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.AbstractProcessor.log_operation
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.AbstractProcessor.log_operation
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: inheritence_complex.AbstractProcessor
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: AsyncProcessor
    [CONTEXT] Entered class: inheritence_complex.AsyncProcessor
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.AsyncProcessor.__init__
    [CONTEXT] Entered function: inheritence_complex.AsyncProcessor.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'processor_id': 'str'}
        [ARG_TYPE] Processing type annotation for processor_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: inheritence_complex.AsyncProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(str): inheritence_complex.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: processor_id -> inheritence_complex.str
        [ARG_TYPE] RESOLVED processor_id : inheritence_complex.str
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable super not found in any scope
      [LOCAL_RESOLVER] can_resolve(super): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(super): False (current_class: inheritence_complex.AsyncProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(super): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(super): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(super): inheritence_complex.super
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: super -> inheritence_complex.super
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.super
      -> Resolved to: inheritence_complex.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> inheritence_complex.super (cached)
      -> Not module state
      [NAME] Found name reference: processor_id
    [RESOLVE] Attempting to resolve: ['processor_id']
      [RESOLVE_SIMPLE] Resolving base: processor_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found processor_id in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] can_resolve(processor_id): True
      [SYMBOL_LOOKUP] Found processor_id in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] resolve(processor_id): inheritence_complex.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: processor_id -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.async_queue
    [RESOLVE] Attempting to resolve: ['self', 'async_queue']
    [RESOLVE] Chain resolution needed for: ['self', 'async_queue']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: inheritence_complex.AsyncProcessor)
      [SELF_RESOLVER] resolve(self): inheritence_complex.AsyncProcessor
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> inheritence_complex.AsyncProcessor
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> inheritence_complex.AsyncProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AsyncProcessor.async_queue
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AsyncProcessor.async_queue
        [ATTRIBUTE] Direct match found: inheritence_complex.AsyncProcessor.async_queue
      [CHAIN] Step 1 resolved: inheritence_complex.AsyncProcessor.async_queue
    [RESOLVE] RESOLVED to: inheritence_complex.AsyncProcessor.async_queue
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AsyncProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.AsyncProcessor
      -> Not module state
      [NAME] Found name reference: List
    [RESOLVE] Attempting to resolve: ['List']
      [RESOLVE_SIMPLE] Resolving base: List
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable List not found in any scope
      [LOCAL_RESOLVER] can_resolve(List): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(List): False (current_class: inheritence_complex.AsyncProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(List): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(List): typing.List (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: List -> typing.List
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.List
      -> Not module state
      [NAME] Found name reference: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: inheritence_complex.AsyncProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.batch_size
    [RESOLVE] Attempting to resolve: ['self', 'batch_size']
    [RESOLVE] Chain resolution needed for: ['self', 'batch_size']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AsyncProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AsyncProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AsyncProcessor.batch_size
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AsyncProcessor.batch_size
        [ATTRIBUTE] Direct match found: inheritence_complex.AsyncProcessor.batch_size
      [CHAIN] Step 1 resolved: inheritence_complex.AsyncProcessor.batch_size
    [RESOLVE] RESOLVED to: inheritence_complex.AsyncProcessor.batch_size
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AsyncProcessor (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.AsyncProcessor.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.AsyncProcessor.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
      [ASSIGNMENT] Processing: results = ...
        [ASSIGNMENT] Non-call assignment
      [ASSIGNMENT] Processing: batch = ...
        [ASSIGNMENT] Non-call assignment
      [ASSIGNMENT] Processing: tasks = ...
        [ASSIGNMENT] Non-call assignment
      [ASSIGNMENT] Processing: batch_results = ...
        [ASSIGNMENT] Non-call assignment
      [ASSIGNMENT] Processing: error_result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ProcessingResult
    [RESOLVE] Attempting to resolve: ['ProcessingResult']
      [RESOLVE_SIMPLE] Resolving base: ProcessingResult
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ProcessingResult not found in any scope
      [LOCAL_RESOLVER] can_resolve(ProcessingResult): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ProcessingResult): False (current_class: inheritence_complex.AsyncProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ProcessingResult): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ProcessingResult): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(ProcessingResult): inheritence_complex.ProcessingResult
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ProcessingResult -> inheritence_complex.ProcessingResult
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.ProcessingResult
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.ProcessingResult
      [TYPE_INFERENCE] RESOLVED Inferred type: inheritence_complex.ProcessingResult (class instantiation)
      [SYMBOL_UPDATE] Function: error_result -> inheritence_complex.ProcessingResult
        [ASSIGNMENT] RESOLVED Updated symbol table: error_result = inheritence_complex.ProcessingResult
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.AsyncProcessor.queue_for_async_processing
    [CONTEXT] Entered function: inheritence_complex.AsyncProcessor.queue_for_async_processing (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [CALL] Found call: self.async_queue.append
    [RESOLVE] Attempting to resolve: ['self', 'async_queue', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'async_queue', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AsyncProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AsyncProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AsyncProcessor.async_queue
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AsyncProcessor.async_queue
        [ATTRIBUTE] Direct match found: inheritence_complex.AsyncProcessor.async_queue
      [CHAIN] Step 1 resolved: inheritence_complex.AsyncProcessor.async_queue
      [CHAIN] Step 2: Resolving inheritence_complex.AsyncProcessor.async_queue.append
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AsyncProcessor.async_queue.append
        [ATTRIBUTE] Direct match found: inheritence_complex.AsyncProcessor.async_queue.append
      [CHAIN] Step 2 resolved: inheritence_complex.AsyncProcessor.async_queue.append
    [RESOLVE] RESOLVED to: inheritence_complex.AsyncProcessor.async_queue.append
            [INTERMEDIATE] Tracking chain steps for: self.async_queue.append
            [INTERMEDIATE] Step 1: self.async_queue
    [RESOLVE] Attempting to resolve: ['self', 'async_queue']
    [RESOLVE] Chain resolution needed for: ['self', 'async_queue']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AsyncProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AsyncProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AsyncProcessor.async_queue
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AsyncProcessor.async_queue
        [ATTRIBUTE] Direct match found: inheritence_complex.AsyncProcessor.async_queue
      [CHAIN] Step 1 resolved: inheritence_complex.AsyncProcessor.async_queue
    [RESOLVE] RESOLVED to: inheritence_complex.AsyncProcessor.async_queue
            [INTERMEDIATE] Step 1 resolved to: inheritence_complex.AsyncProcessor.async_queue
            [INTERMEDIATE] Step 2: self.async_queue.append
      -> Resolved to: inheritence_complex.AsyncProcessor.async_queue.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(data): True
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(data): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: data -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [ATTRIBUTE] Found attribute access: self.async_queue.append
        [CACHE] self.async_queue.append -> inheritence_complex.AsyncProcessor.async_queue.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.async_queue
        [CACHE] self.async_queue -> inheritence_complex.AsyncProcessor.async_queue (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AsyncProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.AsyncProcessor
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [CALL] Found call: self.log_operation
    [RESOLVE] Attempting to resolve: ['self', 'log_operation']
    [RESOLVE] Chain resolution needed for: ['self', 'log_operation']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AsyncProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AsyncProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AsyncProcessor.log_operation
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AsyncProcessor.log_operation
        [ATTRIBUTE] Direct match found: inheritence_complex.AsyncProcessor.log_operation
      [CHAIN] Step 1 resolved: inheritence_complex.AsyncProcessor.log_operation
    [RESOLVE] RESOLVED to: inheritence_complex.AsyncProcessor.log_operation
            [INTERMEDIATE] Tracking chain steps for: self.log_operation
            [INTERMEDIATE] Step 1: self.log_operation
      -> Resolved to: inheritence_complex.AsyncProcessor.log_operation
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.log_operation
        [CACHE] self.log_operation -> inheritence_complex.AsyncProcessor.log_operation (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AsyncProcessor (cached)
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: inheritence_complex.AsyncProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(len): inheritence_complex.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> inheritence_complex.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.async_queue
        [CACHE] self.async_queue -> inheritence_complex.AsyncProcessor.async_queue (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AsyncProcessor (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.AsyncProcessor.queue_for_async_processing
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.AsyncProcessor.queue_for_async_processing
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: inheritence_complex.AsyncProcessor
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: CacheableMixin
    [CONTEXT] Entered class: inheritence_complex.CacheableMixin
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.CacheableMixin.__init__
    [CONTEXT] Entered function: inheritence_complex.CacheableMixin.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable super not found in any scope
      [LOCAL_RESOLVER] can_resolve(super): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(super): False (current_class: inheritence_complex.CacheableMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(super): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(super): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(super): inheritence_complex.super
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: super -> inheritence_complex.super
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.super
      -> Resolved to: inheritence_complex.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> inheritence_complex.super (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable args not found in any scope
      [LOCAL_RESOLVER] can_resolve(args): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(args): False (current_class: inheritence_complex.CacheableMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(args): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(args): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(args): inheritence_complex.args
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: args -> inheritence_complex.args
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable kwargs not found in any scope
      [LOCAL_RESOLVER] can_resolve(kwargs): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(kwargs): False (current_class: inheritence_complex.CacheableMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(kwargs): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(kwargs): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(kwargs): inheritence_complex.kwargs
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: kwargs -> inheritence_complex.kwargs
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.kwargs
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache
    [RESOLVE] Attempting to resolve: ['self', '_cache']
    [RESOLVE] Chain resolution needed for: ['self', '_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: inheritence_complex.CacheableMixin)
      [SELF_RESOLVER] resolve(self): inheritence_complex.CacheableMixin
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> inheritence_complex.CacheableMixin
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> inheritence_complex.CacheableMixin
      [CHAIN] Step 1: Resolving inheritence_complex.CacheableMixin._cache
        [ATTRIBUTE] Resolving attribute: inheritence_complex.CacheableMixin._cache
        [ATTRIBUTE] Direct match found: inheritence_complex.CacheableMixin._cache
      [CHAIN] Step 1 resolved: inheritence_complex.CacheableMixin._cache
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin._cache
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: inheritence_complex.CacheableMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: inheritence_complex.CacheableMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(str): inheritence_complex.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [NAME] Found name reference: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: inheritence_complex.CacheableMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_hits
    [RESOLVE] Attempting to resolve: ['self', '_cache_hits']
    [RESOLVE] Chain resolution needed for: ['self', '_cache_hits']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
      [CHAIN] Base resolved: self -> inheritence_complex.CacheableMixin
      [CHAIN] Step 1: Resolving inheritence_complex.CacheableMixin._cache_hits
        [ATTRIBUTE] Resolving attribute: inheritence_complex.CacheableMixin._cache_hits
        [ATTRIBUTE] Direct match found: inheritence_complex.CacheableMixin._cache_hits
      [CHAIN] Step 1 resolved: inheritence_complex.CacheableMixin._cache_hits
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin._cache_hits
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_misses
    [RESOLVE] Attempting to resolve: ['self', '_cache_misses']
    [RESOLVE] Chain resolution needed for: ['self', '_cache_misses']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
      [CHAIN] Base resolved: self -> inheritence_complex.CacheableMixin
      [CHAIN] Step 1: Resolving inheritence_complex.CacheableMixin._cache_misses
        [ATTRIBUTE] Resolving attribute: inheritence_complex.CacheableMixin._cache_misses
        [ATTRIBUTE] Direct match found: inheritence_complex.CacheableMixin._cache_misses
      [CHAIN] Step 1 resolved: inheritence_complex.CacheableMixin._cache_misses
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin._cache_misses
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.CacheableMixin.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.CacheableMixin.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.CacheableMixin.get_cache_key
    [CONTEXT] Entered function: inheritence_complex.CacheableMixin.get_cache_key (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [CALL] Found call: hash
    [RESOLVE] Attempting to resolve: ['hash']
      [RESOLVE_SIMPLE] Resolving base: hash
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable hash not found in any scope
      [LOCAL_RESOLVER] can_resolve(hash): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(hash): False (current_class: inheritence_complex.CacheableMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(hash): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(hash): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(hash): inheritence_complex.hash
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: hash -> inheritence_complex.hash
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.hash
      -> Resolved to: inheritence_complex.hash
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: hash
        [CACHE] hash -> inheritence_complex.hash (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(data): True
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(data): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: data -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.CacheableMixin.get_cache_key
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.CacheableMixin.get_cache_key
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.CacheableMixin.get_from_cache
    [DECORATOR] @trace
    [CONTEXT] Entered function: inheritence_complex.CacheableMixin.get_from_cache (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'cache_key': 'str'}
        [ARG_TYPE] Processing type annotation for cache_key: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: cache_key -> inheritence_complex.str
        [ARG_TYPE] RESOLVED cache_key : inheritence_complex.str
      [NAME] Found name reference: cache_key
    [RESOLVE] Attempting to resolve: ['cache_key']
      [RESOLVE_SIMPLE] Resolving base: cache_key
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found cache_key in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] can_resolve(cache_key): True
      [SYMBOL_LOOKUP] Found cache_key in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] resolve(cache_key): inheritence_complex.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: cache_key -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache
    [RESOLVE] Attempting to resolve: ['self', '_cache']
    [RESOLVE] Chain resolution needed for: ['self', '_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
      [CHAIN] Base resolved: self -> inheritence_complex.CacheableMixin
      [CHAIN] Step 1: Resolving inheritence_complex.CacheableMixin._cache
        [ATTRIBUTE] Resolving attribute: inheritence_complex.CacheableMixin._cache
        [ATTRIBUTE] Direct match found: inheritence_complex.CacheableMixin._cache
      [CHAIN] Step 1 resolved: inheritence_complex.CacheableMixin._cache
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin._cache
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_hits
    [RESOLVE] Attempting to resolve: ['self', '_cache_hits']
    [RESOLVE] Chain resolution needed for: ['self', '_cache_hits']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
      [CHAIN] Base resolved: self -> inheritence_complex.CacheableMixin
      [CHAIN] Step 1: Resolving inheritence_complex.CacheableMixin._cache_hits
        [ATTRIBUTE] Resolving attribute: inheritence_complex.CacheableMixin._cache_hits
        [ATTRIBUTE] Direct match found: inheritence_complex.CacheableMixin._cache_hits
      [CHAIN] Step 1 resolved: inheritence_complex.CacheableMixin._cache_hits
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin._cache_hits
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
      [CALL] Found call: self.log_operation
    [RESOLVE] Attempting to resolve: ['self', 'log_operation']
    [RESOLVE] Chain resolution needed for: ['self', 'log_operation']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
      [CHAIN] Base resolved: self -> inheritence_complex.CacheableMixin
      [CHAIN] Step 1: Resolving inheritence_complex.CacheableMixin.log_operation
        [ATTRIBUTE] Resolving attribute: inheritence_complex.CacheableMixin.log_operation
        [ATTRIBUTE] Direct match found: inheritence_complex.CacheableMixin.log_operation
      [CHAIN] Step 1 resolved: inheritence_complex.CacheableMixin.log_operation
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin.log_operation
            [INTERMEDIATE] Tracking chain steps for: self.log_operation
            [INTERMEDIATE] Step 1: self.log_operation
      -> Resolved to: inheritence_complex.CacheableMixin.log_operation
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.log_operation
        [CACHE] self.log_operation -> inheritence_complex.CacheableMixin.log_operation (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> inheritence_complex.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache
        [CACHE] self._cache -> inheritence_complex.CacheableMixin._cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> inheritence_complex.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_misses
    [RESOLVE] Attempting to resolve: ['self', '_cache_misses']
    [RESOLVE] Chain resolution needed for: ['self', '_cache_misses']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
      [CHAIN] Base resolved: self -> inheritence_complex.CacheableMixin
      [CHAIN] Step 1: Resolving inheritence_complex.CacheableMixin._cache_misses
        [ATTRIBUTE] Resolving attribute: inheritence_complex.CacheableMixin._cache_misses
        [ATTRIBUTE] Direct match found: inheritence_complex.CacheableMixin._cache_misses
      [CHAIN] Step 1 resolved: inheritence_complex.CacheableMixin._cache_misses
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin._cache_misses
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
      [CALL] Found call: self.log_operation
    [CACHE] self.log_operation -> inheritence_complex.CacheableMixin.log_operation (cached)
            [INTERMEDIATE] Tracking chain steps for: self.log_operation
            [INTERMEDIATE] Step 1: self.log_operation
      -> Resolved to: inheritence_complex.CacheableMixin.log_operation
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.log_operation
        [CACHE] self.log_operation -> inheritence_complex.CacheableMixin.log_operation (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> inheritence_complex.str (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.CacheableMixin.get_from_cache
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.CacheableMixin.get_from_cache
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.CacheableMixin.store_in_cache
    [CONTEXT] Entered function: inheritence_complex.CacheableMixin.store_in_cache (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'cache_key': 'str', 'data': 'Any'}
        [ARG_TYPE] Processing type annotation for cache_key: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: cache_key -> inheritence_complex.str
        [ARG_TYPE] RESOLVED cache_key : inheritence_complex.str
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [ATTRIBUTE] Found attribute access: self._cache
    [RESOLVE] Attempting to resolve: ['self', '_cache']
    [RESOLVE] Chain resolution needed for: ['self', '_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
      [CHAIN] Base resolved: self -> inheritence_complex.CacheableMixin
      [CHAIN] Step 1: Resolving inheritence_complex.CacheableMixin._cache
        [ATTRIBUTE] Resolving attribute: inheritence_complex.CacheableMixin._cache
        [ATTRIBUTE] Direct match found: inheritence_complex.CacheableMixin._cache
      [CHAIN] Step 1 resolved: inheritence_complex.CacheableMixin._cache
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin._cache
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin
      -> Not module state
      [NAME] Found name reference: cache_key
    [RESOLVE] Attempting to resolve: ['cache_key']
      [RESOLVE_SIMPLE] Resolving base: cache_key
      [CACHE] Hit for cache_key: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [CALL] Found call: self.log_operation
    [RESOLVE] Attempting to resolve: ['self', 'log_operation']
    [RESOLVE] Chain resolution needed for: ['self', 'log_operation']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
      [CHAIN] Base resolved: self -> inheritence_complex.CacheableMixin
      [CHAIN] Step 1: Resolving inheritence_complex.CacheableMixin.log_operation
        [ATTRIBUTE] Resolving attribute: inheritence_complex.CacheableMixin.log_operation
        [ATTRIBUTE] Direct match found: inheritence_complex.CacheableMixin.log_operation
      [CHAIN] Step 1 resolved: inheritence_complex.CacheableMixin.log_operation
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin.log_operation
            [INTERMEDIATE] Tracking chain steps for: self.log_operation
            [INTERMEDIATE] Step 1: self.log_operation
      -> Resolved to: inheritence_complex.CacheableMixin.log_operation
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.log_operation
        [CACHE] self.log_operation -> inheritence_complex.CacheableMixin.log_operation (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> inheritence_complex.str (cached)
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: inheritence_complex.CacheableMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(len): inheritence_complex.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> inheritence_complex.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache
        [CACHE] self._cache -> inheritence_complex.CacheableMixin._cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.CacheableMixin.store_in_cache
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.CacheableMixin.store_in_cache
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.CacheableMixin.get_cache_statistics
    [CONTEXT] Entered function: inheritence_complex.CacheableMixin.get_cache_statistics (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ASSIGNMENT] Processing: total_requests = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: total_requests
    [RESOLVE] Attempting to resolve: ['total_requests']
      [RESOLVE_SIMPLE] Resolving base: total_requests
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable total_requests not found in any scope
      [LOCAL_RESOLVER] can_resolve(total_requests): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(total_requests): False (current_class: inheritence_complex.CacheableMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(total_requests): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(total_requests): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(total_requests): inheritence_complex.total_requests
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: total_requests -> inheritence_complex.total_requests
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.total_requests
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_hits
    [RESOLVE] Attempting to resolve: ['self', '_cache_hits']
    [RESOLVE] Chain resolution needed for: ['self', '_cache_hits']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
      [CHAIN] Base resolved: self -> inheritence_complex.CacheableMixin
      [CHAIN] Step 1: Resolving inheritence_complex.CacheableMixin._cache_hits
        [ATTRIBUTE] Resolving attribute: inheritence_complex.CacheableMixin._cache_hits
        [ATTRIBUTE] Direct match found: inheritence_complex.CacheableMixin._cache_hits
      [CHAIN] Step 1 resolved: inheritence_complex.CacheableMixin._cache_hits
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin._cache_hits
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_misses
    [RESOLVE] Attempting to resolve: ['self', '_cache_misses']
    [RESOLVE] Chain resolution needed for: ['self', '_cache_misses']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
      [CHAIN] Base resolved: self -> inheritence_complex.CacheableMixin
      [CHAIN] Step 1: Resolving inheritence_complex.CacheableMixin._cache_misses
        [ATTRIBUTE] Resolving attribute: inheritence_complex.CacheableMixin._cache_misses
        [ATTRIBUTE] Direct match found: inheritence_complex.CacheableMixin._cache_misses
      [CHAIN] Step 1 resolved: inheritence_complex.CacheableMixin._cache_misses
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin._cache_misses
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
      [ASSIGNMENT] Processing: hit_rate = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: hit_rate
    [RESOLVE] Attempting to resolve: ['hit_rate']
      [RESOLVE_SIMPLE] Resolving base: hit_rate
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable hit_rate not found in any scope
      [LOCAL_RESOLVER] can_resolve(hit_rate): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(hit_rate): False (current_class: inheritence_complex.CacheableMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(hit_rate): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(hit_rate): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(hit_rate): inheritence_complex.hit_rate
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: hit_rate -> inheritence_complex.hit_rate
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.hit_rate
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_hits
        [CACHE] self._cache_hits -> inheritence_complex.CacheableMixin._cache_hits (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
      [CALL] Found call: max
      -> IGNORED (built-in function)
      [NAME] Found name reference: max
    [RESOLVE] Attempting to resolve: ['max']
      [RESOLVE_SIMPLE] Resolving base: max
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable max not found in any scope
      [LOCAL_RESOLVER] can_resolve(max): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(max): False (current_class: inheritence_complex.CacheableMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(max): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(max): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(max): inheritence_complex.max
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: max -> inheritence_complex.max
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.max
      -> Not module state
      [NAME] Found name reference: total_requests
        [CACHE] total_requests -> inheritence_complex.total_requests (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_hits
        [CACHE] self._cache_hits -> inheritence_complex.CacheableMixin._cache_hits (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache_misses
        [CACHE] self._cache_misses -> inheritence_complex.CacheableMixin._cache_misses (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
      [NAME] Found name reference: hit_rate
        [CACHE] hit_rate -> inheritence_complex.hit_rate (cached)
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [CACHE] Hit for len: inheritence_complex.len
    [RESOLVE] RESOLVED to: inheritence_complex.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._cache
    [RESOLVE] Attempting to resolve: ['self', '_cache']
    [RESOLVE] Chain resolution needed for: ['self', '_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.CacheableMixin
      [CHAIN] Base resolved: self -> inheritence_complex.CacheableMixin
      [CHAIN] Step 1: Resolving inheritence_complex.CacheableMixin._cache
        [ATTRIBUTE] Resolving attribute: inheritence_complex.CacheableMixin._cache
        [ATTRIBUTE] Direct match found: inheritence_complex.CacheableMixin._cache
      [CHAIN] Step 1 resolved: inheritence_complex.CacheableMixin._cache
    [RESOLVE] RESOLVED to: inheritence_complex.CacheableMixin._cache
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.CacheableMixin (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.CacheableMixin.get_cache_statistics
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.CacheableMixin.get_cache_statistics
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: inheritence_complex.CacheableMixin
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: ValidatedMixin
    [CONTEXT] Entered class: inheritence_complex.ValidatedMixin
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.ValidatedMixin.__init__
    [CONTEXT] Entered function: inheritence_complex.ValidatedMixin.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable super not found in any scope
      [LOCAL_RESOLVER] can_resolve(super): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(super): False (current_class: inheritence_complex.ValidatedMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(super): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(super): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(super): inheritence_complex.super
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: super -> inheritence_complex.super
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.super
      -> Resolved to: inheritence_complex.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> inheritence_complex.super (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable args not found in any scope
      [LOCAL_RESOLVER] can_resolve(args): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(args): False (current_class: inheritence_complex.ValidatedMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(args): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(args): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(args): inheritence_complex.args
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: args -> inheritence_complex.args
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable kwargs not found in any scope
      [LOCAL_RESOLVER] can_resolve(kwargs): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(kwargs): False (current_class: inheritence_complex.ValidatedMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(kwargs): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(kwargs): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(kwargs): inheritence_complex.kwargs
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: kwargs -> inheritence_complex.kwargs
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.kwargs
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_rules
    [RESOLVE] Attempting to resolve: ['self', 'validation_rules']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_rules']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: inheritence_complex.ValidatedMixin)
      [SELF_RESOLVER] resolve(self): inheritence_complex.ValidatedMixin
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> inheritence_complex.ValidatedMixin
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> inheritence_complex.ValidatedMixin
      [CHAIN] Step 1: Resolving inheritence_complex.ValidatedMixin.validation_rules
        [ATTRIBUTE] Resolving attribute: inheritence_complex.ValidatedMixin.validation_rules
        [ATTRIBUTE] Direct match found: inheritence_complex.ValidatedMixin.validation_rules
      [CHAIN] Step 1 resolved: inheritence_complex.ValidatedMixin.validation_rules
    [RESOLVE] RESOLVED to: inheritence_complex.ValidatedMixin.validation_rules
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.ValidatedMixin
    [RESOLVE] RESOLVED to: inheritence_complex.ValidatedMixin
      -> Not module state
      [NAME] Found name reference: List
    [RESOLVE] Attempting to resolve: ['List']
      [RESOLVE_SIMPLE] Resolving base: List
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable List not found in any scope
      [LOCAL_RESOLVER] can_resolve(List): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(List): False (current_class: inheritence_complex.ValidatedMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(List): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(List): typing.List (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: List -> typing.List
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.List
      -> Not module state
      [NAME] Found name reference: callable
    [RESOLVE] Attempting to resolve: ['callable']
      [RESOLVE_SIMPLE] Resolving base: callable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable callable not found in any scope
      [LOCAL_RESOLVER] can_resolve(callable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(callable): False (current_class: inheritence_complex.ValidatedMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(callable): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(callable): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(callable): inheritence_complex.callable
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: callable -> inheritence_complex.callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.callable
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_errors
    [RESOLVE] Attempting to resolve: ['self', 'validation_errors']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_errors']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.ValidatedMixin
      [CHAIN] Base resolved: self -> inheritence_complex.ValidatedMixin
      [CHAIN] Step 1: Resolving inheritence_complex.ValidatedMixin.validation_errors
        [ATTRIBUTE] Resolving attribute: inheritence_complex.ValidatedMixin.validation_errors
        [ATTRIBUTE] Direct match found: inheritence_complex.ValidatedMixin.validation_errors
      [CHAIN] Step 1 resolved: inheritence_complex.ValidatedMixin.validation_errors
    [RESOLVE] RESOLVED to: inheritence_complex.ValidatedMixin.validation_errors
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.ValidatedMixin (cached)
      -> Not module state
      [NAME] Found name reference: List
        [CACHE] List -> typing.List (cached)
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: inheritence_complex.ValidatedMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(str): inheritence_complex.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.ValidatedMixin.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.ValidatedMixin.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.ValidatedMixin.add_validation_rule
    [CONTEXT] Entered function: inheritence_complex.ValidatedMixin.add_validation_rule (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'rule': 'callable', 'description': 'str'}
        [ARG_TYPE] Processing type annotation for rule: callable
    [RESOLVE] Attempting to resolve: ['callable']
      [RESOLVE_SIMPLE] Resolving base: callable
      [CACHE] Hit for callable: inheritence_complex.callable
    [RESOLVE] RESOLVED to: inheritence_complex.callable
      [SYMBOL_UPDATE] Function: rule -> inheritence_complex.callable
        [ARG_TYPE] RESOLVED rule : inheritence_complex.callable
        [ARG_TYPE] Processing type annotation for description: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: description -> inheritence_complex.str
        [ARG_TYPE] RESOLVED description : inheritence_complex.str
      [CALL] Found call: self.validation_rules.append
    [RESOLVE] Attempting to resolve: ['self', 'validation_rules', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_rules', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.ValidatedMixin
      [CHAIN] Base resolved: self -> inheritence_complex.ValidatedMixin
      [CHAIN] Step 1: Resolving inheritence_complex.ValidatedMixin.validation_rules
        [ATTRIBUTE] Resolving attribute: inheritence_complex.ValidatedMixin.validation_rules
        [ATTRIBUTE] Direct match found: inheritence_complex.ValidatedMixin.validation_rules
      [CHAIN] Step 1 resolved: inheritence_complex.ValidatedMixin.validation_rules
      [CHAIN] Step 2: Resolving inheritence_complex.ValidatedMixin.validation_rules.append
        [ATTRIBUTE] Resolving attribute: inheritence_complex.ValidatedMixin.validation_rules.append
        [ATTRIBUTE] Direct match found: inheritence_complex.ValidatedMixin.validation_rules.append
      [CHAIN] Step 2 resolved: inheritence_complex.ValidatedMixin.validation_rules.append
    [RESOLVE] RESOLVED to: inheritence_complex.ValidatedMixin.validation_rules.append
            [INTERMEDIATE] Tracking chain steps for: self.validation_rules.append
            [INTERMEDIATE] Step 1: self.validation_rules
    [RESOLVE] Attempting to resolve: ['self', 'validation_rules']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_rules']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.ValidatedMixin
      [CHAIN] Base resolved: self -> inheritence_complex.ValidatedMixin
      [CHAIN] Step 1: Resolving inheritence_complex.ValidatedMixin.validation_rules
        [ATTRIBUTE] Resolving attribute: inheritence_complex.ValidatedMixin.validation_rules
        [ATTRIBUTE] Direct match found: inheritence_complex.ValidatedMixin.validation_rules
      [CHAIN] Step 1 resolved: inheritence_complex.ValidatedMixin.validation_rules
    [RESOLVE] RESOLVED to: inheritence_complex.ValidatedMixin.validation_rules
            [INTERMEDIATE] Step 1 resolved to: inheritence_complex.ValidatedMixin.validation_rules
            [INTERMEDIATE] Step 2: self.validation_rules.append
      -> Resolved to: inheritence_complex.ValidatedMixin.validation_rules.append
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.validation_rules.append
        [CACHE] self.validation_rules.append -> inheritence_complex.ValidatedMixin.validation_rules.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_rules
        [CACHE] self.validation_rules -> inheritence_complex.ValidatedMixin.validation_rules (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.ValidatedMixin
    [RESOLVE] RESOLVED to: inheritence_complex.ValidatedMixin
      -> Not module state
      [NAME] Found name reference: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found rule in function scope: inheritence_complex.callable
      [LOCAL_RESOLVER] can_resolve(rule): True
      [SYMBOL_LOOKUP] Found rule in function scope: inheritence_complex.callable
      [LOCAL_RESOLVER] resolve(rule): inheritence_complex.callable
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: rule -> inheritence_complex.callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.callable
      -> Not module state
      [NAME] Found name reference: description
    [RESOLVE] Attempting to resolve: ['description']
      [RESOLVE_SIMPLE] Resolving base: description
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found description in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] can_resolve(description): True
      [SYMBOL_LOOKUP] Found description in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] resolve(description): inheritence_complex.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: description -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [CALL] Found call: self.log_operation
    [RESOLVE] Attempting to resolve: ['self', 'log_operation']
    [RESOLVE] Chain resolution needed for: ['self', 'log_operation']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.ValidatedMixin
      [CHAIN] Base resolved: self -> inheritence_complex.ValidatedMixin
      [CHAIN] Step 1: Resolving inheritence_complex.ValidatedMixin.log_operation
        [ATTRIBUTE] Resolving attribute: inheritence_complex.ValidatedMixin.log_operation
        [ATTRIBUTE] Direct match found: inheritence_complex.ValidatedMixin.log_operation
      [CHAIN] Step 1 resolved: inheritence_complex.ValidatedMixin.log_operation
    [RESOLVE] RESOLVED to: inheritence_complex.ValidatedMixin.log_operation
            [INTERMEDIATE] Tracking chain steps for: self.log_operation
            [INTERMEDIATE] Step 1: self.log_operation
      -> Resolved to: inheritence_complex.ValidatedMixin.log_operation
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.log_operation
        [CACHE] self.log_operation -> inheritence_complex.ValidatedMixin.log_operation (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.ValidatedMixin (cached)
      -> Not module state
      [NAME] Found name reference: description
        [CACHE] description -> inheritence_complex.str (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.ValidatedMixin.add_validation_rule
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.ValidatedMixin.add_validation_rule
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.ValidatedMixin.comprehensive_validate
    [DECORATOR] @trace
    [CONTEXT] Entered function: inheritence_complex.ValidatedMixin.comprehensive_validate (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: inheritence_complex.ValidatedMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [CALL] Found call: self.validation_errors.clear
    [RESOLVE] Attempting to resolve: ['self', 'validation_errors', 'clear']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_errors', 'clear']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.ValidatedMixin
      [CHAIN] Base resolved: self -> inheritence_complex.ValidatedMixin
      [CHAIN] Step 1: Resolving inheritence_complex.ValidatedMixin.validation_errors
        [ATTRIBUTE] Resolving attribute: inheritence_complex.ValidatedMixin.validation_errors
        [ATTRIBUTE] Direct match found: inheritence_complex.ValidatedMixin.validation_errors
      [CHAIN] Step 1 resolved: inheritence_complex.ValidatedMixin.validation_errors
      [CHAIN] Step 2: Resolving inheritence_complex.ValidatedMixin.validation_errors.clear
        [ATTRIBUTE] Resolving attribute: inheritence_complex.ValidatedMixin.validation_errors.clear
        [ATTRIBUTE] Direct match found: inheritence_complex.ValidatedMixin.validation_errors.clear
      [CHAIN] Step 2 resolved: inheritence_complex.ValidatedMixin.validation_errors.clear
    [RESOLVE] RESOLVED to: inheritence_complex.ValidatedMixin.validation_errors.clear
            [INTERMEDIATE] Tracking chain steps for: self.validation_errors.clear
            [INTERMEDIATE] Step 1: self.validation_errors
    [RESOLVE] Attempting to resolve: ['self', 'validation_errors']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_errors']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.ValidatedMixin
      [CHAIN] Base resolved: self -> inheritence_complex.ValidatedMixin
      [CHAIN] Step 1: Resolving inheritence_complex.ValidatedMixin.validation_errors
        [ATTRIBUTE] Resolving attribute: inheritence_complex.ValidatedMixin.validation_errors
        [ATTRIBUTE] Direct match found: inheritence_complex.ValidatedMixin.validation_errors
      [CHAIN] Step 1 resolved: inheritence_complex.ValidatedMixin.validation_errors
    [RESOLVE] RESOLVED to: inheritence_complex.ValidatedMixin.validation_errors
            [INTERMEDIATE] Step 1 resolved to: inheritence_complex.ValidatedMixin.validation_errors
            [INTERMEDIATE] Step 2: self.validation_errors.clear
      -> Resolved to: inheritence_complex.ValidatedMixin.validation_errors.clear
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.validation_errors.clear
        [CACHE] self.validation_errors.clear -> inheritence_complex.ValidatedMixin.validation_errors.clear (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_errors
        [CACHE] self.validation_errors -> inheritence_complex.ValidatedMixin.validation_errors (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.ValidatedMixin
    [RESOLVE] RESOLVED to: inheritence_complex.ValidatedMixin
      -> Not module state
      [CALL] Found call: hasattr
    [RESOLVE] Attempting to resolve: ['hasattr']
      [RESOLVE_SIMPLE] Resolving base: hasattr
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable hasattr not found in any scope
      [LOCAL_RESOLVER] can_resolve(hasattr): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(hasattr): False (current_class: inheritence_complex.ValidatedMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(hasattr): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(hasattr): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(hasattr): inheritence_complex.hasattr
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: hasattr -> inheritence_complex.hasattr
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.hasattr
      -> Resolved to: inheritence_complex.hasattr
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: hasattr
        [CACHE] hasattr -> inheritence_complex.hasattr (cached)
      -> Not module state
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [CACHE] Hit for super: inheritence_complex.super
    [RESOLVE] RESOLVED to: inheritence_complex.super
      -> Resolved to: inheritence_complex.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> inheritence_complex.super (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [CACHE] super -> inheritence_complex.super (cached)
      -> Resolved to: inheritence_complex.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> inheritence_complex.super (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(data): True
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(data): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: data -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [CALL] Found call: self.validation_errors.append
    [RESOLVE] Attempting to resolve: ['self', 'validation_errors', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_errors', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.ValidatedMixin
      [CHAIN] Base resolved: self -> inheritence_complex.ValidatedMixin
      [CHAIN] Step 1: Resolving inheritence_complex.ValidatedMixin.validation_errors
        [ATTRIBUTE] Resolving attribute: inheritence_complex.ValidatedMixin.validation_errors
        [ATTRIBUTE] Direct match found: inheritence_complex.ValidatedMixin.validation_errors
      [CHAIN] Step 1 resolved: inheritence_complex.ValidatedMixin.validation_errors
      [CHAIN] Step 2: Resolving inheritence_complex.ValidatedMixin.validation_errors.append
        [ATTRIBUTE] Resolving attribute: inheritence_complex.ValidatedMixin.validation_errors.append
        [ATTRIBUTE] Direct match found: inheritence_complex.ValidatedMixin.validation_errors.append
      [CHAIN] Step 2 resolved: inheritence_complex.ValidatedMixin.validation_errors.append
    [RESOLVE] RESOLVED to: inheritence_complex.ValidatedMixin.validation_errors.append
            [INTERMEDIATE] Tracking chain steps for: self.validation_errors.append
            [INTERMEDIATE] Step 1: self.validation_errors
    [CACHE] self.validation_errors -> inheritence_complex.ValidatedMixin.validation_errors (cached)
            [INTERMEDIATE] Step 1 resolved to: inheritence_complex.ValidatedMixin.validation_errors
            [INTERMEDIATE] Step 2: self.validation_errors.append
      -> Resolved to: inheritence_complex.ValidatedMixin.validation_errors.append
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.validation_errors.append
        [CACHE] self.validation_errors.append -> inheritence_complex.ValidatedMixin.validation_errors.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_errors
        [CACHE] self.validation_errors -> inheritence_complex.ValidatedMixin.validation_errors (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.ValidatedMixin (cached)
      -> Not module state
      [NAME] Found name reference: rule
    [RESOLVE] Attempting to resolve: ['rule']
      [RESOLVE_SIMPLE] Resolving base: rule
      [CACHE] Hit for rule: inheritence_complex.callable
    [RESOLVE] RESOLVED to: inheritence_complex.callable
      -> Not module state
      [NAME] Found name reference: description
    [RESOLVE] Attempting to resolve: ['description']
      [RESOLVE_SIMPLE] Resolving base: description
      [CACHE] Hit for description: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_rules
    [RESOLVE] Attempting to resolve: ['self', 'validation_rules']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_rules']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.ValidatedMixin
      [CHAIN] Base resolved: self -> inheritence_complex.ValidatedMixin
      [CHAIN] Step 1: Resolving inheritence_complex.ValidatedMixin.validation_rules
        [ATTRIBUTE] Resolving attribute: inheritence_complex.ValidatedMixin.validation_rules
        [ATTRIBUTE] Direct match found: inheritence_complex.ValidatedMixin.validation_rules
      [CHAIN] Step 1 resolved: inheritence_complex.ValidatedMixin.validation_rules
    [RESOLVE] RESOLVED to: inheritence_complex.ValidatedMixin.validation_rules
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.ValidatedMixin (cached)
      -> Not module state
      [CALL] Found call: rule
    [CACHE] rule -> inheritence_complex.callable (cached)
      -> Resolved to: inheritence_complex.callable
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [NAME] Found name reference: rule
        [CACHE] rule -> inheritence_complex.callable (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [CALL] Found call: self.validation_errors.append
    [CACHE] self.validation_errors.append -> inheritence_complex.ValidatedMixin.validation_errors.append (cached)
            [INTERMEDIATE] Tracking chain steps for: self.validation_errors.append
            [INTERMEDIATE] Step 1: self.validation_errors
    [CACHE] self.validation_errors -> inheritence_complex.ValidatedMixin.validation_errors (cached)
            [INTERMEDIATE] Step 1 resolved to: inheritence_complex.ValidatedMixin.validation_errors
            [INTERMEDIATE] Step 2: self.validation_errors.append
      -> Resolved to: inheritence_complex.ValidatedMixin.validation_errors.append
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.validation_errors.append
        [CACHE] self.validation_errors.append -> inheritence_complex.ValidatedMixin.validation_errors.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_errors
        [CACHE] self.validation_errors -> inheritence_complex.ValidatedMixin.validation_errors (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.ValidatedMixin (cached)
      -> Not module state
      [NAME] Found name reference: description
        [CACHE] description -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Exception not found in any scope
      [LOCAL_RESOLVER] can_resolve(Exception): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Exception): False (current_class: inheritence_complex.ValidatedMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Exception): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(Exception): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(Exception): inheritence_complex.Exception
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: Exception -> inheritence_complex.Exception
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.Exception
      -> Not module state
      [CALL] Found call: self.validation_errors.append
    [CACHE] self.validation_errors.append -> inheritence_complex.ValidatedMixin.validation_errors.append (cached)
            [INTERMEDIATE] Tracking chain steps for: self.validation_errors.append
            [INTERMEDIATE] Step 1: self.validation_errors
    [CACHE] self.validation_errors -> inheritence_complex.ValidatedMixin.validation_errors (cached)
            [INTERMEDIATE] Step 1 resolved to: inheritence_complex.ValidatedMixin.validation_errors
            [INTERMEDIATE] Step 2: self.validation_errors.append
      -> Resolved to: inheritence_complex.ValidatedMixin.validation_errors.append
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.validation_errors.append
        [CACHE] self.validation_errors.append -> inheritence_complex.ValidatedMixin.validation_errors.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_errors
        [CACHE] self.validation_errors -> inheritence_complex.ValidatedMixin.validation_errors (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.ValidatedMixin (cached)
      -> Not module state
      [NAME] Found name reference: description
        [CACHE] description -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable e not found in any scope
      [LOCAL_RESOLVER] can_resolve(e): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(e): False (current_class: inheritence_complex.ValidatedMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(e): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(e): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(e): inheritence_complex.e
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: e -> inheritence_complex.e
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.e
      -> Not module state
      [ASSIGNMENT] Processing: is_valid = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: is_valid
    [RESOLVE] Attempting to resolve: ['is_valid']
      [RESOLVE_SIMPLE] Resolving base: is_valid
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable is_valid not found in any scope
      [LOCAL_RESOLVER] can_resolve(is_valid): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(is_valid): False (current_class: inheritence_complex.ValidatedMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(is_valid): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(is_valid): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(is_valid): inheritence_complex.is_valid
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: is_valid -> inheritence_complex.is_valid
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.is_valid
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: inheritence_complex.ValidatedMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(len): inheritence_complex.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> inheritence_complex.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_errors
        [CACHE] self.validation_errors -> inheritence_complex.ValidatedMixin.validation_errors (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.ValidatedMixin (cached)
      -> Not module state
      [CALL] Found call: self.log_operation
    [RESOLVE] Attempting to resolve: ['self', 'log_operation']
    [RESOLVE] Chain resolution needed for: ['self', 'log_operation']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.ValidatedMixin
      [CHAIN] Base resolved: self -> inheritence_complex.ValidatedMixin
      [CHAIN] Step 1: Resolving inheritence_complex.ValidatedMixin.log_operation
        [ATTRIBUTE] Resolving attribute: inheritence_complex.ValidatedMixin.log_operation
        [ATTRIBUTE] Direct match found: inheritence_complex.ValidatedMixin.log_operation
      [CHAIN] Step 1 resolved: inheritence_complex.ValidatedMixin.log_operation
    [RESOLVE] RESOLVED to: inheritence_complex.ValidatedMixin.log_operation
            [INTERMEDIATE] Tracking chain steps for: self.log_operation
            [INTERMEDIATE] Step 1: self.log_operation
      -> Resolved to: inheritence_complex.ValidatedMixin.log_operation
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.log_operation
        [CACHE] self.log_operation -> inheritence_complex.ValidatedMixin.log_operation (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.ValidatedMixin (cached)
      -> Not module state
      [NAME] Found name reference: is_valid
        [CACHE] is_valid -> inheritence_complex.is_valid (cached)
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
        [CACHE] len -> inheritence_complex.len (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_errors
        [CACHE] self.validation_errors -> inheritence_complex.ValidatedMixin.validation_errors (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.ValidatedMixin (cached)
      -> Not module state
      [NAME] Found name reference: is_valid
        [CACHE] is_valid -> inheritence_complex.is_valid (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.ValidatedMixin.comprehensive_validate
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.ValidatedMixin.comprehensive_validate
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: inheritence_complex.ValidatedMixin
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: MetricsMixin
    [CONTEXT] Entered class: inheritence_complex.MetricsMixin
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.MetricsMixin.__init__
    [CONTEXT] Entered function: inheritence_complex.MetricsMixin.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable super not found in any scope
      [LOCAL_RESOLVER] can_resolve(super): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(super): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(super): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(super): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(super): inheritence_complex.super
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: super -> inheritence_complex.super
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.super
      -> Resolved to: inheritence_complex.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> inheritence_complex.super (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable args not found in any scope
      [LOCAL_RESOLVER] can_resolve(args): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(args): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(args): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(args): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(args): inheritence_complex.args
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: args -> inheritence_complex.args
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable kwargs not found in any scope
      [LOCAL_RESOLVER] can_resolve(kwargs): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(kwargs): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(kwargs): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(kwargs): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(kwargs): inheritence_complex.kwargs
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: kwargs -> inheritence_complex.kwargs
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.kwargs
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.custom_metrics
    [RESOLVE] Attempting to resolve: ['self', 'custom_metrics']
    [RESOLVE] Chain resolution needed for: ['self', 'custom_metrics']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: inheritence_complex.MetricsMixin)
      [SELF_RESOLVER] resolve(self): inheritence_complex.MetricsMixin
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> inheritence_complex.MetricsMixin
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> inheritence_complex.MetricsMixin
      [CHAIN] Step 1: Resolving inheritence_complex.MetricsMixin.custom_metrics
        [ATTRIBUTE] Resolving attribute: inheritence_complex.MetricsMixin.custom_metrics
        [ATTRIBUTE] Direct match found: inheritence_complex.MetricsMixin.custom_metrics
      [CHAIN] Step 1 resolved: inheritence_complex.MetricsMixin.custom_metrics
    [RESOLVE] RESOLVED to: inheritence_complex.MetricsMixin.custom_metrics
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.MetricsMixin
    [RESOLVE] RESOLVED to: inheritence_complex.MetricsMixin
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(str): inheritence_complex.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [NAME] Found name reference: List
    [RESOLVE] Attempting to resolve: ['List']
      [RESOLVE_SIMPLE] Resolving base: List
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable List not found in any scope
      [LOCAL_RESOLVER] can_resolve(List): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(List): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(List): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(List): typing.List (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: List -> typing.List
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.List
      -> Not module state
      [NAME] Found name reference: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable float not found in any scope
      [LOCAL_RESOLVER] can_resolve(float): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(float): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(float): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(float): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(float): inheritence_complex.float
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: float -> inheritence_complex.float
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.float
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.metric_callbacks
    [RESOLVE] Attempting to resolve: ['self', 'metric_callbacks']
    [RESOLVE] Chain resolution needed for: ['self', 'metric_callbacks']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.MetricsMixin
      [CHAIN] Base resolved: self -> inheritence_complex.MetricsMixin
      [CHAIN] Step 1: Resolving inheritence_complex.MetricsMixin.metric_callbacks
        [ATTRIBUTE] Resolving attribute: inheritence_complex.MetricsMixin.metric_callbacks
        [ATTRIBUTE] Direct match found: inheritence_complex.MetricsMixin.metric_callbacks
      [CHAIN] Step 1 resolved: inheritence_complex.MetricsMixin.metric_callbacks
    [RESOLVE] RESOLVED to: inheritence_complex.MetricsMixin.metric_callbacks
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.MetricsMixin (cached)
      -> Not module state
      [NAME] Found name reference: Dict
        [CACHE] Dict -> typing.Dict (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: List
        [CACHE] List -> typing.List (cached)
      -> Not module state
      [NAME] Found name reference: callable
    [RESOLVE] Attempting to resolve: ['callable']
      [RESOLVE_SIMPLE] Resolving base: callable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable callable not found in any scope
      [LOCAL_RESOLVER] can_resolve(callable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(callable): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(callable): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(callable): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(callable): inheritence_complex.callable
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: callable -> inheritence_complex.callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.callable
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.MetricsMixin.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.MetricsMixin.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.MetricsMixin.record_metric
    [CONTEXT] Entered function: inheritence_complex.MetricsMixin.record_metric (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'metric_name': 'str', 'value': 'float'}
        [ARG_TYPE] Processing type annotation for metric_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: metric_name -> inheritence_complex.str
        [ARG_TYPE] RESOLVED metric_name : inheritence_complex.str
        [ARG_TYPE] Processing type annotation for value: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [CACHE] Hit for float: inheritence_complex.float
    [RESOLVE] RESOLVED to: inheritence_complex.float
      [SYMBOL_UPDATE] Function: value -> inheritence_complex.float
        [ARG_TYPE] RESOLVED value : inheritence_complex.float
      [NAME] Found name reference: metric_name
    [RESOLVE] Attempting to resolve: ['metric_name']
      [RESOLVE_SIMPLE] Resolving base: metric_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found metric_name in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] can_resolve(metric_name): True
      [SYMBOL_LOOKUP] Found metric_name in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] resolve(metric_name): inheritence_complex.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: metric_name -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.custom_metrics
    [RESOLVE] Attempting to resolve: ['self', 'custom_metrics']
    [RESOLVE] Chain resolution needed for: ['self', 'custom_metrics']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.MetricsMixin
      [CHAIN] Base resolved: self -> inheritence_complex.MetricsMixin
      [CHAIN] Step 1: Resolving inheritence_complex.MetricsMixin.custom_metrics
        [ATTRIBUTE] Resolving attribute: inheritence_complex.MetricsMixin.custom_metrics
        [ATTRIBUTE] Direct match found: inheritence_complex.MetricsMixin.custom_metrics
      [CHAIN] Step 1 resolved: inheritence_complex.MetricsMixin.custom_metrics
    [RESOLVE] RESOLVED to: inheritence_complex.MetricsMixin.custom_metrics
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.MetricsMixin
    [RESOLVE] RESOLVED to: inheritence_complex.MetricsMixin
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.custom_metrics
        [CACHE] self.custom_metrics -> inheritence_complex.MetricsMixin.custom_metrics (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.MetricsMixin (cached)
      -> Not module state
      [NAME] Found name reference: metric_name
        [CACHE] metric_name -> inheritence_complex.str (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [ATTRIBUTE] Found attribute access: self.custom_metrics
        [CACHE] self.custom_metrics -> inheritence_complex.MetricsMixin.custom_metrics (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.MetricsMixin (cached)
      -> Not module state
      [NAME] Found name reference: metric_name
        [CACHE] metric_name -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found value in function scope: inheritence_complex.float
      [LOCAL_RESOLVER] can_resolve(value): True
      [SYMBOL_LOOKUP] Found value in function scope: inheritence_complex.float
      [LOCAL_RESOLVER] resolve(value): inheritence_complex.float
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: value -> inheritence_complex.float
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.float
      -> Not module state
      [NAME] Found name reference: callback
    [RESOLVE] Attempting to resolve: ['callback']
      [RESOLVE_SIMPLE] Resolving base: callback
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable callback not found in any scope
      [LOCAL_RESOLVER] can_resolve(callback): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(callback): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(callback): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(callback): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(callback): inheritence_complex.callback
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: callback -> inheritence_complex.callback
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.callback
      -> Not module state
      [CALL] Found call: self.metric_callbacks.get
    [RESOLVE] Attempting to resolve: ['self', 'metric_callbacks', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'metric_callbacks', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.MetricsMixin
      [CHAIN] Base resolved: self -> inheritence_complex.MetricsMixin
      [CHAIN] Step 1: Resolving inheritence_complex.MetricsMixin.metric_callbacks
        [ATTRIBUTE] Resolving attribute: inheritence_complex.MetricsMixin.metric_callbacks
        [ATTRIBUTE] Direct match found: inheritence_complex.MetricsMixin.metric_callbacks
      [CHAIN] Step 1 resolved: inheritence_complex.MetricsMixin.metric_callbacks
      [CHAIN] Step 2: Resolving inheritence_complex.MetricsMixin.metric_callbacks.get
        [ATTRIBUTE] Resolving attribute: inheritence_complex.MetricsMixin.metric_callbacks.get
        [ATTRIBUTE] Direct match found: inheritence_complex.MetricsMixin.metric_callbacks.get
      [CHAIN] Step 2 resolved: inheritence_complex.MetricsMixin.metric_callbacks.get
    [RESOLVE] RESOLVED to: inheritence_complex.MetricsMixin.metric_callbacks.get
            [INTERMEDIATE] Tracking chain steps for: self.metric_callbacks.get
            [INTERMEDIATE] Step 1: self.metric_callbacks
    [RESOLVE] Attempting to resolve: ['self', 'metric_callbacks']
    [RESOLVE] Chain resolution needed for: ['self', 'metric_callbacks']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.MetricsMixin
      [CHAIN] Base resolved: self -> inheritence_complex.MetricsMixin
      [CHAIN] Step 1: Resolving inheritence_complex.MetricsMixin.metric_callbacks
        [ATTRIBUTE] Resolving attribute: inheritence_complex.MetricsMixin.metric_callbacks
        [ATTRIBUTE] Direct match found: inheritence_complex.MetricsMixin.metric_callbacks
      [CHAIN] Step 1 resolved: inheritence_complex.MetricsMixin.metric_callbacks
    [RESOLVE] RESOLVED to: inheritence_complex.MetricsMixin.metric_callbacks
            [INTERMEDIATE] Step 1 resolved to: inheritence_complex.MetricsMixin.metric_callbacks
            [INTERMEDIATE] Step 2: self.metric_callbacks.get
      -> Resolved to: inheritence_complex.MetricsMixin.metric_callbacks.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: metric_name
    [RESOLVE] Attempting to resolve: ['metric_name']
      [RESOLVE_SIMPLE] Resolving base: metric_name
      [CACHE] Hit for metric_name: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [ATTRIBUTE] Found attribute access: self.metric_callbacks.get
        [CACHE] self.metric_callbacks.get -> inheritence_complex.MetricsMixin.metric_callbacks.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.metric_callbacks
        [CACHE] self.metric_callbacks -> inheritence_complex.MetricsMixin.metric_callbacks (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.MetricsMixin (cached)
      -> Not module state
      [NAME] Found name reference: metric_name
        [CACHE] metric_name -> inheritence_complex.str (cached)
      -> Not module state
      [CALL] Found call: callback
    [CACHE] callback -> inheritence_complex.callback (cached)
      -> Resolved to: inheritence_complex.callback
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: metric_name
    [RESOLVE] Attempting to resolve: ['metric_name']
      [RESOLVE_SIMPLE] Resolving base: metric_name
      [CACHE] Hit for metric_name: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: inheritence_complex.float
    [RESOLVE] RESOLVED to: inheritence_complex.float
      [NAME] Found name reference: callback
        [CACHE] callback -> inheritence_complex.callback (cached)
      -> Not module state
      [NAME] Found name reference: metric_name
        [CACHE] metric_name -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> inheritence_complex.float (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.custom_metrics
        [CACHE] self.custom_metrics -> inheritence_complex.MetricsMixin.custom_metrics (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.MetricsMixin (cached)
      -> Not module state
      [NAME] Found name reference: metric_name
        [CACHE] metric_name -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Exception not found in any scope
      [LOCAL_RESOLVER] can_resolve(Exception): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Exception): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Exception): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(Exception): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(Exception): inheritence_complex.Exception
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: Exception -> inheritence_complex.Exception
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.Exception
      -> Not module state
      [CALL] Found call: self.log_operation
    [RESOLVE] Attempting to resolve: ['self', 'log_operation']
    [RESOLVE] Chain resolution needed for: ['self', 'log_operation']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.MetricsMixin
      [CHAIN] Base resolved: self -> inheritence_complex.MetricsMixin
      [CHAIN] Step 1: Resolving inheritence_complex.MetricsMixin.log_operation
        [ATTRIBUTE] Resolving attribute: inheritence_complex.MetricsMixin.log_operation
        [ATTRIBUTE] Direct match found: inheritence_complex.MetricsMixin.log_operation
      [CHAIN] Step 1 resolved: inheritence_complex.MetricsMixin.log_operation
    [RESOLVE] RESOLVED to: inheritence_complex.MetricsMixin.log_operation
            [INTERMEDIATE] Tracking chain steps for: self.log_operation
            [INTERMEDIATE] Step 1: self.log_operation
      -> Resolved to: inheritence_complex.MetricsMixin.log_operation
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.log_operation
        [CACHE] self.log_operation -> inheritence_complex.MetricsMixin.log_operation (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.MetricsMixin (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
        [CACHE] str -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable e not found in any scope
      [LOCAL_RESOLVER] can_resolve(e): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(e): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(e): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(e): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(e): inheritence_complex.e
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: e -> inheritence_complex.e
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.e
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.MetricsMixin.record_metric
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.MetricsMixin.record_metric
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.MetricsMixin.add_metric_callback
    [CONTEXT] Entered function: inheritence_complex.MetricsMixin.add_metric_callback (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'metric_name': 'str', 'callback': 'callable'}
        [ARG_TYPE] Processing type annotation for metric_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: metric_name -> inheritence_complex.str
        [ARG_TYPE] RESOLVED metric_name : inheritence_complex.str
        [ARG_TYPE] Processing type annotation for callback: callable
    [RESOLVE] Attempting to resolve: ['callable']
      [RESOLVE_SIMPLE] Resolving base: callable
      [CACHE] Hit for callable: inheritence_complex.callable
    [RESOLVE] RESOLVED to: inheritence_complex.callable
      [SYMBOL_UPDATE] Function: callback -> inheritence_complex.callable
        [ARG_TYPE] RESOLVED callback : inheritence_complex.callable
      [NAME] Found name reference: metric_name
    [RESOLVE] Attempting to resolve: ['metric_name']
      [RESOLVE_SIMPLE] Resolving base: metric_name
      [CACHE] Hit for metric_name: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.metric_callbacks
    [RESOLVE] Attempting to resolve: ['self', 'metric_callbacks']
    [RESOLVE] Chain resolution needed for: ['self', 'metric_callbacks']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.MetricsMixin
      [CHAIN] Base resolved: self -> inheritence_complex.MetricsMixin
      [CHAIN] Step 1: Resolving inheritence_complex.MetricsMixin.metric_callbacks
        [ATTRIBUTE] Resolving attribute: inheritence_complex.MetricsMixin.metric_callbacks
        [ATTRIBUTE] Direct match found: inheritence_complex.MetricsMixin.metric_callbacks
      [CHAIN] Step 1 resolved: inheritence_complex.MetricsMixin.metric_callbacks
    [RESOLVE] RESOLVED to: inheritence_complex.MetricsMixin.metric_callbacks
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.MetricsMixin
    [RESOLVE] RESOLVED to: inheritence_complex.MetricsMixin
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.metric_callbacks
        [CACHE] self.metric_callbacks -> inheritence_complex.MetricsMixin.metric_callbacks (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.MetricsMixin (cached)
      -> Not module state
      [NAME] Found name reference: metric_name
        [CACHE] metric_name -> inheritence_complex.str (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [ATTRIBUTE] Found attribute access: self.metric_callbacks
        [CACHE] self.metric_callbacks -> inheritence_complex.MetricsMixin.metric_callbacks (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.MetricsMixin (cached)
      -> Not module state
      [NAME] Found name reference: metric_name
        [CACHE] metric_name -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: callback
    [RESOLVE] Attempting to resolve: ['callback']
      [RESOLVE_SIMPLE] Resolving base: callback
      [CACHE] Hit for callback: inheritence_complex.callback
    [RESOLVE] RESOLVED to: inheritence_complex.callback
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.MetricsMixin.add_metric_callback
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.MetricsMixin.add_metric_callback
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.MetricsMixin.get_metric_summary
    [CONTEXT] Entered function: inheritence_complex.MetricsMixin.get_metric_summary (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'metric_name': 'str'}
        [ARG_TYPE] Processing type annotation for metric_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: metric_name -> inheritence_complex.str
        [ARG_TYPE] RESOLVED metric_name : inheritence_complex.str
      [NAME] Found name reference: metric_name
    [RESOLVE] Attempting to resolve: ['metric_name']
      [RESOLVE_SIMPLE] Resolving base: metric_name
      [CACHE] Hit for metric_name: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.custom_metrics
    [RESOLVE] Attempting to resolve: ['self', 'custom_metrics']
    [RESOLVE] Chain resolution needed for: ['self', 'custom_metrics']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.MetricsMixin
      [CHAIN] Base resolved: self -> inheritence_complex.MetricsMixin
      [CHAIN] Step 1: Resolving inheritence_complex.MetricsMixin.custom_metrics
        [ATTRIBUTE] Resolving attribute: inheritence_complex.MetricsMixin.custom_metrics
        [ATTRIBUTE] Direct match found: inheritence_complex.MetricsMixin.custom_metrics
      [CHAIN] Step 1 resolved: inheritence_complex.MetricsMixin.custom_metrics
    [RESOLVE] RESOLVED to: inheritence_complex.MetricsMixin.custom_metrics
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.MetricsMixin
    [RESOLVE] RESOLVED to: inheritence_complex.MetricsMixin
      -> Not module state
      [ASSIGNMENT] Processing: values = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: values
    [RESOLVE] Attempting to resolve: ['values']
      [RESOLVE_SIMPLE] Resolving base: values
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable values not found in any scope
      [LOCAL_RESOLVER] can_resolve(values): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(values): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(values): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(values): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(values): inheritence_complex.values
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: values -> inheritence_complex.values
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.values
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.custom_metrics
        [CACHE] self.custom_metrics -> inheritence_complex.MetricsMixin.custom_metrics (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.MetricsMixin (cached)
      -> Not module state
      [NAME] Found name reference: metric_name
        [CACHE] metric_name -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: values
        [CACHE] values -> inheritence_complex.values (cached)
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(len): inheritence_complex.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> inheritence_complex.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.len
      -> Not module state
      [NAME] Found name reference: values
        [CACHE] values -> inheritence_complex.values (cached)
      -> Not module state
      [CALL] Found call: sum
      -> IGNORED (built-in function)
      [NAME] Found name reference: sum
    [RESOLVE] Attempting to resolve: ['sum']
      [RESOLVE_SIMPLE] Resolving base: sum
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable sum not found in any scope
      [LOCAL_RESOLVER] can_resolve(sum): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(sum): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(sum): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(sum): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(sum): inheritence_complex.sum
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: sum -> inheritence_complex.sum
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.sum
      -> Not module state
      [NAME] Found name reference: values
        [CACHE] values -> inheritence_complex.values (cached)
      -> Not module state
      [CALL] Found call: sum
      -> IGNORED (built-in function)
      [NAME] Found name reference: sum
        [CACHE] sum -> inheritence_complex.sum (cached)
      -> Not module state
      [NAME] Found name reference: values
        [CACHE] values -> inheritence_complex.values (cached)
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
        [CACHE] len -> inheritence_complex.len (cached)
      -> Not module state
      [NAME] Found name reference: values
        [CACHE] values -> inheritence_complex.values (cached)
      -> Not module state
      [CALL] Found call: min
      -> IGNORED (built-in function)
      [NAME] Found name reference: min
    [RESOLVE] Attempting to resolve: ['min']
      [RESOLVE_SIMPLE] Resolving base: min
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable min not found in any scope
      [LOCAL_RESOLVER] can_resolve(min): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(min): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(min): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(min): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(min): inheritence_complex.min
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: min -> inheritence_complex.min
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.min
      -> Not module state
      [NAME] Found name reference: values
        [CACHE] values -> inheritence_complex.values (cached)
      -> Not module state
      [CALL] Found call: max
      -> IGNORED (built-in function)
      [NAME] Found name reference: max
    [RESOLVE] Attempting to resolve: ['max']
      [RESOLVE_SIMPLE] Resolving base: max
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable max not found in any scope
      [LOCAL_RESOLVER] can_resolve(max): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(max): False (current_class: inheritence_complex.MetricsMixin)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(max): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(max): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(max): inheritence_complex.max
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: max -> inheritence_complex.max
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.max
      -> Not module state
      [NAME] Found name reference: values
        [CACHE] values -> inheritence_complex.values (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.MetricsMixin.get_metric_summary
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.MetricsMixin.get_metric_summary
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: inheritence_complex.MetricsMixin
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: BasicDataProcessor
    [CONTEXT] Entered class: inheritence_complex.BasicDataProcessor
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.BasicDataProcessor.__init__
    [CONTEXT] Entered function: inheritence_complex.BasicDataProcessor.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'processor_id': 'str', 'enable_cache': 'bool'}
        [ARG_TYPE] Processing type annotation for processor_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(str): inheritence_complex.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: processor_id -> inheritence_complex.str
        [ARG_TYPE] RESOLVED processor_id : inheritence_complex.str
        [ARG_TYPE] Processing type annotation for enable_cache: bool
    [RESOLVE] Attempting to resolve: ['bool']
      [RESOLVE_SIMPLE] Resolving base: bool
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable bool not found in any scope
      [LOCAL_RESOLVER] can_resolve(bool): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(bool): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(bool): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(bool): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(bool): inheritence_complex.bool
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: bool -> inheritence_complex.bool
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.bool
      [SYMBOL_UPDATE] Function: enable_cache -> inheritence_complex.bool
        [ARG_TYPE] RESOLVED enable_cache : inheritence_complex.bool
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable super not found in any scope
      [LOCAL_RESOLVER] can_resolve(super): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(super): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(super): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(super): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(super): inheritence_complex.super
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: super -> inheritence_complex.super
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.super
      -> Resolved to: inheritence_complex.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> inheritence_complex.super (cached)
      -> Not module state
      [NAME] Found name reference: processor_id
    [RESOLVE] Attempting to resolve: ['processor_id']
      [RESOLVE_SIMPLE] Resolving base: processor_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found processor_id in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] can_resolve(processor_id): True
      [SYMBOL_LOOKUP] Found processor_id in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] resolve(processor_id): inheritence_complex.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: processor_id -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.enable_cache
    [RESOLVE] Attempting to resolve: ['self', 'enable_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'enable_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: inheritence_complex.BasicDataProcessor)
      [SELF_RESOLVER] resolve(self): inheritence_complex.BasicDataProcessor
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> inheritence_complex.BasicDataProcessor
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.enable_cache
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.enable_cache
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.enable_cache
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.enable_cache
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.enable_cache
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor
      -> Not module state
      [NAME] Found name reference: enable_cache
    [RESOLVE] Attempting to resolve: ['enable_cache']
      [RESOLVE_SIMPLE] Resolving base: enable_cache
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found enable_cache in function scope: inheritence_complex.bool
      [LOCAL_RESOLVER] can_resolve(enable_cache): True
      [SYMBOL_LOOKUP] Found enable_cache in function scope: inheritence_complex.bool
      [LOCAL_RESOLVER] resolve(enable_cache): inheritence_complex.bool
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: enable_cache -> inheritence_complex.bool
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.bool
      -> Not module state
      [CALL] Found call: self.add_validation_rule
    [RESOLVE] Attempting to resolve: ['self', 'add_validation_rule']
    [RESOLVE] Chain resolution needed for: ['self', 'add_validation_rule']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.add_validation_rule
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.add_validation_rule
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.add_validation_rule
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.add_validation_rule
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.add_validation_rule
            [INTERMEDIATE] Tracking chain steps for: self.add_validation_rule
            [INTERMEDIATE] Step 1: self.add_validation_rule
      -> Resolved to: inheritence_complex.BasicDataProcessor.add_validation_rule
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.add_validation_rule
        [CACHE] self.add_validation_rule -> inheritence_complex.BasicDataProcessor.add_validation_rule (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable data not found in any scope
      [LOCAL_RESOLVER] can_resolve(data): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(data): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(data): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(data): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(data): inheritence_complex.data
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: data -> inheritence_complex.data
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.data
      -> Not module state
      [CALL] Found call: self.add_validation_rule
    [CACHE] self.add_validation_rule -> inheritence_complex.BasicDataProcessor.add_validation_rule (cached)
            [INTERMEDIATE] Tracking chain steps for: self.add_validation_rule
            [INTERMEDIATE] Step 1: self.add_validation_rule
      -> Resolved to: inheritence_complex.BasicDataProcessor.add_validation_rule
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.add_validation_rule
        [CACHE] self.add_validation_rule -> inheritence_complex.BasicDataProcessor.add_validation_rule (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [RESOLVE] Attempting to resolve: ['isinstance']
      [RESOLVE_SIMPLE] Resolving base: isinstance
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable isinstance not found in any scope
      [LOCAL_RESOLVER] can_resolve(isinstance): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(isinstance): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(isinstance): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(isinstance): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(isinstance): inheritence_complex.isinstance
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: isinstance -> inheritence_complex.isinstance
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.isinstance
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.data (cached)
      -> Not module state
      [NAME] Found name reference: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(dict): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(dict): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(dict): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(dict): inheritence_complex.dict
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: dict -> inheritence_complex.dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      -> Not module state
      [NAME] Found name reference: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable list not found in any scope
      [LOCAL_RESOLVER] can_resolve(list): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(list): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(list): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(list): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(list): inheritence_complex.list
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: list -> inheritence_complex.list
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.list
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: int
    [RESOLVE] Attempting to resolve: ['int']
      [RESOLVE_SIMPLE] Resolving base: int
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable int not found in any scope
      [LOCAL_RESOLVER] can_resolve(int): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(int): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(int): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(int): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(int): inheritence_complex.int
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: int -> inheritence_complex.int
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.int
      -> Not module state
      [NAME] Found name reference: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable float not found in any scope
      [LOCAL_RESOLVER] can_resolve(float): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(float): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(float): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(float): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(float): inheritence_complex.float
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: float -> inheritence_complex.float
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.float
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.BasicDataProcessor.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.BasicDataProcessor.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.BasicDataProcessor.validate_input
    [CONTEXT] Entered function: inheritence_complex.BasicDataProcessor.validate_input (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [CALL] Found call: self.comprehensive_validate
    [RESOLVE] Attempting to resolve: ['self', 'comprehensive_validate']
    [RESOLVE] Chain resolution needed for: ['self', 'comprehensive_validate']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.comprehensive_validate
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.comprehensive_validate
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.comprehensive_validate
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.comprehensive_validate
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.comprehensive_validate
            [INTERMEDIATE] Tracking chain steps for: self.comprehensive_validate
            [INTERMEDIATE] Step 1: self.comprehensive_validate
      -> Resolved to: inheritence_complex.BasicDataProcessor.comprehensive_validate
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
      [ATTRIBUTE] Found attribute access: self.comprehensive_validate
        [CACHE] self.comprehensive_validate -> inheritence_complex.BasicDataProcessor.comprehensive_validate (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.BasicDataProcessor.validate_input
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.BasicDataProcessor.validate_input
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.BasicDataProcessor.process_data
    [DECORATOR] @trace
    [DECORATOR] @monitor_performance
    [CONTEXT] Entered function: inheritence_complex.BasicDataProcessor.process_data (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [CALL] Found call: self.validate_input
    [RESOLVE] Attempting to resolve: ['self', 'validate_input']
    [RESOLVE] Chain resolution needed for: ['self', 'validate_input']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.validate_input
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.validate_input
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.validate_input
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.validate_input
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.validate_input
            [INTERMEDIATE] Tracking chain steps for: self.validate_input
            [INTERMEDIATE] Step 1: self.validate_input
      -> Resolved to: inheritence_complex.BasicDataProcessor.validate_input
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
      [ATTRIBUTE] Found attribute access: self.validate_input
        [CACHE] self.validate_input -> inheritence_complex.BasicDataProcessor.validate_input (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.error_count
    [RESOLVE] Attempting to resolve: ['self', 'error_count']
    [RESOLVE] Chain resolution needed for: ['self', 'error_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.error_count
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.error_count
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.error_count
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.error_count
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.error_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [CALL] Found call: ProcessingResult
    [RESOLVE] Attempting to resolve: ['ProcessingResult']
      [RESOLVE_SIMPLE] Resolving base: ProcessingResult
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ProcessingResult not found in any scope
      [LOCAL_RESOLVER] can_resolve(ProcessingResult): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ProcessingResult): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ProcessingResult): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ProcessingResult): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(ProcessingResult): inheritence_complex.ProcessingResult
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ProcessingResult -> inheritence_complex.ProcessingResult
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.ProcessingResult
      -> Resolved to: inheritence_complex.ProcessingResult
      -> ADDED to instantiations
      [NAME] Found name reference: ProcessingResult
        [CACHE] ProcessingResult -> inheritence_complex.ProcessingResult (cached)
      -> Not module state
      [CALL] Found call: self.validation_errors.copy
    [RESOLVE] Attempting to resolve: ['self', 'validation_errors', 'copy']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_errors', 'copy']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.validation_errors
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.validation_errors
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.validation_errors
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.validation_errors
      [CHAIN] Step 2: Resolving inheritence_complex.BasicDataProcessor.validation_errors.copy
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.validation_errors.copy
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.validation_errors.copy
      [CHAIN] Step 2 resolved: inheritence_complex.BasicDataProcessor.validation_errors.copy
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.validation_errors.copy
            [INTERMEDIATE] Tracking chain steps for: self.validation_errors.copy
            [INTERMEDIATE] Step 1: self.validation_errors
    [RESOLVE] Attempting to resolve: ['self', 'validation_errors']
    [RESOLVE] Chain resolution needed for: ['self', 'validation_errors']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.validation_errors
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.validation_errors
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.validation_errors
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.validation_errors
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.validation_errors
            [INTERMEDIATE] Step 1 resolved to: inheritence_complex.BasicDataProcessor.validation_errors
            [INTERMEDIATE] Step 2: self.validation_errors.copy
      -> Resolved to: inheritence_complex.BasicDataProcessor.validation_errors.copy
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.validation_errors.copy
        [CACHE] self.validation_errors.copy -> inheritence_complex.BasicDataProcessor.validation_errors.copy (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.validation_errors
        [CACHE] self.validation_errors -> inheritence_complex.BasicDataProcessor.validation_errors (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.enable_cache
    [RESOLVE] Attempting to resolve: ['self', 'enable_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'enable_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.enable_cache
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.enable_cache
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.enable_cache
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.enable_cache
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.enable_cache
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [ASSIGNMENT] Processing: cache_key = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.get_cache_key
    [RESOLVE] Attempting to resolve: ['self', 'get_cache_key']
    [RESOLVE] Chain resolution needed for: ['self', 'get_cache_key']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.get_cache_key
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.get_cache_key
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.get_cache_key
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.get_cache_key
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.get_cache_key
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.BasicDataProcessor.get_cache_key
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for cache_key
      [NAME] Found name reference: cache_key
    [RESOLVE] Attempting to resolve: ['cache_key']
      [RESOLVE_SIMPLE] Resolving base: cache_key
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable cache_key not found in any scope
      [LOCAL_RESOLVER] can_resolve(cache_key): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(cache_key): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(cache_key): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(cache_key): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(cache_key): inheritence_complex.cache_key
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: cache_key -> inheritence_complex.cache_key
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.cache_key
      -> Not module state
      [CALL] Found call: self.get_cache_key
    [RESOLVE] Attempting to resolve: ['self', 'get_cache_key']
    [RESOLVE] Chain resolution needed for: ['self', 'get_cache_key']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.get_cache_key
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.get_cache_key
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.get_cache_key
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.get_cache_key
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.get_cache_key
            [INTERMEDIATE] Tracking chain steps for: self.get_cache_key
            [INTERMEDIATE] Step 1: self.get_cache_key
      -> Resolved to: inheritence_complex.BasicDataProcessor.get_cache_key
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
      [ATTRIBUTE] Found attribute access: self.get_cache_key
        [CACHE] self.get_cache_key -> inheritence_complex.BasicDataProcessor.get_cache_key (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.data (cached)
      -> Not module state
      [ASSIGNMENT] Processing: cached_result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.get_from_cache
    [RESOLVE] Attempting to resolve: ['self', 'get_from_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'get_from_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.get_from_cache
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.get_from_cache
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.get_from_cache
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.get_from_cache
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.get_from_cache
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.BasicDataProcessor.get_from_cache
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for cached_result
      [NAME] Found name reference: cached_result
    [RESOLVE] Attempting to resolve: ['cached_result']
      [RESOLVE_SIMPLE] Resolving base: cached_result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable cached_result not found in any scope
      [LOCAL_RESOLVER] can_resolve(cached_result): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(cached_result): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(cached_result): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(cached_result): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(cached_result): inheritence_complex.cached_result
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: cached_result -> inheritence_complex.cached_result
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.cached_result
      -> Not module state
      [CALL] Found call: self.get_from_cache
    [RESOLVE] Attempting to resolve: ['self', 'get_from_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'get_from_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.get_from_cache
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.get_from_cache
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.get_from_cache
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.get_from_cache
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.get_from_cache
            [INTERMEDIATE] Tracking chain steps for: self.get_from_cache
            [INTERMEDIATE] Step 1: self.get_from_cache
      -> Resolved to: inheritence_complex.BasicDataProcessor.get_from_cache
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: cache_key
    [RESOLVE] Attempting to resolve: ['cache_key']
      [RESOLVE_SIMPLE] Resolving base: cache_key
      [CACHE] Hit for cache_key: inheritence_complex.cache_key
    [RESOLVE] RESOLVED to: inheritence_complex.cache_key
      [ATTRIBUTE] Found attribute access: self.get_from_cache
        [CACHE] self.get_from_cache -> inheritence_complex.BasicDataProcessor.get_from_cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> inheritence_complex.cache_key (cached)
      -> Not module state
      [NAME] Found name reference: cached_result
        [CACHE] cached_result -> inheritence_complex.cached_result (cached)
      -> Not module state
      [NAME] Found name reference: cached_result
        [CACHE] cached_result -> inheritence_complex.cached_result (cached)
      -> Not module state
      [ASSIGNMENT] Processing: processed_data = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self._internal_process
    [RESOLVE] Attempting to resolve: ['self', '_internal_process']
    [RESOLVE] Chain resolution needed for: ['self', '_internal_process']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor._internal_process
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor._internal_process
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor._internal_process
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor._internal_process
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor._internal_process
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.BasicDataProcessor._internal_process
        [RETURN_TYPE_RESOLUTION] Resolving return type: Any
        [RETURN_TYPE_RESOLUTION] Class 'Any' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: Any
      [TYPE_INFERENCE] Could not resolve return type 'Any' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: Any (from return type - unresolved)
      [SYMBOL_UPDATE] Function: processed_data -> Any
        [ASSIGNMENT] RESOLVED Updated symbol table: processed_data = Any
      [NAME] Found name reference: processed_data
    [RESOLVE] Attempting to resolve: ['processed_data']
      [RESOLVE_SIMPLE] Resolving base: processed_data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found processed_data in function scope: Any
      [LOCAL_RESOLVER] can_resolve(processed_data): True
      [SYMBOL_LOOKUP] Found processed_data in function scope: Any
      [LOCAL_RESOLVER] resolve(processed_data): Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: processed_data -> Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: Any
      -> Not module state
      [CALL] Found call: self._internal_process
    [RESOLVE] Attempting to resolve: ['self', '_internal_process']
    [RESOLVE] Chain resolution needed for: ['self', '_internal_process']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor._internal_process
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor._internal_process
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor._internal_process
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor._internal_process
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor._internal_process
            [INTERMEDIATE] Tracking chain steps for: self._internal_process
            [INTERMEDIATE] Step 1: self._internal_process
      -> Resolved to: inheritence_complex.BasicDataProcessor._internal_process
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
      [ATTRIBUTE] Found attribute access: self._internal_process
        [CACHE] self._internal_process -> inheritence_complex.BasicDataProcessor._internal_process (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.data (cached)
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ProcessingResult
    [RESOLVE] Attempting to resolve: ['ProcessingResult']
      [RESOLVE_SIMPLE] Resolving base: ProcessingResult
      [CACHE] Hit for ProcessingResult: inheritence_complex.ProcessingResult
    [RESOLVE] RESOLVED to: inheritence_complex.ProcessingResult
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.ProcessingResult
      [TYPE_INFERENCE] RESOLVED Inferred type: inheritence_complex.ProcessingResult (class instantiation)
      [SYMBOL_UPDATE] Function: result -> inheritence_complex.ProcessingResult
        [ASSIGNMENT] RESOLVED Updated symbol table: result = inheritence_complex.ProcessingResult
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found result in function scope: inheritence_complex.ProcessingResult
      [LOCAL_RESOLVER] can_resolve(result): True
      [SYMBOL_LOOKUP] Found result in function scope: inheritence_complex.ProcessingResult
      [LOCAL_RESOLVER] resolve(result): inheritence_complex.ProcessingResult
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: result -> inheritence_complex.ProcessingResult
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.ProcessingResult
      -> Not module state
      [CALL] Found call: ProcessingResult
    [CACHE] ProcessingResult -> inheritence_complex.ProcessingResult (cached)
      -> Resolved to: inheritence_complex.ProcessingResult
      -> ADDED to instantiations
      [NAME] Found name reference: ProcessingResult
        [CACHE] ProcessingResult -> inheritence_complex.ProcessingResult (cached)
      -> Not module state
      [NAME] Found name reference: processed_data
        [CACHE] processed_data -> Any (cached)
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable time not found in any scope
      [LOCAL_RESOLVER] can_resolve(time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(time): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(time): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(time): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(time): inheritence_complex.time
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: time -> inheritence_complex.time
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: time -> inheritence_complex.time
      [CHAIN] Step 1: Resolving inheritence_complex.time.time
        [ATTRIBUTE] Resolving attribute: inheritence_complex.time.time
        [ATTRIBUTE] Direct match found: inheritence_complex.time.time
      [CHAIN] Step 1 resolved: inheritence_complex.time.time
    [RESOLVE] RESOLVED to: inheritence_complex.time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: inheritence_complex.time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> inheritence_complex.time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: inheritence_complex.time
    [RESOLVE] RESOLVED to: inheritence_complex.time
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.enable_cache
        [CACHE] self.enable_cache -> inheritence_complex.BasicDataProcessor.enable_cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [CALL] Found call: self.store_in_cache
    [RESOLVE] Attempting to resolve: ['self', 'store_in_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'store_in_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.store_in_cache
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.store_in_cache
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.store_in_cache
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.store_in_cache
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.store_in_cache
            [INTERMEDIATE] Tracking chain steps for: self.store_in_cache
            [INTERMEDIATE] Step 1: self.store_in_cache
      -> Resolved to: inheritence_complex.BasicDataProcessor.store_in_cache
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: cache_key
    [RESOLVE] Attempting to resolve: ['cache_key']
      [RESOLVE_SIMPLE] Resolving base: cache_key
      [CACHE] Hit for cache_key: inheritence_complex.cache_key
    [RESOLVE] RESOLVED to: inheritence_complex.cache_key
        [FUNCTION_ARG] Checking argument: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: inheritence_complex.ProcessingResult
    [RESOLVE] RESOLVED to: inheritence_complex.ProcessingResult
      [ATTRIBUTE] Found attribute access: self.store_in_cache
        [CACHE] self.store_in_cache -> inheritence_complex.BasicDataProcessor.store_in_cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> inheritence_complex.cache_key (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> inheritence_complex.ProcessingResult (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.processed_count
    [RESOLVE] Attempting to resolve: ['self', 'processed_count']
    [RESOLVE] Chain resolution needed for: ['self', 'processed_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.processed_count
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.processed_count
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.processed_count
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.processed_count
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.processed_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> inheritence_complex.ProcessingResult (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Exception not found in any scope
      [LOCAL_RESOLVER] can_resolve(Exception): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Exception): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Exception): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(Exception): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(Exception): inheritence_complex.Exception
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: Exception -> inheritence_complex.Exception
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.Exception
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.error_count
        [CACHE] self.error_count -> inheritence_complex.BasicDataProcessor.error_count (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [CALL] Found call: ProcessingResult
    [CACHE] ProcessingResult -> inheritence_complex.ProcessingResult (cached)
      -> Resolved to: inheritence_complex.ProcessingResult
      -> ADDED to instantiations
      [NAME] Found name reference: ProcessingResult
        [CACHE] ProcessingResult -> inheritence_complex.ProcessingResult (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable e not found in any scope
      [LOCAL_RESOLVER] can_resolve(e): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(e): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(e): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(e): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(e): inheritence_complex.e
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: e -> inheritence_complex.e
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.e
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.BasicDataProcessor.process_data
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.BasicDataProcessor.process_data
        Calls: 2
        Instantiations: 1
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.BasicDataProcessor._internal_process
    [CONTEXT] Entered function: inheritence_complex.BasicDataProcessor._internal_process (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [CALL] Found call: isinstance
    [RESOLVE] Attempting to resolve: ['isinstance']
      [RESOLVE_SIMPLE] Resolving base: isinstance
      [CACHE] Hit for isinstance: inheritence_complex.isinstance
    [RESOLVE] RESOLVED to: inheritence_complex.isinstance
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
        [FUNCTION_ARG] Checking argument: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
      -> Not module state
      [NAME] Found name reference: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      -> Not module state
      [NAME] Found name reference: k
    [RESOLVE] Attempting to resolve: ['k']
      [RESOLVE_SIMPLE] Resolving base: k
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable k not found in any scope
      [LOCAL_RESOLVER] can_resolve(k): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(k): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(k): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(k): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(k): inheritence_complex.k
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: k -> inheritence_complex.k
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.k
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: v
    [RESOLVE] Attempting to resolve: ['v']
      [RESOLVE_SIMPLE] Resolving base: v
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable v not found in any scope
      [LOCAL_RESOLVER] can_resolve(v): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(v): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(v): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(v): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(v): inheritence_complex.v
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: v -> inheritence_complex.v
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.v
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: v
    [RESOLVE] Attempting to resolve: ['v']
      [RESOLVE_SIMPLE] Resolving base: v
      [CACHE] Hit for v: inheritence_complex.v
    [RESOLVE] RESOLVED to: inheritence_complex.v
      -> Not module state
      [NAME] Found name reference: int
    [RESOLVE] Attempting to resolve: ['int']
      [RESOLVE_SIMPLE] Resolving base: int
      [CACHE] Hit for int: inheritence_complex.int
    [RESOLVE] RESOLVED to: inheritence_complex.int
      -> Not module state
      [NAME] Found name reference: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [CACHE] Hit for float: inheritence_complex.float
    [RESOLVE] RESOLVED to: inheritence_complex.float
      -> Not module state
      [NAME] Found name reference: v
        [CACHE] v -> inheritence_complex.v (cached)
      -> Not module state
      [NAME] Found name reference: v
        [CACHE] v -> inheritence_complex.v (cached)
      -> Not module state
      [NAME] Found name reference: k
        [CACHE] k -> inheritence_complex.k (cached)
      -> Not module state
      [NAME] Found name reference: v
        [CACHE] v -> inheritence_complex.v (cached)
      -> Not module state
      [CALL] Found call: data.items
    [RESOLVE] Attempting to resolve: ['data', 'items']
    [RESOLVE] Chain resolution needed for: ['data', 'items']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
      [CHAIN] Base resolved: data -> inheritence_complex.data
      [CHAIN] Step 1: Resolving inheritence_complex.data.items
        [ATTRIBUTE] Resolving attribute: inheritence_complex.data.items
        [ATTRIBUTE] Direct match found: inheritence_complex.data.items
      [CHAIN] Step 1 resolved: inheritence_complex.data.items
    [RESOLVE] RESOLVED to: inheritence_complex.data.items
            [INTERMEDIATE] Tracking chain steps for: data.items
            [INTERMEDIATE] Step 1: data.items
      -> Resolved to: inheritence_complex.data.items
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: data.items
        [CACHE] data.items -> inheritence_complex.data.items (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.data (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
        [FUNCTION_ARG] Checking argument: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [CACHE] Hit for list: inheritence_complex.list
    [RESOLVE] RESOLVED to: inheritence_complex.list
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.data (cached)
      -> Not module state
      [NAME] Found name reference: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [CACHE] Hit for list: inheritence_complex.list
    [RESOLVE] RESOLVED to: inheritence_complex.list
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: item
    [RESOLVE] Attempting to resolve: ['item']
      [RESOLVE_SIMPLE] Resolving base: item
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable item not found in any scope
      [LOCAL_RESOLVER] can_resolve(item): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(item): False (current_class: inheritence_complex.BasicDataProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(item): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(item): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(item): inheritence_complex.item
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: item -> inheritence_complex.item
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.item
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: item
    [RESOLVE] Attempting to resolve: ['item']
      [RESOLVE_SIMPLE] Resolving base: item
      [CACHE] Hit for item: inheritence_complex.item
    [RESOLVE] RESOLVED to: inheritence_complex.item
      -> Not module state
      [NAME] Found name reference: int
        [CACHE] int -> inheritence_complex.int (cached)
      -> Not module state
      [NAME] Found name reference: float
        [CACHE] float -> inheritence_complex.float (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> inheritence_complex.item (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> inheritence_complex.item (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> inheritence_complex.item (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.data (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.data (cached)
      -> Not module state
      [NAME] Found name reference: int
        [CACHE] int -> inheritence_complex.int (cached)
      -> Not module state
      [NAME] Found name reference: float
        [CACHE] float -> inheritence_complex.float (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.data (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.data (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.BasicDataProcessor._internal_process
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.BasicDataProcessor._internal_process
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: inheritence_complex.BasicDataProcessor
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: AdvancedProcessor
    [CONTEXT] Entered class: inheritence_complex.AdvancedProcessor
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.AdvancedProcessor.__init__
    [CONTEXT] Entered function: inheritence_complex.AdvancedProcessor.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'processor_id': 'str', 'priority': 'Priority'}
        [ARG_TYPE] Processing type annotation for processor_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(str): inheritence_complex.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: processor_id -> inheritence_complex.str
        [ARG_TYPE] RESOLVED processor_id : inheritence_complex.str
        [ARG_TYPE] Processing type annotation for priority: Priority
    [RESOLVE] Attempting to resolve: ['Priority']
      [RESOLVE_SIMPLE] Resolving base: Priority
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Priority not found in any scope
      [LOCAL_RESOLVER] can_resolve(Priority): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Priority): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Priority): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(Priority): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(Priority): inheritence_complex.Priority
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: Priority -> inheritence_complex.Priority
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.Priority
      [SYMBOL_UPDATE] Function: priority -> inheritence_complex.Priority
        [ARG_TYPE] RESOLVED priority : inheritence_complex.Priority
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable super not found in any scope
      [LOCAL_RESOLVER] can_resolve(super): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(super): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(super): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(super): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(super): inheritence_complex.super
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: super -> inheritence_complex.super
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.super
      -> Resolved to: inheritence_complex.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> inheritence_complex.super (cached)
      -> Not module state
      [NAME] Found name reference: processor_id
    [RESOLVE] Attempting to resolve: ['processor_id']
      [RESOLVE_SIMPLE] Resolving base: processor_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found processor_id in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] can_resolve(processor_id): True
      [SYMBOL_LOOKUP] Found processor_id in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] resolve(processor_id): inheritence_complex.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: processor_id -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.priority
    [RESOLVE] Attempting to resolve: ['self', 'priority']
    [RESOLVE] Chain resolution needed for: ['self', 'priority']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: inheritence_complex.AdvancedProcessor)
      [SELF_RESOLVER] resolve(self): inheritence_complex.AdvancedProcessor
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> inheritence_complex.AdvancedProcessor
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> inheritence_complex.AdvancedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AdvancedProcessor.priority
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AdvancedProcessor.priority
        [ATTRIBUTE] Direct match found: inheritence_complex.AdvancedProcessor.priority
      [CHAIN] Step 1 resolved: inheritence_complex.AdvancedProcessor.priority
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor.priority
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor
      -> Not module state
      [NAME] Found name reference: priority
    [RESOLVE] Attempting to resolve: ['priority']
      [RESOLVE_SIMPLE] Resolving base: priority
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found priority in function scope: inheritence_complex.Priority
      [LOCAL_RESOLVER] can_resolve(priority): True
      [SYMBOL_LOOKUP] Found priority in function scope: inheritence_complex.Priority
      [LOCAL_RESOLVER] resolve(priority): inheritence_complex.Priority
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: priority -> inheritence_complex.Priority
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.Priority
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.processing_strategy
    [RESOLVE] Attempting to resolve: ['self', 'processing_strategy']
    [RESOLVE] Chain resolution needed for: ['self', 'processing_strategy']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AdvancedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AdvancedProcessor.processing_strategy
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AdvancedProcessor.processing_strategy
        [ATTRIBUTE] Direct match found: inheritence_complex.AdvancedProcessor.processing_strategy
      [CHAIN] Step 1 resolved: inheritence_complex.AdvancedProcessor.processing_strategy
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor.processing_strategy
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AdvancedProcessor (cached)
      -> Not module state
      [CALL] Found call: self.add_metric_callback
    [RESOLVE] Attempting to resolve: ['self', 'add_metric_callback']
    [RESOLVE] Chain resolution needed for: ['self', 'add_metric_callback']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AdvancedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AdvancedProcessor.add_metric_callback
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AdvancedProcessor.add_metric_callback
        [ATTRIBUTE] Direct match found: inheritence_complex.AdvancedProcessor.add_metric_callback
      [CHAIN] Step 1 resolved: inheritence_complex.AdvancedProcessor.add_metric_callback
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor.add_metric_callback
            [INTERMEDIATE] Tracking chain steps for: self.add_metric_callback
            [INTERMEDIATE] Step 1: self.add_metric_callback
      -> Resolved to: inheritence_complex.AdvancedProcessor.add_metric_callback
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.add_metric_callback
        [CACHE] self.add_metric_callback -> inheritence_complex.AdvancedProcessor.add_metric_callback (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AdvancedProcessor (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._processing_time_callback
    [RESOLVE] Attempting to resolve: ['self', '_processing_time_callback']
    [RESOLVE] Chain resolution needed for: ['self', '_processing_time_callback']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AdvancedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AdvancedProcessor._processing_time_callback
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AdvancedProcessor._processing_time_callback
        [ATTRIBUTE] Direct match found: inheritence_complex.AdvancedProcessor._processing_time_callback
      [CHAIN] Step 1 resolved: inheritence_complex.AdvancedProcessor._processing_time_callback
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor._processing_time_callback
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AdvancedProcessor (cached)
      -> Not module state
      [CALL] Found call: self.add_metric_callback
    [CACHE] self.add_metric_callback -> inheritence_complex.AdvancedProcessor.add_metric_callback (cached)
            [INTERMEDIATE] Tracking chain steps for: self.add_metric_callback
            [INTERMEDIATE] Step 1: self.add_metric_callback
      -> Resolved to: inheritence_complex.AdvancedProcessor.add_metric_callback
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.add_metric_callback
        [CACHE] self.add_metric_callback -> inheritence_complex.AdvancedProcessor.add_metric_callback (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AdvancedProcessor (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._data_size_callback
    [RESOLVE] Attempting to resolve: ['self', '_data_size_callback']
    [RESOLVE] Chain resolution needed for: ['self', '_data_size_callback']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AdvancedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AdvancedProcessor._data_size_callback
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AdvancedProcessor._data_size_callback
        [ATTRIBUTE] Direct match found: inheritence_complex.AdvancedProcessor._data_size_callback
      [CHAIN] Step 1 resolved: inheritence_complex.AdvancedProcessor._data_size_callback
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor._data_size_callback
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AdvancedProcessor (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.AdvancedProcessor.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.AdvancedProcessor.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.AdvancedProcessor.process_data
    [DECORATOR] @trace
    [CONTEXT] Entered function: inheritence_complex.AdvancedProcessor.process_data (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
    [IMPORT] time -> time
      [ASSIGNMENT] Processing: start_time = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable time not found in any scope
      [LOCAL_RESOLVER] can_resolve(time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(time): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(time): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(time): time (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: time -> time
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
      [TYPE_INFERENCE] Call resolved to: time.time
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for start_time
      [NAME] Found name reference: start_time
    [RESOLVE] Attempting to resolve: ['start_time']
      [RESOLVE_SIMPLE] Resolving base: start_time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable start_time not found in any scope
      [LOCAL_RESOLVER] can_resolve(start_time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(start_time): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(start_time): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(start_time): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(start_time): inheritence_complex.start_time
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: start_time -> inheritence_complex.start_time
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.start_time
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [ASSIGNMENT] Processing: data_size = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(len): inheritence_complex.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> inheritence_complex.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.len
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.len
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for data_size
      [NAME] Found name reference: data_size
    [RESOLVE] Attempting to resolve: ['data_size']
      [RESOLVE_SIMPLE] Resolving base: data_size
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable data_size not found in any scope
      [LOCAL_RESOLVER] can_resolve(data_size): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(data_size): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(data_size): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(data_size): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(data_size): inheritence_complex.data_size
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: data_size -> inheritence_complex.data_size
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.data_size
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [CACHE] Hit for len: inheritence_complex.len
    [RESOLVE] RESOLVED to: inheritence_complex.len
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(data): True
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(data): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: data -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [CALL] Found call: self.record_metric
    [RESOLVE] Attempting to resolve: ['self', 'record_metric']
    [RESOLVE] Chain resolution needed for: ['self', 'record_metric']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AdvancedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AdvancedProcessor.record_metric
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AdvancedProcessor.record_metric
        [ATTRIBUTE] Direct match found: inheritence_complex.AdvancedProcessor.record_metric
      [CHAIN] Step 1 resolved: inheritence_complex.AdvancedProcessor.record_metric
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor.record_metric
            [INTERMEDIATE] Tracking chain steps for: self.record_metric
            [INTERMEDIATE] Step 1: self.record_metric
      -> Resolved to: inheritence_complex.AdvancedProcessor.record_metric
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data_size
    [RESOLVE] Attempting to resolve: ['data_size']
      [RESOLVE_SIMPLE] Resolving base: data_size
      [CACHE] Hit for data_size: inheritence_complex.data_size
    [RESOLVE] RESOLVED to: inheritence_complex.data_size
      [ATTRIBUTE] Found attribute access: self.record_metric
        [CACHE] self.record_metric -> inheritence_complex.AdvancedProcessor.record_metric (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor
      -> Not module state
      [NAME] Found name reference: data_size
        [CACHE] data_size -> inheritence_complex.data_size (cached)
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] No name parts extracted from call
        [ASSIGNMENT] FAILED Could not infer type for result
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable result not found in any scope
      [LOCAL_RESOLVER] can_resolve(result): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(result): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(result): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(result): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(result): inheritence_complex.result
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: result -> inheritence_complex.result
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.result
      -> Resolved to state: inheritence_complex.result
      [SYMBOL_LOOKUP] Variable result not found in any scope
      -> ADDED to accessed_state
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [CACHE] Hit for super: inheritence_complex.super
    [RESOLVE] RESOLVED to: inheritence_complex.super
      -> Resolved to: inheritence_complex.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> inheritence_complex.super (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [ASSIGNMENT] Processing: processing_time = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: processing_time
    [RESOLVE] Attempting to resolve: ['processing_time']
      [RESOLVE_SIMPLE] Resolving base: processing_time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable processing_time not found in any scope
      [LOCAL_RESOLVER] can_resolve(processing_time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(processing_time): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(processing_time): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(processing_time): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(processing_time): inheritence_complex.processing_time
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: processing_time -> inheritence_complex.processing_time
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.processing_time
      -> Not module state
      [CALL] Found call: time.time
    [CACHE] time.time -> time.time (cached)
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
        [CACHE] time -> time (cached)
      -> Not module state
      [NAME] Found name reference: start_time
        [CACHE] start_time -> inheritence_complex.start_time (cached)
      -> Not module state
      [CALL] Found call: self.record_metric
    [CACHE] self.record_metric -> inheritence_complex.AdvancedProcessor.record_metric (cached)
            [INTERMEDIATE] Tracking chain steps for: self.record_metric
            [INTERMEDIATE] Step 1: self.record_metric
      -> Resolved to: inheritence_complex.AdvancedProcessor.record_metric
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: processing_time
    [RESOLVE] Attempting to resolve: ['processing_time']
      [RESOLVE_SIMPLE] Resolving base: processing_time
      [CACHE] Hit for processing_time: inheritence_complex.processing_time
    [RESOLVE] RESOLVED to: inheritence_complex.processing_time
      [ATTRIBUTE] Found attribute access: self.record_metric
        [CACHE] self.record_metric -> inheritence_complex.AdvancedProcessor.record_metric (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AdvancedProcessor (cached)
      -> Not module state
      [NAME] Found name reference: processing_time
        [CACHE] processing_time -> inheritence_complex.processing_time (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: result.metrics
    [RESOLVE] Attempting to resolve: ['result', 'metrics']
    [RESOLVE] Chain resolution needed for: ['result', 'metrics']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: inheritence_complex.result
      [CHAIN] Base resolved: result -> inheritence_complex.result
      [CHAIN] Step 1: Resolving inheritence_complex.result.metrics
        [ATTRIBUTE] Resolving attribute: inheritence_complex.result.metrics
        [ATTRIBUTE] Direct match found: inheritence_complex.result.metrics
      [CHAIN] Step 1 resolved: inheritence_complex.result.metrics
    [RESOLVE] RESOLVED to: inheritence_complex.result.metrics
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> inheritence_complex.result (cached)
      -> Resolved to state: inheritence_complex.result
      [SYMBOL_LOOKUP] Variable result not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: processing_time
        [CACHE] processing_time -> inheritence_complex.processing_time (cached)
      -> Not module state
      [NAME] Found name reference: data_size
        [CACHE] data_size -> inheritence_complex.data_size (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.priority.name
    [RESOLVE] Attempting to resolve: ['self', 'priority', 'name']
    [RESOLVE] Chain resolution needed for: ['self', 'priority', 'name']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AdvancedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AdvancedProcessor.priority
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AdvancedProcessor.priority
        [ATTRIBUTE] Direct match found: inheritence_complex.AdvancedProcessor.priority
      [CHAIN] Step 1 resolved: inheritence_complex.AdvancedProcessor.priority
      [CHAIN] Step 2: Resolving inheritence_complex.AdvancedProcessor.priority.name
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AdvancedProcessor.priority.name
        [ATTRIBUTE] Direct match found: inheritence_complex.AdvancedProcessor.priority.name
      [CHAIN] Step 2 resolved: inheritence_complex.AdvancedProcessor.priority.name
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor.priority.name
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.priority
    [RESOLVE] Attempting to resolve: ['self', 'priority']
    [RESOLVE] Chain resolution needed for: ['self', 'priority']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AdvancedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AdvancedProcessor.priority
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AdvancedProcessor.priority
        [ATTRIBUTE] Direct match found: inheritence_complex.AdvancedProcessor.priority
      [CHAIN] Step 1 resolved: inheritence_complex.AdvancedProcessor.priority
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor.priority
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AdvancedProcessor (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> inheritence_complex.result (cached)
      -> Resolved to state: inheritence_complex.result
      [SYMBOL_LOOKUP] Variable result not found in any scope
      -> ADDED to accessed_state
    [CONTEXT] Exited function: inheritence_complex.AdvancedProcessor.process_data
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.AdvancedProcessor.process_data
        Calls: 0
        Instantiations: 0
        State Access: 1
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.AdvancedProcessor._processing_time_callback
    [CONTEXT] Entered function: inheritence_complex.AdvancedProcessor._processing_time_callback (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 4 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'metric_name': 'str', 'value': 'float', 'history': 'List[float]'}
        [ARG_TYPE] Processing type annotation for metric_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: metric_name -> inheritence_complex.str
        [ARG_TYPE] RESOLVED metric_name : inheritence_complex.str
        [ARG_TYPE] Processing type annotation for value: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable float not found in any scope
      [LOCAL_RESOLVER] can_resolve(float): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(float): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(float): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(float): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(float): inheritence_complex.float
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: float -> inheritence_complex.float
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.float
      [SYMBOL_UPDATE] Function: value -> inheritence_complex.float
        [ARG_TYPE] RESOLVED value : inheritence_complex.float
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [CACHE] Hit for len: inheritence_complex.len
    [RESOLVE] RESOLVED to: inheritence_complex.len
      -> Not module state
      [NAME] Found name reference: history
    [RESOLVE] Attempting to resolve: ['history']
      [RESOLVE_SIMPLE] Resolving base: history
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable history not found in any scope
      [LOCAL_RESOLVER] can_resolve(history): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(history): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(history): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(history): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(history): inheritence_complex.history
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: history -> inheritence_complex.history
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.history
      -> Not module state
      [ASSIGNMENT] Processing: avg_time = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: avg_time
    [RESOLVE] Attempting to resolve: ['avg_time']
      [RESOLVE_SIMPLE] Resolving base: avg_time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable avg_time not found in any scope
      [LOCAL_RESOLVER] can_resolve(avg_time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(avg_time): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(avg_time): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(avg_time): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(avg_time): inheritence_complex.avg_time
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: avg_time -> inheritence_complex.avg_time
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.avg_time
      -> Not module state
      [CALL] Found call: sum
      -> IGNORED (built-in function)
      [NAME] Found name reference: sum
    [RESOLVE] Attempting to resolve: ['sum']
      [RESOLVE_SIMPLE] Resolving base: sum
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable sum not found in any scope
      [LOCAL_RESOLVER] can_resolve(sum): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(sum): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(sum): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(sum): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(sum): inheritence_complex.sum
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: sum -> inheritence_complex.sum
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.sum
      -> Not module state
      [NAME] Found name reference: history
        [CACHE] history -> inheritence_complex.history (cached)
      -> Not module state
      [NAME] Found name reference: avg_time
        [CACHE] avg_time -> inheritence_complex.avg_time (cached)
      -> Not module state
      [CALL] Found call: self.log_operation
    [RESOLVE] Attempting to resolve: ['self', 'log_operation']
    [RESOLVE] Chain resolution needed for: ['self', 'log_operation']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AdvancedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AdvancedProcessor.log_operation
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AdvancedProcessor.log_operation
        [ATTRIBUTE] Direct match found: inheritence_complex.AdvancedProcessor.log_operation
      [CHAIN] Step 1 resolved: inheritence_complex.AdvancedProcessor.log_operation
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor.log_operation
            [INTERMEDIATE] Tracking chain steps for: self.log_operation
            [INTERMEDIATE] Step 1: self.log_operation
      -> Resolved to: inheritence_complex.AdvancedProcessor.log_operation
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.log_operation
        [CACHE] self.log_operation -> inheritence_complex.AdvancedProcessor.log_operation (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor
      -> Not module state
      [NAME] Found name reference: avg_time
        [CACHE] avg_time -> inheritence_complex.avg_time (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.AdvancedProcessor._processing_time_callback
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.AdvancedProcessor._processing_time_callback
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.AdvancedProcessor._data_size_callback
    [CONTEXT] Entered function: inheritence_complex.AdvancedProcessor._data_size_callback (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 4 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'metric_name': 'str', 'value': 'float', 'history': 'List[float]'}
        [ARG_TYPE] Processing type annotation for metric_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: metric_name -> inheritence_complex.str
        [ARG_TYPE] RESOLVED metric_name : inheritence_complex.str
        [ARG_TYPE] Processing type annotation for value: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [CACHE] Hit for float: inheritence_complex.float
    [RESOLVE] RESOLVED to: inheritence_complex.float
      [SYMBOL_UPDATE] Function: value -> inheritence_complex.float
        [ARG_TYPE] RESOLVED value : inheritence_complex.float
      [NAME] Found name reference: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found value in function scope: inheritence_complex.float
      [LOCAL_RESOLVER] can_resolve(value): True
      [SYMBOL_LOOKUP] Found value in function scope: inheritence_complex.float
      [LOCAL_RESOLVER] resolve(value): inheritence_complex.float
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: value -> inheritence_complex.float
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.float
      -> Not module state
      [CALL] Found call: self.log_operation
    [RESOLVE] Attempting to resolve: ['self', 'log_operation']
    [RESOLVE] Chain resolution needed for: ['self', 'log_operation']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AdvancedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AdvancedProcessor.log_operation
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AdvancedProcessor.log_operation
        [ATTRIBUTE] Direct match found: inheritence_complex.AdvancedProcessor.log_operation
      [CHAIN] Step 1 resolved: inheritence_complex.AdvancedProcessor.log_operation
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor.log_operation
            [INTERMEDIATE] Tracking chain steps for: self.log_operation
            [INTERMEDIATE] Step 1: self.log_operation
      -> Resolved to: inheritence_complex.AdvancedProcessor.log_operation
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.log_operation
        [CACHE] self.log_operation -> inheritence_complex.AdvancedProcessor.log_operation (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> inheritence_complex.float (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.AdvancedProcessor._data_size_callback
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.AdvancedProcessor._data_size_callback
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.AdvancedProcessor.change_processing_strategy
    [DECORATOR] @validate_auth(required_role='operator')
    [CONTEXT] Entered function: inheritence_complex.AdvancedProcessor.change_processing_strategy (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'new_strategy': 'str'}
        [ARG_TYPE] Processing type annotation for new_strategy: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: new_strategy -> inheritence_complex.str
        [ARG_TYPE] RESOLVED new_strategy : inheritence_complex.str
      [ASSIGNMENT] Processing: old_strategy = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: old_strategy
    [RESOLVE] Attempting to resolve: ['old_strategy']
      [RESOLVE_SIMPLE] Resolving base: old_strategy
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable old_strategy not found in any scope
      [LOCAL_RESOLVER] can_resolve(old_strategy): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(old_strategy): False (current_class: inheritence_complex.AdvancedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(old_strategy): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(old_strategy): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(old_strategy): inheritence_complex.old_strategy
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: old_strategy -> inheritence_complex.old_strategy
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.old_strategy
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.processing_strategy
    [RESOLVE] Attempting to resolve: ['self', 'processing_strategy']
    [RESOLVE] Chain resolution needed for: ['self', 'processing_strategy']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AdvancedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AdvancedProcessor.processing_strategy
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AdvancedProcessor.processing_strategy
        [ATTRIBUTE] Direct match found: inheritence_complex.AdvancedProcessor.processing_strategy
      [CHAIN] Step 1 resolved: inheritence_complex.AdvancedProcessor.processing_strategy
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor.processing_strategy
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.processing_strategy
        [CACHE] self.processing_strategy -> inheritence_complex.AdvancedProcessor.processing_strategy (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AdvancedProcessor (cached)
      -> Not module state
      [NAME] Found name reference: new_strategy
    [RESOLVE] Attempting to resolve: ['new_strategy']
      [RESOLVE_SIMPLE] Resolving base: new_strategy
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found new_strategy in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] can_resolve(new_strategy): True
      [SYMBOL_LOOKUP] Found new_strategy in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] resolve(new_strategy): inheritence_complex.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: new_strategy -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [CALL] Found call: self.log_operation
    [RESOLVE] Attempting to resolve: ['self', 'log_operation']
    [RESOLVE] Chain resolution needed for: ['self', 'log_operation']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.AdvancedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.AdvancedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.AdvancedProcessor.log_operation
        [ATTRIBUTE] Resolving attribute: inheritence_complex.AdvancedProcessor.log_operation
        [ATTRIBUTE] Direct match found: inheritence_complex.AdvancedProcessor.log_operation
      [CHAIN] Step 1 resolved: inheritence_complex.AdvancedProcessor.log_operation
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor.log_operation
            [INTERMEDIATE] Tracking chain steps for: self.log_operation
            [INTERMEDIATE] Step 1: self.log_operation
      -> Resolved to: inheritence_complex.AdvancedProcessor.log_operation
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.log_operation
        [CACHE] self.log_operation -> inheritence_complex.AdvancedProcessor.log_operation (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.AdvancedProcessor (cached)
      -> Not module state
      [NAME] Found name reference: old_strategy
        [CACHE] old_strategy -> inheritence_complex.old_strategy (cached)
      -> Not module state
      [NAME] Found name reference: new_strategy
        [CACHE] new_strategy -> inheritence_complex.str (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.AdvancedProcessor.change_processing_strategy
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.AdvancedProcessor.change_processing_strategy
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: inheritence_complex.AdvancedProcessor
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: SpecializedProcessor
    [CONTEXT] Entered class: inheritence_complex.SpecializedProcessor
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.SpecializedProcessor.__init__
    [CONTEXT] Entered function: inheritence_complex.SpecializedProcessor.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'processor_id': 'str', 'specialization': 'str'}
        [ARG_TYPE] Processing type annotation for processor_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(str): inheritence_complex.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: processor_id -> inheritence_complex.str
        [ARG_TYPE] RESOLVED processor_id : inheritence_complex.str
        [ARG_TYPE] Processing type annotation for specialization: str
        [CACHE] str -> inheritence_complex.str (cached)
      [SYMBOL_UPDATE] Function: specialization -> inheritence_complex.str
        [ARG_TYPE] RESOLVED specialization : inheritence_complex.str
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable super not found in any scope
      [LOCAL_RESOLVER] can_resolve(super): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(super): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(super): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(super): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(super): inheritence_complex.super
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: super -> inheritence_complex.super
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.super
      -> Resolved to: inheritence_complex.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> inheritence_complex.super (cached)
      -> Not module state
      [NAME] Found name reference: processor_id
    [RESOLVE] Attempting to resolve: ['processor_id']
      [RESOLVE_SIMPLE] Resolving base: processor_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found processor_id in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] can_resolve(processor_id): True
      [SYMBOL_LOOKUP] Found processor_id in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] resolve(processor_id): inheritence_complex.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: processor_id -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: Priority.HIGH
    [RESOLVE] Attempting to resolve: ['Priority', 'HIGH']
    [RESOLVE] Chain resolution needed for: ['Priority', 'HIGH']
      [CHAIN] Resolving base: Priority
      [RESOLVE_SIMPLE] Resolving base: Priority
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Priority not found in any scope
      [LOCAL_RESOLVER] can_resolve(Priority): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Priority): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Priority): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(Priority): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(Priority): inheritence_complex.Priority
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: Priority -> inheritence_complex.Priority
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: Priority -> inheritence_complex.Priority
      [CHAIN] Step 1: Resolving inheritence_complex.Priority.HIGH
        [ATTRIBUTE] Resolving attribute: inheritence_complex.Priority.HIGH
        [ATTRIBUTE] Direct match found: inheritence_complex.Priority.HIGH
      [CHAIN] Step 1 resolved: inheritence_complex.Priority.HIGH
    [RESOLVE] RESOLVED to: inheritence_complex.Priority.HIGH
      -> Not module state
      [NAME] Found name reference: Priority
    [RESOLVE] Attempting to resolve: ['Priority']
      [RESOLVE_SIMPLE] Resolving base: Priority
      [CACHE] Hit for Priority: inheritence_complex.Priority
    [RESOLVE] RESOLVED to: inheritence_complex.Priority
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.specialization
    [RESOLVE] Attempting to resolve: ['self', 'specialization']
    [RESOLVE] Chain resolution needed for: ['self', 'specialization']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: inheritence_complex.SpecializedProcessor)
      [SELF_RESOLVER] resolve(self): inheritence_complex.SpecializedProcessor
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> inheritence_complex.SpecializedProcessor
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> inheritence_complex.SpecializedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.SpecializedProcessor.specialization
        [ATTRIBUTE] Resolving attribute: inheritence_complex.SpecializedProcessor.specialization
        [ATTRIBUTE] Direct match found: inheritence_complex.SpecializedProcessor.specialization
      [CHAIN] Step 1 resolved: inheritence_complex.SpecializedProcessor.specialization
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor.specialization
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.SpecializedProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor
      -> Not module state
      [NAME] Found name reference: specialization
    [RESOLVE] Attempting to resolve: ['specialization']
      [RESOLVE_SIMPLE] Resolving base: specialization
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found specialization in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] can_resolve(specialization): True
      [SYMBOL_LOOKUP] Found specialization in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] resolve(specialization): inheritence_complex.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: specialization -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.specialist_cache
    [RESOLVE] Attempting to resolve: ['self', 'specialist_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'specialist_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.SpecializedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.SpecializedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.SpecializedProcessor.specialist_cache
        [ATTRIBUTE] Resolving attribute: inheritence_complex.SpecializedProcessor.specialist_cache
        [ATTRIBUTE] Direct match found: inheritence_complex.SpecializedProcessor.specialist_cache
      [CHAIN] Step 1 resolved: inheritence_complex.SpecializedProcessor.specialist_cache
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor.specialist_cache
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.SpecializedProcessor (cached)
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [CALL] Found call: self.add_validation_rule
    [RESOLVE] Attempting to resolve: ['self', 'add_validation_rule']
    [RESOLVE] Chain resolution needed for: ['self', 'add_validation_rule']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.SpecializedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.SpecializedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.SpecializedProcessor.add_validation_rule
        [ATTRIBUTE] Resolving attribute: inheritence_complex.SpecializedProcessor.add_validation_rule
        [ATTRIBUTE] Direct match found: inheritence_complex.SpecializedProcessor.add_validation_rule
      [CHAIN] Step 1 resolved: inheritence_complex.SpecializedProcessor.add_validation_rule
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor.add_validation_rule
            [INTERMEDIATE] Tracking chain steps for: self.add_validation_rule
            [INTERMEDIATE] Step 1: self.add_validation_rule
      -> Resolved to: inheritence_complex.SpecializedProcessor.add_validation_rule
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.add_validation_rule
        [CACHE] self.add_validation_rule -> inheritence_complex.SpecializedProcessor.add_validation_rule (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.SpecializedProcessor (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self._validate_specialization
    [RESOLVE] Attempting to resolve: ['self', '_validate_specialization']
    [RESOLVE] Chain resolution needed for: ['self', '_validate_specialization']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.SpecializedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.SpecializedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.SpecializedProcessor._validate_specialization
        [ATTRIBUTE] Resolving attribute: inheritence_complex.SpecializedProcessor._validate_specialization
        [ATTRIBUTE] Direct match found: inheritence_complex.SpecializedProcessor._validate_specialization
      [CHAIN] Step 1 resolved: inheritence_complex.SpecializedProcessor._validate_specialization
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor._validate_specialization
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.SpecializedProcessor (cached)
      -> Not module state
      [NAME] Found name reference: specialization
        [CACHE] specialization -> inheritence_complex.str (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.SpecializedProcessor.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.SpecializedProcessor.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.SpecializedProcessor._validate_specialization
    [CONTEXT] Entered function: inheritence_complex.SpecializedProcessor._validate_specialization (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [ATTRIBUTE] Found attribute access: self.specialization
    [RESOLVE] Attempting to resolve: ['self', 'specialization']
    [RESOLVE] Chain resolution needed for: ['self', 'specialization']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.SpecializedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.SpecializedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.SpecializedProcessor.specialization
        [ATTRIBUTE] Resolving attribute: inheritence_complex.SpecializedProcessor.specialization
        [ATTRIBUTE] Direct match found: inheritence_complex.SpecializedProcessor.specialization
      [CHAIN] Step 1 resolved: inheritence_complex.SpecializedProcessor.specialization
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor.specialization
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.SpecializedProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor
      -> Not module state
      [CALL] Found call: isinstance
    [RESOLVE] Attempting to resolve: ['isinstance']
      [RESOLVE_SIMPLE] Resolving base: isinstance
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable isinstance not found in any scope
      [LOCAL_RESOLVER] can_resolve(isinstance): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(isinstance): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(isinstance): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(isinstance): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(isinstance): inheritence_complex.isinstance
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: isinstance -> inheritence_complex.isinstance
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.isinstance
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(data): True
      [SYMBOL_LOOKUP] Found data in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(data): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: data -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [NAME] Found name reference: int
    [RESOLVE] Attempting to resolve: ['int']
      [RESOLVE_SIMPLE] Resolving base: int
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable int not found in any scope
      [LOCAL_RESOLVER] can_resolve(int): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(int): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(int): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(int): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(int): inheritence_complex.int
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: int -> inheritence_complex.int
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.int
      -> Not module state
      [NAME] Found name reference: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable float not found in any scope
      [LOCAL_RESOLVER] can_resolve(float): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(float): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(float): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(float): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(float): inheritence_complex.float
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: float -> inheritence_complex.float
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.float
      -> Not module state
      [NAME] Found name reference: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable list not found in any scope
      [LOCAL_RESOLVER] can_resolve(list): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(list): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(list): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(list): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(list): inheritence_complex.list
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: list -> inheritence_complex.list
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.list
      -> Not module state
      [NAME] Found name reference: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(dict): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(dict): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(dict): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(dict): inheritence_complex.dict
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: dict -> inheritence_complex.dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.specialization
        [CACHE] self.specialization -> inheritence_complex.SpecializedProcessor.specialization (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.SpecializedProcessor (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [NAME] Found name reference: list
        [CACHE] list -> inheritence_complex.list (cached)
      -> Not module state
      [NAME] Found name reference: dict
        [CACHE] dict -> inheritence_complex.dict (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.specialization
        [CACHE] self.specialization -> inheritence_complex.SpecializedProcessor.specialization (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.SpecializedProcessor (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: dict
        [CACHE] dict -> inheritence_complex.dict (cached)
      -> Not module state
      [NAME] Found name reference: list
        [CACHE] list -> inheritence_complex.list (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.SpecializedProcessor._validate_specialization
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.SpecializedProcessor._validate_specialization
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.SpecializedProcessor._internal_process
    [DECORATOR] @trace
    [CONTEXT] Entered function: inheritence_complex.SpecializedProcessor._internal_process (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [ATTRIBUTE] Found attribute access: self.specialization
    [RESOLVE] Attempting to resolve: ['self', 'specialization']
    [RESOLVE] Chain resolution needed for: ['self', 'specialization']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.SpecializedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.SpecializedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.SpecializedProcessor.specialization
        [ATTRIBUTE] Resolving attribute: inheritence_complex.SpecializedProcessor.specialization
        [ATTRIBUTE] Direct match found: inheritence_complex.SpecializedProcessor.specialization
      [CHAIN] Step 1 resolved: inheritence_complex.SpecializedProcessor.specialization
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor.specialization
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.SpecializedProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor
      -> Not module state
      [CALL] Found call: self._process_numeric
    [RESOLVE] Attempting to resolve: ['self', '_process_numeric']
    [RESOLVE] Chain resolution needed for: ['self', '_process_numeric']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.SpecializedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.SpecializedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.SpecializedProcessor._process_numeric
        [ATTRIBUTE] Resolving attribute: inheritence_complex.SpecializedProcessor._process_numeric
        [ATTRIBUTE] Direct match found: inheritence_complex.SpecializedProcessor._process_numeric
      [CHAIN] Step 1 resolved: inheritence_complex.SpecializedProcessor._process_numeric
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor._process_numeric
            [INTERMEDIATE] Tracking chain steps for: self._process_numeric
            [INTERMEDIATE] Step 1: self._process_numeric
      -> Resolved to: inheritence_complex.SpecializedProcessor._process_numeric
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [ATTRIBUTE] Found attribute access: self._process_numeric
        [CACHE] self._process_numeric -> inheritence_complex.SpecializedProcessor._process_numeric (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.SpecializedProcessor (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.specialization
        [CACHE] self.specialization -> inheritence_complex.SpecializedProcessor.specialization (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.SpecializedProcessor (cached)
      -> Not module state
      [CALL] Found call: self._process_text
    [RESOLVE] Attempting to resolve: ['self', '_process_text']
    [RESOLVE] Chain resolution needed for: ['self', '_process_text']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.SpecializedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.SpecializedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.SpecializedProcessor._process_text
        [ATTRIBUTE] Resolving attribute: inheritence_complex.SpecializedProcessor._process_text
        [ATTRIBUTE] Direct match found: inheritence_complex.SpecializedProcessor._process_text
      [CHAIN] Step 1 resolved: inheritence_complex.SpecializedProcessor._process_text
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor._process_text
            [INTERMEDIATE] Tracking chain steps for: self._process_text
            [INTERMEDIATE] Step 1: self._process_text
      -> Resolved to: inheritence_complex.SpecializedProcessor._process_text
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [ATTRIBUTE] Found attribute access: self._process_text
        [CACHE] self._process_text -> inheritence_complex.SpecializedProcessor._process_text (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.SpecializedProcessor (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.specialization
        [CACHE] self.specialization -> inheritence_complex.SpecializedProcessor.specialization (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.SpecializedProcessor (cached)
      -> Not module state
      [CALL] Found call: self._process_structured
    [RESOLVE] Attempting to resolve: ['self', '_process_structured']
    [RESOLVE] Chain resolution needed for: ['self', '_process_structured']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.SpecializedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.SpecializedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.SpecializedProcessor._process_structured
        [ATTRIBUTE] Resolving attribute: inheritence_complex.SpecializedProcessor._process_structured
        [ATTRIBUTE] Direct match found: inheritence_complex.SpecializedProcessor._process_structured
      [CHAIN] Step 1 resolved: inheritence_complex.SpecializedProcessor._process_structured
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor._process_structured
            [INTERMEDIATE] Tracking chain steps for: self._process_structured
            [INTERMEDIATE] Step 1: self._process_structured
      -> Resolved to: inheritence_complex.SpecializedProcessor._process_structured
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [ATTRIBUTE] Found attribute access: self._process_structured
        [CACHE] self._process_structured -> inheritence_complex.SpecializedProcessor._process_structured (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.SpecializedProcessor (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [CACHE] Hit for super: inheritence_complex.super
    [RESOLVE] RESOLVED to: inheritence_complex.super
      -> Resolved to: inheritence_complex.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> inheritence_complex.super (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.SpecializedProcessor._internal_process
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.SpecializedProcessor._internal_process
        Calls: 3
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.SpecializedProcessor._process_numeric
    [CONTEXT] Entered function: inheritence_complex.SpecializedProcessor._process_numeric (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [CALL] Found call: isinstance
    [RESOLVE] Attempting to resolve: ['isinstance']
      [RESOLVE_SIMPLE] Resolving base: isinstance
      [CACHE] Hit for isinstance: inheritence_complex.isinstance
    [RESOLVE] RESOLVED to: inheritence_complex.isinstance
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [NAME] Found name reference: int
    [RESOLVE] Attempting to resolve: ['int']
      [RESOLVE_SIMPLE] Resolving base: int
      [CACHE] Hit for int: inheritence_complex.int
    [RESOLVE] RESOLVED to: inheritence_complex.int
      -> Not module state
      [NAME] Found name reference: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [CACHE] Hit for float: inheritence_complex.float
    [RESOLVE] RESOLVED to: inheritence_complex.float
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
        [FUNCTION_ARG] Checking argument: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [CACHE] Hit for list: inheritence_complex.list
    [RESOLVE] RESOLVED to: inheritence_complex.list
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [CACHE] Hit for list: inheritence_complex.list
    [RESOLVE] RESOLVED to: inheritence_complex.list
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: x
    [RESOLVE] Attempting to resolve: ['x']
      [RESOLVE_SIMPLE] Resolving base: x
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable x not found in any scope
      [LOCAL_RESOLVER] can_resolve(x): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(x): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(x): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(x): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(x): inheritence_complex.x
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: x -> inheritence_complex.x
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.x
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: x
    [RESOLVE] Attempting to resolve: ['x']
      [RESOLVE_SIMPLE] Resolving base: x
      [CACHE] Hit for x: inheritence_complex.x
    [RESOLVE] RESOLVED to: inheritence_complex.x
      -> Not module state
      [NAME] Found name reference: int
        [CACHE] int -> inheritence_complex.int (cached)
      -> Not module state
      [NAME] Found name reference: float
        [CACHE] float -> inheritence_complex.float (cached)
      -> Not module state
      [NAME] Found name reference: x
        [CACHE] x -> inheritence_complex.x (cached)
      -> Not module state
      [NAME] Found name reference: x
        [CACHE] x -> inheritence_complex.x (cached)
      -> Not module state
      [NAME] Found name reference: x
        [CACHE] x -> inheritence_complex.x (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
        [FUNCTION_ARG] Checking argument: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      -> Not module state
      [NAME] Found name reference: k
    [RESOLVE] Attempting to resolve: ['k']
      [RESOLVE_SIMPLE] Resolving base: k
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable k not found in any scope
      [LOCAL_RESOLVER] can_resolve(k): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(k): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(k): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(k): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(k): inheritence_complex.k
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: k -> inheritence_complex.k
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.k
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: v
    [RESOLVE] Attempting to resolve: ['v']
      [RESOLVE_SIMPLE] Resolving base: v
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable v not found in any scope
      [LOCAL_RESOLVER] can_resolve(v): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(v): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(v): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(v): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(v): inheritence_complex.v
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: v -> inheritence_complex.v
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.v
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: v
    [RESOLVE] Attempting to resolve: ['v']
      [RESOLVE_SIMPLE] Resolving base: v
      [CACHE] Hit for v: inheritence_complex.v
    [RESOLVE] RESOLVED to: inheritence_complex.v
      -> Not module state
      [NAME] Found name reference: int
        [CACHE] int -> inheritence_complex.int (cached)
      -> Not module state
      [NAME] Found name reference: float
        [CACHE] float -> inheritence_complex.float (cached)
      -> Not module state
      [NAME] Found name reference: v
        [CACHE] v -> inheritence_complex.v (cached)
      -> Not module state
      [NAME] Found name reference: v
        [CACHE] v -> inheritence_complex.v (cached)
      -> Not module state
      [NAME] Found name reference: k
        [CACHE] k -> inheritence_complex.k (cached)
      -> Not module state
      [NAME] Found name reference: v
        [CACHE] v -> inheritence_complex.v (cached)
      -> Not module state
      [CALL] Found call: data.items
    [RESOLVE] Attempting to resolve: ['data', 'items']
    [RESOLVE] Chain resolution needed for: ['data', 'items']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
      [CHAIN] Base resolved: data -> typing.Any
      [CHAIN] Step 1: Resolving typing.Any.items
        [ATTRIBUTE] Resolving attribute: typing.Any.items
        [ATTRIBUTE] Direct match found: typing.Any.items
      [CHAIN] Step 1 resolved: typing.Any.items
    [RESOLVE] RESOLVED to: typing.Any.items
            [INTERMEDIATE] Tracking chain steps for: data.items
            [INTERMEDIATE] Step 1: data.items
      -> Resolved to: typing.Any.items
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: data.items
        [CACHE] data.items -> typing.Any.items (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.SpecializedProcessor._process_numeric
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.SpecializedProcessor._process_numeric
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.SpecializedProcessor._process_text
    [CONTEXT] Entered function: inheritence_complex.SpecializedProcessor._process_text (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [CALL] Found call: isinstance
    [RESOLVE] Attempting to resolve: ['isinstance']
      [RESOLVE_SIMPLE] Resolving base: isinstance
      [CACHE] Hit for isinstance: inheritence_complex.isinstance
    [RESOLVE] RESOLVED to: inheritence_complex.isinstance
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
        [FUNCTION_ARG] Checking argument: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: data.upper
    [RESOLVE] Attempting to resolve: ['data', 'upper']
    [RESOLVE] Chain resolution needed for: ['data', 'upper']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
      [CHAIN] Base resolved: data -> typing.Any
      [CHAIN] Step 1: Resolving typing.Any.upper
        [ATTRIBUTE] Resolving attribute: typing.Any.upper
        [ATTRIBUTE] Direct match found: typing.Any.upper
      [CHAIN] Step 1 resolved: typing.Any.upper
    [RESOLVE] RESOLVED to: typing.Any.upper
            [INTERMEDIATE] Tracking chain steps for: data.upper
            [INTERMEDIATE] Step 1: data.upper
      -> Resolved to: typing.Any.upper
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: data.upper
        [CACHE] data.upper -> typing.Any.upper (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
        [FUNCTION_ARG] Checking argument: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [CACHE] Hit for list: inheritence_complex.list
    [RESOLVE] RESOLVED to: inheritence_complex.list
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [CACHE] Hit for list: inheritence_complex.list
    [RESOLVE] RESOLVED to: inheritence_complex.list
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: item
    [RESOLVE] Attempting to resolve: ['item']
      [RESOLVE_SIMPLE] Resolving base: item
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable item not found in any scope
      [LOCAL_RESOLVER] can_resolve(item): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(item): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(item): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(item): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(item): inheritence_complex.item
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: item -> inheritence_complex.item
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.item
        [FUNCTION_ARG] Checking argument: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: item
    [RESOLVE] Attempting to resolve: ['item']
      [RESOLVE_SIMPLE] Resolving base: item
      [CACHE] Hit for item: inheritence_complex.item
    [RESOLVE] RESOLVED to: inheritence_complex.item
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> inheritence_complex.str (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: item.upper
    [RESOLVE] Attempting to resolve: ['item', 'upper']
    [RESOLVE] Chain resolution needed for: ['item', 'upper']
      [CHAIN] Resolving base: item
      [RESOLVE_SIMPLE] Resolving base: item
      [CACHE] Hit for item: inheritence_complex.item
      [CHAIN] Base resolved: item -> inheritence_complex.item
      [CHAIN] Step 1: Resolving inheritence_complex.item.upper
        [ATTRIBUTE] Resolving attribute: inheritence_complex.item.upper
        [ATTRIBUTE] Direct match found: inheritence_complex.item.upper
      [CHAIN] Step 1 resolved: inheritence_complex.item.upper
    [RESOLVE] RESOLVED to: inheritence_complex.item.upper
            [INTERMEDIATE] Tracking chain steps for: item.upper
            [INTERMEDIATE] Step 1: item.upper
      -> Resolved to: inheritence_complex.item.upper
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: item.upper
        [CACHE] item.upper -> inheritence_complex.item.upper (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> inheritence_complex.item (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> inheritence_complex.item (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> inheritence_complex.item (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
        [FUNCTION_ARG] Checking argument: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      -> Not module state
      [NAME] Found name reference: k
    [RESOLVE] Attempting to resolve: ['k']
      [RESOLVE_SIMPLE] Resolving base: k
      [CACHE] Hit for k: inheritence_complex.k
    [RESOLVE] RESOLVED to: inheritence_complex.k
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: v
    [RESOLVE] Attempting to resolve: ['v']
      [RESOLVE_SIMPLE] Resolving base: v
      [CACHE] Hit for v: inheritence_complex.v
    [RESOLVE] RESOLVED to: inheritence_complex.v
        [FUNCTION_ARG] Checking argument: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: v
    [RESOLVE] Attempting to resolve: ['v']
      [RESOLVE_SIMPLE] Resolving base: v
      [CACHE] Hit for v: inheritence_complex.v
    [RESOLVE] RESOLVED to: inheritence_complex.v
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> inheritence_complex.str (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: v.upper
    [RESOLVE] Attempting to resolve: ['v', 'upper']
    [RESOLVE] Chain resolution needed for: ['v', 'upper']
      [CHAIN] Resolving base: v
      [RESOLVE_SIMPLE] Resolving base: v
      [CACHE] Hit for v: inheritence_complex.v
      [CHAIN] Base resolved: v -> inheritence_complex.v
      [CHAIN] Step 1: Resolving inheritence_complex.v.upper
        [ATTRIBUTE] Resolving attribute: inheritence_complex.v.upper
        [ATTRIBUTE] Direct match found: inheritence_complex.v.upper
      [CHAIN] Step 1 resolved: inheritence_complex.v.upper
    [RESOLVE] RESOLVED to: inheritence_complex.v.upper
            [INTERMEDIATE] Tracking chain steps for: v.upper
            [INTERMEDIATE] Step 1: v.upper
      -> Resolved to: inheritence_complex.v.upper
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: v.upper
        [CACHE] v.upper -> inheritence_complex.v.upper (cached)
      -> Not module state
      [NAME] Found name reference: v
        [CACHE] v -> inheritence_complex.v (cached)
      -> Not module state
      [NAME] Found name reference: v
        [CACHE] v -> inheritence_complex.v (cached)
      -> Not module state
      [NAME] Found name reference: k
        [CACHE] k -> inheritence_complex.k (cached)
      -> Not module state
      [NAME] Found name reference: v
        [CACHE] v -> inheritence_complex.v (cached)
      -> Not module state
      [CALL] Found call: data.items
    [RESOLVE] Attempting to resolve: ['data', 'items']
    [RESOLVE] Chain resolution needed for: ['data', 'items']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
      [CHAIN] Base resolved: data -> typing.Any
      [CHAIN] Step 1: Resolving typing.Any.items
        [ATTRIBUTE] Resolving attribute: typing.Any.items
        [ATTRIBUTE] Direct match found: typing.Any.items
      [CHAIN] Step 1 resolved: typing.Any.items
    [RESOLVE] RESOLVED to: typing.Any.items
            [INTERMEDIATE] Tracking chain steps for: data.items
            [INTERMEDIATE] Step 1: data.items
      -> Resolved to: typing.Any.items
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: data.items
        [CACHE] data.items -> typing.Any.items (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.SpecializedProcessor._process_text
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.SpecializedProcessor._process_text
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.SpecializedProcessor._process_structured
    [CONTEXT] Entered function: inheritence_complex.SpecializedProcessor._process_structured (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [CALL] Found call: isinstance
    [RESOLVE] Attempting to resolve: ['isinstance']
      [RESOLVE_SIMPLE] Resolving base: isinstance
      [CACHE] Hit for isinstance: inheritence_complex.isinstance
    [RESOLVE] RESOLVED to: inheritence_complex.isinstance
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
        [FUNCTION_ARG] Checking argument: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [NAME] Found name reference: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable result not found in any scope
      [LOCAL_RESOLVER] can_resolve(result): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(result): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(result): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(result): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(result): inheritence_complex.result
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: result -> inheritence_complex.result
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.result
      -> Resolved to state: inheritence_complex.result
      [SYMBOL_LOOKUP] Variable result not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: key
    [RESOLVE] Attempting to resolve: ['key']
      [RESOLVE_SIMPLE] Resolving base: key
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable key not found in any scope
      [LOCAL_RESOLVER] can_resolve(key): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(key): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(key): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(key): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(key): inheritence_complex.key
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: key -> inheritence_complex.key
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.key
      -> Not module state
      [NAME] Found name reference: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable value not found in any scope
      [LOCAL_RESOLVER] can_resolve(value): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(value): False (current_class: inheritence_complex.SpecializedProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(value): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(value): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(value): inheritence_complex.value
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: value -> inheritence_complex.value
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.value
      -> Not module state
      [CALL] Found call: data.items
    [RESOLVE] Attempting to resolve: ['data', 'items']
    [RESOLVE] Chain resolution needed for: ['data', 'items']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
      [CHAIN] Base resolved: data -> typing.Any
      [CHAIN] Step 1: Resolving typing.Any.items
        [ATTRIBUTE] Resolving attribute: typing.Any.items
        [ATTRIBUTE] Direct match found: typing.Any.items
      [CHAIN] Step 1 resolved: typing.Any.items
    [RESOLVE] RESOLVED to: typing.Any.items
            [INTERMEDIATE] Tracking chain steps for: data.items
            [INTERMEDIATE] Step 1: data.items
      -> Resolved to: typing.Any.items
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: data.items
        [CACHE] data.items -> typing.Any.items (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: inheritence_complex.value
    [RESOLVE] RESOLVED to: inheritence_complex.value
        [FUNCTION_ARG] Checking argument: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> inheritence_complex.value (cached)
      -> Not module state
      [NAME] Found name reference: dict
        [CACHE] dict -> inheritence_complex.dict (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> inheritence_complex.result (cached)
      -> Resolved to state: inheritence_complex.result
      [SYMBOL_LOOKUP] Variable result not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: key
        [CACHE] key -> inheritence_complex.key (cached)
      -> Not module state
      [CALL] Found call: self._process_structured
    [RESOLVE] Attempting to resolve: ['self', '_process_structured']
    [RESOLVE] Chain resolution needed for: ['self', '_process_structured']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.SpecializedProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.SpecializedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.SpecializedProcessor._process_structured
        [ATTRIBUTE] Resolving attribute: inheritence_complex.SpecializedProcessor._process_structured
        [ATTRIBUTE] Direct match found: inheritence_complex.SpecializedProcessor._process_structured
      [CHAIN] Step 1 resolved: inheritence_complex.SpecializedProcessor._process_structured
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor._process_structured
            [INTERMEDIATE] Tracking chain steps for: self._process_structured
            [INTERMEDIATE] Step 1: self._process_structured
      -> Resolved to: inheritence_complex.SpecializedProcessor._process_structured
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: inheritence_complex.value
    [RESOLVE] RESOLVED to: inheritence_complex.value
      [ATTRIBUTE] Found attribute access: self._process_structured
        [CACHE] self._process_structured -> inheritence_complex.SpecializedProcessor._process_structured (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.SpecializedProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> inheritence_complex.value (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: inheritence_complex.value
    [RESOLVE] RESOLVED to: inheritence_complex.value
        [FUNCTION_ARG] Checking argument: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [CACHE] Hit for list: inheritence_complex.list
    [RESOLVE] RESOLVED to: inheritence_complex.list
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> inheritence_complex.value (cached)
      -> Not module state
      [NAME] Found name reference: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [CACHE] Hit for list: inheritence_complex.list
    [RESOLVE] RESOLVED to: inheritence_complex.list
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> inheritence_complex.result (cached)
      -> Resolved to state: inheritence_complex.result
      [SYMBOL_LOOKUP] Variable result not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: key
        [CACHE] key -> inheritence_complex.key (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: item
    [RESOLVE] Attempting to resolve: ['item']
      [RESOLVE_SIMPLE] Resolving base: item
      [CACHE] Hit for item: inheritence_complex.item
    [RESOLVE] RESOLVED to: inheritence_complex.item
        [FUNCTION_ARG] Checking argument: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: item
    [RESOLVE] Attempting to resolve: ['item']
      [RESOLVE_SIMPLE] Resolving base: item
      [CACHE] Hit for item: inheritence_complex.item
    [RESOLVE] RESOLVED to: inheritence_complex.item
      -> Not module state
      [NAME] Found name reference: dict
        [CACHE] dict -> inheritence_complex.dict (cached)
      -> Not module state
      [CALL] Found call: self._process_structured
    [CACHE] self._process_structured -> inheritence_complex.SpecializedProcessor._process_structured (cached)
            [INTERMEDIATE] Tracking chain steps for: self._process_structured
            [INTERMEDIATE] Step 1: self._process_structured
      -> Resolved to: inheritence_complex.SpecializedProcessor._process_structured
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: item
    [RESOLVE] Attempting to resolve: ['item']
      [RESOLVE_SIMPLE] Resolving base: item
      [CACHE] Hit for item: inheritence_complex.item
    [RESOLVE] RESOLVED to: inheritence_complex.item
      [ATTRIBUTE] Found attribute access: self._process_structured
        [CACHE] self._process_structured -> inheritence_complex.SpecializedProcessor._process_structured (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.SpecializedProcessor (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> inheritence_complex.item (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> inheritence_complex.item (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> inheritence_complex.item (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> inheritence_complex.value (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> inheritence_complex.result (cached)
      -> Resolved to state: inheritence_complex.result
      [SYMBOL_LOOKUP] Variable result not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: key
        [CACHE] key -> inheritence_complex.key (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> inheritence_complex.value (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> inheritence_complex.result (cached)
      -> Resolved to state: inheritence_complex.result
      [SYMBOL_LOOKUP] Variable result not found in any scope
      -> ADDED to accessed_state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
        [FUNCTION_ARG] Checking argument: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [CACHE] Hit for list: inheritence_complex.list
    [RESOLVE] RESOLVED to: inheritence_complex.list
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: list
        [CACHE] list -> inheritence_complex.list (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: item
    [RESOLVE] Attempting to resolve: ['item']
      [RESOLVE_SIMPLE] Resolving base: item
      [CACHE] Hit for item: inheritence_complex.item
    [RESOLVE] RESOLVED to: inheritence_complex.item
        [FUNCTION_ARG] Checking argument: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> inheritence_complex.item (cached)
      -> Not module state
      [NAME] Found name reference: dict
        [CACHE] dict -> inheritence_complex.dict (cached)
      -> Not module state
      [CALL] Found call: self._process_structured
    [CACHE] self._process_structured -> inheritence_complex.SpecializedProcessor._process_structured (cached)
            [INTERMEDIATE] Tracking chain steps for: self._process_structured
            [INTERMEDIATE] Step 1: self._process_structured
      -> Resolved to: inheritence_complex.SpecializedProcessor._process_structured
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: item
    [RESOLVE] Attempting to resolve: ['item']
      [RESOLVE_SIMPLE] Resolving base: item
      [CACHE] Hit for item: inheritence_complex.item
    [RESOLVE] RESOLVED to: inheritence_complex.item
      [ATTRIBUTE] Found attribute access: self._process_structured
        [CACHE] self._process_structured -> inheritence_complex.SpecializedProcessor._process_structured (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.SpecializedProcessor (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> inheritence_complex.item (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> inheritence_complex.item (cached)
      -> Not module state
      [NAME] Found name reference: item
        [CACHE] item -> inheritence_complex.item (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> typing.Any (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.SpecializedProcessor._process_structured
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.SpecializedProcessor._process_structured
        Calls: 1
        Instantiations: 0
        State Access: 1
    [CONTEXT] Exited class: inheritence_complex.SpecializedProcessor
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: ProcessorProtocol
    [CONTEXT] Entered class: inheritence_complex.ProcessorProtocol
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.ProcessorProtocol.process_data
    [CONTEXT] Entered function: inheritence_complex.ProcessorProtocol.process_data (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: inheritence_complex.ProcessorProtocol)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
    [CONTEXT] Exited function: inheritence_complex.ProcessorProtocol.process_data
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.ProcessorProtocol.process_data
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.ProcessorProtocol.get_statistics
    [CONTEXT] Entered function: inheritence_complex.ProcessorProtocol.get_statistics (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
    [CONTEXT] Exited function: inheritence_complex.ProcessorProtocol.get_statistics
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.ProcessorProtocol.get_statistics
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: inheritence_complex.ProcessorProtocol
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: GenericProcessor
    [CONTEXT] Entered class: inheritence_complex.GenericProcessor
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.GenericProcessor.__init__
    [CONTEXT] Entered function: inheritence_complex.GenericProcessor.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'input_type': 'type', 'output_type': 'type'}
        [ARG_TYPE] Processing type annotation for input_type: type
    [RESOLVE] Attempting to resolve: ['type']
      [RESOLVE_SIMPLE] Resolving base: type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable type not found in any scope
      [LOCAL_RESOLVER] can_resolve(type): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(type): False (current_class: inheritence_complex.GenericProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(type): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(type): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(type): inheritence_complex.type
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: type -> inheritence_complex.type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.type
      [SYMBOL_UPDATE] Function: input_type -> inheritence_complex.type
        [ARG_TYPE] RESOLVED input_type : inheritence_complex.type
        [ARG_TYPE] Processing type annotation for output_type: type
        [CACHE] type -> inheritence_complex.type (cached)
      [SYMBOL_UPDATE] Function: output_type -> inheritence_complex.type
        [ARG_TYPE] RESOLVED output_type : inheritence_complex.type
      [ATTRIBUTE] Found attribute access: self.input_type
    [RESOLVE] Attempting to resolve: ['self', 'input_type']
    [RESOLVE] Chain resolution needed for: ['self', 'input_type']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: inheritence_complex.GenericProcessor)
      [SELF_RESOLVER] resolve(self): inheritence_complex.GenericProcessor
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> inheritence_complex.GenericProcessor
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> inheritence_complex.GenericProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.GenericProcessor.input_type
        [ATTRIBUTE] Resolving attribute: inheritence_complex.GenericProcessor.input_type
        [ATTRIBUTE] Direct match found: inheritence_complex.GenericProcessor.input_type
      [CHAIN] Step 1 resolved: inheritence_complex.GenericProcessor.input_type
    [RESOLVE] RESOLVED to: inheritence_complex.GenericProcessor.input_type
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.GenericProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.GenericProcessor
      -> Not module state
      [NAME] Found name reference: input_type
    [RESOLVE] Attempting to resolve: ['input_type']
      [RESOLVE_SIMPLE] Resolving base: input_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found input_type in function scope: inheritence_complex.type
      [LOCAL_RESOLVER] can_resolve(input_type): True
      [SYMBOL_LOOKUP] Found input_type in function scope: inheritence_complex.type
      [LOCAL_RESOLVER] resolve(input_type): inheritence_complex.type
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: input_type -> inheritence_complex.type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.type
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.output_type
    [RESOLVE] Attempting to resolve: ['self', 'output_type']
    [RESOLVE] Chain resolution needed for: ['self', 'output_type']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.GenericProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.GenericProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.GenericProcessor.output_type
        [ATTRIBUTE] Resolving attribute: inheritence_complex.GenericProcessor.output_type
        [ATTRIBUTE] Direct match found: inheritence_complex.GenericProcessor.output_type
      [CHAIN] Step 1 resolved: inheritence_complex.GenericProcessor.output_type
    [RESOLVE] RESOLVED to: inheritence_complex.GenericProcessor.output_type
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.GenericProcessor (cached)
      -> Not module state
      [NAME] Found name reference: output_type
    [RESOLVE] Attempting to resolve: ['output_type']
      [RESOLVE_SIMPLE] Resolving base: output_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found output_type in function scope: inheritence_complex.type
      [LOCAL_RESOLVER] can_resolve(output_type): True
      [SYMBOL_LOOKUP] Found output_type in function scope: inheritence_complex.type
      [LOCAL_RESOLVER] resolve(output_type): inheritence_complex.type
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: output_type -> inheritence_complex.type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.type
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.type_conversion_cache
    [RESOLVE] Attempting to resolve: ['self', 'type_conversion_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'type_conversion_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.GenericProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.GenericProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.GenericProcessor.type_conversion_cache
        [ATTRIBUTE] Resolving attribute: inheritence_complex.GenericProcessor.type_conversion_cache
        [ATTRIBUTE] Direct match found: inheritence_complex.GenericProcessor.type_conversion_cache
      [CHAIN] Step 1 resolved: inheritence_complex.GenericProcessor.type_conversion_cache
    [RESOLVE] RESOLVED to: inheritence_complex.GenericProcessor.type_conversion_cache
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.GenericProcessor (cached)
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: inheritence_complex.GenericProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: inheritence_complex.GenericProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(str): inheritence_complex.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [NAME] Found name reference: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: inheritence_complex.GenericProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.GenericProcessor.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.GenericProcessor.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.GenericProcessor.process_typed_data
    [CONTEXT] Entered function: inheritence_complex.GenericProcessor.process_typed_data (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'T'}
        [ARG_TYPE] Processing type annotation for data: T
    [RESOLVE] Attempting to resolve: ['T']
      [RESOLVE_SIMPLE] Resolving base: T
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable T not found in any scope
      [LOCAL_RESOLVER] can_resolve(T): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(T): False (current_class: inheritence_complex.GenericProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(T): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(T): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(T): inheritence_complex.T
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: T -> inheritence_complex.T
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.T
      [SYMBOL_UPDATE] Function: data -> inheritence_complex.T
        [ARG_TYPE] RESOLVED data : inheritence_complex.T
      [CALL] Found call: isinstance
    [RESOLVE] Attempting to resolve: ['isinstance']
      [RESOLVE_SIMPLE] Resolving base: isinstance
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable isinstance not found in any scope
      [LOCAL_RESOLVER] can_resolve(isinstance): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(isinstance): False (current_class: inheritence_complex.GenericProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(isinstance): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(isinstance): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(isinstance): inheritence_complex.isinstance
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: isinstance -> inheritence_complex.isinstance
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.isinstance
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found data in function scope: inheritence_complex.T
      [LOCAL_RESOLVER] can_resolve(data): True
      [SYMBOL_LOOKUP] Found data in function scope: inheritence_complex.T
      [LOCAL_RESOLVER] resolve(data): inheritence_complex.T
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: data -> inheritence_complex.T
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.T
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.T
    [RESOLVE] RESOLVED to: inheritence_complex.T
      -> Resolved to state: inheritence_complex.T
      [SYMBOL_LOOKUP] Found data in function scope: inheritence_complex.T
      -> REJECTED (shadowed by local variable)
      [ATTRIBUTE] Found attribute access: self.input_type
    [RESOLVE] Attempting to resolve: ['self', 'input_type']
    [RESOLVE] Chain resolution needed for: ['self', 'input_type']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.GenericProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.GenericProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.GenericProcessor.input_type
        [ATTRIBUTE] Resolving attribute: inheritence_complex.GenericProcessor.input_type
        [ATTRIBUTE] Direct match found: inheritence_complex.GenericProcessor.input_type
      [CHAIN] Step 1 resolved: inheritence_complex.GenericProcessor.input_type
    [RESOLVE] RESOLVED to: inheritence_complex.GenericProcessor.input_type
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.GenericProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.GenericProcessor
      -> Not module state
      [CALL] Found call: TypeError
    [RESOLVE] Attempting to resolve: ['TypeError']
      [RESOLVE_SIMPLE] Resolving base: TypeError
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable TypeError not found in any scope
      [LOCAL_RESOLVER] can_resolve(TypeError): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(TypeError): False (current_class: inheritence_complex.GenericProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(TypeError): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(TypeError): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(TypeError): inheritence_complex.TypeError
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: TypeError -> inheritence_complex.TypeError
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.TypeError
      -> Resolved to: inheritence_complex.TypeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: TypeError
        [CACHE] TypeError -> inheritence_complex.TypeError (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.input_type
        [CACHE] self.input_type -> inheritence_complex.GenericProcessor.input_type (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.GenericProcessor (cached)
      -> Not module state
      [CALL] Found call: type
    [RESOLVE] Attempting to resolve: ['type']
      [RESOLVE_SIMPLE] Resolving base: type
      [CACHE] Hit for type: inheritence_complex.type
    [RESOLVE] RESOLVED to: inheritence_complex.type
      -> Resolved to: inheritence_complex.type
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.T
    [RESOLVE] RESOLVED to: inheritence_complex.T
      [NAME] Found name reference: type
        [CACHE] type -> inheritence_complex.type (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.T (cached)
      -> Resolved to state: inheritence_complex.T
      [SYMBOL_LOOKUP] Found data in function scope: inheritence_complex.T
      -> REJECTED (shadowed by local variable)
      [ASSIGNMENT] Processing: cache_key = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: cache_key
    [RESOLVE] Attempting to resolve: ['cache_key']
      [RESOLVE_SIMPLE] Resolving base: cache_key
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable cache_key not found in any scope
      [LOCAL_RESOLVER] can_resolve(cache_key): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(cache_key): False (current_class: inheritence_complex.GenericProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(cache_key): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(cache_key): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(cache_key): inheritence_complex.cache_key
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: cache_key -> inheritence_complex.cache_key
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.cache_key
      -> Not module state
      [CALL] Found call: type
    [CACHE] type -> inheritence_complex.type (cached)
      -> Resolved to: inheritence_complex.type
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.T
    [RESOLVE] RESOLVED to: inheritence_complex.T
      [NAME] Found name reference: type
        [CACHE] type -> inheritence_complex.type (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.T (cached)
      -> Resolved to state: inheritence_complex.T
      [SYMBOL_LOOKUP] Found data in function scope: inheritence_complex.T
      -> REJECTED (shadowed by local variable)
      [ATTRIBUTE] Found attribute access: self.output_type.__name__
    [RESOLVE] Attempting to resolve: ['self', 'output_type', '__name__']
    [RESOLVE] Chain resolution needed for: ['self', 'output_type', '__name__']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.GenericProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.GenericProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.GenericProcessor.output_type
        [ATTRIBUTE] Resolving attribute: inheritence_complex.GenericProcessor.output_type
        [ATTRIBUTE] Direct match found: inheritence_complex.GenericProcessor.output_type
      [CHAIN] Step 1 resolved: inheritence_complex.GenericProcessor.output_type
      [CHAIN] Step 2: Resolving inheritence_complex.GenericProcessor.output_type.__name__
        [ATTRIBUTE] Resolving attribute: inheritence_complex.GenericProcessor.output_type.__name__
        [ATTRIBUTE] Direct match found: inheritence_complex.GenericProcessor.output_type.__name__
      [CHAIN] Step 2 resolved: inheritence_complex.GenericProcessor.output_type.__name__
    [RESOLVE] RESOLVED to: inheritence_complex.GenericProcessor.output_type.__name__
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.output_type
    [RESOLVE] Attempting to resolve: ['self', 'output_type']
    [RESOLVE] Chain resolution needed for: ['self', 'output_type']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.GenericProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.GenericProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.GenericProcessor.output_type
        [ATTRIBUTE] Resolving attribute: inheritence_complex.GenericProcessor.output_type
        [ATTRIBUTE] Direct match found: inheritence_complex.GenericProcessor.output_type
      [CHAIN] Step 1 resolved: inheritence_complex.GenericProcessor.output_type
    [RESOLVE] RESOLVED to: inheritence_complex.GenericProcessor.output_type
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.GenericProcessor (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> inheritence_complex.cache_key (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.type_conversion_cache
    [RESOLVE] Attempting to resolve: ['self', 'type_conversion_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'type_conversion_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.GenericProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.GenericProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.GenericProcessor.type_conversion_cache
        [ATTRIBUTE] Resolving attribute: inheritence_complex.GenericProcessor.type_conversion_cache
        [ATTRIBUTE] Direct match found: inheritence_complex.GenericProcessor.type_conversion_cache
      [CHAIN] Step 1 resolved: inheritence_complex.GenericProcessor.type_conversion_cache
    [RESOLVE] RESOLVED to: inheritence_complex.GenericProcessor.type_conversion_cache
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.GenericProcessor (cached)
      -> Not module state
      [ASSIGNMENT] Processing: converter = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: converter
    [RESOLVE] Attempting to resolve: ['converter']
      [RESOLVE_SIMPLE] Resolving base: converter
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable converter not found in any scope
      [LOCAL_RESOLVER] can_resolve(converter): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(converter): False (current_class: inheritence_complex.GenericProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(converter): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(converter): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(converter): inheritence_complex.converter
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: converter -> inheritence_complex.converter
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.converter
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.type_conversion_cache
        [CACHE] self.type_conversion_cache -> inheritence_complex.GenericProcessor.type_conversion_cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.GenericProcessor (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> inheritence_complex.cache_key (cached)
      -> Not module state
      [ASSIGNMENT] Processing: converter = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self._create_type_converter
    [RESOLVE] Attempting to resolve: ['self', '_create_type_converter']
    [RESOLVE] Chain resolution needed for: ['self', '_create_type_converter']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.GenericProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.GenericProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.GenericProcessor._create_type_converter
        [ATTRIBUTE] Resolving attribute: inheritence_complex.GenericProcessor._create_type_converter
        [ATTRIBUTE] Direct match found: inheritence_complex.GenericProcessor._create_type_converter
      [CHAIN] Step 1 resolved: inheritence_complex.GenericProcessor._create_type_converter
    [RESOLVE] RESOLVED to: inheritence_complex.GenericProcessor._create_type_converter
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.GenericProcessor._create_type_converter
        [RETURN_TYPE_RESOLUTION] Resolving return type: callable
        [RETURN_TYPE_RESOLUTION] Class 'callable' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: callable
      [TYPE_INFERENCE] Could not resolve return type 'callable' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: callable (from return type - unresolved)
      [SYMBOL_UPDATE] Function: converter -> callable
        [ASSIGNMENT] RESOLVED Updated symbol table: converter = callable
      [NAME] Found name reference: converter
        [CACHE] converter -> inheritence_complex.converter (cached)
      -> Not module state
      [CALL] Found call: self._create_type_converter
    [RESOLVE] Attempting to resolve: ['self', '_create_type_converter']
    [RESOLVE] Chain resolution needed for: ['self', '_create_type_converter']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.GenericProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.GenericProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.GenericProcessor._create_type_converter
        [ATTRIBUTE] Resolving attribute: inheritence_complex.GenericProcessor._create_type_converter
        [ATTRIBUTE] Direct match found: inheritence_complex.GenericProcessor._create_type_converter
      [CHAIN] Step 1 resolved: inheritence_complex.GenericProcessor._create_type_converter
    [RESOLVE] RESOLVED to: inheritence_complex.GenericProcessor._create_type_converter
            [INTERMEDIATE] Tracking chain steps for: self._create_type_converter
            [INTERMEDIATE] Step 1: self._create_type_converter
      -> Resolved to: inheritence_complex.GenericProcessor._create_type_converter
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self._create_type_converter
        [CACHE] self._create_type_converter -> inheritence_complex.GenericProcessor._create_type_converter (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.GenericProcessor (cached)
      -> Not module state
      [CALL] Found call: type
    [CACHE] type -> inheritence_complex.type (cached)
      -> Resolved to: inheritence_complex.type
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.T
    [RESOLVE] RESOLVED to: inheritence_complex.T
      [NAME] Found name reference: type
        [CACHE] type -> inheritence_complex.type (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.T (cached)
      -> Resolved to state: inheritence_complex.T
      [SYMBOL_LOOKUP] Found data in function scope: inheritence_complex.T
      -> REJECTED (shadowed by local variable)
      [ATTRIBUTE] Found attribute access: self.output_type
        [CACHE] self.output_type -> inheritence_complex.GenericProcessor.output_type (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.GenericProcessor (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.type_conversion_cache
        [CACHE] self.type_conversion_cache -> inheritence_complex.GenericProcessor.type_conversion_cache (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.GenericProcessor (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> inheritence_complex.cache_key (cached)
      -> Not module state
      [NAME] Found name reference: converter
        [CACHE] converter -> inheritence_complex.converter (cached)
      -> Not module state
      [CALL] Found call: converter
    [CACHE] converter -> inheritence_complex.converter (cached)
      -> Resolved to: inheritence_complex.converter
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.T
    [RESOLVE] RESOLVED to: inheritence_complex.T
      [NAME] Found name reference: converter
        [CACHE] converter -> inheritence_complex.converter (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.T (cached)
      -> Resolved to state: inheritence_complex.T
      [SYMBOL_LOOKUP] Found data in function scope: inheritence_complex.T
      -> REJECTED (shadowed by local variable)
    [CONTEXT] Exited function: inheritence_complex.GenericProcessor.process_typed_data
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.GenericProcessor.process_typed_data
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.GenericProcessor._create_type_converter
    [CONTEXT] Entered function: inheritence_complex.GenericProcessor._create_type_converter (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'from_type': 'type', 'to_type': 'type'}
        [ARG_TYPE] Processing type annotation for from_type: type
    [RESOLVE] Attempting to resolve: ['type']
      [RESOLVE_SIMPLE] Resolving base: type
      [CACHE] Hit for type: inheritence_complex.type
    [RESOLVE] RESOLVED to: inheritence_complex.type
      [SYMBOL_UPDATE] Function: from_type -> inheritence_complex.type
        [ARG_TYPE] RESOLVED from_type : inheritence_complex.type
        [ARG_TYPE] Processing type annotation for to_type: type
        [CACHE] type -> inheritence_complex.type (cached)
      [SYMBOL_UPDATE] Function: to_type -> inheritence_complex.type
        [ARG_TYPE] RESOLVED to_type : inheritence_complex.type
      [NAME] Found name reference: from_type
    [RESOLVE] Attempting to resolve: ['from_type']
      [RESOLVE_SIMPLE] Resolving base: from_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found from_type in function scope: inheritence_complex.type
      [LOCAL_RESOLVER] can_resolve(from_type): True
      [SYMBOL_LOOKUP] Found from_type in function scope: inheritence_complex.type
      [LOCAL_RESOLVER] resolve(from_type): inheritence_complex.type
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: from_type -> inheritence_complex.type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.type
      -> Not module state
      [NAME] Found name reference: to_type
    [RESOLVE] Attempting to resolve: ['to_type']
      [RESOLVE_SIMPLE] Resolving base: to_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found to_type in function scope: inheritence_complex.type
      [LOCAL_RESOLVER] can_resolve(to_type): True
      [SYMBOL_LOOKUP] Found to_type in function scope: inheritence_complex.type
      [LOCAL_RESOLVER] resolve(to_type): inheritence_complex.type
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: to_type -> inheritence_complex.type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.type
      -> Not module state
      [NAME] Found name reference: x
    [RESOLVE] Attempting to resolve: ['x']
      [RESOLVE_SIMPLE] Resolving base: x
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable x not found in any scope
      [LOCAL_RESOLVER] can_resolve(x): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(x): False (current_class: inheritence_complex.GenericProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(x): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(x): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(x): inheritence_complex.x
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: x -> inheritence_complex.x
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.x
      -> Not module state
      [NAME] Found name reference: to_type
        [CACHE] to_type -> inheritence_complex.type (cached)
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: to_type
        [CACHE] to_type -> inheritence_complex.type (cached)
      -> Not module state
      [NAME] Found name reference: int
    [RESOLVE] Attempting to resolve: ['int']
      [RESOLVE_SIMPLE] Resolving base: int
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable int not found in any scope
      [LOCAL_RESOLVER] can_resolve(int): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(int): False (current_class: inheritence_complex.GenericProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(int): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(int): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(int): inheritence_complex.int
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: int -> inheritence_complex.int
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.int
      -> Not module state
      [NAME] Found name reference: from_type
        [CACHE] from_type -> inheritence_complex.type (cached)
      -> Not module state
      [NAME] Found name reference: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable float not found in any scope
      [LOCAL_RESOLVER] can_resolve(float): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(float): False (current_class: inheritence_complex.GenericProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(float): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(float): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(float): inheritence_complex.float
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: float -> inheritence_complex.float
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.float
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: int
        [CACHE] int -> inheritence_complex.int (cached)
      -> Not module state
      [NAME] Found name reference: to_type
        [CACHE] to_type -> inheritence_complex.type (cached)
      -> Not module state
      [NAME] Found name reference: float
        [CACHE] float -> inheritence_complex.float (cached)
      -> Not module state
      [NAME] Found name reference: from_type
        [CACHE] from_type -> inheritence_complex.type (cached)
      -> Not module state
      [NAME] Found name reference: int
        [CACHE] int -> inheritence_complex.int (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: float
        [CACHE] float -> inheritence_complex.float (cached)
      -> Not module state
      [CALL] Found call: to_type
    [CACHE] to_type -> inheritence_complex.type (cached)
      -> Resolved to: inheritence_complex.type
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: x
    [RESOLVE] Attempting to resolve: ['x']
      [RESOLVE_SIMPLE] Resolving base: x
      [CACHE] Hit for x: inheritence_complex.x
    [RESOLVE] RESOLVED to: inheritence_complex.x
      [NAME] Found name reference: to_type
        [CACHE] to_type -> inheritence_complex.type (cached)
      -> Not module state
      [NAME] Found name reference: x
        [CACHE] x -> inheritence_complex.x (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.GenericProcessor._create_type_converter
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.GenericProcessor._create_type_converter
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: inheritence_complex.GenericProcessor
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: UltimateProcessor
    [CONTEXT] Entered class: inheritence_complex.UltimateProcessor
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.UltimateProcessor.__init__
    [CONTEXT] Entered function: inheritence_complex.UltimateProcessor.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'processor_id': 'str'}
        [ARG_TYPE] Processing type annotation for processor_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(str): inheritence_complex.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [SYMBOL_UPDATE] Function: processor_id -> inheritence_complex.str
        [ARG_TYPE] RESOLVED processor_id : inheritence_complex.str
      [CALL] Found call: SpecializedProcessor.__init__
    [RESOLVE] Attempting to resolve: ['SpecializedProcessor', '__init__']
    [RESOLVE] Chain resolution needed for: ['SpecializedProcessor', '__init__']
      [CHAIN] Resolving base: SpecializedProcessor
      [RESOLVE_SIMPLE] Resolving base: SpecializedProcessor
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable SpecializedProcessor not found in any scope
      [LOCAL_RESOLVER] can_resolve(SpecializedProcessor): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(SpecializedProcessor): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(SpecializedProcessor): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(SpecializedProcessor): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(SpecializedProcessor): inheritence_complex.SpecializedProcessor
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: SpecializedProcessor -> inheritence_complex.SpecializedProcessor
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: SpecializedProcessor -> inheritence_complex.SpecializedProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.SpecializedProcessor.__init__
        [ATTRIBUTE] Resolving attribute: inheritence_complex.SpecializedProcessor.__init__
        [ATTRIBUTE] Direct match found: inheritence_complex.SpecializedProcessor.__init__
      [CHAIN] Step 1 resolved: inheritence_complex.SpecializedProcessor.__init__
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor.__init__
            [INTERMEDIATE] Tracking chain steps for: SpecializedProcessor.__init__
            [INTERMEDIATE] Step 1: SpecializedProcessor.__init__
      -> Resolved to: inheritence_complex.SpecializedProcessor.__init__
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: inheritence_complex.UltimateProcessor)
      [SELF_RESOLVER] resolve(self): inheritence_complex.UltimateProcessor
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> inheritence_complex.UltimateProcessor
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor
        [FUNCTION_ARG] Checking argument: processor_id
    [RESOLVE] Attempting to resolve: ['processor_id']
      [RESOLVE_SIMPLE] Resolving base: processor_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found processor_id in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] can_resolve(processor_id): True
      [SYMBOL_LOOKUP] Found processor_id in function scope: inheritence_complex.str
      [LOCAL_RESOLVER] resolve(processor_id): inheritence_complex.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: processor_id -> inheritence_complex.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.str
      [ATTRIBUTE] Found attribute access: SpecializedProcessor.__init__
        [CACHE] SpecializedProcessor.__init__ -> inheritence_complex.SpecializedProcessor.__init__ (cached)
      -> Not module state
      [NAME] Found name reference: SpecializedProcessor
    [RESOLVE] Attempting to resolve: ['SpecializedProcessor']
      [RESOLVE_SIMPLE] Resolving base: SpecializedProcessor
      [CACHE] Hit for SpecializedProcessor: inheritence_complex.SpecializedProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor
      -> Not module state
      [NAME] Found name reference: processor_id
    [RESOLVE] Attempting to resolve: ['processor_id']
      [RESOLVE_SIMPLE] Resolving base: processor_id
      [CACHE] Hit for processor_id: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [CALL] Found call: GenericProcessor.__init__
    [RESOLVE] Attempting to resolve: ['GenericProcessor', '__init__']
    [RESOLVE] Chain resolution needed for: ['GenericProcessor', '__init__']
      [CHAIN] Resolving base: GenericProcessor
      [RESOLVE_SIMPLE] Resolving base: GenericProcessor
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable GenericProcessor not found in any scope
      [LOCAL_RESOLVER] can_resolve(GenericProcessor): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(GenericProcessor): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(GenericProcessor): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(GenericProcessor): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(GenericProcessor): inheritence_complex.GenericProcessor
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: GenericProcessor -> inheritence_complex.GenericProcessor
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: GenericProcessor -> inheritence_complex.GenericProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.GenericProcessor.__init__
        [ATTRIBUTE] Resolving attribute: inheritence_complex.GenericProcessor.__init__
        [ATTRIBUTE] Direct match found: inheritence_complex.GenericProcessor.__init__
      [CHAIN] Step 1 resolved: inheritence_complex.GenericProcessor.__init__
    [RESOLVE] RESOLVED to: inheritence_complex.GenericProcessor.__init__
            [INTERMEDIATE] Tracking chain steps for: GenericProcessor.__init__
            [INTERMEDIATE] Step 1: GenericProcessor.__init__
      -> Resolved to: inheritence_complex.GenericProcessor.__init__
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor
        [FUNCTION_ARG] Checking argument: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(dict): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(dict): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(dict): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(dict): inheritence_complex.dict
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: dict -> inheritence_complex.dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.dict
        [FUNCTION_ARG] Checking argument: ProcessingResult
    [RESOLVE] Attempting to resolve: ['ProcessingResult']
      [RESOLVE_SIMPLE] Resolving base: ProcessingResult
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ProcessingResult not found in any scope
      [LOCAL_RESOLVER] can_resolve(ProcessingResult): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ProcessingResult): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ProcessingResult): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ProcessingResult): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(ProcessingResult): inheritence_complex.ProcessingResult
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ProcessingResult -> inheritence_complex.ProcessingResult
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.ProcessingResult
      [ATTRIBUTE] Found attribute access: GenericProcessor.__init__
        [CACHE] GenericProcessor.__init__ -> inheritence_complex.GenericProcessor.__init__ (cached)
      -> Not module state
      [NAME] Found name reference: GenericProcessor
    [RESOLVE] Attempting to resolve: ['GenericProcessor']
      [RESOLVE_SIMPLE] Resolving base: GenericProcessor
      [CACHE] Hit for GenericProcessor: inheritence_complex.GenericProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.GenericProcessor
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.UltimateProcessor (cached)
      -> Not module state
      [NAME] Found name reference: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      -> Not module state
      [NAME] Found name reference: ProcessingResult
    [RESOLVE] Attempting to resolve: ['ProcessingResult']
      [RESOLVE_SIMPLE] Resolving base: ProcessingResult
      [CACHE] Hit for ProcessingResult: inheritence_complex.ProcessingResult
    [RESOLVE] RESOLVED to: inheritence_complex.ProcessingResult
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.ultimate_features_enabled
    [RESOLVE] Attempting to resolve: ['self', 'ultimate_features_enabled']
    [RESOLVE] Chain resolution needed for: ['self', 'ultimate_features_enabled']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.ultimate_features_enabled
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.ultimate_features_enabled
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.ultimate_features_enabled
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.ultimate_features_enabled
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.ultimate_features_enabled
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.UltimateProcessor (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cross_references
    [RESOLVE] Attempting to resolve: ['self', 'cross_references']
    [RESOLVE] Chain resolution needed for: ['self', 'cross_references']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.cross_references
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.cross_references
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.cross_references
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.cross_references
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.cross_references
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.UltimateProcessor (cached)
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.UltimateProcessor.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.UltimateProcessor.__init__
        Calls: 2
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.UltimateProcessor.ultimate_process
    [DECORATOR] @trace
    [DECORATOR] @monitor_performance
    [DECORATOR] @validate_auth(required_role='admin')
    [CONTEXT] Entered function: inheritence_complex.UltimateProcessor.ultimate_process (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Dict[str, Any]'}
      [ASSIGNMENT] Processing: typed_result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.process_typed_data
    [RESOLVE] Attempting to resolve: ['self', 'process_typed_data']
    [RESOLVE] Chain resolution needed for: ['self', 'process_typed_data']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.process_typed_data
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.process_typed_data
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.process_typed_data
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.process_typed_data
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.process_typed_data
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.UltimateProcessor.process_typed_data
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for typed_result
      [NAME] Found name reference: typed_result
    [RESOLVE] Attempting to resolve: ['typed_result']
      [RESOLVE_SIMPLE] Resolving base: typed_result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable typed_result not found in any scope
      [LOCAL_RESOLVER] can_resolve(typed_result): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(typed_result): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(typed_result): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(typed_result): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(typed_result): inheritence_complex.typed_result
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: typed_result -> inheritence_complex.typed_result
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.typed_result
      -> Not module state
      [CALL] Found call: self.process_typed_data
    [RESOLVE] Attempting to resolve: ['self', 'process_typed_data']
    [RESOLVE] Chain resolution needed for: ['self', 'process_typed_data']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.process_typed_data
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.process_typed_data
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.process_typed_data
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.process_typed_data
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.process_typed_data
            [INTERMEDIATE] Tracking chain steps for: self.process_typed_data
            [INTERMEDIATE] Step 1: self.process_typed_data
      -> Resolved to: inheritence_complex.UltimateProcessor.process_typed_data
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable data not found in any scope
      [LOCAL_RESOLVER] can_resolve(data): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(data): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(data): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(data): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(data): inheritence_complex.data
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: data -> inheritence_complex.data
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.data
      [ATTRIBUTE] Found attribute access: self.process_typed_data
        [CACHE] self.process_typed_data -> inheritence_complex.UltimateProcessor.process_typed_data (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
      -> Not module state
      [CALL] Found call: isinstance
    [RESOLVE] Attempting to resolve: ['isinstance']
      [RESOLVE_SIMPLE] Resolving base: isinstance
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable isinstance not found in any scope
      [LOCAL_RESOLVER] can_resolve(isinstance): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(isinstance): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(isinstance): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(isinstance): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(isinstance): inheritence_complex.isinstance
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: isinstance -> inheritence_complex.isinstance
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.isinstance
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: typed_result
    [RESOLVE] Attempting to resolve: ['typed_result']
      [RESOLVE_SIMPLE] Resolving base: typed_result
      [CACHE] Hit for typed_result: inheritence_complex.typed_result
    [RESOLVE] RESOLVED to: inheritence_complex.typed_result
        [FUNCTION_ARG] Checking argument: ProcessingResult
    [RESOLVE] Attempting to resolve: ['ProcessingResult']
      [RESOLVE_SIMPLE] Resolving base: ProcessingResult
      [CACHE] Hit for ProcessingResult: inheritence_complex.ProcessingResult
    [RESOLVE] RESOLVED to: inheritence_complex.ProcessingResult
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: typed_result
        [CACHE] typed_result -> inheritence_complex.typed_result (cached)
      -> Not module state
      [NAME] Found name reference: ProcessingResult
    [RESOLVE] Attempting to resolve: ['ProcessingResult']
      [RESOLVE_SIMPLE] Resolving base: ProcessingResult
      [CACHE] Hit for ProcessingResult: inheritence_complex.ProcessingResult
    [RESOLVE] RESOLVED to: inheritence_complex.ProcessingResult
      -> Not module state
      [NAME] Found name reference: typed_result
        [CACHE] typed_result -> inheritence_complex.typed_result (cached)
      -> Not module state
      [ASSIGNMENT] Processing: specialized_result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.process_data
    [RESOLVE] Attempting to resolve: ['self', 'process_data']
    [RESOLVE] Chain resolution needed for: ['self', 'process_data']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.process_data
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.process_data
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.process_data
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.process_data
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.process_data
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.UltimateProcessor.process_data
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for specialized_result
      [NAME] Found name reference: specialized_result
    [RESOLVE] Attempting to resolve: ['specialized_result']
      [RESOLVE_SIMPLE] Resolving base: specialized_result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable specialized_result not found in any scope
      [LOCAL_RESOLVER] can_resolve(specialized_result): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(specialized_result): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(specialized_result): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(specialized_result): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(specialized_result): inheritence_complex.specialized_result
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: specialized_result -> inheritence_complex.specialized_result
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.specialized_result
      -> Not module state
      [CALL] Found call: self.process_data
    [RESOLVE] Attempting to resolve: ['self', 'process_data']
    [RESOLVE] Chain resolution needed for: ['self', 'process_data']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.process_data
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.process_data
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.process_data
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.process_data
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.process_data
            [INTERMEDIATE] Tracking chain steps for: self.process_data
            [INTERMEDIATE] Step 1: self.process_data
      -> Resolved to: inheritence_complex.UltimateProcessor.process_data
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
      [ATTRIBUTE] Found attribute access: self.process_data
        [CACHE] self.process_data -> inheritence_complex.UltimateProcessor.process_data (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.UltimateProcessor (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.data (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: specialized_result.success
    [RESOLVE] Attempting to resolve: ['specialized_result', 'success']
    [RESOLVE] Chain resolution needed for: ['specialized_result', 'success']
      [CHAIN] Resolving base: specialized_result
      [RESOLVE_SIMPLE] Resolving base: specialized_result
      [CACHE] Hit for specialized_result: inheritence_complex.specialized_result
      [CHAIN] Base resolved: specialized_result -> inheritence_complex.specialized_result
      [CHAIN] Step 1: Resolving inheritence_complex.specialized_result.success
        [ATTRIBUTE] Resolving attribute: inheritence_complex.specialized_result.success
        [ATTRIBUTE] Direct match found: inheritence_complex.specialized_result.success
      [CHAIN] Step 1 resolved: inheritence_complex.specialized_result.success
    [RESOLVE] RESOLVED to: inheritence_complex.specialized_result.success
      -> Not module state
      [NAME] Found name reference: specialized_result
        [CACHE] specialized_result -> inheritence_complex.specialized_result (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.ultimate_features_enabled
    [RESOLVE] Attempting to resolve: ['self', 'ultimate_features_enabled']
    [RESOLVE] Chain resolution needed for: ['self', 'ultimate_features_enabled']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.ultimate_features_enabled
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.ultimate_features_enabled
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.ultimate_features_enabled
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.ultimate_features_enabled
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.ultimate_features_enabled
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.UltimateProcessor (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: specialized_result.data
    [RESOLVE] Attempting to resolve: ['specialized_result', 'data']
    [RESOLVE] Chain resolution needed for: ['specialized_result', 'data']
      [CHAIN] Resolving base: specialized_result
      [RESOLVE_SIMPLE] Resolving base: specialized_result
      [CACHE] Hit for specialized_result: inheritence_complex.specialized_result
      [CHAIN] Base resolved: specialized_result -> inheritence_complex.specialized_result
      [CHAIN] Step 1: Resolving inheritence_complex.specialized_result.data
        [ATTRIBUTE] Resolving attribute: inheritence_complex.specialized_result.data
        [ATTRIBUTE] Direct match found: inheritence_complex.specialized_result.data
      [CHAIN] Step 1 resolved: inheritence_complex.specialized_result.data
    [RESOLVE] RESOLVED to: inheritence_complex.specialized_result.data
      -> Not module state
      [NAME] Found name reference: specialized_result
        [CACHE] specialized_result -> inheritence_complex.specialized_result (cached)
      -> Not module state
      [CALL] Found call: self._apply_ultimate_enhancements
    [RESOLVE] Attempting to resolve: ['self', '_apply_ultimate_enhancements']
    [RESOLVE] Chain resolution needed for: ['self', '_apply_ultimate_enhancements']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor._apply_ultimate_enhancements
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor._apply_ultimate_enhancements
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor._apply_ultimate_enhancements
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor._apply_ultimate_enhancements
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor._apply_ultimate_enhancements
            [INTERMEDIATE] Tracking chain steps for: self._apply_ultimate_enhancements
            [INTERMEDIATE] Step 1: self._apply_ultimate_enhancements
      -> Resolved to: inheritence_complex.UltimateProcessor._apply_ultimate_enhancements
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self._apply_ultimate_enhancements
        [CACHE] self._apply_ultimate_enhancements -> inheritence_complex.UltimateProcessor._apply_ultimate_enhancements (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.UltimateProcessor (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: specialized_result.data
        [CACHE] specialized_result.data -> inheritence_complex.specialized_result.data (cached)
      -> Not module state
      [NAME] Found name reference: specialized_result
        [CACHE] specialized_result -> inheritence_complex.specialized_result (cached)
      -> Not module state
      [CALL] Found call: specialized_result.metrics.update
    [RESOLVE] Attempting to resolve: ['specialized_result', 'metrics', 'update']
    [RESOLVE] Chain resolution needed for: ['specialized_result', 'metrics', 'update']
      [CHAIN] Resolving base: specialized_result
      [RESOLVE_SIMPLE] Resolving base: specialized_result
      [CACHE] Hit for specialized_result: inheritence_complex.specialized_result
      [CHAIN] Base resolved: specialized_result -> inheritence_complex.specialized_result
      [CHAIN] Step 1: Resolving inheritence_complex.specialized_result.metrics
        [ATTRIBUTE] Resolving attribute: inheritence_complex.specialized_result.metrics
        [ATTRIBUTE] Direct match found: inheritence_complex.specialized_result.metrics
      [CHAIN] Step 1 resolved: inheritence_complex.specialized_result.metrics
      [CHAIN] Step 2: Resolving inheritence_complex.specialized_result.metrics.update
        [ATTRIBUTE] Resolving attribute: inheritence_complex.specialized_result.metrics.update
        [ATTRIBUTE] Direct match found: inheritence_complex.specialized_result.metrics.update
      [CHAIN] Step 2 resolved: inheritence_complex.specialized_result.metrics.update
    [RESOLVE] RESOLVED to: inheritence_complex.specialized_result.metrics.update
            [INTERMEDIATE] Tracking chain steps for: specialized_result.metrics.update
            [INTERMEDIATE] Step 1: specialized_result.metrics
    [RESOLVE] Attempting to resolve: ['specialized_result', 'metrics']
    [RESOLVE] Chain resolution needed for: ['specialized_result', 'metrics']
      [CHAIN] Resolving base: specialized_result
      [RESOLVE_SIMPLE] Resolving base: specialized_result
      [CACHE] Hit for specialized_result: inheritence_complex.specialized_result
      [CHAIN] Base resolved: specialized_result -> inheritence_complex.specialized_result
      [CHAIN] Step 1: Resolving inheritence_complex.specialized_result.metrics
        [ATTRIBUTE] Resolving attribute: inheritence_complex.specialized_result.metrics
        [ATTRIBUTE] Direct match found: inheritence_complex.specialized_result.metrics
      [CHAIN] Step 1 resolved: inheritence_complex.specialized_result.metrics
    [RESOLVE] RESOLVED to: inheritence_complex.specialized_result.metrics
            [INTERMEDIATE] Step 1 resolved to: inheritence_complex.specialized_result.metrics
            [INTERMEDIATE] Step 2: specialized_result.metrics.update
      -> Resolved to: inheritence_complex.specialized_result.metrics.update
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: specialized_result.metrics.update
        [CACHE] specialized_result.metrics.update -> inheritence_complex.specialized_result.metrics.update (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: specialized_result.metrics
        [CACHE] specialized_result.metrics -> inheritence_complex.specialized_result.metrics (cached)
      -> Not module state
      [NAME] Found name reference: specialized_result
        [CACHE] specialized_result -> inheritence_complex.specialized_result (cached)
      -> Not module state
      [NAME] Found name reference: specialized_result
        [CACHE] specialized_result -> inheritence_complex.specialized_result (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.UltimateProcessor.ultimate_process
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.UltimateProcessor.ultimate_process
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.UltimateProcessor._apply_ultimate_enhancements
    [CONTEXT] Entered function: inheritence_complex.UltimateProcessor._apply_ultimate_enhancements (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data': 'Any'}
        [ARG_TYPE] Processing type annotation for data: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [CACHE] Hit for Any: typing.Any
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data -> typing.Any
        [ARG_TYPE] RESOLVED data : typing.Any
      [CALL] Found call: isinstance
    [RESOLVE] Attempting to resolve: ['isinstance']
      [RESOLVE_SIMPLE] Resolving base: isinstance
      [CACHE] Hit for isinstance: inheritence_complex.isinstance
    [RESOLVE] RESOLVED to: inheritence_complex.isinstance
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
        [FUNCTION_ARG] Checking argument: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
    [RESOLVE] RESOLVED to: inheritence_complex.data
      -> Not module state
      [NAME] Found name reference: dict
    [RESOLVE] Attempting to resolve: ['dict']
      [RESOLVE_SIMPLE] Resolving base: dict
      [CACHE] Hit for dict: inheritence_complex.dict
    [RESOLVE] RESOLVED to: inheritence_complex.dict
      -> Not module state
      [ASSIGNMENT] Processing: enhanced = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: enhanced
    [RESOLVE] Attempting to resolve: ['enhanced']
      [RESOLVE_SIMPLE] Resolving base: enhanced
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable enhanced not found in any scope
      [LOCAL_RESOLVER] can_resolve(enhanced): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(enhanced): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(enhanced): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(enhanced): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(enhanced): inheritence_complex.enhanced
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: enhanced -> inheritence_complex.enhanced
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.enhanced
      -> Not module state
      [NAME] Found name reference: key
    [RESOLVE] Attempting to resolve: ['key']
      [RESOLVE_SIMPLE] Resolving base: key
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable key not found in any scope
      [LOCAL_RESOLVER] can_resolve(key): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(key): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(key): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(key): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(key): inheritence_complex.key
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: key -> inheritence_complex.key
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.key
      -> Not module state
      [NAME] Found name reference: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable value not found in any scope
      [LOCAL_RESOLVER] can_resolve(value): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(value): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(value): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(value): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(value): inheritence_complex.value
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: value -> inheritence_complex.value
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.value
      -> Not module state
      [CALL] Found call: data.items
    [RESOLVE] Attempting to resolve: ['data', 'items']
    [RESOLVE] Chain resolution needed for: ['data', 'items']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: inheritence_complex.data
      [CHAIN] Base resolved: data -> inheritence_complex.data
      [CHAIN] Step 1: Resolving inheritence_complex.data.items
        [ATTRIBUTE] Resolving attribute: inheritence_complex.data.items
        [ATTRIBUTE] Direct match found: inheritence_complex.data.items
      [CHAIN] Step 1 resolved: inheritence_complex.data.items
    [RESOLVE] RESOLVED to: inheritence_complex.data.items
            [INTERMEDIATE] Tracking chain steps for: data.items
            [INTERMEDIATE] Step 1: data.items
      -> Resolved to: inheritence_complex.data.items
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: data.items
        [CACHE] data.items -> inheritence_complex.data.items (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.data (cached)
      -> Not module state
      [NAME] Found name reference: enhanced
        [CACHE] enhanced -> inheritence_complex.enhanced (cached)
      -> Not module state
      [NAME] Found name reference: key
        [CACHE] key -> inheritence_complex.key (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> inheritence_complex.value (cached)
      -> Not module state
      [CALL] Found call: isinstance
    [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Resolved to: inheritence_complex.isinstance
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: value
    [RESOLVE] Attempting to resolve: ['value']
      [RESOLVE_SIMPLE] Resolving base: value
      [CACHE] Hit for value: inheritence_complex.value
    [RESOLVE] RESOLVED to: inheritence_complex.value
      [NAME] Found name reference: isinstance
        [CACHE] isinstance -> inheritence_complex.isinstance (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> inheritence_complex.value (cached)
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: inheritence_complex.str
    [RESOLVE] RESOLVED to: inheritence_complex.str
      -> Not module state
      [NAME] Found name reference: int
    [RESOLVE] Attempting to resolve: ['int']
      [RESOLVE_SIMPLE] Resolving base: int
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable int not found in any scope
      [LOCAL_RESOLVER] can_resolve(int): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(int): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(int): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(int): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(int): inheritence_complex.int
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: int -> inheritence_complex.int
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.int
      -> Not module state
      [ASSIGNMENT] Processing: ref_key = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: ref_key
    [RESOLVE] Attempting to resolve: ['ref_key']
      [RESOLVE_SIMPLE] Resolving base: ref_key
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ref_key not found in any scope
      [LOCAL_RESOLVER] can_resolve(ref_key): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ref_key): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ref_key): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ref_key): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(ref_key): inheritence_complex.ref_key
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ref_key -> inheritence_complex.ref_key
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.ref_key
      -> Not module state
      [CALL] Found call: hash
    [RESOLVE] Attempting to resolve: ['hash']
      [RESOLVE_SIMPLE] Resolving base: hash
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable hash not found in any scope
      [LOCAL_RESOLVER] can_resolve(hash): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(hash): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(hash): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(hash): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(hash): inheritence_complex.hash
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: hash -> inheritence_complex.hash
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.hash
      -> Resolved to: inheritence_complex.hash
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: hash
        [CACHE] hash -> inheritence_complex.hash (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
        [CACHE] str -> inheritence_complex.str (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> inheritence_complex.value (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cross_references
    [RESOLVE] Attempting to resolve: ['self', 'cross_references']
    [RESOLVE] Chain resolution needed for: ['self', 'cross_references']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.cross_references
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.cross_references
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.cross_references
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.cross_references
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.cross_references
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor
      -> Not module state
      [NAME] Found name reference: ref_key
        [CACHE] ref_key -> inheritence_complex.ref_key (cached)
      -> Not module state
      [NAME] Found name reference: value
        [CACHE] value -> inheritence_complex.value (cached)
      -> Not module state
      [NAME] Found name reference: enhanced
        [CACHE] enhanced -> inheritence_complex.enhanced (cached)
      -> Not module state
      [NAME] Found name reference: key
        [CACHE] key -> inheritence_complex.key (cached)
      -> Not module state
      [NAME] Found name reference: ref_key
        [CACHE] ref_key -> inheritence_complex.ref_key (cached)
      -> Not module state
      [NAME] Found name reference: enhanced
        [CACHE] enhanced -> inheritence_complex.enhanced (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> inheritence_complex.data (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.UltimateProcessor._apply_ultimate_enhancements
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.UltimateProcessor._apply_ultimate_enhancements
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.UltimateProcessor.ultimate_processing_context
    [DECORATOR] @contextmanager
      [CODE_STANDARD_VIOLATION] MISSING_RETURN_TYPE: Function inheritence_complex.UltimateProcessor.ultimate_processing_context
      [IMPACT] Cannot infer return type - chained method calls may fail
      [ACTION_REQUIRED] Add appropriate type annotation
      [CODE_QUALITY] Found 1 violations in inheritence_complex.UltimateProcessor.ultimate_processing_context
    [CONTEXT] Entered function: inheritence_complex.UltimateProcessor.ultimate_processing_context (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ASSIGNMENT] Processing: original_features = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: original_features
    [RESOLVE] Attempting to resolve: ['original_features']
      [RESOLVE_SIMPLE] Resolving base: original_features
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable original_features not found in any scope
      [LOCAL_RESOLVER] can_resolve(original_features): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(original_features): False (current_class: inheritence_complex.UltimateProcessor)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(original_features): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(original_features): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(original_features): inheritence_complex.original_features
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: original_features -> inheritence_complex.original_features
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.original_features
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.ultimate_features_enabled
    [RESOLVE] Attempting to resolve: ['self', 'ultimate_features_enabled']
    [RESOLVE] Chain resolution needed for: ['self', 'ultimate_features_enabled']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.ultimate_features_enabled
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.ultimate_features_enabled
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.ultimate_features_enabled
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.ultimate_features_enabled
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.ultimate_features_enabled
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.ultimate_features_enabled
        [CACHE] self.ultimate_features_enabled -> inheritence_complex.UltimateProcessor.ultimate_features_enabled (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.UltimateProcessor (cached)
      -> Not module state
      [CALL] Found call: self.log_operation
    [RESOLVE] Attempting to resolve: ['self', 'log_operation']
    [RESOLVE] Chain resolution needed for: ['self', 'log_operation']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: self -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.log_operation
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.log_operation
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.log_operation
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.log_operation
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.log_operation
            [INTERMEDIATE] Tracking chain steps for: self.log_operation
            [INTERMEDIATE] Step 1: self.log_operation
      -> Resolved to: inheritence_complex.UltimateProcessor.log_operation
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.log_operation
        [CACHE] self.log_operation -> inheritence_complex.UltimateProcessor.log_operation (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.UltimateProcessor (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.UltimateProcessor (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.ultimate_features_enabled
        [CACHE] self.ultimate_features_enabled -> inheritence_complex.UltimateProcessor.ultimate_features_enabled (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.UltimateProcessor (cached)
      -> Not module state
      [NAME] Found name reference: original_features
        [CACHE] original_features -> inheritence_complex.original_features (cached)
      -> Not module state
      [CALL] Found call: self.log_operation
    [CACHE] self.log_operation -> inheritence_complex.UltimateProcessor.log_operation (cached)
            [INTERMEDIATE] Tracking chain steps for: self.log_operation
            [INTERMEDIATE] Step 1: self.log_operation
      -> Resolved to: inheritence_complex.UltimateProcessor.log_operation
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.log_operation
        [CACHE] self.log_operation -> inheritence_complex.UltimateProcessor.log_operation (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> inheritence_complex.UltimateProcessor (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.UltimateProcessor.ultimate_processing_context
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.UltimateProcessor.ultimate_processing_context
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: inheritence_complex.UltimateProcessor
    [SYMBOL_TABLE] Exited class scope
  [FUNCTION] Analyzing function: create_processor_hierarchy
    [FUNCTION_ANALYSIS] Starting analysis of: inheritence_complex.create_processor_hierarchy
    [CONTEXT] Entered function: inheritence_complex.create_processor_hierarchy (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'processor_configs': 'List[Dict[str, Any]]'}
      [ASSIGNMENT] Processing: processors = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: processors
    [RESOLVE] Attempting to resolve: ['processors']
      [RESOLVE_SIMPLE] Resolving base: processors
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable processors not found in any scope
      [LOCAL_RESOLVER] can_resolve(processors): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(processors): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(processors): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(processors): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(processors): inheritence_complex.processors
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: processors -> inheritence_complex.processors
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.processors
      -> Not module state
      [NAME] Found name reference: config
    [RESOLVE] Attempting to resolve: ['config']
      [RESOLVE_SIMPLE] Resolving base: config
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable config not found in any scope
      [LOCAL_RESOLVER] can_resolve(config): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(config): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(config): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(config): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(config): inheritence_complex.config
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: config -> inheritence_complex.config
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.config
      -> Not module state
      [NAME] Found name reference: processor_configs
    [RESOLVE] Attempting to resolve: ['processor_configs']
      [RESOLVE_SIMPLE] Resolving base: processor_configs
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable processor_configs not found in any scope
      [LOCAL_RESOLVER] can_resolve(processor_configs): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(processor_configs): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(processor_configs): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(processor_configs): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(processor_configs): inheritence_complex.processor_configs
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: processor_configs -> inheritence_complex.processor_configs
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.processor_configs
      -> Not module state
      [ASSIGNMENT] Processing: processor_type = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: config.get
    [RESOLVE] Attempting to resolve: ['config', 'get']
    [RESOLVE] Chain resolution needed for: ['config', 'get']
      [CHAIN] Resolving base: config
      [RESOLVE_SIMPLE] Resolving base: config
      [CACHE] Hit for config: inheritence_complex.config
      [CHAIN] Base resolved: config -> inheritence_complex.config
      [CHAIN] Step 1: Resolving inheritence_complex.config.get
        [ATTRIBUTE] Resolving attribute: inheritence_complex.config.get
        [ATTRIBUTE] Direct match found: inheritence_complex.config.get
      [CHAIN] Step 1 resolved: inheritence_complex.config.get
    [RESOLVE] RESOLVED to: inheritence_complex.config.get
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.config.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for processor_type
      [NAME] Found name reference: processor_type
    [RESOLVE] Attempting to resolve: ['processor_type']
      [RESOLVE_SIMPLE] Resolving base: processor_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable processor_type not found in any scope
      [LOCAL_RESOLVER] can_resolve(processor_type): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(processor_type): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(processor_type): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(processor_type): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(processor_type): inheritence_complex.processor_type
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: processor_type -> inheritence_complex.processor_type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.processor_type
      -> Not module state
      [CALL] Found call: config.get
    [RESOLVE] Attempting to resolve: ['config', 'get']
    [RESOLVE] Chain resolution needed for: ['config', 'get']
      [CHAIN] Resolving base: config
      [RESOLVE_SIMPLE] Resolving base: config
      [CACHE] Hit for config: inheritence_complex.config
      [CHAIN] Base resolved: config -> inheritence_complex.config
      [CHAIN] Step 1: Resolving inheritence_complex.config.get
        [ATTRIBUTE] Resolving attribute: inheritence_complex.config.get
        [ATTRIBUTE] Direct match found: inheritence_complex.config.get
      [CHAIN] Step 1 resolved: inheritence_complex.config.get
    [RESOLVE] RESOLVED to: inheritence_complex.config.get
            [INTERMEDIATE] Tracking chain steps for: config.get
            [INTERMEDIATE] Step 1: config.get
      -> Resolved to: inheritence_complex.config.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: config.get
        [CACHE] config.get -> inheritence_complex.config.get (cached)
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> inheritence_complex.config (cached)
      -> Not module state
      [ASSIGNMENT] Processing: processor_id = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: processor_id
    [RESOLVE] Attempting to resolve: ['processor_id']
      [RESOLVE_SIMPLE] Resolving base: processor_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable processor_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(processor_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(processor_id): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(processor_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(processor_id): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(processor_id): inheritence_complex.processor_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: processor_id -> inheritence_complex.processor_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.processor_id
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> inheritence_complex.config (cached)
      -> Not module state
      [NAME] Found name reference: processor_type
        [CACHE] processor_type -> inheritence_complex.processor_type (cached)
      -> Not module state
      [ASSIGNMENT] Processing: processor = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: BasicDataProcessor
    [RESOLVE] Attempting to resolve: ['BasicDataProcessor']
      [RESOLVE_SIMPLE] Resolving base: BasicDataProcessor
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable BasicDataProcessor not found in any scope
      [LOCAL_RESOLVER] can_resolve(BasicDataProcessor): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(BasicDataProcessor): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(BasicDataProcessor): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(BasicDataProcessor): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(BasicDataProcessor): inheritence_complex.BasicDataProcessor
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: BasicDataProcessor -> inheritence_complex.BasicDataProcessor
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.BasicDataProcessor
      [TYPE_INFERENCE] RESOLVED Inferred type: inheritence_complex.BasicDataProcessor (class instantiation)
      [SYMBOL_UPDATE] Function: processor -> inheritence_complex.BasicDataProcessor
        [ASSIGNMENT] RESOLVED Updated symbol table: processor = inheritence_complex.BasicDataProcessor
      [NAME] Found name reference: processor
    [RESOLVE] Attempting to resolve: ['processor']
      [RESOLVE_SIMPLE] Resolving base: processor
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found processor in function scope: inheritence_complex.BasicDataProcessor
      [LOCAL_RESOLVER] can_resolve(processor): True
      [SYMBOL_LOOKUP] Found processor in function scope: inheritence_complex.BasicDataProcessor
      [LOCAL_RESOLVER] resolve(processor): inheritence_complex.BasicDataProcessor
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: processor -> inheritence_complex.BasicDataProcessor
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor
      -> Not module state
      [CALL] Found call: BasicDataProcessor
    [RESOLVE] Attempting to resolve: ['BasicDataProcessor']
      [RESOLVE_SIMPLE] Resolving base: BasicDataProcessor
      [CACHE] Hit for BasicDataProcessor: inheritence_complex.BasicDataProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor
      -> Resolved to: inheritence_complex.BasicDataProcessor
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: processor_id
    [RESOLVE] Attempting to resolve: ['processor_id']
      [RESOLVE_SIMPLE] Resolving base: processor_id
      [CACHE] Hit for processor_id: inheritence_complex.processor_id
    [RESOLVE] RESOLVED to: inheritence_complex.processor_id
      [NAME] Found name reference: BasicDataProcessor
        [CACHE] BasicDataProcessor -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [NAME] Found name reference: processor_id
        [CACHE] processor_id -> inheritence_complex.processor_id (cached)
      -> Not module state
      [NAME] Found name reference: processor_type
        [CACHE] processor_type -> inheritence_complex.processor_type (cached)
      -> Not module state
      [ASSIGNMENT] Processing: priority = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: priority
    [RESOLVE] Attempting to resolve: ['priority']
      [RESOLVE_SIMPLE] Resolving base: priority
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable priority not found in any scope
      [LOCAL_RESOLVER] can_resolve(priority): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(priority): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(priority): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(priority): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(priority): inheritence_complex.priority
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: priority -> inheritence_complex.priority
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.priority
      -> Not module state
      [NAME] Found name reference: Priority
    [RESOLVE] Attempting to resolve: ['Priority']
      [RESOLVE_SIMPLE] Resolving base: Priority
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Priority not found in any scope
      [LOCAL_RESOLVER] can_resolve(Priority): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Priority): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Priority): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(Priority): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(Priority): inheritence_complex.Priority
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: Priority -> inheritence_complex.Priority
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.Priority
      -> Not module state
      [CALL] Found call: config.get
    [CACHE] config.get -> inheritence_complex.config.get (cached)
            [INTERMEDIATE] Tracking chain steps for: config.get
            [INTERMEDIATE] Step 1: config.get
      -> Resolved to: inheritence_complex.config.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: config.get
        [CACHE] config.get -> inheritence_complex.config.get (cached)
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> inheritence_complex.config (cached)
      -> Not module state
      [ASSIGNMENT] Processing: processor = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: AdvancedProcessor
    [RESOLVE] Attempting to resolve: ['AdvancedProcessor']
      [RESOLVE_SIMPLE] Resolving base: AdvancedProcessor
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable AdvancedProcessor not found in any scope
      [LOCAL_RESOLVER] can_resolve(AdvancedProcessor): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(AdvancedProcessor): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(AdvancedProcessor): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(AdvancedProcessor): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(AdvancedProcessor): inheritence_complex.AdvancedProcessor
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: AdvancedProcessor -> inheritence_complex.AdvancedProcessor
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.AdvancedProcessor
      [TYPE_INFERENCE] RESOLVED Inferred type: inheritence_complex.AdvancedProcessor (class instantiation)
      [SYMBOL_UPDATE] Function: processor -> inheritence_complex.AdvancedProcessor
        [ASSIGNMENT] RESOLVED Updated symbol table: processor = inheritence_complex.AdvancedProcessor
      [NAME] Found name reference: processor
        [CACHE] processor -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [CALL] Found call: AdvancedProcessor
    [RESOLVE] Attempting to resolve: ['AdvancedProcessor']
      [RESOLVE_SIMPLE] Resolving base: AdvancedProcessor
      [CACHE] Hit for AdvancedProcessor: inheritence_complex.AdvancedProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.AdvancedProcessor
      -> Resolved to: inheritence_complex.AdvancedProcessor
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: processor_id
    [RESOLVE] Attempting to resolve: ['processor_id']
      [RESOLVE_SIMPLE] Resolving base: processor_id
      [CACHE] Hit for processor_id: inheritence_complex.processor_id
    [RESOLVE] RESOLVED to: inheritence_complex.processor_id
        [FUNCTION_ARG] Checking argument: priority
    [RESOLVE] Attempting to resolve: ['priority']
      [RESOLVE_SIMPLE] Resolving base: priority
      [CACHE] Hit for priority: inheritence_complex.priority
    [RESOLVE] RESOLVED to: inheritence_complex.priority
      [NAME] Found name reference: AdvancedProcessor
        [CACHE] AdvancedProcessor -> inheritence_complex.AdvancedProcessor (cached)
      -> Not module state
      [NAME] Found name reference: processor_id
        [CACHE] processor_id -> inheritence_complex.processor_id (cached)
      -> Not module state
      [NAME] Found name reference: priority
        [CACHE] priority -> inheritence_complex.priority (cached)
      -> Not module state
      [NAME] Found name reference: processor_type
        [CACHE] processor_type -> inheritence_complex.processor_type (cached)
      -> Not module state
      [ASSIGNMENT] Processing: specialization = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: config.get
    [RESOLVE] Attempting to resolve: ['config', 'get']
    [RESOLVE] Chain resolution needed for: ['config', 'get']
      [CHAIN] Resolving base: config
      [RESOLVE_SIMPLE] Resolving base: config
      [CACHE] Hit for config: inheritence_complex.config
      [CHAIN] Base resolved: config -> inheritence_complex.config
      [CHAIN] Step 1: Resolving inheritence_complex.config.get
        [ATTRIBUTE] Resolving attribute: inheritence_complex.config.get
        [ATTRIBUTE] Direct match found: inheritence_complex.config.get
      [CHAIN] Step 1 resolved: inheritence_complex.config.get
    [RESOLVE] RESOLVED to: inheritence_complex.config.get
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.config.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for specialization
      [NAME] Found name reference: specialization
    [RESOLVE] Attempting to resolve: ['specialization']
      [RESOLVE_SIMPLE] Resolving base: specialization
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable specialization not found in any scope
      [LOCAL_RESOLVER] can_resolve(specialization): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(specialization): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(specialization): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(specialization): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(specialization): inheritence_complex.specialization
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: specialization -> inheritence_complex.specialization
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.specialization
      -> Not module state
      [CALL] Found call: config.get
    [CACHE] config.get -> inheritence_complex.config.get (cached)
            [INTERMEDIATE] Tracking chain steps for: config.get
            [INTERMEDIATE] Step 1: config.get
      -> Resolved to: inheritence_complex.config.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: config.get
        [CACHE] config.get -> inheritence_complex.config.get (cached)
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> inheritence_complex.config (cached)
      -> Not module state
      [ASSIGNMENT] Processing: processor = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: SpecializedProcessor
    [RESOLVE] Attempting to resolve: ['SpecializedProcessor']
      [RESOLVE_SIMPLE] Resolving base: SpecializedProcessor
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable SpecializedProcessor not found in any scope
      [LOCAL_RESOLVER] can_resolve(SpecializedProcessor): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(SpecializedProcessor): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(SpecializedProcessor): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(SpecializedProcessor): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(SpecializedProcessor): inheritence_complex.SpecializedProcessor
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: SpecializedProcessor -> inheritence_complex.SpecializedProcessor
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.SpecializedProcessor
      [TYPE_INFERENCE] RESOLVED Inferred type: inheritence_complex.SpecializedProcessor (class instantiation)
      [SYMBOL_UPDATE] Function: processor -> inheritence_complex.SpecializedProcessor
        [ASSIGNMENT] RESOLVED Updated symbol table: processor = inheritence_complex.SpecializedProcessor
      [NAME] Found name reference: processor
        [CACHE] processor -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [CALL] Found call: SpecializedProcessor
    [RESOLVE] Attempting to resolve: ['SpecializedProcessor']
      [RESOLVE_SIMPLE] Resolving base: SpecializedProcessor
      [CACHE] Hit for SpecializedProcessor: inheritence_complex.SpecializedProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.SpecializedProcessor
      -> Resolved to: inheritence_complex.SpecializedProcessor
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: processor_id
    [RESOLVE] Attempting to resolve: ['processor_id']
      [RESOLVE_SIMPLE] Resolving base: processor_id
      [CACHE] Hit for processor_id: inheritence_complex.processor_id
    [RESOLVE] RESOLVED to: inheritence_complex.processor_id
        [FUNCTION_ARG] Checking argument: specialization
    [RESOLVE] Attempting to resolve: ['specialization']
      [RESOLVE_SIMPLE] Resolving base: specialization
      [CACHE] Hit for specialization: inheritence_complex.specialization
    [RESOLVE] RESOLVED to: inheritence_complex.specialization
      [NAME] Found name reference: SpecializedProcessor
        [CACHE] SpecializedProcessor -> inheritence_complex.SpecializedProcessor (cached)
      -> Not module state
      [NAME] Found name reference: processor_id
        [CACHE] processor_id -> inheritence_complex.processor_id (cached)
      -> Not module state
      [NAME] Found name reference: specialization
        [CACHE] specialization -> inheritence_complex.specialization (cached)
      -> Not module state
      [NAME] Found name reference: processor_type
        [CACHE] processor_type -> inheritence_complex.processor_type (cached)
      -> Not module state
      [ASSIGNMENT] Processing: processor = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: UltimateProcessor
    [RESOLVE] Attempting to resolve: ['UltimateProcessor']
      [RESOLVE_SIMPLE] Resolving base: UltimateProcessor
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable UltimateProcessor not found in any scope
      [LOCAL_RESOLVER] can_resolve(UltimateProcessor): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(UltimateProcessor): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(UltimateProcessor): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(UltimateProcessor): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(UltimateProcessor): inheritence_complex.UltimateProcessor
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: UltimateProcessor -> inheritence_complex.UltimateProcessor
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.UltimateProcessor
      [TYPE_INFERENCE] RESOLVED Inferred type: inheritence_complex.UltimateProcessor (class instantiation)
      [SYMBOL_UPDATE] Function: processor -> inheritence_complex.UltimateProcessor
        [ASSIGNMENT] RESOLVED Updated symbol table: processor = inheritence_complex.UltimateProcessor
      [NAME] Found name reference: processor
        [CACHE] processor -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [CALL] Found call: UltimateProcessor
    [RESOLVE] Attempting to resolve: ['UltimateProcessor']
      [RESOLVE_SIMPLE] Resolving base: UltimateProcessor
      [CACHE] Hit for UltimateProcessor: inheritence_complex.UltimateProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor
      -> Resolved to: inheritence_complex.UltimateProcessor
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: processor_id
    [RESOLVE] Attempting to resolve: ['processor_id']
      [RESOLVE_SIMPLE] Resolving base: processor_id
      [CACHE] Hit for processor_id: inheritence_complex.processor_id
    [RESOLVE] RESOLVED to: inheritence_complex.processor_id
      [NAME] Found name reference: UltimateProcessor
        [CACHE] UltimateProcessor -> inheritence_complex.UltimateProcessor (cached)
      -> Not module state
      [NAME] Found name reference: processor_id
        [CACHE] processor_id -> inheritence_complex.processor_id (cached)
      -> Not module state
      [ASSIGNMENT] Processing: processor = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: BasicDataProcessor
    [RESOLVE] Attempting to resolve: ['BasicDataProcessor']
      [RESOLVE_SIMPLE] Resolving base: BasicDataProcessor
      [CACHE] Hit for BasicDataProcessor: inheritence_complex.BasicDataProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.BasicDataProcessor
      [TYPE_INFERENCE] RESOLVED Inferred type: inheritence_complex.BasicDataProcessor (class instantiation)
      [SYMBOL_UPDATE] Function: processor -> inheritence_complex.BasicDataProcessor
        [ASSIGNMENT] RESOLVED Updated symbol table: processor = inheritence_complex.BasicDataProcessor
      [NAME] Found name reference: processor
        [CACHE] processor -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [CALL] Found call: BasicDataProcessor
    [CACHE] BasicDataProcessor -> inheritence_complex.BasicDataProcessor (cached)
      -> Resolved to: inheritence_complex.BasicDataProcessor
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: processor_id
    [RESOLVE] Attempting to resolve: ['processor_id']
      [RESOLVE_SIMPLE] Resolving base: processor_id
      [CACHE] Hit for processor_id: inheritence_complex.processor_id
    [RESOLVE] RESOLVED to: inheritence_complex.processor_id
      [NAME] Found name reference: BasicDataProcessor
        [CACHE] BasicDataProcessor -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [NAME] Found name reference: processor_id
        [CACHE] processor_id -> inheritence_complex.processor_id (cached)
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> inheritence_complex.config (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: processor.enable_cache
    [RESOLVE] Attempting to resolve: ['processor', 'enable_cache']
    [RESOLVE] Chain resolution needed for: ['processor', 'enable_cache']
      [CHAIN] Resolving base: processor
      [RESOLVE_SIMPLE] Resolving base: processor
      [CACHE] Hit for processor: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: processor -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.enable_cache
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.enable_cache
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.enable_cache
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.enable_cache
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.enable_cache
      -> Not module state
      [NAME] Found name reference: processor
        [CACHE] processor -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> inheritence_complex.config (cached)
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> inheritence_complex.config (cached)
      -> Not module state
      [NAME] Found name reference: rule_config
    [RESOLVE] Attempting to resolve: ['rule_config']
      [RESOLVE_SIMPLE] Resolving base: rule_config
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable rule_config not found in any scope
      [LOCAL_RESOLVER] can_resolve(rule_config): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(rule_config): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(rule_config): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(rule_config): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(rule_config): inheritence_complex.rule_config
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: rule_config -> inheritence_complex.rule_config
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.rule_config
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> inheritence_complex.config (cached)
      -> Not module state
      [ASSIGNMENT] Processing: rule_func = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: eval
    [RESOLVE] Attempting to resolve: ['eval']
      [RESOLVE_SIMPLE] Resolving base: eval
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable eval not found in any scope
      [LOCAL_RESOLVER] can_resolve(eval): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(eval): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(eval): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(eval): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(eval): inheritence_complex.eval
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: eval -> inheritence_complex.eval
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.eval
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.eval
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for rule_func
      [NAME] Found name reference: rule_func
    [RESOLVE] Attempting to resolve: ['rule_func']
      [RESOLVE_SIMPLE] Resolving base: rule_func
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable rule_func not found in any scope
      [LOCAL_RESOLVER] can_resolve(rule_func): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(rule_func): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(rule_func): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(rule_func): True (fallback, module: inheritence_complex)
      [MODULE_RESOLVER] resolve(rule_func): inheritence_complex.rule_func
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: rule_func -> inheritence_complex.rule_func
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: inheritence_complex.rule_func
      -> Not module state
      [CALL] Found call: eval
    [RESOLVE] Attempting to resolve: ['eval']
      [RESOLVE_SIMPLE] Resolving base: eval
      [CACHE] Hit for eval: inheritence_complex.eval
    [RESOLVE] RESOLVED to: inheritence_complex.eval
      -> Resolved to: inheritence_complex.eval
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: eval
        [CACHE] eval -> inheritence_complex.eval (cached)
      -> Not module state
      [NAME] Found name reference: rule_config
        [CACHE] rule_config -> inheritence_complex.rule_config (cached)
      -> Not module state
      [CALL] Found call: processor.add_validation_rule
    [RESOLVE] Attempting to resolve: ['processor', 'add_validation_rule']
    [RESOLVE] Chain resolution needed for: ['processor', 'add_validation_rule']
      [CHAIN] Resolving base: processor
      [RESOLVE_SIMPLE] Resolving base: processor
      [CACHE] Hit for processor: inheritence_complex.BasicDataProcessor
      [CHAIN] Base resolved: processor -> inheritence_complex.BasicDataProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.BasicDataProcessor.add_validation_rule
        [ATTRIBUTE] Resolving attribute: inheritence_complex.BasicDataProcessor.add_validation_rule
        [ATTRIBUTE] Direct match found: inheritence_complex.BasicDataProcessor.add_validation_rule
      [CHAIN] Step 1 resolved: inheritence_complex.BasicDataProcessor.add_validation_rule
    [RESOLVE] RESOLVED to: inheritence_complex.BasicDataProcessor.add_validation_rule
            [INTERMEDIATE] Tracking chain steps for: processor.add_validation_rule
            [INTERMEDIATE] Step 1: processor.add_validation_rule
      -> Resolved to: inheritence_complex.BasicDataProcessor.add_validation_rule
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: rule_func
    [RESOLVE] Attempting to resolve: ['rule_func']
      [RESOLVE_SIMPLE] Resolving base: rule_func
      [CACHE] Hit for rule_func: inheritence_complex.rule_func
    [RESOLVE] RESOLVED to: inheritence_complex.rule_func
      [ATTRIBUTE] Found attribute access: processor.add_validation_rule
        [CACHE] processor.add_validation_rule -> inheritence_complex.BasicDataProcessor.add_validation_rule (cached)
      -> Not module state
      [NAME] Found name reference: processor
        [CACHE] processor -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [NAME] Found name reference: rule_func
        [CACHE] rule_func -> inheritence_complex.rule_func (cached)
      -> Not module state
      [NAME] Found name reference: rule_config
        [CACHE] rule_config -> inheritence_complex.rule_config (cached)
      -> Not module state
      [NAME] Found name reference: processors
        [CACHE] processors -> inheritence_complex.processors (cached)
      -> Not module state
      [NAME] Found name reference: processor_id
        [CACHE] processor_id -> inheritence_complex.processor_id (cached)
      -> Not module state
      [NAME] Found name reference: processor
        [CACHE] processor -> inheritence_complex.BasicDataProcessor (cached)
      -> Not module state
      [NAME] Found name reference: processors
        [CACHE] processors -> inheritence_complex.processors (cached)
      -> Not module state
    [CONTEXT] Exited function: inheritence_complex.create_processor_hierarchy
    [FUNCTION_ANALYSIS] Completed analysis of: inheritence_complex.create_processor_hierarchy
        Calls: 0
        Instantiations: 4
        State Access: 0
    [IMPORT] time -> time
      [ASSIGNMENT] Processing: ultimate_processor = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: UltimateProcessor
    [RESOLVE] Attempting to resolve: ['UltimateProcessor']
      [RESOLVE_SIMPLE] Resolving base: UltimateProcessor
      [CACHE] Hit for UltimateProcessor: inheritence_complex.UltimateProcessor
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.UltimateProcessor
      [TYPE_INFERENCE] RESOLVED Inferred type: inheritence_complex.UltimateProcessor (class instantiation)
      [SYMBOL_UPDATE] Function: ultimate_processor -> inheritence_complex.UltimateProcessor
        [ASSIGNMENT] RESOLVED Updated symbol table: ultimate_processor = inheritence_complex.UltimateProcessor
      [ASSIGNMENT] Processing: test_data = ...
        [ASSIGNMENT] Non-call assignment
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ultimate_processor.ultimate_process
    [RESOLVE] Attempting to resolve: ['ultimate_processor', 'ultimate_process']
    [RESOLVE] Chain resolution needed for: ['ultimate_processor', 'ultimate_process']
      [CHAIN] Resolving base: ultimate_processor
      [RESOLVE_SIMPLE] Resolving base: ultimate_processor
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found ultimate_processor in function scope: inheritence_complex.UltimateProcessor
      [LOCAL_RESOLVER] can_resolve(ultimate_processor): True
      [SYMBOL_LOOKUP] Found ultimate_processor in function scope: inheritence_complex.UltimateProcessor
      [LOCAL_RESOLVER] resolve(ultimate_processor): inheritence_complex.UltimateProcessor
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: ultimate_processor -> inheritence_complex.UltimateProcessor
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: ultimate_processor -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.ultimate_process
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.ultimate_process
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.ultimate_process
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.ultimate_process
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.ultimate_process
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.UltimateProcessor.ultimate_process
        [RETURN_TYPE_RESOLUTION] Resolving return type: ProcessingResult
        [RETURN_TYPE_RESOLUTION] Found in current module: inheritence_complex.ProcessingResult
      [TYPE_INFERENCE] RESOLVED Inferred type: inheritence_complex.ProcessingResult (from return type)
      [SYMBOL_UPDATE] Function: result -> inheritence_complex.ProcessingResult
        [ASSIGNMENT] RESOLVED Updated symbol table: result = inheritence_complex.ProcessingResult
      [ASSIGNMENT] Processing: stats = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ultimate_processor.get_statistics
    [RESOLVE] Attempting to resolve: ['ultimate_processor', 'get_statistics']
    [RESOLVE] Chain resolution needed for: ['ultimate_processor', 'get_statistics']
      [CHAIN] Resolving base: ultimate_processor
      [RESOLVE_SIMPLE] Resolving base: ultimate_processor
      [CACHE] Hit for ultimate_processor: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: ultimate_processor -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.get_statistics
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.get_statistics
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.get_statistics
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.get_statistics
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.get_statistics
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.UltimateProcessor.get_statistics
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for stats
      [ASSIGNMENT] Processing: cache_stats = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ultimate_processor.get_cache_statistics
    [RESOLVE] Attempting to resolve: ['ultimate_processor', 'get_cache_statistics']
    [RESOLVE] Chain resolution needed for: ['ultimate_processor', 'get_cache_statistics']
      [CHAIN] Resolving base: ultimate_processor
      [RESOLVE_SIMPLE] Resolving base: ultimate_processor
      [CACHE] Hit for ultimate_processor: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: ultimate_processor -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.get_cache_statistics
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.get_cache_statistics
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.get_cache_statistics
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.get_cache_statistics
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.get_cache_statistics
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.UltimateProcessor.get_cache_statistics
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for cache_stats
      [ASSIGNMENT] Processing: metric_summary = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: ultimate_processor.get_metric_summary
    [RESOLVE] Attempting to resolve: ['ultimate_processor', 'get_metric_summary']
    [RESOLVE] Chain resolution needed for: ['ultimate_processor', 'get_metric_summary']
      [CHAIN] Resolving base: ultimate_processor
      [RESOLVE_SIMPLE] Resolving base: ultimate_processor
      [CACHE] Hit for ultimate_processor: inheritence_complex.UltimateProcessor
      [CHAIN] Base resolved: ultimate_processor -> inheritence_complex.UltimateProcessor
      [CHAIN] Step 1: Resolving inheritence_complex.UltimateProcessor.get_metric_summary
        [ATTRIBUTE] Resolving attribute: inheritence_complex.UltimateProcessor.get_metric_summary
        [ATTRIBUTE] Direct match found: inheritence_complex.UltimateProcessor.get_metric_summary
      [CHAIN] Step 1 resolved: inheritence_complex.UltimateProcessor.get_metric_summary
    [RESOLVE] RESOLVED to: inheritence_complex.UltimateProcessor.get_metric_summary
      [TYPE_INFERENCE] Call resolved to: inheritence_complex.UltimateProcessor.get_metric_summary
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for metric_summary
=== Module Analysis Complete ===
  Module analysis complete
=== Analyzing proxy_handler.py ===
  [RESOLVER] Using implementation: refactored
=== Starting Module Analysis ===
    [FROM_IMPORT] Any -> typing.Any
    [FROM_IMPORT] Dict -> typing.Dict
    [FROM_IMPORT] List -> typing.List
    [FROM_IMPORT] Optional -> typing.Optional
    [FROM_IMPORT] Callable -> typing.Callable
    [FROM_IMPORT] Union -> typing.Union
    [FROM_IMPORT] TypeVar -> typing.TypeVar
    [FROM_IMPORT] Generic -> typing.Generic
    [FROM_IMPORT] Set -> typing.Set
    [FROM_IMPORT] ABC -> abc.ABC
    [FROM_IMPORT] abstractmethod -> abc.abstractmethod
    [FROM_IMPORT] wraps -> functools.wraps
    [IMPORT] threading -> threading
    [IMPORT] time -> time
    [FROM_IMPORT] dataclass -> dataclasses.dataclass
    [FROM_IMPORT] contextmanager -> contextlib.contextmanager
    [FROM_IMPORT] trace -> decorators.trace
    [FROM_IMPORT] monitor_performance -> decorators.monitor_performance
    [FROM_IMPORT] validate_auth -> decorators.validate_auth
    [FROM_IMPORT] rate_limit -> decorators.rate_limit
    [MODULE_STATE] T = TypeVar('T')
  [CLASS] Analyzing class: ProxyConfig
    [CONTEXT] Entered class: proxy_handler.ProxyConfig
    [SYMBOL_TABLE] Entered class scope
    [CONTEXT] Exited class: proxy_handler.ProxyConfig
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: ProxyMetrics
    [CONTEXT] Entered class: proxy_handler.ProxyMetrics
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.ProxyMetrics.__init__
    [CONTEXT] Entered function: proxy_handler.ProxyMetrics.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.call_count
    [RESOLVE] Attempting to resolve: ['self', 'call_count']
    [RESOLVE] Chain resolution needed for: ['self', 'call_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: proxy_handler.ProxyMetrics)
      [SELF_RESOLVER] resolve(self): proxy_handler.ProxyMetrics
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> proxy_handler.ProxyMetrics
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.call_count
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.call_count
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.call_count
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.call_count
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.call_count
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.success_count
    [RESOLVE] Attempting to resolve: ['self', 'success_count']
    [RESOLVE] Chain resolution needed for: ['self', 'success_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.success_count
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.success_count
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.success_count
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.success_count
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.success_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.error_count
    [RESOLVE] Attempting to resolve: ['self', 'error_count']
    [RESOLVE] Chain resolution needed for: ['self', 'error_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.error_count
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.error_count
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.error_count
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.error_count
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.error_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache_hits
    [RESOLVE] Attempting to resolve: ['self', 'cache_hits']
    [RESOLVE] Chain resolution needed for: ['self', 'cache_hits']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.cache_hits
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.cache_hits
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.cache_hits
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.cache_hits
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.cache_hits
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache_misses
    [RESOLVE] Attempting to resolve: ['self', 'cache_misses']
    [RESOLVE] Chain resolution needed for: ['self', 'cache_misses']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.cache_misses
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.cache_misses
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.cache_misses
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.cache_misses
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.cache_misses
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.total_execution_time
    [RESOLVE] Attempting to resolve: ['self', 'total_execution_time']
    [RESOLVE] Chain resolution needed for: ['self', 'total_execution_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.total_execution_time
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.total_execution_time
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.total_execution_time
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.total_execution_time
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.total_execution_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.average_execution_time
    [RESOLVE] Attempting to resolve: ['self', 'average_execution_time']
    [RESOLVE] Chain resolution needed for: ['self', 'average_execution_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.average_execution_time
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.average_execution_time
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.average_execution_time
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.average_execution_time
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.average_execution_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.last_error_time
    [RESOLVE] Attempting to resolve: ['self', 'last_error_time']
    [RESOLVE] Chain resolution needed for: ['self', 'last_error_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.last_error_time
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.last_error_time
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.last_error_time
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.last_error_time
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.last_error_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [NAME] Found name reference: Optional
    [RESOLVE] Attempting to resolve: ['Optional']
      [RESOLVE_SIMPLE] Resolving base: Optional
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Optional not found in any scope
      [LOCAL_RESOLVER] can_resolve(Optional): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Optional): False (current_class: proxy_handler.ProxyMetrics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Optional): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Optional): typing.Optional (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Optional -> typing.Optional
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Optional
      -> Not module state
      [NAME] Found name reference: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable float not found in any scope
      [LOCAL_RESOLVER] can_resolve(float): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(float): False (current_class: proxy_handler.ProxyMetrics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(float): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(float): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(float): proxy_handler.float
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: float -> proxy_handler.float
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.float
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.last_success_time
    [RESOLVE] Attempting to resolve: ['self', 'last_success_time']
    [RESOLVE] Chain resolution needed for: ['self', 'last_success_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.last_success_time
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.last_success_time
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.last_success_time
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.last_success_time
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.last_success_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [NAME] Found name reference: Optional
        [CACHE] Optional -> typing.Optional (cached)
      -> Not module state
      [NAME] Found name reference: float
        [CACHE] float -> proxy_handler.float (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.ProxyMetrics.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.ProxyMetrics.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.ProxyMetrics.record_call
    [CONTEXT] Entered function: proxy_handler.ProxyMetrics.record_call (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 4 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'execution_time': 'float', 'success': 'bool', 'cache_hit': 'bool'}
        [ARG_TYPE] Processing type annotation for execution_time: float
    [RESOLVE] Attempting to resolve: ['float']
      [RESOLVE_SIMPLE] Resolving base: float
      [CACHE] Hit for float: proxy_handler.float
    [RESOLVE] RESOLVED to: proxy_handler.float
      [SYMBOL_UPDATE] Function: execution_time -> proxy_handler.float
        [ARG_TYPE] RESOLVED execution_time : proxy_handler.float
        [ARG_TYPE] Processing type annotation for success: bool
    [RESOLVE] Attempting to resolve: ['bool']
      [RESOLVE_SIMPLE] Resolving base: bool
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable bool not found in any scope
      [LOCAL_RESOLVER] can_resolve(bool): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(bool): False (current_class: proxy_handler.ProxyMetrics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(bool): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(bool): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(bool): proxy_handler.bool
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: bool -> proxy_handler.bool
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.bool
      [SYMBOL_UPDATE] Function: success -> proxy_handler.bool
        [ARG_TYPE] RESOLVED success : proxy_handler.bool
        [ARG_TYPE] Processing type annotation for cache_hit: bool
        [CACHE] bool -> proxy_handler.bool (cached)
      [SYMBOL_UPDATE] Function: cache_hit -> proxy_handler.bool
        [ARG_TYPE] RESOLVED cache_hit : proxy_handler.bool
      [ATTRIBUTE] Found attribute access: self.call_count
    [RESOLVE] Attempting to resolve: ['self', 'call_count']
    [RESOLVE] Chain resolution needed for: ['self', 'call_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.call_count
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.call_count
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.call_count
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.call_count
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.call_count
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.total_execution_time
    [RESOLVE] Attempting to resolve: ['self', 'total_execution_time']
    [RESOLVE] Chain resolution needed for: ['self', 'total_execution_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.total_execution_time
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.total_execution_time
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.total_execution_time
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.total_execution_time
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.total_execution_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [NAME] Found name reference: execution_time
    [RESOLVE] Attempting to resolve: ['execution_time']
      [RESOLVE_SIMPLE] Resolving base: execution_time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found execution_time in function scope: proxy_handler.float
      [LOCAL_RESOLVER] can_resolve(execution_time): True
      [SYMBOL_LOOKUP] Found execution_time in function scope: proxy_handler.float
      [LOCAL_RESOLVER] resolve(execution_time): proxy_handler.float
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: execution_time -> proxy_handler.float
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.float
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.average_execution_time
    [RESOLVE] Attempting to resolve: ['self', 'average_execution_time']
    [RESOLVE] Chain resolution needed for: ['self', 'average_execution_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.average_execution_time
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.average_execution_time
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.average_execution_time
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.average_execution_time
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.average_execution_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.total_execution_time
        [CACHE] self.total_execution_time -> proxy_handler.ProxyMetrics.total_execution_time (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.call_count
        [CACHE] self.call_count -> proxy_handler.ProxyMetrics.call_count (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [NAME] Found name reference: success
    [RESOLVE] Attempting to resolve: ['success']
      [RESOLVE_SIMPLE] Resolving base: success
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found success in function scope: proxy_handler.bool
      [LOCAL_RESOLVER] can_resolve(success): True
      [SYMBOL_LOOKUP] Found success in function scope: proxy_handler.bool
      [LOCAL_RESOLVER] resolve(success): proxy_handler.bool
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: success -> proxy_handler.bool
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.bool
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.success_count
    [RESOLVE] Attempting to resolve: ['self', 'success_count']
    [RESOLVE] Chain resolution needed for: ['self', 'success_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.success_count
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.success_count
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.success_count
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.success_count
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.success_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.last_success_time
    [RESOLVE] Attempting to resolve: ['self', 'last_success_time']
    [RESOLVE] Chain resolution needed for: ['self', 'last_success_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.last_success_time
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.last_success_time
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.last_success_time
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.last_success_time
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.last_success_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable time not found in any scope
      [LOCAL_RESOLVER] can_resolve(time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(time): False (current_class: proxy_handler.ProxyMetrics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(time): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(time): time (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: time -> time
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.error_count
    [RESOLVE] Attempting to resolve: ['self', 'error_count']
    [RESOLVE] Chain resolution needed for: ['self', 'error_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.error_count
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.error_count
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.error_count
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.error_count
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.error_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.last_error_time
    [RESOLVE] Attempting to resolve: ['self', 'last_error_time']
    [RESOLVE] Chain resolution needed for: ['self', 'last_error_time']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.last_error_time
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.last_error_time
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.last_error_time
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.last_error_time
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.last_error_time
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [CALL] Found call: time.time
    [CACHE] time.time -> time.time (cached)
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
        [CACHE] time -> time (cached)
      -> Not module state
      [NAME] Found name reference: cache_hit
    [RESOLVE] Attempting to resolve: ['cache_hit']
      [RESOLVE_SIMPLE] Resolving base: cache_hit
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found cache_hit in function scope: proxy_handler.bool
      [LOCAL_RESOLVER] can_resolve(cache_hit): True
      [SYMBOL_LOOKUP] Found cache_hit in function scope: proxy_handler.bool
      [LOCAL_RESOLVER] resolve(cache_hit): proxy_handler.bool
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: cache_hit -> proxy_handler.bool
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.bool
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache_hits
    [RESOLVE] Attempting to resolve: ['self', 'cache_hits']
    [RESOLVE] Chain resolution needed for: ['self', 'cache_hits']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.cache_hits
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.cache_hits
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.cache_hits
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.cache_hits
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.cache_hits
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache_misses
    [RESOLVE] Attempting to resolve: ['self', 'cache_misses']
    [RESOLVE] Chain resolution needed for: ['self', 'cache_misses']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.cache_misses
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.cache_misses
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.cache_misses
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.cache_misses
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.cache_misses
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.ProxyMetrics.record_call
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.ProxyMetrics.record_call
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.ProxyMetrics.get_success_rate
    [CONTEXT] Entered function: proxy_handler.ProxyMetrics.get_success_rate (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.success_count
    [RESOLVE] Attempting to resolve: ['self', 'success_count']
    [RESOLVE] Chain resolution needed for: ['self', 'success_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.success_count
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.success_count
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.success_count
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.success_count
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.success_count
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics
      -> Not module state
      [CALL] Found call: max
      -> IGNORED (built-in function)
      [NAME] Found name reference: max
    [RESOLVE] Attempting to resolve: ['max']
      [RESOLVE_SIMPLE] Resolving base: max
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable max not found in any scope
      [LOCAL_RESOLVER] can_resolve(max): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(max): False (current_class: proxy_handler.ProxyMetrics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(max): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(max): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(max): proxy_handler.max
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: max -> proxy_handler.max
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.max
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.call_count
    [RESOLVE] Attempting to resolve: ['self', 'call_count']
    [RESOLVE] Chain resolution needed for: ['self', 'call_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.call_count
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.call_count
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.call_count
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.call_count
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.call_count
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.ProxyMetrics.get_success_rate
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.ProxyMetrics.get_success_rate
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.ProxyMetrics.get_cache_hit_rate
    [CONTEXT] Entered function: proxy_handler.ProxyMetrics.get_cache_hit_rate (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ASSIGNMENT] Processing: total_cacheable = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: total_cacheable
    [RESOLVE] Attempting to resolve: ['total_cacheable']
      [RESOLVE_SIMPLE] Resolving base: total_cacheable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable total_cacheable not found in any scope
      [LOCAL_RESOLVER] can_resolve(total_cacheable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(total_cacheable): False (current_class: proxy_handler.ProxyMetrics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(total_cacheable): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(total_cacheable): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(total_cacheable): proxy_handler.total_cacheable
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: total_cacheable -> proxy_handler.total_cacheable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.total_cacheable
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache_hits
    [RESOLVE] Attempting to resolve: ['self', 'cache_hits']
    [RESOLVE] Chain resolution needed for: ['self', 'cache_hits']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.cache_hits
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.cache_hits
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.cache_hits
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.cache_hits
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.cache_hits
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache_misses
    [RESOLVE] Attempting to resolve: ['self', 'cache_misses']
    [RESOLVE] Chain resolution needed for: ['self', 'cache_misses']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.ProxyMetrics
      [CHAIN] Base resolved: self -> proxy_handler.ProxyMetrics
      [CHAIN] Step 1: Resolving proxy_handler.ProxyMetrics.cache_misses
        [ATTRIBUTE] Resolving attribute: proxy_handler.ProxyMetrics.cache_misses
        [ATTRIBUTE] Direct match found: proxy_handler.ProxyMetrics.cache_misses
      [CHAIN] Step 1 resolved: proxy_handler.ProxyMetrics.cache_misses
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics.cache_misses
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache_hits
        [CACHE] self.cache_hits -> proxy_handler.ProxyMetrics.cache_hits (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [CALL] Found call: max
      -> IGNORED (built-in function)
      [NAME] Found name reference: max
    [RESOLVE] Attempting to resolve: ['max']
      [RESOLVE_SIMPLE] Resolving base: max
      [CACHE] Hit for max: proxy_handler.max
    [RESOLVE] RESOLVED to: proxy_handler.max
      -> Not module state
      [NAME] Found name reference: total_cacheable
        [CACHE] total_cacheable -> proxy_handler.total_cacheable (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.ProxyMetrics.get_cache_hit_rate
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.ProxyMetrics.get_cache_hit_rate
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: proxy_handler.ProxyMetrics
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: BaseProxy
    [CONTEXT] Entered class: proxy_handler.BaseProxy
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.BaseProxy.__init__
    [CONTEXT] Entered function: proxy_handler.BaseProxy.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'target': 'Any', 'config': 'ProxyConfig'}
        [ARG_TYPE] Processing type annotation for target: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: target -> typing.Any
        [ARG_TYPE] RESOLVED target : typing.Any
        [ARG_TYPE] Processing type annotation for config: ProxyConfig
    [RESOLVE] Attempting to resolve: ['ProxyConfig']
      [RESOLVE_SIMPLE] Resolving base: ProxyConfig
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ProxyConfig not found in any scope
      [LOCAL_RESOLVER] can_resolve(ProxyConfig): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ProxyConfig): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ProxyConfig): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ProxyConfig): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(ProxyConfig): proxy_handler.ProxyConfig
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ProxyConfig -> proxy_handler.ProxyConfig
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.ProxyConfig
      [SYMBOL_UPDATE] Function: config -> proxy_handler.ProxyConfig
        [ARG_TYPE] RESOLVED config : proxy_handler.ProxyConfig
      [ATTRIBUTE] Found attribute access: self.target
    [RESOLVE] Attempting to resolve: ['self', 'target']
    [RESOLVE] Chain resolution needed for: ['self', 'target']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: proxy_handler.BaseProxy)
      [SELF_RESOLVER] resolve(self): proxy_handler.BaseProxy
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> proxy_handler.BaseProxy
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.target
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.target
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.target
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.target
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.target
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy
      -> Not module state
      [NAME] Found name reference: target
    [RESOLVE] Attempting to resolve: ['target']
      [RESOLVE_SIMPLE] Resolving base: target
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found target in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(target): True
      [SYMBOL_LOOKUP] Found target in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(target): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: target -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.config
    [RESOLVE] Attempting to resolve: ['self', 'config']
    [RESOLVE] Chain resolution needed for: ['self', 'config']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.config
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.config
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.config
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.config
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.config
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [NAME] Found name reference: config
    [RESOLVE] Attempting to resolve: ['config']
      [RESOLVE_SIMPLE] Resolving base: config
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found config in function scope: proxy_handler.ProxyConfig
      [LOCAL_RESOLVER] can_resolve(config): True
      [SYMBOL_LOOKUP] Found config in function scope: proxy_handler.ProxyConfig
      [LOCAL_RESOLVER] resolve(config): proxy_handler.ProxyConfig
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: config -> proxy_handler.ProxyConfig
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.ProxyConfig
      -> Not module state
      [CALL] Found call: ProxyConfig
    [CACHE] ProxyConfig -> proxy_handler.ProxyConfig (cached)
      -> Resolved to: proxy_handler.ProxyConfig
      -> ADDED to instantiations
      [NAME] Found name reference: ProxyConfig
        [CACHE] ProxyConfig -> proxy_handler.ProxyConfig (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.metrics
    [RESOLVE] Attempting to resolve: ['self', 'metrics']
    [RESOLVE] Chain resolution needed for: ['self', 'metrics']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.metrics
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.metrics
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.metrics
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.metrics
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.metrics
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [CALL] Found call: ProxyMetrics
    [RESOLVE] Attempting to resolve: ['ProxyMetrics']
      [RESOLVE_SIMPLE] Resolving base: ProxyMetrics
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ProxyMetrics not found in any scope
      [LOCAL_RESOLVER] can_resolve(ProxyMetrics): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ProxyMetrics): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ProxyMetrics): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ProxyMetrics): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(ProxyMetrics): proxy_handler.ProxyMetrics
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ProxyMetrics -> proxy_handler.ProxyMetrics
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.ProxyMetrics
      -> Resolved to: proxy_handler.ProxyMetrics
      -> ADDED to instantiations
      [NAME] Found name reference: ProxyMetrics
        [CACHE] ProxyMetrics -> proxy_handler.ProxyMetrics (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache
    [RESOLVE] Attempting to resolve: ['self', 'cache']
    [RESOLVE] Chain resolution needed for: ['self', 'cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.cache
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.cache
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.cache
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.cache
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.cache
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(str): proxy_handler.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> proxy_handler.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [NAME] Found name reference: Any
        [CACHE] Any -> typing.Any (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.lock
    [RESOLVE] Attempting to resolve: ['self', 'lock']
    [RESOLVE] Chain resolution needed for: ['self', 'lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.lock
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.lock
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.lock
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.lock
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.lock
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [CALL] Found call: threading.RLock
    [RESOLVE] Attempting to resolve: ['threading', 'RLock']
    [RESOLVE] Chain resolution needed for: ['threading', 'RLock']
      [CHAIN] Resolving base: threading
      [RESOLVE_SIMPLE] Resolving base: threading
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable threading not found in any scope
      [LOCAL_RESOLVER] can_resolve(threading): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(threading): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(threading): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(threading): threading (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: threading -> threading
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: threading -> threading
      [CHAIN] Step 1: Resolving threading.RLock
        [ATTRIBUTE] Resolving attribute: threading.RLock
        [ATTRIBUTE] Direct match found: threading.RLock
      [CHAIN] Step 1 resolved: threading.RLock
    [RESOLVE] RESOLVED to: threading.RLock
            [INTERMEDIATE] Tracking chain steps for: threading.RLock
            [INTERMEDIATE] Step 1: threading.RLock
      -> Resolved to: threading.RLock
      -> ADDED to calls (external library)
      [ATTRIBUTE] Found attribute access: threading.RLock
        [CACHE] threading.RLock -> threading.RLock (cached)
      -> Not module state
      [NAME] Found name reference: threading
    [RESOLVE] Attempting to resolve: ['threading']
      [RESOLVE_SIMPLE] Resolving base: threading
      [CACHE] Hit for threading: threading
    [RESOLVE] RESOLVED to: threading
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.circuit_breaker_open
    [RESOLVE] Attempting to resolve: ['self', 'circuit_breaker_open']
    [RESOLVE] Chain resolution needed for: ['self', 'circuit_breaker_open']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.circuit_breaker_open
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.circuit_breaker_open
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.circuit_breaker_open
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.circuit_breaker_open
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.circuit_breaker_open
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.circuit_breaker_failures
    [RESOLVE] Attempting to resolve: ['self', 'circuit_breaker_failures']
    [RESOLVE] Chain resolution needed for: ['self', 'circuit_breaker_failures']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.circuit_breaker_failures
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.circuit_breaker_failures
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.circuit_breaker_failures
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.circuit_breaker_failures
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.circuit_breaker_failures
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.circuit_breaker_last_failure
    [RESOLVE] Attempting to resolve: ['self', 'circuit_breaker_last_failure']
    [RESOLVE] Chain resolution needed for: ['self', 'circuit_breaker_last_failure']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.circuit_breaker_last_failure
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.circuit_breaker_last_failure
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.circuit_breaker_last_failure
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.circuit_breaker_last_failure
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.circuit_breaker_last_failure
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.BaseProxy.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.BaseProxy.__init__
        Calls: 1
        Instantiations: 2
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.BaseProxy._proxy_method_call
    [DECORATOR] @abstractmethod
    [CONTEXT] Entered function: proxy_handler.BaseProxy._proxy_method_call (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'method_name': 'str'}
        [ARG_TYPE] Processing type annotation for method_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: method_name -> proxy_handler.str
        [ARG_TYPE] RESOLVED method_name : proxy_handler.str
    [CONTEXT] Exited function: proxy_handler.BaseProxy._proxy_method_call
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.BaseProxy._proxy_method_call
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.BaseProxy.__getattr__
    [DECORATOR] @trace
    [CONTEXT] Entered function: proxy_handler.BaseProxy.__getattr__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'name': 'str'}
        [ARG_TYPE] Processing type annotation for name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: name -> proxy_handler.str
        [ARG_TYPE] RESOLVED name : proxy_handler.str
      [CALL] Found call: hasattr
    [RESOLVE] Attempting to resolve: ['hasattr']
      [RESOLVE_SIMPLE] Resolving base: hasattr
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable hasattr not found in any scope
      [LOCAL_RESOLVER] can_resolve(hasattr): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(hasattr): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(hasattr): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(hasattr): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(hasattr): proxy_handler.hasattr
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: hasattr -> proxy_handler.hasattr
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.hasattr
      -> Resolved to: proxy_handler.hasattr
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: name
    [RESOLVE] Attempting to resolve: ['name']
      [RESOLVE_SIMPLE] Resolving base: name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found name in function scope: proxy_handler.str
      [LOCAL_RESOLVER] can_resolve(name): True
      [SYMBOL_LOOKUP] Found name in function scope: proxy_handler.str
      [LOCAL_RESOLVER] resolve(name): proxy_handler.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: name -> proxy_handler.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.str
      [NAME] Found name reference: hasattr
        [CACHE] hasattr -> proxy_handler.hasattr (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.target
    [RESOLVE] Attempting to resolve: ['self', 'target']
    [RESOLVE] Chain resolution needed for: ['self', 'target']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.target
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.target
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.target
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.target
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.target
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy
      -> Not module state
      [NAME] Found name reference: name
    [RESOLVE] Attempting to resolve: ['name']
      [RESOLVE_SIMPLE] Resolving base: name
      [CACHE] Hit for name: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [ASSIGNMENT] Processing: attr = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: getattr
    [RESOLVE] Attempting to resolve: ['getattr']
      [RESOLVE_SIMPLE] Resolving base: getattr
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable getattr not found in any scope
      [LOCAL_RESOLVER] can_resolve(getattr): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(getattr): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(getattr): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(getattr): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(getattr): proxy_handler.getattr
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: getattr -> proxy_handler.getattr
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.getattr
      [TYPE_INFERENCE] Call resolved to: proxy_handler.getattr
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for attr
      [NAME] Found name reference: attr
    [RESOLVE] Attempting to resolve: ['attr']
      [RESOLVE_SIMPLE] Resolving base: attr
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable attr not found in any scope
      [LOCAL_RESOLVER] can_resolve(attr): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(attr): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(attr): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(attr): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(attr): proxy_handler.attr
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: attr -> proxy_handler.attr
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.attr
      -> Not module state
      [CALL] Found call: getattr
    [RESOLVE] Attempting to resolve: ['getattr']
      [RESOLVE_SIMPLE] Resolving base: getattr
      [CACHE] Hit for getattr: proxy_handler.getattr
    [RESOLVE] RESOLVED to: proxy_handler.getattr
      -> Resolved to: proxy_handler.getattr
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: name
    [RESOLVE] Attempting to resolve: ['name']
      [RESOLVE_SIMPLE] Resolving base: name
      [CACHE] Hit for name: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [NAME] Found name reference: getattr
        [CACHE] getattr -> proxy_handler.getattr (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.target
        [CACHE] self.target -> proxy_handler.BaseProxy.target (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [NAME] Found name reference: name
        [CACHE] name -> proxy_handler.str (cached)
      -> Not module state
      [CALL] Found call: callable
    [RESOLVE] Attempting to resolve: ['callable']
      [RESOLVE_SIMPLE] Resolving base: callable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable callable not found in any scope
      [LOCAL_RESOLVER] can_resolve(callable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(callable): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(callable): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(callable): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(callable): proxy_handler.callable
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: callable -> proxy_handler.callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.callable
      -> Resolved to: proxy_handler.callable
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: attr
    [RESOLVE] Attempting to resolve: ['attr']
      [RESOLVE_SIMPLE] Resolving base: attr
      [CACHE] Hit for attr: proxy_handler.attr
    [RESOLVE] RESOLVED to: proxy_handler.attr
      [NAME] Found name reference: callable
        [CACHE] callable -> proxy_handler.callable (cached)
      -> Not module state
      [NAME] Found name reference: attr
        [CACHE] attr -> proxy_handler.attr (cached)
      -> Not module state
      [CALL] Found call: self._create_proxy_method
    [RESOLVE] Attempting to resolve: ['self', '_create_proxy_method']
    [RESOLVE] Chain resolution needed for: ['self', '_create_proxy_method']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy._create_proxy_method
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy._create_proxy_method
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy._create_proxy_method
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy._create_proxy_method
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy._create_proxy_method
            [INTERMEDIATE] Tracking chain steps for: self._create_proxy_method
            [INTERMEDIATE] Step 1: self._create_proxy_method
      -> Resolved to: proxy_handler.BaseProxy._create_proxy_method
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: name
    [RESOLVE] Attempting to resolve: ['name']
      [RESOLVE_SIMPLE] Resolving base: name
      [CACHE] Hit for name: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
        [FUNCTION_ARG] Checking argument: attr
    [RESOLVE] Attempting to resolve: ['attr']
      [RESOLVE_SIMPLE] Resolving base: attr
      [CACHE] Hit for attr: proxy_handler.attr
    [RESOLVE] RESOLVED to: proxy_handler.attr
      [ATTRIBUTE] Found attribute access: self._create_proxy_method
        [CACHE] self._create_proxy_method -> proxy_handler.BaseProxy._create_proxy_method (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [NAME] Found name reference: name
        [CACHE] name -> proxy_handler.str (cached)
      -> Not module state
      [NAME] Found name reference: attr
        [CACHE] attr -> proxy_handler.attr (cached)
      -> Not module state
      [NAME] Found name reference: attr
        [CACHE] attr -> proxy_handler.attr (cached)
      -> Not module state
      [CALL] Found call: AttributeError
    [RESOLVE] Attempting to resolve: ['AttributeError']
      [RESOLVE_SIMPLE] Resolving base: AttributeError
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable AttributeError not found in any scope
      [LOCAL_RESOLVER] can_resolve(AttributeError): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(AttributeError): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(AttributeError): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(AttributeError): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(AttributeError): proxy_handler.AttributeError
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: AttributeError -> proxy_handler.AttributeError
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.AttributeError
      -> Resolved to: proxy_handler.AttributeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: AttributeError
        [CACHE] AttributeError -> proxy_handler.AttributeError (cached)
      -> Not module state
      [CALL] Found call: type
    [RESOLVE] Attempting to resolve: ['type']
      [RESOLVE_SIMPLE] Resolving base: type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable type not found in any scope
      [LOCAL_RESOLVER] can_resolve(type): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(type): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(type): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(type): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(type): proxy_handler.type
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: type -> proxy_handler.type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.type
      -> Resolved to: proxy_handler.type
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: type
        [CACHE] type -> proxy_handler.type (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.target
        [CACHE] self.target -> proxy_handler.BaseProxy.target (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [NAME] Found name reference: name
        [CACHE] name -> proxy_handler.str (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.BaseProxy.__getattr__
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.BaseProxy.__getattr__
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.BaseProxy._create_proxy_method
    [CONTEXT] Entered function: proxy_handler.BaseProxy._create_proxy_method (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'method_name': 'str', 'original_method': 'Callable'}
        [ARG_TYPE] Processing type annotation for method_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: method_name -> proxy_handler.str
        [ARG_TYPE] RESOLVED method_name : proxy_handler.str
        [ARG_TYPE] Processing type annotation for original_method: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Callable not found in any scope
      [LOCAL_RESOLVER] can_resolve(Callable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Callable): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Callable): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Callable): typing.Callable (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Callable -> typing.Callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Function: original_method -> typing.Callable
        [ARG_TYPE] RESOLVED original_method : typing.Callable
      [NESTED_FUNCTION] Analyzing nested function: proxy_wrapper
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 0 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'method_name': 'str', 'original_method': 'Callable'}
      [CALL] Found call: self._proxy_method_call
    [RESOLVE] Attempting to resolve: ['self', '_proxy_method_call']
    [RESOLVE] Chain resolution needed for: ['self', '_proxy_method_call']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy._proxy_method_call
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy._proxy_method_call
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy._proxy_method_call
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy._proxy_method_call
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy._proxy_method_call
            [INTERMEDIATE] Tracking chain steps for: self._proxy_method_call
            [INTERMEDIATE] Step 1: self._proxy_method_call
      -> Resolved to: proxy_handler.BaseProxy._proxy_method_call
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: method_name
    [RESOLVE] Attempting to resolve: ['method_name']
      [RESOLVE_SIMPLE] Resolving base: method_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found method_name in function scope: proxy_handler.str
      [LOCAL_RESOLVER] can_resolve(method_name): True
      [SYMBOL_LOOKUP] Found method_name in function scope: proxy_handler.str
      [LOCAL_RESOLVER] resolve(method_name): proxy_handler.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: method_name -> proxy_handler.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.str
      [ATTRIBUTE] Found attribute access: self._proxy_method_call
        [CACHE] self._proxy_method_call -> proxy_handler.BaseProxy._proxy_method_call (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy
      -> Not module state
      [NAME] Found name reference: method_name
    [RESOLVE] Attempting to resolve: ['method_name']
      [RESOLVE_SIMPLE] Resolving base: method_name
      [CACHE] Hit for method_name: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable args not found in any scope
      [LOCAL_RESOLVER] can_resolve(args): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(args): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(args): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(args): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(args): proxy_handler.args
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: args -> proxy_handler.args
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable kwargs not found in any scope
      [LOCAL_RESOLVER] can_resolve(kwargs): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(kwargs): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(kwargs): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(kwargs): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(kwargs): proxy_handler.kwargs
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: kwargs -> proxy_handler.kwargs
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.kwargs
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: proxy_wrapper
    [RESOLVE] Attempting to resolve: ['proxy_wrapper']
      [RESOLVE_SIMPLE] Resolving base: proxy_wrapper
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable proxy_wrapper not found in any scope
      [LOCAL_RESOLVER] can_resolve(proxy_wrapper): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(proxy_wrapper): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(proxy_wrapper): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(proxy_wrapper): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(proxy_wrapper): proxy_handler.proxy_wrapper
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: proxy_wrapper -> proxy_handler.proxy_wrapper
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.proxy_wrapper
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.BaseProxy._create_proxy_method
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.BaseProxy._create_proxy_method
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.BaseProxy._execute_with_circuit_breaker
    [DECORATOR] @trace
    [DECORATOR] @monitor_performance
    [CONTEXT] Entered function: proxy_handler.BaseProxy._execute_with_circuit_breaker (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'method_name': 'str', 'method': 'Callable'}
        [ARG_TYPE] Processing type annotation for method_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: method_name -> proxy_handler.str
        [ARG_TYPE] RESOLVED method_name : proxy_handler.str
        [ARG_TYPE] Processing type annotation for method: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Function: method -> typing.Callable
        [ARG_TYPE] RESOLVED method : typing.Callable
      [ATTRIBUTE] Found attribute access: self.circuit_breaker_open
    [RESOLVE] Attempting to resolve: ['self', 'circuit_breaker_open']
    [RESOLVE] Chain resolution needed for: ['self', 'circuit_breaker_open']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.circuit_breaker_open
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.circuit_breaker_open
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.circuit_breaker_open
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.circuit_breaker_open
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.circuit_breaker_open
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable time not found in any scope
      [LOCAL_RESOLVER] can_resolve(time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(time): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(time): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(time): time (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: time -> time
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.circuit_breaker_last_failure
    [RESOLVE] Attempting to resolve: ['self', 'circuit_breaker_last_failure']
    [RESOLVE] Chain resolution needed for: ['self', 'circuit_breaker_last_failure']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.circuit_breaker_last_failure
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.circuit_breaker_last_failure
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.circuit_breaker_last_failure
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.circuit_breaker_last_failure
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.circuit_breaker_last_failure
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.circuit_breaker_open
        [CACHE] self.circuit_breaker_open -> proxy_handler.BaseProxy.circuit_breaker_open (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.circuit_breaker_failures
    [RESOLVE] Attempting to resolve: ['self', 'circuit_breaker_failures']
    [RESOLVE] Chain resolution needed for: ['self', 'circuit_breaker_failures']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.circuit_breaker_failures
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.circuit_breaker_failures
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.circuit_breaker_failures
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.circuit_breaker_failures
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.circuit_breaker_failures
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [CALL] Found call: RuntimeError
    [RESOLVE] Attempting to resolve: ['RuntimeError']
      [RESOLVE_SIMPLE] Resolving base: RuntimeError
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable RuntimeError not found in any scope
      [LOCAL_RESOLVER] can_resolve(RuntimeError): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(RuntimeError): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(RuntimeError): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(RuntimeError): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(RuntimeError): proxy_handler.RuntimeError
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: RuntimeError -> proxy_handler.RuntimeError
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.RuntimeError
      -> Resolved to: proxy_handler.RuntimeError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: RuntimeError
        [CACHE] RuntimeError -> proxy_handler.RuntimeError (cached)
      -> Not module state
      [NAME] Found name reference: method_name
    [RESOLVE] Attempting to resolve: ['method_name']
      [RESOLVE_SIMPLE] Resolving base: method_name
      [CACHE] Hit for method_name: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: method
    [RESOLVE] Attempting to resolve: ['method']
      [RESOLVE_SIMPLE] Resolving base: method
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found method in function scope: typing.Callable
      [LOCAL_RESOLVER] can_resolve(method): True
      [SYMBOL_LOOKUP] Found method in function scope: typing.Callable
      [LOCAL_RESOLVER] resolve(method): typing.Callable
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: method -> typing.Callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Callable
      [TYPE_INFERENCE] Call resolved to: typing.Callable
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for result
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable result not found in any scope
      [LOCAL_RESOLVER] can_resolve(result): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(result): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(result): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(result): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(result): proxy_handler.result
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: result -> proxy_handler.result
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.result
      -> Not module state
      [CALL] Found call: method
    [RESOLVE] Attempting to resolve: ['method']
      [RESOLVE_SIMPLE] Resolving base: method
      [CACHE] Hit for method: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      -> Resolved to: typing.Callable
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: method
        [CACHE] method -> typing.Callable (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: proxy_handler.args
    [RESOLVE] RESOLVED to: proxy_handler.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: proxy_handler.kwargs
    [RESOLVE] RESOLVED to: proxy_handler.kwargs
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.circuit_breaker_failures
        [CACHE] self.circuit_breaker_failures -> proxy_handler.BaseProxy.circuit_breaker_failures (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> proxy_handler.result (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Exception not found in any scope
      [LOCAL_RESOLVER] can_resolve(Exception): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Exception): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Exception): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(Exception): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(Exception): proxy_handler.Exception
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: Exception -> proxy_handler.Exception
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.Exception
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.circuit_breaker_failures
        [CACHE] self.circuit_breaker_failures -> proxy_handler.BaseProxy.circuit_breaker_failures (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.circuit_breaker_last_failure
        [CACHE] self.circuit_breaker_last_failure -> proxy_handler.BaseProxy.circuit_breaker_last_failure (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [CALL] Found call: time.time
    [CACHE] time.time -> time.time (cached)
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
        [CACHE] time -> time (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.circuit_breaker_failures
        [CACHE] self.circuit_breaker_failures -> proxy_handler.BaseProxy.circuit_breaker_failures (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.circuit_breaker_open
        [CACHE] self.circuit_breaker_open -> proxy_handler.BaseProxy.circuit_breaker_open (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable e not found in any scope
      [LOCAL_RESOLVER] can_resolve(e): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(e): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(e): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(e): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(e): proxy_handler.e
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: e -> proxy_handler.e
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.e
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.BaseProxy._execute_with_circuit_breaker
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.BaseProxy._execute_with_circuit_breaker
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.BaseProxy._get_cache_key
    [CONTEXT] Entered function: proxy_handler.BaseProxy._get_cache_key (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'method_name': 'str'}
        [ARG_TYPE] Processing type annotation for method_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: method_name -> proxy_handler.str
        [ARG_TYPE] RESOLVED method_name : proxy_handler.str
      [NAME] Found name reference: method_name
    [RESOLVE] Attempting to resolve: ['method_name']
      [RESOLVE_SIMPLE] Resolving base: method_name
      [CACHE] Hit for method_name: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [CALL] Found call: hash
    [RESOLVE] Attempting to resolve: ['hash']
      [RESOLVE_SIMPLE] Resolving base: hash
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable hash not found in any scope
      [LOCAL_RESOLVER] can_resolve(hash): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(hash): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(hash): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(hash): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(hash): proxy_handler.hash
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: hash -> proxy_handler.hash
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.hash
      -> Resolved to: proxy_handler.hash
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: hash
        [CACHE] hash -> proxy_handler.hash (cached)
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
        [CACHE] str -> proxy_handler.str (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [CACHE] Hit for args: proxy_handler.args
    [RESOLVE] RESOLVED to: proxy_handler.args
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
        [CACHE] str -> proxy_handler.str (cached)
      -> Not module state
      [CALL] Found call: sorted
      -> IGNORED (built-in function)
      [NAME] Found name reference: sorted
    [RESOLVE] Attempting to resolve: ['sorted']
      [RESOLVE_SIMPLE] Resolving base: sorted
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable sorted not found in any scope
      [LOCAL_RESOLVER] can_resolve(sorted): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(sorted): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(sorted): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(sorted): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(sorted): proxy_handler.sorted
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: sorted -> proxy_handler.sorted
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.sorted
      -> Not module state
      [CALL] Found call: kwargs.items
    [RESOLVE] Attempting to resolve: ['kwargs', 'items']
    [RESOLVE] Chain resolution needed for: ['kwargs', 'items']
      [CHAIN] Resolving base: kwargs
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: proxy_handler.kwargs
      [CHAIN] Base resolved: kwargs -> proxy_handler.kwargs
      [CHAIN] Step 1: Resolving proxy_handler.kwargs.items
        [ATTRIBUTE] Resolving attribute: proxy_handler.kwargs.items
        [ATTRIBUTE] Direct match found: proxy_handler.kwargs.items
      [CHAIN] Step 1 resolved: proxy_handler.kwargs.items
    [RESOLVE] RESOLVED to: proxy_handler.kwargs.items
            [INTERMEDIATE] Tracking chain steps for: kwargs.items
            [INTERMEDIATE] Step 1: kwargs.items
      -> Resolved to: proxy_handler.kwargs.items
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: kwargs.items
        [CACHE] kwargs.items -> proxy_handler.kwargs.items (cached)
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [CACHE] Hit for kwargs: proxy_handler.kwargs
    [RESOLVE] RESOLVED to: proxy_handler.kwargs
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.BaseProxy._get_cache_key
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.BaseProxy._get_cache_key
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.BaseProxy._metrics_context
    [DECORATOR] @contextmanager
      [CODE_STANDARD_VIOLATION] MISSING_RETURN_TYPE: Function proxy_handler.BaseProxy._metrics_context
      [IMPACT] Cannot infer return type - chained method calls may fail
      [ACTION_REQUIRED] Add appropriate type annotation
      [CODE_QUALITY] Found 1 violations in proxy_handler.BaseProxy._metrics_context
    [CONTEXT] Entered function: proxy_handler.BaseProxy._metrics_context (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'method_name': 'str'}
        [ARG_TYPE] Processing type annotation for method_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: method_name -> proxy_handler.str
        [ARG_TYPE] RESOLVED method_name : proxy_handler.str
      [ASSIGNMENT] Processing: start_time = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
      [TYPE_INFERENCE] Call resolved to: time.time
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for start_time
      [NAME] Found name reference: start_time
    [RESOLVE] Attempting to resolve: ['start_time']
      [RESOLVE_SIMPLE] Resolving base: start_time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable start_time not found in any scope
      [LOCAL_RESOLVER] can_resolve(start_time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(start_time): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(start_time): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(start_time): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(start_time): proxy_handler.start_time
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: start_time -> proxy_handler.start_time
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.start_time
      -> Not module state
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
      [ASSIGNMENT] Processing: success = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: success
    [RESOLVE] Attempting to resolve: ['success']
      [RESOLVE_SIMPLE] Resolving base: success
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable success not found in any scope
      [LOCAL_RESOLVER] can_resolve(success): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(success): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(success): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(success): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(success): proxy_handler.success
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: success -> proxy_handler.success
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.success
      -> Not module state
      [ASSIGNMENT] Processing: cache_hit = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: cache_hit
    [RESOLVE] Attempting to resolve: ['cache_hit']
      [RESOLVE_SIMPLE] Resolving base: cache_hit
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable cache_hit not found in any scope
      [LOCAL_RESOLVER] can_resolve(cache_hit): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(cache_hit): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(cache_hit): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(cache_hit): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(cache_hit): proxy_handler.cache_hit
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: cache_hit -> proxy_handler.cache_hit
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.cache_hit
      -> Not module state
      [CALL] Found call: setattr
    [RESOLVE] Attempting to resolve: ['setattr']
      [RESOLVE_SIMPLE] Resolving base: setattr
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable setattr not found in any scope
      [LOCAL_RESOLVER] can_resolve(setattr): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(setattr): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(setattr): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(setattr): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(setattr): proxy_handler.setattr
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: setattr -> proxy_handler.setattr
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.setattr
      -> Resolved to: proxy_handler.setattr
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy
      [NAME] Found name reference: setattr
        [CACHE] setattr -> proxy_handler.setattr (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy
      -> Not module state
      [ASSIGNMENT] Processing: success = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: success
        [CACHE] success -> proxy_handler.success (cached)
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [CACHE] Hit for Exception: proxy_handler.Exception
    [RESOLVE] RESOLVED to: proxy_handler.Exception
      -> Not module state
      [ASSIGNMENT] Processing: success = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: success
        [CACHE] success -> proxy_handler.success (cached)
      -> Not module state
      [ASSIGNMENT] Processing: execution_time = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: execution_time
    [RESOLVE] Attempting to resolve: ['execution_time']
      [RESOLVE_SIMPLE] Resolving base: execution_time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable execution_time not found in any scope
      [LOCAL_RESOLVER] can_resolve(execution_time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(execution_time): False (current_class: proxy_handler.BaseProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(execution_time): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(execution_time): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(execution_time): proxy_handler.execution_time
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: execution_time -> proxy_handler.execution_time
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.execution_time
      -> Not module state
      [CALL] Found call: time.time
    [CACHE] time.time -> time.time (cached)
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
        [CACHE] time -> time (cached)
      -> Not module state
      [NAME] Found name reference: start_time
        [CACHE] start_time -> proxy_handler.start_time (cached)
      -> Not module state
      [ASSIGNMENT] Processing: cache_hit = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: getattr
    [RESOLVE] Attempting to resolve: ['getattr']
      [RESOLVE_SIMPLE] Resolving base: getattr
      [CACHE] Hit for getattr: proxy_handler.getattr
    [RESOLVE] RESOLVED to: proxy_handler.getattr
      [TYPE_INFERENCE] Call resolved to: proxy_handler.getattr
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for cache_hit
      [NAME] Found name reference: cache_hit
        [CACHE] cache_hit -> proxy_handler.cache_hit (cached)
      -> Not module state
      [CALL] Found call: getattr
    [RESOLVE] Attempting to resolve: ['getattr']
      [RESOLVE_SIMPLE] Resolving base: getattr
      [CACHE] Hit for getattr: proxy_handler.getattr
    [RESOLVE] RESOLVED to: proxy_handler.getattr
      -> Resolved to: proxy_handler.getattr
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy
      [NAME] Found name reference: getattr
        [CACHE] getattr -> proxy_handler.getattr (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [CALL] Found call: setattr
    [CACHE] setattr -> proxy_handler.setattr (cached)
      -> Resolved to: proxy_handler.setattr
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy
      [NAME] Found name reference: setattr
        [CACHE] setattr -> proxy_handler.setattr (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [CALL] Found call: self.metrics.record_call
    [RESOLVE] Attempting to resolve: ['self', 'metrics', 'record_call']
    [RESOLVE] Chain resolution needed for: ['self', 'metrics', 'record_call']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.metrics
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.metrics
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.metrics
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.metrics
      [CHAIN] Step 2: Resolving proxy_handler.BaseProxy.metrics.record_call
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.metrics.record_call
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.metrics.record_call
      [CHAIN] Step 2 resolved: proxy_handler.BaseProxy.metrics.record_call
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.metrics.record_call
            [INTERMEDIATE] Tracking chain steps for: self.metrics.record_call
            [INTERMEDIATE] Step 1: self.metrics
    [RESOLVE] Attempting to resolve: ['self', 'metrics']
    [RESOLVE] Chain resolution needed for: ['self', 'metrics']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.BaseProxy
      [CHAIN] Base resolved: self -> proxy_handler.BaseProxy
      [CHAIN] Step 1: Resolving proxy_handler.BaseProxy.metrics
        [ATTRIBUTE] Resolving attribute: proxy_handler.BaseProxy.metrics
        [ATTRIBUTE] Direct match found: proxy_handler.BaseProxy.metrics
      [CHAIN] Step 1 resolved: proxy_handler.BaseProxy.metrics
    [RESOLVE] RESOLVED to: proxy_handler.BaseProxy.metrics
            [INTERMEDIATE] Step 1 resolved to: proxy_handler.BaseProxy.metrics
            [INTERMEDIATE] Step 2: self.metrics.record_call
      -> Resolved to: proxy_handler.BaseProxy.metrics.record_call
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: execution_time
    [RESOLVE] Attempting to resolve: ['execution_time']
      [RESOLVE_SIMPLE] Resolving base: execution_time
      [CACHE] Hit for execution_time: proxy_handler.execution_time
    [RESOLVE] RESOLVED to: proxy_handler.execution_time
        [FUNCTION_ARG] Checking argument: success
    [RESOLVE] Attempting to resolve: ['success']
      [RESOLVE_SIMPLE] Resolving base: success
      [CACHE] Hit for success: proxy_handler.success
    [RESOLVE] RESOLVED to: proxy_handler.success
        [FUNCTION_ARG] Checking argument: cache_hit
    [RESOLVE] Attempting to resolve: ['cache_hit']
      [RESOLVE_SIMPLE] Resolving base: cache_hit
      [CACHE] Hit for cache_hit: proxy_handler.cache_hit
    [RESOLVE] RESOLVED to: proxy_handler.cache_hit
      [ATTRIBUTE] Found attribute access: self.metrics.record_call
        [CACHE] self.metrics.record_call -> proxy_handler.BaseProxy.metrics.record_call (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.metrics
        [CACHE] self.metrics -> proxy_handler.BaseProxy.metrics (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.BaseProxy (cached)
      -> Not module state
      [NAME] Found name reference: execution_time
        [CACHE] execution_time -> proxy_handler.execution_time (cached)
      -> Not module state
      [NAME] Found name reference: success
        [CACHE] success -> proxy_handler.success (cached)
      -> Not module state
      [NAME] Found name reference: cache_hit
        [CACHE] cache_hit -> proxy_handler.cache_hit (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.BaseProxy._metrics_context
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.BaseProxy._metrics_context
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: proxy_handler.BaseProxy
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: DataProxy
    [CONTEXT] Entered class: proxy_handler.DataProxy
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.DataProxy.__init__
    [CONTEXT] Entered function: proxy_handler.DataProxy.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'data_source': 'Any', 'config': 'ProxyConfig'}
        [ARG_TYPE] Processing type annotation for data_source: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: proxy_handler.DataProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: data_source -> typing.Any
        [ARG_TYPE] RESOLVED data_source : typing.Any
        [ARG_TYPE] Processing type annotation for config: ProxyConfig
    [RESOLVE] Attempting to resolve: ['ProxyConfig']
      [RESOLVE_SIMPLE] Resolving base: ProxyConfig
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ProxyConfig not found in any scope
      [LOCAL_RESOLVER] can_resolve(ProxyConfig): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ProxyConfig): False (current_class: proxy_handler.DataProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ProxyConfig): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ProxyConfig): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(ProxyConfig): proxy_handler.ProxyConfig
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ProxyConfig -> proxy_handler.ProxyConfig
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.ProxyConfig
      [SYMBOL_UPDATE] Function: config -> proxy_handler.ProxyConfig
        [ARG_TYPE] RESOLVED config : proxy_handler.ProxyConfig
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable super not found in any scope
      [LOCAL_RESOLVER] can_resolve(super): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(super): False (current_class: proxy_handler.DataProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(super): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(super): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(super): proxy_handler.super
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: super -> proxy_handler.super
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.super
      -> Resolved to: proxy_handler.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> proxy_handler.super (cached)
      -> Not module state
      [NAME] Found name reference: data_source
    [RESOLVE] Attempting to resolve: ['data_source']
      [RESOLVE_SIMPLE] Resolving base: data_source
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found data_source in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(data_source): True
      [SYMBOL_LOOKUP] Found data_source in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(data_source): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: data_source -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [NAME] Found name reference: config
    [RESOLVE] Attempting to resolve: ['config']
      [RESOLVE_SIMPLE] Resolving base: config
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found config in function scope: proxy_handler.ProxyConfig
      [LOCAL_RESOLVER] can_resolve(config): True
      [SYMBOL_LOOKUP] Found config in function scope: proxy_handler.ProxyConfig
      [LOCAL_RESOLVER] resolve(config): proxy_handler.ProxyConfig
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: config -> proxy_handler.ProxyConfig
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.ProxyConfig
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.data_validators
    [RESOLVE] Attempting to resolve: ['self', 'data_validators']
    [RESOLVE] Chain resolution needed for: ['self', 'data_validators']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: proxy_handler.DataProxy)
      [SELF_RESOLVER] resolve(self): proxy_handler.DataProxy
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> proxy_handler.DataProxy
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> proxy_handler.DataProxy
      [CHAIN] Step 1: Resolving proxy_handler.DataProxy.data_validators
        [ATTRIBUTE] Resolving attribute: proxy_handler.DataProxy.data_validators
        [ATTRIBUTE] Direct match found: proxy_handler.DataProxy.data_validators
      [CHAIN] Step 1 resolved: proxy_handler.DataProxy.data_validators
    [RESOLVE] RESOLVED to: proxy_handler.DataProxy.data_validators
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.DataProxy
    [RESOLVE] RESOLVED to: proxy_handler.DataProxy
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: proxy_handler.DataProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: proxy_handler.DataProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(str): proxy_handler.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> proxy_handler.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [NAME] Found name reference: List
    [RESOLVE] Attempting to resolve: ['List']
      [RESOLVE_SIMPLE] Resolving base: List
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable List not found in any scope
      [LOCAL_RESOLVER] can_resolve(List): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(List): False (current_class: proxy_handler.DataProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(List): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(List): typing.List (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: List -> typing.List
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.List
      -> Not module state
      [NAME] Found name reference: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Callable not found in any scope
      [LOCAL_RESOLVER] can_resolve(Callable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Callable): False (current_class: proxy_handler.DataProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Callable): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Callable): typing.Callable (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Callable -> typing.Callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Callable
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.data_transformers
    [RESOLVE] Attempting to resolve: ['self', 'data_transformers']
    [RESOLVE] Chain resolution needed for: ['self', 'data_transformers']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.DataProxy
      [CHAIN] Base resolved: self -> proxy_handler.DataProxy
      [CHAIN] Step 1: Resolving proxy_handler.DataProxy.data_transformers
        [ATTRIBUTE] Resolving attribute: proxy_handler.DataProxy.data_transformers
        [ATTRIBUTE] Direct match found: proxy_handler.DataProxy.data_transformers
      [CHAIN] Step 1 resolved: proxy_handler.DataProxy.data_transformers
    [RESOLVE] RESOLVED to: proxy_handler.DataProxy.data_transformers
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.DataProxy (cached)
      -> Not module state
      [NAME] Found name reference: Dict
        [CACHE] Dict -> typing.Dict (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> proxy_handler.str (cached)
      -> Not module state
      [NAME] Found name reference: List
        [CACHE] List -> typing.List (cached)
      -> Not module state
      [NAME] Found name reference: Callable
        [CACHE] Callable -> typing.Callable (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.DataProxy.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.DataProxy.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.DataProxy._proxy_method_call
    [DECORATOR] @trace
    [CONTEXT] Entered function: proxy_handler.DataProxy._proxy_method_call (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'method_name': 'str'}
        [ARG_TYPE] Processing type annotation for method_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: method_name -> proxy_handler.str
        [ARG_TYPE] RESOLVED method_name : proxy_handler.str
      [CALL] Found call: self._metrics_context
    [RESOLVE] Attempting to resolve: ['self', '_metrics_context']
    [RESOLVE] Chain resolution needed for: ['self', '_metrics_context']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.DataProxy
      [CHAIN] Base resolved: self -> proxy_handler.DataProxy
      [CHAIN] Step 1: Resolving proxy_handler.DataProxy._metrics_context
        [ATTRIBUTE] Resolving attribute: proxy_handler.DataProxy._metrics_context
        [ATTRIBUTE] Direct match found: proxy_handler.DataProxy._metrics_context
      [CHAIN] Step 1 resolved: proxy_handler.DataProxy._metrics_context
    [RESOLVE] RESOLVED to: proxy_handler.DataProxy._metrics_context
            [INTERMEDIATE] Tracking chain steps for: self._metrics_context
            [INTERMEDIATE] Step 1: self._metrics_context
      -> Resolved to: proxy_handler.DataProxy._metrics_context
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: method_name
    [RESOLVE] Attempting to resolve: ['method_name']
      [RESOLVE_SIMPLE] Resolving base: method_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found method_name in function scope: proxy_handler.str
      [LOCAL_RESOLVER] can_resolve(method_name): True
      [SYMBOL_LOOKUP] Found method_name in function scope: proxy_handler.str
      [LOCAL_RESOLVER] resolve(method_name): proxy_handler.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: method_name -> proxy_handler.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.str
      [ATTRIBUTE] Found attribute access: self._metrics_context
        [CACHE] self._metrics_context -> proxy_handler.DataProxy._metrics_context (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.DataProxy
    [RESOLVE] RESOLVED to: proxy_handler.DataProxy
      -> Not module state
      [NAME] Found name reference: method_name
    [RESOLVE] Attempting to resolve: ['method_name']
      [RESOLVE_SIMPLE] Resolving base: method_name
      [CACHE] Hit for method_name: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [NAME] Found name reference: mark_cache_hit
    [RESOLVE] Attempting to resolve: ['mark_cache_hit']
      [RESOLVE_SIMPLE] Resolving base: mark_cache_hit
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable mark_cache_hit not found in any scope
      [LOCAL_RESOLVER] can_resolve(mark_cache_hit): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(mark_cache_hit): False (current_class: proxy_handler.DataProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(mark_cache_hit): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(mark_cache_hit): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(mark_cache_hit): proxy_handler.mark_cache_hit
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: mark_cache_hit -> proxy_handler.mark_cache_hit
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.mark_cache_hit
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.config.cache_enabled
    [RESOLVE] Attempting to resolve: ['self', 'config', 'cache_enabled']
    [RESOLVE] Chain resolution needed for: ['self', 'config', 'cache_enabled']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.DataProxy
      [CHAIN] Base resolved: self -> proxy_handler.DataProxy
      [CHAIN] Step 1: Resolving proxy_handler.DataProxy.config
        [ATTRIBUTE] Resolving attribute: proxy_handler.DataProxy.config
        [ATTRIBUTE] Direct match found: proxy_handler.DataProxy.config
      [CHAIN] Step 1 resolved: proxy_handler.DataProxy.config
      [CHAIN] Step 2: Resolving proxy_handler.DataProxy.config.cache_enabled
        [ATTRIBUTE] Resolving attribute: proxy_handler.DataProxy.config.cache_enabled
        [ATTRIBUTE] Direct match found: proxy_handler.DataProxy.config.cache_enabled
      [CHAIN] Step 2 resolved: proxy_handler.DataProxy.config.cache_enabled
    [RESOLVE] RESOLVED to: proxy_handler.DataProxy.config.cache_enabled
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.config
    [RESOLVE] Attempting to resolve: ['self', 'config']
    [RESOLVE] Chain resolution needed for: ['self', 'config']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.DataProxy
      [CHAIN] Base resolved: self -> proxy_handler.DataProxy
      [CHAIN] Step 1: Resolving proxy_handler.DataProxy.config
        [ATTRIBUTE] Resolving attribute: proxy_handler.DataProxy.config
        [ATTRIBUTE] Direct match found: proxy_handler.DataProxy.config
      [CHAIN] Step 1 resolved: proxy_handler.DataProxy.config
    [RESOLVE] RESOLVED to: proxy_handler.DataProxy.config
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.DataProxy (cached)
      -> Not module state
      [ASSIGNMENT] Processing: cache_key = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self._get_cache_key
    [RESOLVE] Attempting to resolve: ['self', '_get_cache_key']
    [RESOLVE] Chain resolution needed for: ['self', '_get_cache_key']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.DataProxy
      [CHAIN] Base resolved: self -> proxy_handler.DataProxy
      [CHAIN] Step 1: Resolving proxy_handler.DataProxy._get_cache_key
        [ATTRIBUTE] Resolving attribute: proxy_handler.DataProxy._get_cache_key
        [ATTRIBUTE] Direct match found: proxy_handler.DataProxy._get_cache_key
      [CHAIN] Step 1 resolved: proxy_handler.DataProxy._get_cache_key
    [RESOLVE] RESOLVED to: proxy_handler.DataProxy._get_cache_key
      [TYPE_INFERENCE] Call resolved to: proxy_handler.DataProxy._get_cache_key
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for cache_key
      [NAME] Found name reference: cache_key
    [RESOLVE] Attempting to resolve: ['cache_key']
      [RESOLVE_SIMPLE] Resolving base: cache_key
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable cache_key not found in any scope
      [LOCAL_RESOLVER] can_resolve(cache_key): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(cache_key): False (current_class: proxy_handler.DataProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(cache_key): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(cache_key): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(cache_key): proxy_handler.cache_key
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: cache_key -> proxy_handler.cache_key
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.cache_key
      -> Not module state
      [CALL] Found call: self._get_cache_key
    [RESOLVE] Attempting to resolve: ['self', '_get_cache_key']
    [RESOLVE] Chain resolution needed for: ['self', '_get_cache_key']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.DataProxy
      [CHAIN] Base resolved: self -> proxy_handler.DataProxy
      [CHAIN] Step 1: Resolving proxy_handler.DataProxy._get_cache_key
        [ATTRIBUTE] Resolving attribute: proxy_handler.DataProxy._get_cache_key
        [ATTRIBUTE] Direct match found: proxy_handler.DataProxy._get_cache_key
      [CHAIN] Step 1 resolved: proxy_handler.DataProxy._get_cache_key
    [RESOLVE] RESOLVED to: proxy_handler.DataProxy._get_cache_key
            [INTERMEDIATE] Tracking chain steps for: self._get_cache_key
            [INTERMEDIATE] Step 1: self._get_cache_key
      -> Resolved to: proxy_handler.DataProxy._get_cache_key
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: method_name
    [RESOLVE] Attempting to resolve: ['method_name']
      [RESOLVE_SIMPLE] Resolving base: method_name
      [CACHE] Hit for method_name: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [ATTRIBUTE] Found attribute access: self._get_cache_key
        [CACHE] self._get_cache_key -> proxy_handler.DataProxy._get_cache_key (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.DataProxy (cached)
      -> Not module state
      [NAME] Found name reference: method_name
        [CACHE] method_name -> proxy_handler.str (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable args not found in any scope
      [LOCAL_RESOLVER] can_resolve(args): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(args): False (current_class: proxy_handler.DataProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(args): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(args): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(args): proxy_handler.args
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: args -> proxy_handler.args
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable kwargs not found in any scope
      [LOCAL_RESOLVER] can_resolve(kwargs): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(kwargs): False (current_class: proxy_handler.DataProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(kwargs): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(kwargs): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(kwargs): proxy_handler.kwargs
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: kwargs -> proxy_handler.kwargs
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.kwargs
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.lock
    [RESOLVE] Attempting to resolve: ['self', 'lock']
    [RESOLVE] Chain resolution needed for: ['self', 'lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.DataProxy
      [CHAIN] Base resolved: self -> proxy_handler.DataProxy
      [CHAIN] Step 1: Resolving proxy_handler.DataProxy.lock
        [ATTRIBUTE] Resolving attribute: proxy_handler.DataProxy.lock
        [ATTRIBUTE] Direct match found: proxy_handler.DataProxy.lock
      [CHAIN] Step 1 resolved: proxy_handler.DataProxy.lock
    [RESOLVE] RESOLVED to: proxy_handler.DataProxy.lock
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.DataProxy (cached)
      -> Not module state
      [NAME] Found name reference: cache_key
        [CACHE] cache_key -> proxy_handler.cache_key (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cache
    [RESOLVE] Attempting to resolve: ['self', 'cache']
    [RESOLVE] Chain resolution needed for: ['self', 'cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.DataProxy
      [CHAIN] Base resolved: self -> proxy_handler.DataProxy
      [CHAIN] Step 1: Resolving proxy_handler.DataProxy.cache
        [ATTRIBUTE] Resolving attribute: proxy_handler.DataProxy.cache
        [ATTRIBUTE] Direct match found: proxy_handler.DataProxy.cache
      [CHAIN] Step 1 resolved: proxy_handler.DataProxy.cache
    [RESOLVE] RESOLVED to: proxy_handler.DataProxy.cache
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.DataProxy (cached)
      -> Not module state
      [CALL] Found call: mark_cache_hit
    [CACHE] mark_cache_hit -> proxy_handler.mark_cache_hit (cached)
      -> Resolved to: proxy_handler.mark_cache_hit
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: mark_cache_hit
        [CACHE] mark_cache_hit -> proxy_handler.mark_cache_hit (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.DataProxy._proxy_method_call
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.DataProxy._proxy_method_call
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: proxy_handler.DataProxy
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: HavenProxy
    [CONTEXT] Entered class: proxy_handler.HavenProxy
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.__init__
    [CONTEXT] Entered function: proxy_handler.HavenProxy.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'target': 'Any', 'config': 'ProxyConfig'}
        [ARG_TYPE] Processing type annotation for target: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: proxy_handler.HavenProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      [SYMBOL_UPDATE] Function: target -> typing.Any
        [ARG_TYPE] RESOLVED target : typing.Any
        [ARG_TYPE] Processing type annotation for config: ProxyConfig
    [RESOLVE] Attempting to resolve: ['ProxyConfig']
      [RESOLVE_SIMPLE] Resolving base: ProxyConfig
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ProxyConfig not found in any scope
      [LOCAL_RESOLVER] can_resolve(ProxyConfig): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ProxyConfig): False (current_class: proxy_handler.HavenProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ProxyConfig): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ProxyConfig): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(ProxyConfig): proxy_handler.ProxyConfig
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ProxyConfig -> proxy_handler.ProxyConfig
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.ProxyConfig
      [SYMBOL_UPDATE] Function: config -> proxy_handler.ProxyConfig
        [ARG_TYPE] RESOLVED config : proxy_handler.ProxyConfig
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable super not found in any scope
      [LOCAL_RESOLVER] can_resolve(super): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(super): False (current_class: proxy_handler.HavenProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(super): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(super): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(super): proxy_handler.super
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: super -> proxy_handler.super
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.super
      -> Resolved to: proxy_handler.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> proxy_handler.super (cached)
      -> Not module state
      [NAME] Found name reference: target
    [RESOLVE] Attempting to resolve: ['target']
      [RESOLVE_SIMPLE] Resolving base: target
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found target in function scope: typing.Any
      [LOCAL_RESOLVER] can_resolve(target): True
      [SYMBOL_LOOKUP] Found target in function scope: typing.Any
      [LOCAL_RESOLVER] resolve(target): typing.Any
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: target -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [NAME] Found name reference: config
    [RESOLVE] Attempting to resolve: ['config']
      [RESOLVE_SIMPLE] Resolving base: config
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found config in function scope: proxy_handler.ProxyConfig
      [LOCAL_RESOLVER] can_resolve(config): True
      [SYMBOL_LOOKUP] Found config in function scope: proxy_handler.ProxyConfig
      [LOCAL_RESOLVER] resolve(config): proxy_handler.ProxyConfig
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: config -> proxy_handler.ProxyConfig
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.ProxyConfig
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_cache
    [RESOLVE] Attempting to resolve: ['self', 'user_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'user_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: proxy_handler.HavenProxy)
      [SELF_RESOLVER] resolve(self): proxy_handler.HavenProxy
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> proxy_handler.HavenProxy
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> proxy_handler.HavenProxy
      [CHAIN] Step 1: Resolving proxy_handler.HavenProxy.user_cache
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.user_cache
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.user_cache
      [CHAIN] Step 1 resolved: proxy_handler.HavenProxy.user_cache
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy.user_cache
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: proxy_handler.HavenProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: proxy_handler.HavenProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(str): proxy_handler.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> proxy_handler.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [NAME] Found name reference: Any
        [CACHE] Any -> typing.Any (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.room_permissions
    [RESOLVE] Attempting to resolve: ['self', 'room_permissions']
    [RESOLVE] Chain resolution needed for: ['self', 'room_permissions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
      [CHAIN] Base resolved: self -> proxy_handler.HavenProxy
      [CHAIN] Step 1: Resolving proxy_handler.HavenProxy.room_permissions
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.room_permissions
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.room_permissions
      [CHAIN] Step 1 resolved: proxy_handler.HavenProxy.room_permissions
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy.room_permissions
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.HavenProxy (cached)
      -> Not module state
      [NAME] Found name reference: Dict
        [CACHE] Dict -> typing.Dict (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> proxy_handler.str (cached)
      -> Not module state
      [NAME] Found name reference: Set
    [RESOLVE] Attempting to resolve: ['Set']
      [RESOLVE_SIMPLE] Resolving base: Set
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Set not found in any scope
      [LOCAL_RESOLVER] can_resolve(Set): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Set): False (current_class: proxy_handler.HavenProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Set): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Set): typing.Set (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Set -> typing.Set
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Set
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> proxy_handler.str (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.HavenProxy.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.validate_user_credentials
    [CONTEXT] Entered function: proxy_handler.HavenProxy.validate_user_credentials (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'auth_data': 'Dict[str, Any]'}
      [CALL] Found call: auth_data.get
    [RESOLVE] Attempting to resolve: ['auth_data', 'get']
    [RESOLVE] Chain resolution needed for: ['auth_data', 'get']
      [CHAIN] Resolving base: auth_data
      [RESOLVE_SIMPLE] Resolving base: auth_data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable auth_data not found in any scope
      [LOCAL_RESOLVER] can_resolve(auth_data): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(auth_data): False (current_class: proxy_handler.HavenProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(auth_data): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(auth_data): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(auth_data): proxy_handler.auth_data
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: auth_data -> proxy_handler.auth_data
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: auth_data -> proxy_handler.auth_data
      [CHAIN] Step 1: Resolving proxy_handler.auth_data.get
        [ATTRIBUTE] Resolving attribute: proxy_handler.auth_data.get
        [ATTRIBUTE] Direct match found: proxy_handler.auth_data.get
      [CHAIN] Step 1 resolved: proxy_handler.auth_data.get
    [RESOLVE] RESOLVED to: proxy_handler.auth_data.get
            [INTERMEDIATE] Tracking chain steps for: auth_data.get
            [INTERMEDIATE] Step 1: auth_data.get
      -> Resolved to: proxy_handler.auth_data.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: auth_data.get
        [CACHE] auth_data.get -> proxy_handler.auth_data.get (cached)
      -> Not module state
      [NAME] Found name reference: auth_data
    [RESOLVE] Attempting to resolve: ['auth_data']
      [RESOLVE_SIMPLE] Resolving base: auth_data
      [CACHE] Hit for auth_data: proxy_handler.auth_data
    [RESOLVE] RESOLVED to: proxy_handler.auth_data
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.HavenProxy.validate_user_credentials
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.validate_user_credentials
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.get_user_preferences
    [CONTEXT] Entered function: proxy_handler.HavenProxy.get_user_preferences (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: user_id -> proxy_handler.str
        [ARG_TYPE] RESOLVED user_id : proxy_handler.str
      [CALL] Found call: self.user_cache.get
    [RESOLVE] Attempting to resolve: ['self', 'user_cache', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'user_cache', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
      [CHAIN] Base resolved: self -> proxy_handler.HavenProxy
      [CHAIN] Step 1: Resolving proxy_handler.HavenProxy.user_cache
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.user_cache
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.user_cache
      [CHAIN] Step 1 resolved: proxy_handler.HavenProxy.user_cache
      [CHAIN] Step 2: Resolving proxy_handler.HavenProxy.user_cache.get
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.user_cache.get
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.user_cache.get
      [CHAIN] Step 2 resolved: proxy_handler.HavenProxy.user_cache.get
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy.user_cache.get
            [INTERMEDIATE] Tracking chain steps for: self.user_cache.get
            [INTERMEDIATE] Step 1: self.user_cache
    [RESOLVE] Attempting to resolve: ['self', 'user_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'user_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
      [CHAIN] Base resolved: self -> proxy_handler.HavenProxy
      [CHAIN] Step 1: Resolving proxy_handler.HavenProxy.user_cache
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.user_cache
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.user_cache
      [CHAIN] Step 1 resolved: proxy_handler.HavenProxy.user_cache
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy.user_cache
            [INTERMEDIATE] Step 1 resolved to: proxy_handler.HavenProxy.user_cache
            [INTERMEDIATE] Step 2: self.user_cache.get
      -> Resolved to: proxy_handler.HavenProxy.user_cache.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found user_id in function scope: proxy_handler.str
      [LOCAL_RESOLVER] can_resolve(user_id): True
      [SYMBOL_LOOKUP] Found user_id in function scope: proxy_handler.str
      [LOCAL_RESOLVER] resolve(user_id): proxy_handler.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: user_id -> proxy_handler.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.str
      [ATTRIBUTE] Found attribute access: self.user_cache.get
        [CACHE] self.user_cache.get -> proxy_handler.HavenProxy.user_cache.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_cache
        [CACHE] self.user_cache -> proxy_handler.HavenProxy.user_cache (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.HavenProxy.get_user_preferences
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.get_user_preferences
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.validate_room_access
    [CONTEXT] Entered function: proxy_handler.HavenProxy.validate_room_access (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str', 'room_name': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: user_id -> proxy_handler.str
        [ARG_TYPE] RESOLVED user_id : proxy_handler.str
        [ARG_TYPE] Processing type annotation for room_name: str
        [CACHE] str -> proxy_handler.str (cached)
      [SYMBOL_UPDATE] Function: room_name -> proxy_handler.str
        [ARG_TYPE] RESOLVED room_name : proxy_handler.str
      [NAME] Found name reference: room_name
    [RESOLVE] Attempting to resolve: ['room_name']
      [RESOLVE_SIMPLE] Resolving base: room_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found room_name in function scope: proxy_handler.str
      [LOCAL_RESOLVER] can_resolve(room_name): True
      [SYMBOL_LOOKUP] Found room_name in function scope: proxy_handler.str
      [LOCAL_RESOLVER] resolve(room_name): proxy_handler.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: room_name -> proxy_handler.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [CALL] Found call: self.room_permissions.get
    [RESOLVE] Attempting to resolve: ['self', 'room_permissions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'room_permissions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
      [CHAIN] Base resolved: self -> proxy_handler.HavenProxy
      [CHAIN] Step 1: Resolving proxy_handler.HavenProxy.room_permissions
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.room_permissions
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.room_permissions
      [CHAIN] Step 1 resolved: proxy_handler.HavenProxy.room_permissions
      [CHAIN] Step 2: Resolving proxy_handler.HavenProxy.room_permissions.get
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.room_permissions.get
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.room_permissions.get
      [CHAIN] Step 2 resolved: proxy_handler.HavenProxy.room_permissions.get
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy.room_permissions.get
            [INTERMEDIATE] Tracking chain steps for: self.room_permissions.get
            [INTERMEDIATE] Step 1: self.room_permissions
    [RESOLVE] Attempting to resolve: ['self', 'room_permissions']
    [RESOLVE] Chain resolution needed for: ['self', 'room_permissions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
      [CHAIN] Base resolved: self -> proxy_handler.HavenProxy
      [CHAIN] Step 1: Resolving proxy_handler.HavenProxy.room_permissions
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.room_permissions
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.room_permissions
      [CHAIN] Step 1 resolved: proxy_handler.HavenProxy.room_permissions
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy.room_permissions
            [INTERMEDIATE] Step 1 resolved to: proxy_handler.HavenProxy.room_permissions
            [INTERMEDIATE] Step 2: self.room_permissions.get
      -> Resolved to: proxy_handler.HavenProxy.room_permissions.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [ATTRIBUTE] Found attribute access: self.room_permissions.get
        [CACHE] self.room_permissions.get -> proxy_handler.HavenProxy.room_permissions.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.room_permissions
        [CACHE] self.room_permissions -> proxy_handler.HavenProxy.room_permissions (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [CALL] Found call: set
      -> IGNORED (built-in function)
      [NAME] Found name reference: set
    [RESOLVE] Attempting to resolve: ['set']
      [RESOLVE_SIMPLE] Resolving base: set
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable set not found in any scope
      [LOCAL_RESOLVER] can_resolve(set): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(set): False (current_class: proxy_handler.HavenProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(set): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(set): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(set): proxy_handler.set
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: set -> proxy_handler.set
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.set
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.HavenProxy.validate_room_access
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.validate_room_access
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.get_user_info
    [CONTEXT] Entered function: proxy_handler.HavenProxy.get_user_info (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: user_id -> proxy_handler.str
        [ARG_TYPE] RESOLVED user_id : proxy_handler.str
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.HavenProxy.get_user_info
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.get_user_info
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.validate_admin_role
    [CONTEXT] Entered function: proxy_handler.HavenProxy.validate_admin_role (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: user_id -> proxy_handler.str
        [ARG_TYPE] RESOLVED user_id : proxy_handler.str
      [CALL] Found call: user_id.startswith
    [RESOLVE] Attempting to resolve: ['user_id', 'startswith']
    [RESOLVE] Chain resolution needed for: ['user_id', 'startswith']
      [CHAIN] Resolving base: user_id
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: proxy_handler.str
      [CHAIN] Base resolved: user_id -> proxy_handler.str
      [CHAIN] Step 1: Resolving proxy_handler.str.startswith
        [ATTRIBUTE] Resolving attribute: proxy_handler.str.startswith
        [ATTRIBUTE] Direct match found: proxy_handler.str.startswith
      [CHAIN] Step 1 resolved: proxy_handler.str.startswith
    [RESOLVE] RESOLVED to: proxy_handler.str.startswith
            [INTERMEDIATE] Tracking chain steps for: user_id.startswith
            [INTERMEDIATE] Step 1: user_id.startswith
      -> Resolved to: proxy_handler.str.startswith
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: user_id.startswith
        [CACHE] user_id.startswith -> proxy_handler.str.startswith (cached)
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.HavenProxy.validate_admin_role
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.validate_admin_role
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.validate_moderator_role
    [CONTEXT] Entered function: proxy_handler.HavenProxy.validate_moderator_role (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: user_id -> proxy_handler.str
        [ARG_TYPE] RESOLVED user_id : proxy_handler.str
      [CALL] Found call: user_id.startswith
    [RESOLVE] Attempting to resolve: ['user_id', 'startswith']
    [RESOLVE] Chain resolution needed for: ['user_id', 'startswith']
      [CHAIN] Resolving base: user_id
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: proxy_handler.str
      [CHAIN] Base resolved: user_id -> proxy_handler.str
      [CHAIN] Step 1: Resolving proxy_handler.str.startswith
        [ATTRIBUTE] Resolving attribute: proxy_handler.str.startswith
        [ATTRIBUTE] Direct match found: proxy_handler.str.startswith
      [CHAIN] Step 1 resolved: proxy_handler.str.startswith
    [RESOLVE] RESOLVED to: proxy_handler.str.startswith
            [INTERMEDIATE] Tracking chain steps for: user_id.startswith
            [INTERMEDIATE] Step 1: user_id.startswith
      -> Resolved to: proxy_handler.str.startswith
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: user_id.startswith
        [CACHE] user_id.startswith -> proxy_handler.str.startswith (cached)
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [CALL] Found call: self.validate_admin_role
    [RESOLVE] Attempting to resolve: ['self', 'validate_admin_role']
    [RESOLVE] Chain resolution needed for: ['self', 'validate_admin_role']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
      [CHAIN] Base resolved: self -> proxy_handler.HavenProxy
      [CHAIN] Step 1: Resolving proxy_handler.HavenProxy.validate_admin_role
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.validate_admin_role
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.validate_admin_role
      [CHAIN] Step 1 resolved: proxy_handler.HavenProxy.validate_admin_role
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy.validate_admin_role
            [INTERMEDIATE] Tracking chain steps for: self.validate_admin_role
            [INTERMEDIATE] Step 1: self.validate_admin_role
      -> Resolved to: proxy_handler.HavenProxy.validate_admin_role
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [ATTRIBUTE] Found attribute access: self.validate_admin_role
        [CACHE] self.validate_admin_role -> proxy_handler.HavenProxy.validate_admin_role (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> proxy_handler.str (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.HavenProxy.validate_moderator_role
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.validate_moderator_role
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.get_runner_capabilities
    [CONTEXT] Entered function: proxy_handler.HavenProxy.get_runner_capabilities (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
    [CONTEXT] Exited function: proxy_handler.HavenProxy.get_runner_capabilities
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.get_runner_capabilities
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.get_guest_limitations
    [CONTEXT] Entered function: proxy_handler.HavenProxy.get_guest_limitations (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
    [CONTEXT] Exited function: proxy_handler.HavenProxy.get_guest_limitations
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.get_guest_limitations
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.validate_message_content
    [CONTEXT] Entered function: proxy_handler.HavenProxy.validate_message_content (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'message': 'str', 'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for message: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: message -> proxy_handler.str
        [ARG_TYPE] RESOLVED message : proxy_handler.str
        [ARG_TYPE] Processing type annotation for user_id: str
        [CACHE] str -> proxy_handler.str (cached)
      [SYMBOL_UPDATE] Function: user_id -> proxy_handler.str
        [ARG_TYPE] RESOLVED user_id : proxy_handler.str
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: proxy_handler.HavenProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(len): proxy_handler.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> proxy_handler.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.len
      -> Not module state
      [CALL] Found call: message.strip
    [RESOLVE] Attempting to resolve: ['message', 'strip']
    [RESOLVE] Chain resolution needed for: ['message', 'strip']
      [CHAIN] Resolving base: message
      [RESOLVE_SIMPLE] Resolving base: message
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found message in function scope: proxy_handler.str
      [LOCAL_RESOLVER] can_resolve(message): True
      [SYMBOL_LOOKUP] Found message in function scope: proxy_handler.str
      [LOCAL_RESOLVER] resolve(message): proxy_handler.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: message -> proxy_handler.str
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: message -> proxy_handler.str
      [CHAIN] Step 1: Resolving proxy_handler.str.strip
        [ATTRIBUTE] Resolving attribute: proxy_handler.str.strip
        [ATTRIBUTE] Direct match found: proxy_handler.str.strip
      [CHAIN] Step 1 resolved: proxy_handler.str.strip
    [RESOLVE] RESOLVED to: proxy_handler.str.strip
            [INTERMEDIATE] Tracking chain steps for: message.strip
            [INTERMEDIATE] Step 1: message.strip
      -> Resolved to: proxy_handler.str.strip
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: message.strip
        [CACHE] message.strip -> proxy_handler.str.strip (cached)
      -> Not module state
      [NAME] Found name reference: message
    [RESOLVE] Attempting to resolve: ['message']
      [RESOLVE_SIMPLE] Resolving base: message
      [CACHE] Hit for message: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
        [CACHE] len -> proxy_handler.len (cached)
      -> Not module state
      [NAME] Found name reference: message
        [CACHE] message -> proxy_handler.str (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.HavenProxy.validate_message_content
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.validate_message_content
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.log_room_message
    [CONTEXT] Entered function: proxy_handler.HavenProxy.log_room_message (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 4 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'room': 'str', 'user_id': 'str', 'message': 'str'}
        [ARG_TYPE] Processing type annotation for room: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: room -> proxy_handler.str
        [ARG_TYPE] RESOLVED room : proxy_handler.str
        [ARG_TYPE] Processing type annotation for user_id: str
        [CACHE] str -> proxy_handler.str (cached)
      [SYMBOL_UPDATE] Function: user_id -> proxy_handler.str
        [ARG_TYPE] RESOLVED user_id : proxy_handler.str
        [ARG_TYPE] Processing type annotation for message: str
        [CACHE] str -> proxy_handler.str (cached)
      [SYMBOL_UPDATE] Function: message -> proxy_handler.str
        [ARG_TYPE] RESOLVED message : proxy_handler.str
    [CONTEXT] Exited function: proxy_handler.HavenProxy.log_room_message
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.log_room_message
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.validate_direct_message_permission
    [CONTEXT] Entered function: proxy_handler.HavenProxy.validate_direct_message_permission (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'sender_id': 'str', 'recipient_id': 'str'}
        [ARG_TYPE] Processing type annotation for sender_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: sender_id -> proxy_handler.str
        [ARG_TYPE] RESOLVED sender_id : proxy_handler.str
        [ARG_TYPE] Processing type annotation for recipient_id: str
        [CACHE] str -> proxy_handler.str (cached)
      [SYMBOL_UPDATE] Function: recipient_id -> proxy_handler.str
        [ARG_TYPE] RESOLVED recipient_id : proxy_handler.str
    [CONTEXT] Exited function: proxy_handler.HavenProxy.validate_direct_message_permission
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.validate_direct_message_permission
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.validate_broadcast_permission
    [CONTEXT] Entered function: proxy_handler.HavenProxy.validate_broadcast_permission (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: user_id -> proxy_handler.str
        [ARG_TYPE] RESOLVED user_id : proxy_handler.str
      [CALL] Found call: self.validate_admin_role
    [RESOLVE] Attempting to resolve: ['self', 'validate_admin_role']
    [RESOLVE] Chain resolution needed for: ['self', 'validate_admin_role']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
      [CHAIN] Base resolved: self -> proxy_handler.HavenProxy
      [CHAIN] Step 1: Resolving proxy_handler.HavenProxy.validate_admin_role
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.validate_admin_role
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.validate_admin_role
      [CHAIN] Step 1 resolved: proxy_handler.HavenProxy.validate_admin_role
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy.validate_admin_role
            [INTERMEDIATE] Tracking chain steps for: self.validate_admin_role
            [INTERMEDIATE] Step 1: self.validate_admin_role
      -> Resolved to: proxy_handler.HavenProxy.validate_admin_role
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [ATTRIBUTE] Found attribute access: self.validate_admin_role
        [CACHE] self.validate_admin_role -> proxy_handler.HavenProxy.validate_admin_role (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.HavenProxy.validate_broadcast_permission
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.validate_broadcast_permission
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.get_room_statistics
    [CONTEXT] Entered function: proxy_handler.HavenProxy.get_room_statistics (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'room_name': 'str'}
        [ARG_TYPE] Processing type annotation for room_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: room_name -> proxy_handler.str
        [ARG_TYPE] RESOLVED room_name : proxy_handler.str
    [CONTEXT] Exited function: proxy_handler.HavenProxy.get_room_statistics
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.get_room_statistics
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.validate_event_data
    [CONTEXT] Entered function: proxy_handler.HavenProxy.validate_event_data (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 4 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'event_name': 'str', 'data': 'Dict[str, Any]', 'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for event_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: event_name -> proxy_handler.str
        [ARG_TYPE] RESOLVED event_name : proxy_handler.str
        [ARG_TYPE] Processing type annotation for user_id: str
        [CACHE] str -> proxy_handler.str (cached)
      [SYMBOL_UPDATE] Function: user_id -> proxy_handler.str
        [ARG_TYPE] RESOLVED user_id : proxy_handler.str
    [CONTEXT] Exited function: proxy_handler.HavenProxy.validate_event_data
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.validate_event_data
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.process_event
    [CONTEXT] Entered function: proxy_handler.HavenProxy.process_event (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 4 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'event_name': 'str', 'data': 'Dict[str, Any]', 'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for event_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: event_name -> proxy_handler.str
        [ARG_TYPE] RESOLVED event_name : proxy_handler.str
        [ARG_TYPE] Processing type annotation for user_id: str
        [CACHE] str -> proxy_handler.str (cached)
      [SYMBOL_UPDATE] Function: user_id -> proxy_handler.str
        [ARG_TYPE] RESOLVED user_id : proxy_handler.str
    [CONTEXT] Exited function: proxy_handler.HavenProxy.process_event
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.process_event
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy.user_exists
    [CONTEXT] Entered function: proxy_handler.HavenProxy.user_exists (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: user_id -> proxy_handler.str
        [ARG_TYPE] RESOLVED user_id : proxy_handler.str
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.HavenProxy.user_exists
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy.user_exists
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.HavenProxy._proxy_method_call
    [CONTEXT] Entered function: proxy_handler.HavenProxy._proxy_method_call (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'method_name': 'str'}
        [ARG_TYPE] Processing type annotation for method_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: method_name -> proxy_handler.str
        [ARG_TYPE] RESOLVED method_name : proxy_handler.str
      [CALL] Could not extract name parts from call
      [CALL] Found call: getattr
    [RESOLVE] Attempting to resolve: ['getattr']
      [RESOLVE_SIMPLE] Resolving base: getattr
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable getattr not found in any scope
      [LOCAL_RESOLVER] can_resolve(getattr): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(getattr): False (current_class: proxy_handler.HavenProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(getattr): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(getattr): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(getattr): proxy_handler.getattr
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: getattr -> proxy_handler.getattr
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.getattr
      -> Resolved to: proxy_handler.getattr
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: method_name
    [RESOLVE] Attempting to resolve: ['method_name']
      [RESOLVE_SIMPLE] Resolving base: method_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found method_name in function scope: proxy_handler.str
      [LOCAL_RESOLVER] can_resolve(method_name): True
      [SYMBOL_LOOKUP] Found method_name in function scope: proxy_handler.str
      [LOCAL_RESOLVER] resolve(method_name): proxy_handler.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: method_name -> proxy_handler.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.str
      [NAME] Found name reference: getattr
        [CACHE] getattr -> proxy_handler.getattr (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.target
    [RESOLVE] Attempting to resolve: ['self', 'target']
    [RESOLVE] Chain resolution needed for: ['self', 'target']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
      [CHAIN] Base resolved: self -> proxy_handler.HavenProxy
      [CHAIN] Step 1: Resolving proxy_handler.HavenProxy.target
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.target
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.target
      [CHAIN] Step 1 resolved: proxy_handler.HavenProxy.target
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy.target
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.HavenProxy
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      -> Not module state
      [NAME] Found name reference: method_name
    [RESOLVE] Attempting to resolve: ['method_name']
      [RESOLVE_SIMPLE] Resolving base: method_name
      [CACHE] Hit for method_name: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable args not found in any scope
      [LOCAL_RESOLVER] can_resolve(args): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(args): False (current_class: proxy_handler.HavenProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(args): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(args): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(args): proxy_handler.args
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: args -> proxy_handler.args
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable kwargs not found in any scope
      [LOCAL_RESOLVER] can_resolve(kwargs): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(kwargs): False (current_class: proxy_handler.HavenProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(kwargs): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(kwargs): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(kwargs): proxy_handler.kwargs
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: kwargs -> proxy_handler.kwargs
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.kwargs
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.HavenProxy._proxy_method_call
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.HavenProxy._proxy_method_call
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: proxy_handler.HavenProxy
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: UserProxy
    [CONTEXT] Entered class: proxy_handler.UserProxy
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.UserProxy.__init__
    [CONTEXT] Entered function: proxy_handler.UserProxy.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_data': 'Dict[str, Any]', 'config': 'ProxyConfig'}
        [ARG_TYPE] Processing type annotation for config: ProxyConfig
    [RESOLVE] Attempting to resolve: ['ProxyConfig']
      [RESOLVE_SIMPLE] Resolving base: ProxyConfig
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ProxyConfig not found in any scope
      [LOCAL_RESOLVER] can_resolve(ProxyConfig): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ProxyConfig): False (current_class: proxy_handler.UserProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ProxyConfig): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ProxyConfig): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(ProxyConfig): proxy_handler.ProxyConfig
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ProxyConfig -> proxy_handler.ProxyConfig
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.ProxyConfig
      [SYMBOL_UPDATE] Function: config -> proxy_handler.ProxyConfig
        [ARG_TYPE] RESOLVED config : proxy_handler.ProxyConfig
      [CALL] Could not extract name parts from call
      [CALL] Found call: super
    [RESOLVE] Attempting to resolve: ['super']
      [RESOLVE_SIMPLE] Resolving base: super
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable super not found in any scope
      [LOCAL_RESOLVER] can_resolve(super): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(super): False (current_class: proxy_handler.UserProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(super): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(super): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(super): proxy_handler.super
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: super -> proxy_handler.super
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.super
      -> Resolved to: proxy_handler.super
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: super
        [CACHE] super -> proxy_handler.super (cached)
      -> Not module state
      [NAME] Found name reference: user_data
    [RESOLVE] Attempting to resolve: ['user_data']
      [RESOLVE_SIMPLE] Resolving base: user_data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable user_data not found in any scope
      [LOCAL_RESOLVER] can_resolve(user_data): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(user_data): False (current_class: proxy_handler.UserProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(user_data): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(user_data): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(user_data): proxy_handler.user_data
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: user_data -> proxy_handler.user_data
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.user_data
      -> Not module state
      [NAME] Found name reference: config
    [RESOLVE] Attempting to resolve: ['config']
      [RESOLVE_SIMPLE] Resolving base: config
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found config in function scope: proxy_handler.ProxyConfig
      [LOCAL_RESOLVER] can_resolve(config): True
      [SYMBOL_LOOKUP] Found config in function scope: proxy_handler.ProxyConfig
      [LOCAL_RESOLVER] resolve(config): proxy_handler.ProxyConfig
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: config -> proxy_handler.ProxyConfig
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.ProxyConfig
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_data
    [RESOLVE] Attempting to resolve: ['self', 'user_data']
    [RESOLVE] Chain resolution needed for: ['self', 'user_data']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: proxy_handler.UserProxy)
      [SELF_RESOLVER] resolve(self): proxy_handler.UserProxy
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> proxy_handler.UserProxy
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> proxy_handler.UserProxy
      [CHAIN] Step 1: Resolving proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Resolving attribute: proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Direct match found: proxy_handler.UserProxy.user_data
      [CHAIN] Step 1 resolved: proxy_handler.UserProxy.user_data
    [RESOLVE] RESOLVED to: proxy_handler.UserProxy.user_data
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.UserProxy
    [RESOLVE] RESOLVED to: proxy_handler.UserProxy
      -> Not module state
      [NAME] Found name reference: user_data
        [CACHE] user_data -> proxy_handler.user_data (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.UserProxy.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.UserProxy.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.UserProxy.has_role
    [CONTEXT] Entered function: proxy_handler.UserProxy.has_role (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'role': 'str'}
        [ARG_TYPE] Processing type annotation for role: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: proxy_handler.UserProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(str): proxy_handler.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> proxy_handler.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: role -> proxy_handler.str
        [ARG_TYPE] RESOLVED role : proxy_handler.str
      [ASSIGNMENT] Processing: user_roles = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.user_data.get
    [RESOLVE] Attempting to resolve: ['self', 'user_data', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'user_data', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.UserProxy
      [CHAIN] Base resolved: self -> proxy_handler.UserProxy
      [CHAIN] Step 1: Resolving proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Resolving attribute: proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Direct match found: proxy_handler.UserProxy.user_data
      [CHAIN] Step 1 resolved: proxy_handler.UserProxy.user_data
      [CHAIN] Step 2: Resolving proxy_handler.UserProxy.user_data.get
        [ATTRIBUTE] Resolving attribute: proxy_handler.UserProxy.user_data.get
        [ATTRIBUTE] Direct match found: proxy_handler.UserProxy.user_data.get
      [CHAIN] Step 2 resolved: proxy_handler.UserProxy.user_data.get
    [RESOLVE] RESOLVED to: proxy_handler.UserProxy.user_data.get
      [TYPE_INFERENCE] Call resolved to: proxy_handler.UserProxy.user_data.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for user_roles
      [NAME] Found name reference: user_roles
    [RESOLVE] Attempting to resolve: ['user_roles']
      [RESOLVE_SIMPLE] Resolving base: user_roles
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable user_roles not found in any scope
      [LOCAL_RESOLVER] can_resolve(user_roles): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(user_roles): False (current_class: proxy_handler.UserProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(user_roles): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(user_roles): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(user_roles): proxy_handler.user_roles
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: user_roles -> proxy_handler.user_roles
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.user_roles
      -> Not module state
      [CALL] Found call: self.user_data.get
    [RESOLVE] Attempting to resolve: ['self', 'user_data', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'user_data', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.UserProxy
      [CHAIN] Base resolved: self -> proxy_handler.UserProxy
      [CHAIN] Step 1: Resolving proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Resolving attribute: proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Direct match found: proxy_handler.UserProxy.user_data
      [CHAIN] Step 1 resolved: proxy_handler.UserProxy.user_data
      [CHAIN] Step 2: Resolving proxy_handler.UserProxy.user_data.get
        [ATTRIBUTE] Resolving attribute: proxy_handler.UserProxy.user_data.get
        [ATTRIBUTE] Direct match found: proxy_handler.UserProxy.user_data.get
      [CHAIN] Step 2 resolved: proxy_handler.UserProxy.user_data.get
    [RESOLVE] RESOLVED to: proxy_handler.UserProxy.user_data.get
            [INTERMEDIATE] Tracking chain steps for: self.user_data.get
            [INTERMEDIATE] Step 1: self.user_data
    [RESOLVE] Attempting to resolve: ['self', 'user_data']
    [RESOLVE] Chain resolution needed for: ['self', 'user_data']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.UserProxy
      [CHAIN] Base resolved: self -> proxy_handler.UserProxy
      [CHAIN] Step 1: Resolving proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Resolving attribute: proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Direct match found: proxy_handler.UserProxy.user_data
      [CHAIN] Step 1 resolved: proxy_handler.UserProxy.user_data
    [RESOLVE] RESOLVED to: proxy_handler.UserProxy.user_data
            [INTERMEDIATE] Step 1 resolved to: proxy_handler.UserProxy.user_data
            [INTERMEDIATE] Step 2: self.user_data.get
      -> Resolved to: proxy_handler.UserProxy.user_data.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.user_data.get
        [CACHE] self.user_data.get -> proxy_handler.UserProxy.user_data.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_data
        [CACHE] self.user_data -> proxy_handler.UserProxy.user_data (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.UserProxy
    [RESOLVE] RESOLVED to: proxy_handler.UserProxy
      -> Not module state
      [NAME] Found name reference: role
    [RESOLVE] Attempting to resolve: ['role']
      [RESOLVE_SIMPLE] Resolving base: role
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found role in function scope: proxy_handler.str
      [LOCAL_RESOLVER] can_resolve(role): True
      [SYMBOL_LOOKUP] Found role in function scope: proxy_handler.str
      [LOCAL_RESOLVER] resolve(role): proxy_handler.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: role -> proxy_handler.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [NAME] Found name reference: user_roles
        [CACHE] user_roles -> proxy_handler.user_roles (cached)
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.UserProxy.has_role
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.UserProxy.has_role
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.UserProxy.id
    [DECORATOR] @property
    [CONTEXT] Entered function: proxy_handler.UserProxy.id (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Found call: self.user_data.get
    [RESOLVE] Attempting to resolve: ['self', 'user_data', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'user_data', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.UserProxy
      [CHAIN] Base resolved: self -> proxy_handler.UserProxy
      [CHAIN] Step 1: Resolving proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Resolving attribute: proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Direct match found: proxy_handler.UserProxy.user_data
      [CHAIN] Step 1 resolved: proxy_handler.UserProxy.user_data
      [CHAIN] Step 2: Resolving proxy_handler.UserProxy.user_data.get
        [ATTRIBUTE] Resolving attribute: proxy_handler.UserProxy.user_data.get
        [ATTRIBUTE] Direct match found: proxy_handler.UserProxy.user_data.get
      [CHAIN] Step 2 resolved: proxy_handler.UserProxy.user_data.get
    [RESOLVE] RESOLVED to: proxy_handler.UserProxy.user_data.get
            [INTERMEDIATE] Tracking chain steps for: self.user_data.get
            [INTERMEDIATE] Step 1: self.user_data
    [RESOLVE] Attempting to resolve: ['self', 'user_data']
    [RESOLVE] Chain resolution needed for: ['self', 'user_data']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.UserProxy
      [CHAIN] Base resolved: self -> proxy_handler.UserProxy
      [CHAIN] Step 1: Resolving proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Resolving attribute: proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Direct match found: proxy_handler.UserProxy.user_data
      [CHAIN] Step 1 resolved: proxy_handler.UserProxy.user_data
    [RESOLVE] RESOLVED to: proxy_handler.UserProxy.user_data
            [INTERMEDIATE] Step 1 resolved to: proxy_handler.UserProxy.user_data
            [INTERMEDIATE] Step 2: self.user_data.get
      -> Resolved to: proxy_handler.UserProxy.user_data.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.user_data.get
        [CACHE] self.user_data.get -> proxy_handler.UserProxy.user_data.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_data
        [CACHE] self.user_data -> proxy_handler.UserProxy.user_data (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.UserProxy
    [RESOLVE] RESOLVED to: proxy_handler.UserProxy
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.UserProxy.id
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.UserProxy.id
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: proxy_handler.UserProxy._proxy_method_call
    [CONTEXT] Entered function: proxy_handler.UserProxy._proxy_method_call (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'method_name': 'str'}
        [ARG_TYPE] Processing type annotation for method_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [SYMBOL_UPDATE] Function: method_name -> proxy_handler.str
        [ARG_TYPE] RESOLVED method_name : proxy_handler.str
      [CALL] Found call: hasattr
    [RESOLVE] Attempting to resolve: ['hasattr']
      [RESOLVE_SIMPLE] Resolving base: hasattr
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable hasattr not found in any scope
      [LOCAL_RESOLVER] can_resolve(hasattr): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(hasattr): False (current_class: proxy_handler.UserProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(hasattr): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(hasattr): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(hasattr): proxy_handler.hasattr
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: hasattr -> proxy_handler.hasattr
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.hasattr
      -> Resolved to: proxy_handler.hasattr
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: method_name
    [RESOLVE] Attempting to resolve: ['method_name']
      [RESOLVE_SIMPLE] Resolving base: method_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found method_name in function scope: proxy_handler.str
      [LOCAL_RESOLVER] can_resolve(method_name): True
      [SYMBOL_LOOKUP] Found method_name in function scope: proxy_handler.str
      [LOCAL_RESOLVER] resolve(method_name): proxy_handler.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: method_name -> proxy_handler.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.str
      [NAME] Found name reference: hasattr
        [CACHE] hasattr -> proxy_handler.hasattr (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_data
    [RESOLVE] Attempting to resolve: ['self', 'user_data']
    [RESOLVE] Chain resolution needed for: ['self', 'user_data']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.UserProxy
      [CHAIN] Base resolved: self -> proxy_handler.UserProxy
      [CHAIN] Step 1: Resolving proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Resolving attribute: proxy_handler.UserProxy.user_data
        [ATTRIBUTE] Direct match found: proxy_handler.UserProxy.user_data
      [CHAIN] Step 1 resolved: proxy_handler.UserProxy.user_data
    [RESOLVE] RESOLVED to: proxy_handler.UserProxy.user_data
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: proxy_handler.UserProxy
    [RESOLVE] RESOLVED to: proxy_handler.UserProxy
      -> Not module state
      [NAME] Found name reference: method_name
    [RESOLVE] Attempting to resolve: ['method_name']
      [RESOLVE_SIMPLE] Resolving base: method_name
      [CACHE] Hit for method_name: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: getattr
    [RESOLVE] Attempting to resolve: ['getattr']
      [RESOLVE_SIMPLE] Resolving base: getattr
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable getattr not found in any scope
      [LOCAL_RESOLVER] can_resolve(getattr): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(getattr): False (current_class: proxy_handler.UserProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(getattr): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(getattr): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(getattr): proxy_handler.getattr
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: getattr -> proxy_handler.getattr
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.getattr
      -> Resolved to: proxy_handler.getattr
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: method_name
    [RESOLVE] Attempting to resolve: ['method_name']
      [RESOLVE_SIMPLE] Resolving base: method_name
      [CACHE] Hit for method_name: proxy_handler.str
    [RESOLVE] RESOLVED to: proxy_handler.str
      [NAME] Found name reference: getattr
        [CACHE] getattr -> proxy_handler.getattr (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_data
        [CACHE] self.user_data -> proxy_handler.UserProxy.user_data (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> proxy_handler.UserProxy (cached)
      -> Not module state
      [NAME] Found name reference: method_name
        [CACHE] method_name -> proxy_handler.str (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable args not found in any scope
      [LOCAL_RESOLVER] can_resolve(args): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(args): False (current_class: proxy_handler.UserProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(args): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(args): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(args): proxy_handler.args
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: args -> proxy_handler.args
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable kwargs not found in any scope
      [LOCAL_RESOLVER] can_resolve(kwargs): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(kwargs): False (current_class: proxy_handler.UserProxy)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(kwargs): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(kwargs): True (fallback, module: proxy_handler)
      [MODULE_RESOLVER] resolve(kwargs): proxy_handler.kwargs
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: kwargs -> proxy_handler.kwargs
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.kwargs
      -> Not module state
    [CONTEXT] Exited function: proxy_handler.UserProxy._proxy_method_call
    [FUNCTION_ANALYSIS] Completed analysis of: proxy_handler.UserProxy._proxy_method_call
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: proxy_handler.UserProxy
    [SYMBOL_TABLE] Exited class scope
=== Module Analysis Complete ===
  Module analysis complete
=== Analyzing session_manager.py ===
  [RESOLVER] Using implementation: refactored
=== Starting Module Analysis ===
    [FROM_IMPORT] Dict -> typing.Dict
    [FROM_IMPORT] List -> typing.List
    [FROM_IMPORT] Optional -> typing.Optional
    [FROM_IMPORT] Any -> typing.Any
    [FROM_IMPORT] Callable -> typing.Callable
    [FROM_IMPORT] Set -> typing.Set
    [FROM_IMPORT] Union -> typing.Union
    [FROM_IMPORT] dataclass -> dataclasses.dataclass
    [FROM_IMPORT] field -> dataclasses.field
    [FROM_IMPORT] datetime -> datetime.datetime
    [FROM_IMPORT] timedelta -> datetime.timedelta
    [IMPORT] uuid -> uuid
    [IMPORT] threading -> threading
    [FROM_IMPORT] contextmanager -> contextlib.contextmanager
    [FROM_IMPORT] Enum -> enum.Enum
    [FROM_IMPORT] auto -> enum.auto
    [FROM_IMPORT] trace -> decorators.trace
    [FROM_IMPORT] monitor_performance -> decorators.monitor_performance
    [FROM_IMPORT] validate_auth -> decorators.validate_auth
    [FROM_IMPORT] rate_limit -> decorators.rate_limit
    [FROM_IMPORT] HavenProxy -> proxy_handler.HavenProxy
    [FROM_IMPORT] UserProxy -> proxy_handler.UserProxy
    [FROM_IMPORT] DataProxy -> proxy_handler.DataProxy
  [CLASS] Analyzing class: SessionState
    [CONTEXT] Entered class: session_manager.SessionState
    [SYMBOL_TABLE] Entered class scope
    [CONTEXT] Exited class: session_manager.SessionState
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: UserRole
    [CONTEXT] Entered class: session_manager.UserRole
    [SYMBOL_TABLE] Entered class scope
    [CONTEXT] Exited class: session_manager.UserRole
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: SessionMetrics
    [CONTEXT] Entered class: session_manager.SessionMetrics
    [SYMBOL_TABLE] Entered class scope
    [CONTEXT] Exited class: session_manager.SessionMetrics
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: UserSession
    [CONTEXT] Entered class: session_manager.UserSession
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.UserSession.is_valid
    [CONTEXT] Entered function: session_manager.UserSession.is_valid (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.state
    [RESOLVE] Attempting to resolve: ['self', 'state']
    [RESOLVE] Chain resolution needed for: ['self', 'state']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: session_manager.UserSession)
      [SELF_RESOLVER] resolve(self): session_manager.UserSession
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> session_manager.UserSession
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.state
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.state
        [ATTRIBUTE] Direct match found: session_manager.UserSession.state
      [CHAIN] Step 1 resolved: session_manager.UserSession.state
    [RESOLVE] RESOLVED to: session_manager.UserSession.state
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [ATTRIBUTE] Found attribute access: SessionState.ACTIVE
    [RESOLVE] Attempting to resolve: ['SessionState', 'ACTIVE']
    [RESOLVE] Chain resolution needed for: ['SessionState', 'ACTIVE']
      [CHAIN] Resolving base: SessionState
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable SessionState not found in any scope
      [LOCAL_RESOLVER] can_resolve(SessionState): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(SessionState): False (current_class: session_manager.UserSession)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(SessionState): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(SessionState): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(SessionState): session_manager.SessionState
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: SessionState -> session_manager.SessionState
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: SessionState -> session_manager.SessionState
      [CHAIN] Step 1: Resolving session_manager.SessionState.ACTIVE
        [ATTRIBUTE] Resolving attribute: session_manager.SessionState.ACTIVE
        [ATTRIBUTE] Direct match found: session_manager.SessionState.ACTIVE
      [CHAIN] Step 1 resolved: session_manager.SessionState.ACTIVE
    [RESOLVE] RESOLVED to: session_manager.SessionState.ACTIVE
      -> Not module state
      [NAME] Found name reference: SessionState
    [RESOLVE] Attempting to resolve: ['SessionState']
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
    [RESOLVE] RESOLVED to: session_manager.SessionState
      -> Not module state
      [ATTRIBUTE] Found attribute access: SessionState.IDLE
    [RESOLVE] Attempting to resolve: ['SessionState', 'IDLE']
    [RESOLVE] Chain resolution needed for: ['SessionState', 'IDLE']
      [CHAIN] Resolving base: SessionState
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
      [CHAIN] Base resolved: SessionState -> session_manager.SessionState
      [CHAIN] Step 1: Resolving session_manager.SessionState.IDLE
        [ATTRIBUTE] Resolving attribute: session_manager.SessionState.IDLE
        [ATTRIBUTE] Direct match found: session_manager.SessionState.IDLE
      [CHAIN] Step 1 resolved: session_manager.SessionState.IDLE
    [RESOLVE] RESOLVED to: session_manager.SessionState.IDLE
      -> Not module state
      [NAME] Found name reference: SessionState
        [CACHE] SessionState -> session_manager.SessionState (cached)
      -> Not module state
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable datetime not found in any scope
      [LOCAL_RESOLVER] can_resolve(datetime): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(datetime): False (current_class: session_manager.UserSession)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(datetime): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(datetime): datetime.datetime (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: datetime -> datetime.datetime
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.expires_at
    [RESOLVE] Attempting to resolve: ['self', 'expires_at']
    [RESOLVE] Chain resolution needed for: ['self', 'expires_at']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.UserSession
      [CHAIN] Base resolved: self -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.expires_at
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.expires_at
        [ATTRIBUTE] Direct match found: session_manager.UserSession.expires_at
      [CHAIN] Step 1 resolved: session_manager.UserSession.expires_at
    [RESOLVE] RESOLVED to: session_manager.UserSession.expires_at
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.UserSession (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.UserSession.is_valid
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.UserSession.is_valid
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.UserSession.is_expired
    [CONTEXT] Entered function: session_manager.UserSession.is_expired (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.expires_at
    [RESOLVE] Attempting to resolve: ['self', 'expires_at']
    [RESOLVE] Chain resolution needed for: ['self', 'expires_at']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.UserSession
      [CHAIN] Base resolved: self -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.expires_at
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.expires_at
        [ATTRIBUTE] Direct match found: session_manager.UserSession.expires_at
      [CHAIN] Step 1 resolved: session_manager.UserSession.expires_at
    [RESOLVE] RESOLVED to: session_manager.UserSession.expires_at
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
    [CONTEXT] Exited function: session_manager.UserSession.is_expired
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.UserSession.is_expired
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.UserSession.time_until_expiry
    [CONTEXT] Entered function: session_manager.UserSession.time_until_expiry (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.expires_at
    [RESOLVE] Attempting to resolve: ['self', 'expires_at']
    [RESOLVE] Chain resolution needed for: ['self', 'expires_at']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.UserSession
      [CHAIN] Base resolved: self -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.expires_at
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.expires_at
        [ATTRIBUTE] Direct match found: session_manager.UserSession.expires_at
      [CHAIN] Step 1 resolved: session_manager.UserSession.expires_at
    [RESOLVE] RESOLVED to: session_manager.UserSession.expires_at
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
    [CONTEXT] Exited function: session_manager.UserSession.time_until_expiry
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.UserSession.time_until_expiry
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.UserSession.update_activity
    [CONTEXT] Entered function: session_manager.UserSession.update_activity (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.last_activity
    [RESOLVE] Attempting to resolve: ['self', 'last_activity']
    [RESOLVE] Chain resolution needed for: ['self', 'last_activity']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.UserSession
      [CHAIN] Base resolved: self -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.last_activity
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.last_activity
        [ATTRIBUTE] Direct match found: session_manager.UserSession.last_activity
      [CHAIN] Step 1 resolved: session_manager.UserSession.last_activity
    [RESOLVE] RESOLVED to: session_manager.UserSession.last_activity
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.metrics.last_activity
    [RESOLVE] Attempting to resolve: ['self', 'metrics', 'last_activity']
    [RESOLVE] Chain resolution needed for: ['self', 'metrics', 'last_activity']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.UserSession
      [CHAIN] Base resolved: self -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
      [CHAIN] Step 2: Resolving session_manager.UserSession.metrics.last_activity
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics.last_activity
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics.last_activity
      [CHAIN] Step 2 resolved: session_manager.UserSession.metrics.last_activity
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics.last_activity
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.metrics
    [RESOLVE] Attempting to resolve: ['self', 'metrics']
    [RESOLVE] Chain resolution needed for: ['self', 'metrics']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.UserSession
      [CHAIN] Base resolved: self -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.last_activity
        [CACHE] self.last_activity -> session_manager.UserSession.last_activity (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.metrics.activity_count
    [RESOLVE] Attempting to resolve: ['self', 'metrics', 'activity_count']
    [RESOLVE] Chain resolution needed for: ['self', 'metrics', 'activity_count']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.UserSession
      [CHAIN] Base resolved: self -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
      [CHAIN] Step 2: Resolving session_manager.UserSession.metrics.activity_count
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics.activity_count
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics.activity_count
      [CHAIN] Step 2 resolved: session_manager.UserSession.metrics.activity_count
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics.activity_count
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.metrics
        [CACHE] self.metrics -> session_manager.UserSession.metrics (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.UserSession (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.UserSession.update_activity
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.UserSession.update_activity
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: session_manager.UserSession
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: SessionManager
    [CONTEXT] Entered class: session_manager.SessionManager
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.__init__
    [CONTEXT] Entered function: session_manager.SessionManager.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'haven_proxy': 'HavenProxy'}
        [ARG_TYPE] Processing type annotation for haven_proxy: HavenProxy
    [RESOLVE] Attempting to resolve: ['HavenProxy']
      [RESOLVE_SIMPLE] Resolving base: HavenProxy
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable HavenProxy not found in any scope
      [LOCAL_RESOLVER] can_resolve(HavenProxy): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(HavenProxy): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(HavenProxy): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(HavenProxy): proxy_handler.HavenProxy (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: HavenProxy -> proxy_handler.HavenProxy
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      [SYMBOL_UPDATE] Function: haven_proxy -> proxy_handler.HavenProxy
        [ARG_TYPE] RESOLVED haven_proxy : proxy_handler.HavenProxy
      [ATTRIBUTE] Found attribute access: self.haven_proxy
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: session_manager.SessionManager)
      [SELF_RESOLVER] resolve(self): session_manager.SessionManager
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> session_manager.SessionManager
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [NAME] Found name reference: haven_proxy
    [RESOLVE] Attempting to resolve: ['haven_proxy']
      [RESOLVE_SIMPLE] Resolving base: haven_proxy
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found haven_proxy in function scope: proxy_handler.HavenProxy
      [LOCAL_RESOLVER] can_resolve(haven_proxy): True
      [SYMBOL_LOOKUP] Found haven_proxy in function scope: proxy_handler.HavenProxy
      [LOCAL_RESOLVER] resolve(haven_proxy): proxy_handler.HavenProxy
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: haven_proxy -> proxy_handler.HavenProxy
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(str): session_manager.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> session_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [NAME] Found name reference: UserSession
    [RESOLVE] Attempting to resolve: ['UserSession']
      [RESOLVE_SIMPLE] Resolving base: UserSession
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable UserSession not found in any scope
      [LOCAL_RESOLVER] can_resolve(UserSession): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(UserSession): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(UserSession): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(UserSession): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(UserSession): session_manager.UserSession
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: UserSession -> session_manager.UserSession
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
    [RESOLVE] Attempting to resolve: ['self', 'user_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'user_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.user_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.user_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.user_sessions
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: Dict
        [CACHE] Dict -> typing.Dict (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> session_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: List
    [RESOLVE] Attempting to resolve: ['List']
      [RESOLVE_SIMPLE] Resolving base: List
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable List not found in any scope
      [LOCAL_RESOLVER] can_resolve(List): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(List): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(List): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(List): typing.List (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: List -> typing.List
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.List
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> session_manager.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_lock
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_lock
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [CALL] Found call: threading.RLock
    [RESOLVE] Attempting to resolve: ['threading', 'RLock']
    [RESOLVE] Chain resolution needed for: ['threading', 'RLock']
      [CHAIN] Resolving base: threading
      [RESOLVE_SIMPLE] Resolving base: threading
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable threading not found in any scope
      [LOCAL_RESOLVER] can_resolve(threading): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(threading): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(threading): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(threading): threading (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: threading -> threading
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: threading -> threading
      [CHAIN] Step 1: Resolving threading.RLock
        [ATTRIBUTE] Resolving attribute: threading.RLock
        [ATTRIBUTE] Direct match found: threading.RLock
      [CHAIN] Step 1 resolved: threading.RLock
    [RESOLVE] RESOLVED to: threading.RLock
            [INTERMEDIATE] Tracking chain steps for: threading.RLock
            [INTERMEDIATE] Step 1: threading.RLock
      -> Resolved to: threading.RLock
      -> ADDED to calls (external library)
      [ATTRIBUTE] Found attribute access: threading.RLock
        [CACHE] threading.RLock -> threading.RLock (cached)
      -> Not module state
      [NAME] Found name reference: threading
    [RESOLVE] Attempting to resolve: ['threading']
      [RESOLVE_SIMPLE] Resolving base: threading
      [CACHE] Hit for threading: threading
    [RESOLVE] RESOLVED to: threading
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_session_id
    [RESOLVE] Attempting to resolve: ['self', 'current_session_id']
    [RESOLVE] Chain resolution needed for: ['self', 'current_session_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.current_session_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.current_session_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.current_session_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.current_session_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.current_session_id
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: Optional
    [RESOLVE] Attempting to resolve: ['Optional']
      [RESOLVE_SIMPLE] Resolving base: Optional
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Optional not found in any scope
      [LOCAL_RESOLVER] can_resolve(Optional): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Optional): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Optional): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Optional): typing.Optional (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Optional -> typing.Optional
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Optional
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> session_manager.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_callbacks
    [RESOLVE] Attempting to resolve: ['self', 'session_callbacks']
    [RESOLVE] Chain resolution needed for: ['self', 'session_callbacks']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_callbacks
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_callbacks
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_callbacks
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_callbacks
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_callbacks
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: Dict
        [CACHE] Dict -> typing.Dict (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> session_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: List
        [CACHE] List -> typing.List (cached)
      -> Not module state
      [NAME] Found name reference: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Callable not found in any scope
      [LOCAL_RESOLVER] can_resolve(Callable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Callable): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Callable): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Callable): typing.Callable (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Callable -> typing.Callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Callable
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.cleanup_interval
    [RESOLVE] Attempting to resolve: ['self', 'cleanup_interval']
    [RESOLVE] Chain resolution needed for: ['self', 'cleanup_interval']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.cleanup_interval
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.cleanup_interval
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.cleanup_interval
      [CHAIN] Step 1 resolved: session_manager.SessionManager.cleanup_interval
    [RESOLVE] RESOLVED to: session_manager.SessionManager.cleanup_interval
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.max_sessions_per_user
    [RESOLVE] Attempting to resolve: ['self', 'max_sessions_per_user']
    [RESOLVE] Chain resolution needed for: ['self', 'max_sessions_per_user']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.max_sessions_per_user
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.max_sessions_per_user
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.max_sessions_per_user
      [CHAIN] Step 1 resolved: session_manager.SessionManager.max_sessions_per_user
    [RESOLVE] RESOLVED to: session_manager.SessionManager.max_sessions_per_user
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.event_handlers
    [RESOLVE] Attempting to resolve: ['self', 'event_handlers']
    [RESOLVE] Chain resolution needed for: ['self', 'event_handlers']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.event_handlers
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.event_handlers
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.event_handlers
      [CHAIN] Step 1 resolved: session_manager.SessionManager.event_handlers
    [RESOLVE] RESOLVED to: session_manager.SessionManager.event_handlers
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: Dict
        [CACHE] Dict -> typing.Dict (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> session_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: List
        [CACHE] List -> typing.List (cached)
      -> Not module state
      [NAME] Found name reference: Callable
        [CACHE] Callable -> typing.Callable (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.__init__
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.create_session
    [DECORATOR] @trace
    [CONTEXT] Entered function: session_manager.SessionManager.create_session (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 5 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'Optional[str]', 'session_duration': 'timedelta', 'ip_address': 'str', 'user_agent': 'str'}
        [ARG_TYPE] Processing type annotation for session_duration: timedelta
    [RESOLVE] Attempting to resolve: ['timedelta']
      [RESOLVE_SIMPLE] Resolving base: timedelta
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable timedelta not found in any scope
      [LOCAL_RESOLVER] can_resolve(timedelta): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(timedelta): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(timedelta): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(timedelta): datetime.timedelta (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: timedelta -> datetime.timedelta
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: datetime.timedelta
      [SYMBOL_UPDATE] Function: session_duration -> datetime.timedelta
        [ARG_TYPE] RESOLVED session_duration : datetime.timedelta
        [ARG_TYPE] Processing type annotation for ip_address: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: ip_address -> session_manager.str
        [ARG_TYPE] RESOLVED ip_address : session_manager.str
        [ARG_TYPE] Processing type annotation for user_agent: str
        [CACHE] str -> session_manager.str (cached)
      [SYMBOL_UPDATE] Function: user_agent -> session_manager.str
        [ARG_TYPE] RESOLVED user_agent : session_manager.str
      [ASSIGNMENT] Processing: session_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [TYPE_INFERENCE] Call resolved to: session_manager.str
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for session_id
      [NAME] Found name reference: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable session_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(session_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(session_id): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(session_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(session_id): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(session_id): session_manager.session_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: session_id -> session_manager.session_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.session_id
      -> Not module state
      [CALL] Found call: str
      -> IGNORED (built-in function)
      [NAME] Found name reference: str
        [CACHE] str -> session_manager.str (cached)
      -> Not module state
      [CALL] Found call: uuid.uuid4
    [RESOLVE] Attempting to resolve: ['uuid', 'uuid4']
    [RESOLVE] Chain resolution needed for: ['uuid', 'uuid4']
      [CHAIN] Resolving base: uuid
      [RESOLVE_SIMPLE] Resolving base: uuid
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable uuid not found in any scope
      [LOCAL_RESOLVER] can_resolve(uuid): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(uuid): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(uuid): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(uuid): uuid (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: uuid -> uuid
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: uuid -> uuid
      [CHAIN] Step 1: Resolving uuid.uuid4
        [ATTRIBUTE] Resolving attribute: uuid.uuid4
        [ATTRIBUTE] Direct match found: uuid.uuid4
      [CHAIN] Step 1 resolved: uuid.uuid4
    [RESOLVE] RESOLVED to: uuid.uuid4
            [INTERMEDIATE] Tracking chain steps for: uuid.uuid4
            [INTERMEDIATE] Step 1: uuid.uuid4
      -> Resolved to: uuid.uuid4
      -> ADDED to calls (external library)
      [ATTRIBUTE] Found attribute access: uuid.uuid4
        [CACHE] uuid.uuid4 -> uuid.uuid4 (cached)
      -> Not module state
      [NAME] Found name reference: uuid
    [RESOLVE] Attempting to resolve: ['uuid']
      [RESOLVE_SIMPLE] Resolving base: uuid
      [CACHE] Hit for uuid: uuid
    [RESOLVE] RESOLVED to: uuid
      -> Not module state
      [ASSIGNMENT] Processing: current_time = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable datetime not found in any scope
      [LOCAL_RESOLVER] can_resolve(datetime): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(datetime): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(datetime): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(datetime): datetime.datetime (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: datetime -> datetime.datetime
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
      [TYPE_INFERENCE] Call resolved to: datetime.datetime.now
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for current_time
      [NAME] Found name reference: current_time
    [RESOLVE] Attempting to resolve: ['current_time']
      [RESOLVE_SIMPLE] Resolving base: current_time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable current_time not found in any scope
      [LOCAL_RESOLVER] can_resolve(current_time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(current_time): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(current_time): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(current_time): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(current_time): session_manager.current_time
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: current_time -> session_manager.current_time
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.current_time
      -> Not module state
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable user_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(user_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(user_id): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(user_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(user_id): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(user_id): session_manager.user_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: user_id -> session_manager.user_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.user_id
      -> Not module state
      [ASSIGNMENT] Processing: user_role = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self._determine_user_role
    [RESOLVE] Attempting to resolve: ['self', '_determine_user_role']
    [RESOLVE] Chain resolution needed for: ['self', '_determine_user_role']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._determine_user_role
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._determine_user_role
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._determine_user_role
      [CHAIN] Step 1 resolved: session_manager.SessionManager._determine_user_role
    [RESOLVE] RESOLVED to: session_manager.SessionManager._determine_user_role
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager._determine_user_role
        [RETURN_TYPE_RESOLUTION] Resolving return type: UserRole
        [RETURN_TYPE_RESOLUTION] Found in current module: session_manager.UserRole
      [TYPE_INFERENCE] RESOLVED Inferred type: session_manager.UserRole (from return type)
      [SYMBOL_UPDATE] Function: user_role -> session_manager.UserRole
        [ASSIGNMENT] RESOLVED Updated symbol table: user_role = session_manager.UserRole
      [NAME] Found name reference: user_role
    [RESOLVE] Attempting to resolve: ['user_role']
      [RESOLVE_SIMPLE] Resolving base: user_role
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found user_role in function scope: session_manager.UserRole
      [LOCAL_RESOLVER] can_resolve(user_role): True
      [SYMBOL_LOOKUP] Found user_role in function scope: session_manager.UserRole
      [LOCAL_RESOLVER] resolve(user_role): session_manager.UserRole
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: user_role -> session_manager.UserRole
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.UserRole
      -> Not module state
      [CALL] Found call: self._determine_user_role
    [RESOLVE] Attempting to resolve: ['self', '_determine_user_role']
    [RESOLVE] Chain resolution needed for: ['self', '_determine_user_role']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._determine_user_role
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._determine_user_role
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._determine_user_role
      [CHAIN] Step 1 resolved: session_manager.SessionManager._determine_user_role
    [RESOLVE] RESOLVED to: session_manager.SessionManager._determine_user_role
            [INTERMEDIATE] Tracking chain steps for: self._determine_user_role
            [INTERMEDIATE] Step 1: self._determine_user_role
      -> Resolved to: session_manager.SessionManager._determine_user_role
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      [ATTRIBUTE] Found attribute access: self._determine_user_role
        [CACHE] self._determine_user_role -> session_manager.SessionManager._determine_user_role (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ASSIGNMENT] Processing: user_role = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: user_role
        [CACHE] user_role -> session_manager.UserRole (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: UserRole.GUEST
    [RESOLVE] Attempting to resolve: ['UserRole', 'GUEST']
    [RESOLVE] Chain resolution needed for: ['UserRole', 'GUEST']
      [CHAIN] Resolving base: UserRole
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable UserRole not found in any scope
      [LOCAL_RESOLVER] can_resolve(UserRole): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(UserRole): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(UserRole): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(UserRole): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(UserRole): session_manager.UserRole
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: UserRole -> session_manager.UserRole
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: UserRole -> session_manager.UserRole
      [CHAIN] Step 1: Resolving session_manager.UserRole.GUEST
        [ATTRIBUTE] Resolving attribute: session_manager.UserRole.GUEST
        [ATTRIBUTE] Direct match found: session_manager.UserRole.GUEST
      [CHAIN] Step 1 resolved: session_manager.UserRole.GUEST
    [RESOLVE] RESOLVED to: session_manager.UserRole.GUEST
      -> Not module state
      [NAME] Found name reference: UserRole
    [RESOLVE] Attempting to resolve: ['UserRole']
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
    [RESOLVE] RESOLVED to: session_manager.UserRole
      -> Not module state
      [ASSIGNMENT] Processing: user_id = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: UserSession
    [RESOLVE] Attempting to resolve: ['UserSession']
      [RESOLVE_SIMPLE] Resolving base: UserSession
      [CACHE] Hit for UserSession: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      [TYPE_INFERENCE] Call resolved to: session_manager.UserSession
      [TYPE_INFERENCE] RESOLVED Inferred type: session_manager.UserSession (class instantiation)
      [SYMBOL_UPDATE] Function: session -> session_manager.UserSession
        [ASSIGNMENT] RESOLVED Updated symbol table: session = session_manager.UserSession
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found session in function scope: session_manager.UserSession
      [LOCAL_RESOLVER] can_resolve(session): True
      [SYMBOL_LOOKUP] Found session in function scope: session_manager.UserSession
      [LOCAL_RESOLVER] resolve(session): session_manager.UserSession
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: session -> session_manager.UserSession
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: UserSession
    [RESOLVE] Attempting to resolve: ['UserSession']
      [RESOLVE_SIMPLE] Resolving base: UserSession
      [CACHE] Hit for UserSession: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Resolved to: session_manager.UserSession
      -> ADDED to instantiations
      [NAME] Found name reference: UserSession
        [CACHE] UserSession -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [NAME] Found name reference: user_role
        [CACHE] user_role -> session_manager.UserRole (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: SessionState.CREATED
    [RESOLVE] Attempting to resolve: ['SessionState', 'CREATED']
    [RESOLVE] Chain resolution needed for: ['SessionState', 'CREATED']
      [CHAIN] Resolving base: SessionState
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable SessionState not found in any scope
      [LOCAL_RESOLVER] can_resolve(SessionState): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(SessionState): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(SessionState): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(SessionState): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(SessionState): session_manager.SessionState
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: SessionState -> session_manager.SessionState
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: SessionState -> session_manager.SessionState
      [CHAIN] Step 1: Resolving session_manager.SessionState.CREATED
        [ATTRIBUTE] Resolving attribute: session_manager.SessionState.CREATED
        [ATTRIBUTE] Direct match found: session_manager.SessionState.CREATED
      [CHAIN] Step 1 resolved: session_manager.SessionState.CREATED
    [RESOLVE] RESOLVED to: session_manager.SessionState.CREATED
      -> Not module state
      [NAME] Found name reference: SessionState
    [RESOLVE] Attempting to resolve: ['SessionState']
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
    [RESOLVE] RESOLVED to: session_manager.SessionState
      -> Not module state
      [NAME] Found name reference: current_time
        [CACHE] current_time -> session_manager.current_time (cached)
      -> Not module state
      [NAME] Found name reference: current_time
        [CACHE] current_time -> session_manager.current_time (cached)
      -> Not module state
      [NAME] Found name reference: session_duration
    [RESOLVE] Attempting to resolve: ['session_duration']
      [RESOLVE_SIMPLE] Resolving base: session_duration
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found session_duration in function scope: datetime.timedelta
      [LOCAL_RESOLVER] can_resolve(session_duration): True
      [SYMBOL_LOOKUP] Found session_duration in function scope: datetime.timedelta
      [LOCAL_RESOLVER] resolve(session_duration): datetime.timedelta
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: session_duration -> datetime.timedelta
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: datetime.timedelta
      -> Not module state
      [NAME] Found name reference: current_time
        [CACHE] current_time -> session_manager.current_time (cached)
      -> Not module state
      [NAME] Found name reference: ip_address
    [RESOLVE] Attempting to resolve: ['ip_address']
      [RESOLVE_SIMPLE] Resolving base: ip_address
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found ip_address in function scope: session_manager.str
      [LOCAL_RESOLVER] can_resolve(ip_address): True
      [SYMBOL_LOOKUP] Found ip_address in function scope: session_manager.str
      [LOCAL_RESOLVER] resolve(ip_address): session_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: ip_address -> session_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [NAME] Found name reference: user_agent
    [RESOLVE] Attempting to resolve: ['user_agent']
      [RESOLVE_SIMPLE] Resolving base: user_agent
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found user_agent in function scope: session_manager.str
      [LOCAL_RESOLVER] can_resolve(user_agent): True
      [SYMBOL_LOOKUP] Found user_agent in function scope: session_manager.str
      [LOCAL_RESOLVER] resolve(user_agent): session_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: user_agent -> session_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.permissions
    [RESOLVE] Attempting to resolve: ['session', 'permissions']
    [RESOLVE] Chain resolution needed for: ['session', 'permissions']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.permissions
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.permissions
        [ATTRIBUTE] Direct match found: session_manager.UserSession.permissions
      [CHAIN] Step 1 resolved: session_manager.UserSession.permissions
    [RESOLVE] RESOLVED to: session_manager.UserSession.permissions
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: self._get_role_permissions
    [RESOLVE] Attempting to resolve: ['self', '_get_role_permissions']
    [RESOLVE] Chain resolution needed for: ['self', '_get_role_permissions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._get_role_permissions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._get_role_permissions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._get_role_permissions
      [CHAIN] Step 1 resolved: session_manager.SessionManager._get_role_permissions
    [RESOLVE] RESOLVED to: session_manager.SessionManager._get_role_permissions
            [INTERMEDIATE] Tracking chain steps for: self._get_role_permissions
            [INTERMEDIATE] Step 1: self._get_role_permissions
      -> Resolved to: session_manager.SessionManager._get_role_permissions
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: user_role
    [RESOLVE] Attempting to resolve: ['user_role']
      [RESOLVE_SIMPLE] Resolving base: user_role
      [CACHE] Hit for user_role: session_manager.UserRole
    [RESOLVE] RESOLVED to: session_manager.UserRole
      [ATTRIBUTE] Found attribute access: self._get_role_permissions
        [CACHE] self._get_role_permissions -> session_manager.SessionManager._get_role_permissions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_role
        [CACHE] user_role -> session_manager.UserRole (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [CALL] Found call: self.haven_proxy.user_exists
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy', 'user_exists']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy', 'user_exists']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 2: Resolving session_manager.SessionManager.haven_proxy.user_exists
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy.user_exists
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy.user_exists
      [CHAIN] Step 2 resolved: session_manager.SessionManager.haven_proxy.user_exists
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy.user_exists
            [INTERMEDIATE] Tracking chain steps for: self.haven_proxy.user_exists
            [INTERMEDIATE] Step 1: self.haven_proxy
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.haven_proxy
            [INTERMEDIATE] Step 2: self.haven_proxy.user_exists
      -> Resolved to: session_manager.SessionManager.haven_proxy.user_exists
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      [ATTRIBUTE] Found attribute access: self.haven_proxy.user_exists
        [CACHE] self.haven_proxy.user_exists -> session_manager.SessionManager.haven_proxy.user_exists (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.haven_proxy
        [CACHE] self.haven_proxy -> session_manager.SessionManager.haven_proxy (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.preferences
    [RESOLVE] Attempting to resolve: ['session', 'preferences']
    [RESOLVE] Chain resolution needed for: ['session', 'preferences']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.preferences
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.preferences
        [ATTRIBUTE] Direct match found: session_manager.UserSession.preferences
      [CHAIN] Step 1 resolved: session_manager.UserSession.preferences
    [RESOLVE] RESOLVED to: session_manager.UserSession.preferences
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: self.haven_proxy.get_user_preferences
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy', 'get_user_preferences']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy', 'get_user_preferences']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 2: Resolving session_manager.SessionManager.haven_proxy.get_user_preferences
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy.get_user_preferences
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy.get_user_preferences
      [CHAIN] Step 2 resolved: session_manager.SessionManager.haven_proxy.get_user_preferences
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy.get_user_preferences
            [INTERMEDIATE] Tracking chain steps for: self.haven_proxy.get_user_preferences
            [INTERMEDIATE] Step 1: self.haven_proxy
    [CACHE] self.haven_proxy -> session_manager.SessionManager.haven_proxy (cached)
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.haven_proxy
            [INTERMEDIATE] Step 2: self.haven_proxy.get_user_preferences
      -> Resolved to: session_manager.SessionManager.haven_proxy.get_user_preferences
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      [ATTRIBUTE] Found attribute access: self.haven_proxy.get_user_preferences
        [CACHE] self.haven_proxy.get_user_preferences -> session_manager.SessionManager.haven_proxy.get_user_preferences (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.haven_proxy
        [CACHE] self.haven_proxy -> session_manager.SessionManager.haven_proxy (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_lock
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_lock
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
    [RESOLVE] Attempting to resolve: ['self', 'user_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'user_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.user_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.user_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.user_sessions
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(len): session_manager.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> session_manager.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.max_sessions_per_user
    [RESOLVE] Attempting to resolve: ['self', 'max_sessions_per_user']
    [RESOLVE] Chain resolution needed for: ['self', 'max_sessions_per_user']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.max_sessions_per_user
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.max_sessions_per_user
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.max_sessions_per_user
      [CHAIN] Step 1 resolved: session_manager.SessionManager.max_sessions_per_user
    [RESOLVE] RESOLVED to: session_manager.SessionManager.max_sessions_per_user
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ASSIGNMENT] Processing: oldest_session_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] No name parts extracted from call
        [ASSIGNMENT] FAILED Could not infer type for oldest_session_id
      [NAME] Found name reference: oldest_session_id
    [RESOLVE] Attempting to resolve: ['oldest_session_id']
      [RESOLVE_SIMPLE] Resolving base: oldest_session_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable oldest_session_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(oldest_session_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(oldest_session_id): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(oldest_session_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(oldest_session_id): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(oldest_session_id): session_manager.oldest_session_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: oldest_session_id -> session_manager.oldest_session_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.oldest_session_id
      -> Not module state
      [CALL] Could not extract name parts from call
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [NAME] Found name reference: oldest_session_id
        [CACHE] oldest_session_id -> session_manager.oldest_session_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [CALL] Found call: self._terminate_session
    [RESOLVE] Attempting to resolve: ['self', '_terminate_session']
    [RESOLVE] Chain resolution needed for: ['self', '_terminate_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._terminate_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._terminate_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._terminate_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager._terminate_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager._terminate_session
            [INTERMEDIATE] Tracking chain steps for: self._terminate_session
            [INTERMEDIATE] Step 1: self._terminate_session
      -> Resolved to: session_manager.SessionManager._terminate_session
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: oldest_session_id
    [RESOLVE] Attempting to resolve: ['oldest_session_id']
      [RESOLVE_SIMPLE] Resolving base: oldest_session_id
      [CACHE] Hit for oldest_session_id: session_manager.oldest_session_id
    [RESOLVE] RESOLVED to: session_manager.oldest_session_id
      [ATTRIBUTE] Found attribute access: self._terminate_session
        [CACHE] self._terminate_session -> session_manager.SessionManager._terminate_session (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: oldest_session_id
        [CACHE] oldest_session_id -> session_manager.oldest_session_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_session_id
    [RESOLVE] Attempting to resolve: ['self', 'current_session_id']
    [RESOLVE] Chain resolution needed for: ['self', 'current_session_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.current_session_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.current_session_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.current_session_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.current_session_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.current_session_id
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_session_id
        [CACHE] self.current_session_id -> session_manager.SessionManager.current_session_id (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [CALL] Found call: self._trigger_event
    [RESOLVE] Attempting to resolve: ['self', '_trigger_event']
    [RESOLVE] Chain resolution needed for: ['self', '_trigger_event']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._trigger_event
      [CHAIN] Step 1 resolved: session_manager.SessionManager._trigger_event
    [RESOLVE] RESOLVED to: session_manager.SessionManager._trigger_event
            [INTERMEDIATE] Tracking chain steps for: self._trigger_event
            [INTERMEDIATE] Step 1: self._trigger_event
      -> Resolved to: session_manager.SessionManager._trigger_event
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      [ATTRIBUTE] Found attribute access: self._trigger_event
        [CACHE] self._trigger_event -> session_manager.SessionManager._trigger_event (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.create_session
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.create_session
        Calls: 5
        Instantiations: 1
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.create_user_session
    [DECORATOR] @trace
    [DECORATOR] @monitor_performance
    [CONTEXT] Entered function: session_manager.SessionManager.create_user_session (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str', 'session_id': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: user_id -> session_manager.str
        [ARG_TYPE] RESOLVED user_id : session_manager.str
        [ARG_TYPE] Processing type annotation for session_id: str
        [CACHE] str -> session_manager.str (cached)
      [SYMBOL_UPDATE] Function: session_id -> session_manager.str
        [ARG_TYPE] RESOLVED session_id : session_manager.str
      [CALL] Found call: self.haven_proxy.validate_user_credentials
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy', 'validate_user_credentials']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy', 'validate_user_credentials']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 2: Resolving session_manager.SessionManager.haven_proxy.validate_user_credentials
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy.validate_user_credentials
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy.validate_user_credentials
      [CHAIN] Step 2 resolved: session_manager.SessionManager.haven_proxy.validate_user_credentials
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy.validate_user_credentials
            [INTERMEDIATE] Tracking chain steps for: self.haven_proxy.validate_user_credentials
            [INTERMEDIATE] Step 1: self.haven_proxy
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.haven_proxy
            [INTERMEDIATE] Step 2: self.haven_proxy.validate_user_credentials
      -> Resolved to: session_manager.SessionManager.haven_proxy.validate_user_credentials
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.haven_proxy.validate_user_credentials
        [CACHE] self.haven_proxy.validate_user_credentials -> session_manager.SessionManager.haven_proxy.validate_user_credentials (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.haven_proxy
        [CACHE] self.haven_proxy -> session_manager.SessionManager.haven_proxy (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      -> Not module state
      [CALL] Found call: ValueError
    [RESOLVE] Attempting to resolve: ['ValueError']
      [RESOLVE_SIMPLE] Resolving base: ValueError
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ValueError not found in any scope
      [LOCAL_RESOLVER] can_resolve(ValueError): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ValueError): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ValueError): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ValueError): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(ValueError): session_manager.ValueError
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ValueError -> session_manager.ValueError
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.ValueError
      -> Resolved to: session_manager.ValueError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: ValueError
        [CACHE] ValueError -> session_manager.ValueError (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_lock
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_lock
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [CALL] Found call: ValueError
    [CACHE] ValueError -> session_manager.ValueError (cached)
      -> Resolved to: session_manager.ValueError
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: ValueError
        [CACHE] ValueError -> session_manager.ValueError (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.user_id
    [RESOLVE] Attempting to resolve: ['session', 'user_id']
    [RESOLVE] Chain resolution needed for: ['session', 'user_id']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.user_id
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.user_id
        [ATTRIBUTE] Direct match found: session_manager.UserSession.user_id
      [CHAIN] Step 1 resolved: session_manager.UserSession.user_id
    [RESOLVE] RESOLVED to: session_manager.UserSession.user_id
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.user_role
    [RESOLVE] Attempting to resolve: ['session', 'user_role']
    [RESOLVE] Chain resolution needed for: ['session', 'user_role']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.user_role
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.user_role
        [ATTRIBUTE] Direct match found: session_manager.UserSession.user_role
      [CHAIN] Step 1 resolved: session_manager.UserSession.user_role
    [RESOLVE] RESOLVED to: session_manager.UserSession.user_role
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: self._determine_user_role
    [RESOLVE] Attempting to resolve: ['self', '_determine_user_role']
    [RESOLVE] Chain resolution needed for: ['self', '_determine_user_role']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._determine_user_role
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._determine_user_role
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._determine_user_role
      [CHAIN] Step 1 resolved: session_manager.SessionManager._determine_user_role
    [RESOLVE] RESOLVED to: session_manager.SessionManager._determine_user_role
            [INTERMEDIATE] Tracking chain steps for: self._determine_user_role
            [INTERMEDIATE] Step 1: self._determine_user_role
      -> Resolved to: session_manager.SessionManager._determine_user_role
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      [ATTRIBUTE] Found attribute access: self._determine_user_role
        [CACHE] self._determine_user_role -> session_manager.SessionManager._determine_user_role (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.state
    [RESOLVE] Attempting to resolve: ['session', 'state']
    [RESOLVE] Chain resolution needed for: ['session', 'state']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.state
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.state
        [ATTRIBUTE] Direct match found: session_manager.UserSession.state
      [CHAIN] Step 1 resolved: session_manager.UserSession.state
    [RESOLVE] RESOLVED to: session_manager.UserSession.state
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: SessionState.ACTIVE
    [RESOLVE] Attempting to resolve: ['SessionState', 'ACTIVE']
    [RESOLVE] Chain resolution needed for: ['SessionState', 'ACTIVE']
      [CHAIN] Resolving base: SessionState
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
      [CHAIN] Base resolved: SessionState -> session_manager.SessionState
      [CHAIN] Step 1: Resolving session_manager.SessionState.ACTIVE
        [ATTRIBUTE] Resolving attribute: session_manager.SessionState.ACTIVE
        [ATTRIBUTE] Direct match found: session_manager.SessionState.ACTIVE
      [CHAIN] Step 1 resolved: session_manager.SessionState.ACTIVE
    [RESOLVE] RESOLVED to: session_manager.SessionState.ACTIVE
      -> Not module state
      [NAME] Found name reference: SessionState
    [RESOLVE] Attempting to resolve: ['SessionState']
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
    [RESOLVE] RESOLVED to: session_manager.SessionState
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.permissions
    [RESOLVE] Attempting to resolve: ['session', 'permissions']
    [RESOLVE] Chain resolution needed for: ['session', 'permissions']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.permissions
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.permissions
        [ATTRIBUTE] Direct match found: session_manager.UserSession.permissions
      [CHAIN] Step 1 resolved: session_manager.UserSession.permissions
    [RESOLVE] RESOLVED to: session_manager.UserSession.permissions
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: self._get_role_permissions
    [RESOLVE] Attempting to resolve: ['self', '_get_role_permissions']
    [RESOLVE] Chain resolution needed for: ['self', '_get_role_permissions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._get_role_permissions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._get_role_permissions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._get_role_permissions
      [CHAIN] Step 1 resolved: session_manager.SessionManager._get_role_permissions
    [RESOLVE] RESOLVED to: session_manager.SessionManager._get_role_permissions
            [INTERMEDIATE] Tracking chain steps for: self._get_role_permissions
            [INTERMEDIATE] Step 1: self._get_role_permissions
      -> Resolved to: session_manager.SessionManager._get_role_permissions
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self._get_role_permissions
        [CACHE] self._get_role_permissions -> session_manager.SessionManager._get_role_permissions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.user_role
        [CACHE] session.user_role -> session_manager.UserSession.user_role (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.preferences
    [RESOLVE] Attempting to resolve: ['session', 'preferences']
    [RESOLVE] Chain resolution needed for: ['session', 'preferences']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.preferences
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.preferences
        [ATTRIBUTE] Direct match found: session_manager.UserSession.preferences
      [CHAIN] Step 1 resolved: session_manager.UserSession.preferences
    [RESOLVE] RESOLVED to: session_manager.UserSession.preferences
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: self.haven_proxy.get_user_preferences
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy', 'get_user_preferences']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy', 'get_user_preferences']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 2: Resolving session_manager.SessionManager.haven_proxy.get_user_preferences
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy.get_user_preferences
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy.get_user_preferences
      [CHAIN] Step 2 resolved: session_manager.SessionManager.haven_proxy.get_user_preferences
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy.get_user_preferences
            [INTERMEDIATE] Tracking chain steps for: self.haven_proxy.get_user_preferences
            [INTERMEDIATE] Step 1: self.haven_proxy
    [CACHE] self.haven_proxy -> session_manager.SessionManager.haven_proxy (cached)
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.haven_proxy
            [INTERMEDIATE] Step 2: self.haven_proxy.get_user_preferences
      -> Resolved to: session_manager.SessionManager.haven_proxy.get_user_preferences
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      [ATTRIBUTE] Found attribute access: self.haven_proxy.get_user_preferences
        [CACHE] self.haven_proxy.get_user_preferences -> session_manager.SessionManager.haven_proxy.get_user_preferences (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.haven_proxy
        [CACHE] self.haven_proxy -> session_manager.SessionManager.haven_proxy (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [CALL] Found call: session.update_activity
    [RESOLVE] Attempting to resolve: ['session', 'update_activity']
    [RESOLVE] Chain resolution needed for: ['session', 'update_activity']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.update_activity
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.update_activity
        [ATTRIBUTE] Direct match found: session_manager.UserSession.update_activity
      [CHAIN] Step 1 resolved: session_manager.UserSession.update_activity
    [RESOLVE] RESOLVED to: session_manager.UserSession.update_activity
            [INTERMEDIATE] Tracking chain steps for: session.update_activity
            [INTERMEDIATE] Step 1: session.update_activity
      -> Resolved to: session_manager.UserSession.update_activity
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session.update_activity
        [CACHE] session.update_activity -> session_manager.UserSession.update_activity (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
    [RESOLVE] Attempting to resolve: ['self', 'user_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'user_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.user_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.user_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.user_sessions
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [CALL] Found call: self._trigger_event
    [RESOLVE] Attempting to resolve: ['self', '_trigger_event']
    [RESOLVE] Chain resolution needed for: ['self', '_trigger_event']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._trigger_event
      [CHAIN] Step 1 resolved: session_manager.SessionManager._trigger_event
    [RESOLVE] RESOLVED to: session_manager.SessionManager._trigger_event
            [INTERMEDIATE] Tracking chain steps for: self._trigger_event
            [INTERMEDIATE] Step 1: self._trigger_event
      -> Resolved to: session_manager.SessionManager._trigger_event
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      [ATTRIBUTE] Found attribute access: self._trigger_event
        [CACHE] self._trigger_event -> session_manager.SessionManager._trigger_event (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.create_user_session
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.create_user_session
        Calls: 4
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.get_current_session
    [DECORATOR] @trace
    [CONTEXT] Entered function: session_manager.SessionManager.get_current_session (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.current_session_id
    [RESOLVE] Attempting to resolve: ['self', 'current_session_id']
    [RESOLVE] Chain resolution needed for: ['self', 'current_session_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.current_session_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.current_session_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.current_session_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.current_session_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.current_session_id
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_lock
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_lock
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.get
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.active_sessions.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for session
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.get
            [INTERMEDIATE] Tracking chain steps for: self.active_sessions.get
            [INTERMEDIATE] Step 1: self.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 2: self.active_sessions.get
      -> Resolved to: session_manager.SessionManager.active_sessions.get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.active_sessions.get
        [CACHE] self.active_sessions.get -> session_manager.SessionManager.active_sessions.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_session_id
        [CACHE] self.current_session_id -> session_manager.SessionManager.current_session_id (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: session.is_valid
    [RESOLVE] Attempting to resolve: ['session', 'is_valid']
    [RESOLVE] Chain resolution needed for: ['session', 'is_valid']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.is_valid
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.is_valid
        [ATTRIBUTE] Direct match found: session_manager.UserSession.is_valid
      [CHAIN] Step 1 resolved: session_manager.UserSession.is_valid
    [RESOLVE] RESOLVED to: session_manager.UserSession.is_valid
            [INTERMEDIATE] Tracking chain steps for: session.is_valid
            [INTERMEDIATE] Step 1: session.is_valid
      -> Resolved to: session_manager.UserSession.is_valid
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session.is_valid
        [CACHE] session.is_valid -> session_manager.UserSession.is_valid (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: session.update_activity
    [RESOLVE] Attempting to resolve: ['session', 'update_activity']
    [RESOLVE] Chain resolution needed for: ['session', 'update_activity']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.update_activity
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.update_activity
        [ATTRIBUTE] Direct match found: session_manager.UserSession.update_activity
      [CHAIN] Step 1 resolved: session_manager.UserSession.update_activity
    [RESOLVE] RESOLVED to: session_manager.UserSession.update_activity
            [INTERMEDIATE] Tracking chain steps for: session.update_activity
            [INTERMEDIATE] Step 1: session.update_activity
      -> Resolved to: session_manager.UserSession.update_activity
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session.update_activity
        [CACHE] session.update_activity -> session_manager.UserSession.update_activity (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: self._trigger_event
    [RESOLVE] Attempting to resolve: ['self', '_trigger_event']
    [RESOLVE] Chain resolution needed for: ['self', '_trigger_event']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._trigger_event
      [CHAIN] Step 1 resolved: session_manager.SessionManager._trigger_event
    [RESOLVE] RESOLVED to: session_manager.SessionManager._trigger_event
            [INTERMEDIATE] Tracking chain steps for: self._trigger_event
            [INTERMEDIATE] Step 1: self._trigger_event
      -> Resolved to: session_manager.SessionManager._trigger_event
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      [ATTRIBUTE] Found attribute access: self._trigger_event
        [CACHE] self._trigger_event -> session_manager.SessionManager._trigger_event (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: session.is_expired
    [RESOLVE] Attempting to resolve: ['session', 'is_expired']
    [RESOLVE] Chain resolution needed for: ['session', 'is_expired']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.is_expired
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.is_expired
        [ATTRIBUTE] Direct match found: session_manager.UserSession.is_expired
      [CHAIN] Step 1 resolved: session_manager.UserSession.is_expired
    [RESOLVE] RESOLVED to: session_manager.UserSession.is_expired
            [INTERMEDIATE] Tracking chain steps for: session.is_expired
            [INTERMEDIATE] Step 1: session.is_expired
      -> Resolved to: session_manager.UserSession.is_expired
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session.is_expired
        [CACHE] session.is_expired -> session_manager.UserSession.is_expired (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: self._expire_session
    [RESOLVE] Attempting to resolve: ['self', '_expire_session']
    [RESOLVE] Chain resolution needed for: ['self', '_expire_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._expire_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._expire_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._expire_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager._expire_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager._expire_session
            [INTERMEDIATE] Tracking chain steps for: self._expire_session
            [INTERMEDIATE] Step 1: self._expire_session
      -> Resolved to: session_manager.SessionManager._expire_session
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self._expire_session
        [CACHE] self._expire_session -> session_manager.SessionManager._expire_session (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_session_id
        [CACHE] self.current_session_id -> session_manager.SessionManager.current_session_id (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.get_current_session
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.get_current_session
        Calls: 5
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.get_current_session_id
    [CONTEXT] Entered function: session_manager.SessionManager.get_current_session_id (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.get_current_session
    [RESOLVE] Attempting to resolve: ['self', 'get_current_session']
    [RESOLVE] Chain resolution needed for: ['self', 'get_current_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_session
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.get_current_session
        [RETURN_TYPE_RESOLUTION] Resolving return type: UserSession
        [RETURN_TYPE_RESOLUTION] Found in current module: session_manager.UserSession
      [TYPE_INFERENCE] RESOLVED Inferred type: session_manager.UserSession (from return type)
      [SYMBOL_UPDATE] Function: session -> session_manager.UserSession
        [ASSIGNMENT] RESOLVED Updated symbol table: session = session_manager.UserSession
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self.get_current_session
    [RESOLVE] Attempting to resolve: ['self', 'get_current_session']
    [RESOLVE] Chain resolution needed for: ['self', 'get_current_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_session
            [INTERMEDIATE] Tracking chain steps for: self.get_current_session
            [INTERMEDIATE] Step 1: self.get_current_session
      -> Resolved to: session_manager.SessionManager.get_current_session
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self.get_current_session
        [CACHE] self.get_current_session -> session_manager.SessionManager.get_current_session (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.session_id
    [RESOLVE] Attempting to resolve: ['session', 'session_id']
    [RESOLVE] Chain resolution needed for: ['session', 'session_id']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.session_id
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.session_id
        [ATTRIBUTE] Direct match found: session_manager.UserSession.session_id
      [CHAIN] Step 1 resolved: session_manager.UserSession.session_id
    [RESOLVE] RESOLVED to: session_manager.UserSession.session_id
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.get_current_session_id
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.get_current_session_id
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.get_current_user_id
    [CONTEXT] Entered function: session_manager.SessionManager.get_current_user_id (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.get_current_session
    [RESOLVE] Attempting to resolve: ['self', 'get_current_session']
    [RESOLVE] Chain resolution needed for: ['self', 'get_current_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_session
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.get_current_session
        [RETURN_TYPE_RESOLUTION] Resolving return type: UserSession
        [RETURN_TYPE_RESOLUTION] Found in current module: session_manager.UserSession
      [TYPE_INFERENCE] RESOLVED Inferred type: session_manager.UserSession (from return type)
      [SYMBOL_UPDATE] Function: session -> session_manager.UserSession
        [ASSIGNMENT] RESOLVED Updated symbol table: session = session_manager.UserSession
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self.get_current_session
    [RESOLVE] Attempting to resolve: ['self', 'get_current_session']
    [RESOLVE] Chain resolution needed for: ['self', 'get_current_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_session
            [INTERMEDIATE] Tracking chain steps for: self.get_current_session
            [INTERMEDIATE] Step 1: self.get_current_session
      -> Resolved to: session_manager.SessionManager.get_current_session
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self.get_current_session
        [CACHE] self.get_current_session -> session_manager.SessionManager.get_current_session (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.user_id
    [RESOLVE] Attempting to resolve: ['session', 'user_id']
    [RESOLVE] Chain resolution needed for: ['session', 'user_id']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.user_id
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.user_id
        [ATTRIBUTE] Direct match found: session_manager.UserSession.user_id
      [CHAIN] Step 1 resolved: session_manager.UserSession.user_id
    [RESOLVE] RESOLVED to: session_manager.UserSession.user_id
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.get_current_user_id
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.get_current_user_id
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.get_current_user
    [CONTEXT] Entered function: session_manager.SessionManager.get_current_user (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ASSIGNMENT] Processing: user_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.get_current_user_id
    [RESOLVE] Attempting to resolve: ['self', 'get_current_user_id']
    [RESOLVE] Chain resolution needed for: ['self', 'get_current_user_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_user_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_user_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_user_id
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.get_current_user_id
        [RETURN_TYPE_RESOLUTION] Resolving return type: str
        [RETURN_TYPE_RESOLUTION] Class 'str' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: str
      [TYPE_INFERENCE] Could not resolve return type 'str' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: str (from return type - unresolved)
      [SYMBOL_UPDATE] Function: user_id -> str
        [ASSIGNMENT] RESOLVED Updated symbol table: user_id = str
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      -> Not module state
      [CALL] Found call: self.get_current_user_id
    [RESOLVE] Attempting to resolve: ['self', 'get_current_user_id']
    [RESOLVE] Chain resolution needed for: ['self', 'get_current_user_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_user_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_user_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_user_id
            [INTERMEDIATE] Tracking chain steps for: self.get_current_user_id
            [INTERMEDIATE] Step 1: self.get_current_user_id
      -> Resolved to: session_manager.SessionManager.get_current_user_id
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self.get_current_user_id
        [CACHE] self.get_current_user_id -> session_manager.SessionManager.get_current_user_id (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [CALL] Found call: self.haven_proxy.get_user_info
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy', 'get_user_info']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy', 'get_user_info']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 2: Resolving session_manager.SessionManager.haven_proxy.get_user_info
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy.get_user_info
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy.get_user_info
      [CHAIN] Step 2 resolved: session_manager.SessionManager.haven_proxy.get_user_info
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy.get_user_info
            [INTERMEDIATE] Tracking chain steps for: self.haven_proxy.get_user_info
            [INTERMEDIATE] Step 1: self.haven_proxy
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.haven_proxy
            [INTERMEDIATE] Step 2: self.haven_proxy.get_user_info
      -> Resolved to: session_manager.SessionManager.haven_proxy.get_user_info
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      [ATTRIBUTE] Found attribute access: self.haven_proxy.get_user_info
        [CACHE] self.haven_proxy.get_user_info -> session_manager.SessionManager.haven_proxy.get_user_info (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.haven_proxy
        [CACHE] self.haven_proxy -> session_manager.SessionManager.haven_proxy (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.get_current_user
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.get_current_user
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.get_current_timestamp
    [CONTEXT] Entered function: session_manager.SessionManager.get_current_timestamp (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
    [IMPORT] time -> time
      [CALL] Found call: time.time
    [RESOLVE] Attempting to resolve: ['time', 'time']
    [RESOLVE] Chain resolution needed for: ['time', 'time']
      [CHAIN] Resolving base: time
      [RESOLVE_SIMPLE] Resolving base: time
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable time not found in any scope
      [LOCAL_RESOLVER] can_resolve(time): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(time): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(time): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(time): time (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: time -> time
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: time -> time
      [CHAIN] Step 1: Resolving time.time
        [ATTRIBUTE] Resolving attribute: time.time
        [ATTRIBUTE] Direct match found: time.time
      [CHAIN] Step 1 resolved: time.time
    [RESOLVE] RESOLVED to: time.time
            [INTERMEDIATE] Tracking chain steps for: time.time
            [INTERMEDIATE] Step 1: time.time
      -> Resolved to: time.time
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: time.time
        [CACHE] time.time -> time.time (cached)
      -> Not module state
      [NAME] Found name reference: time
    [RESOLVE] Attempting to resolve: ['time']
      [RESOLVE_SIMPLE] Resolving base: time
      [CACHE] Hit for time: time
    [RESOLVE] RESOLVED to: time
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.get_current_timestamp
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.get_current_timestamp
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.validate_session
    [DECORATOR] @trace
    [CONTEXT] Entered function: session_manager.SessionManager.validate_session (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'session_id': 'str'}
        [ARG_TYPE] Processing type annotation for session_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: session_id -> session_manager.str
        [ARG_TYPE] RESOLVED session_id : session_manager.str
      [ATTRIBUTE] Found attribute access: self.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_lock
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.get
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.active_sessions.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for session
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.get
            [INTERMEDIATE] Tracking chain steps for: self.active_sessions.get
            [INTERMEDIATE] Step 1: self.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 2: self.active_sessions.get
      -> Resolved to: session_manager.SessionManager.active_sessions.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      [ATTRIBUTE] Found attribute access: self.active_sessions.get
        [CACHE] self.active_sessions.get -> session_manager.SessionManager.active_sessions.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: session.is_expired
    [RESOLVE] Attempting to resolve: ['session', 'is_expired']
    [RESOLVE] Chain resolution needed for: ['session', 'is_expired']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.is_expired
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.is_expired
        [ATTRIBUTE] Direct match found: session_manager.UserSession.is_expired
      [CHAIN] Step 1 resolved: session_manager.UserSession.is_expired
    [RESOLVE] RESOLVED to: session_manager.UserSession.is_expired
            [INTERMEDIATE] Tracking chain steps for: session.is_expired
            [INTERMEDIATE] Step 1: session.is_expired
      -> Resolved to: session_manager.UserSession.is_expired
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session.is_expired
        [CACHE] session.is_expired -> session_manager.UserSession.is_expired (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: self._expire_session
    [RESOLVE] Attempting to resolve: ['self', '_expire_session']
    [RESOLVE] Chain resolution needed for: ['self', '_expire_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._expire_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._expire_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._expire_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager._expire_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager._expire_session
            [INTERMEDIATE] Tracking chain steps for: self._expire_session
            [INTERMEDIATE] Step 1: self._expire_session
      -> Resolved to: session_manager.SessionManager._expire_session
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      [ATTRIBUTE] Found attribute access: self._expire_session
        [CACHE] self._expire_session -> session_manager.SessionManager._expire_session (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [CALL] Found call: session.is_valid
    [RESOLVE] Attempting to resolve: ['session', 'is_valid']
    [RESOLVE] Chain resolution needed for: ['session', 'is_valid']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.is_valid
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.is_valid
        [ATTRIBUTE] Direct match found: session_manager.UserSession.is_valid
      [CHAIN] Step 1 resolved: session_manager.UserSession.is_valid
    [RESOLVE] RESOLVED to: session_manager.UserSession.is_valid
            [INTERMEDIATE] Tracking chain steps for: session.is_valid
            [INTERMEDIATE] Step 1: session.is_valid
      -> Resolved to: session_manager.UserSession.is_valid
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session.is_valid
        [CACHE] session.is_valid -> session_manager.UserSession.is_valid (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: session.update_activity
    [RESOLVE] Attempting to resolve: ['session', 'update_activity']
    [RESOLVE] Chain resolution needed for: ['session', 'update_activity']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.update_activity
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.update_activity
        [ATTRIBUTE] Direct match found: session_manager.UserSession.update_activity
      [CHAIN] Step 1 resolved: session_manager.UserSession.update_activity
    [RESOLVE] RESOLVED to: session_manager.UserSession.update_activity
            [INTERMEDIATE] Tracking chain steps for: session.update_activity
            [INTERMEDIATE] Step 1: session.update_activity
      -> Resolved to: session_manager.UserSession.update_activity
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session.update_activity
        [CACHE] session.update_activity -> session_manager.UserSession.update_activity (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: self._trigger_event
    [RESOLVE] Attempting to resolve: ['self', '_trigger_event']
    [RESOLVE] Chain resolution needed for: ['self', '_trigger_event']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._trigger_event
      [CHAIN] Step 1 resolved: session_manager.SessionManager._trigger_event
    [RESOLVE] RESOLVED to: session_manager.SessionManager._trigger_event
            [INTERMEDIATE] Tracking chain steps for: self._trigger_event
            [INTERMEDIATE] Step 1: self._trigger_event
      -> Resolved to: session_manager.SessionManager._trigger_event
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      [ATTRIBUTE] Found attribute access: self._trigger_event
        [CACHE] self._trigger_event -> session_manager.SessionManager._trigger_event (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.validate_session
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.validate_session
        Calls: 5
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.validate_room_access
    [DECORATOR] @validate_auth(required_role='user')
    [CONTEXT] Entered function: session_manager.SessionManager.validate_room_access (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'room_name': 'str'}
        [ARG_TYPE] Processing type annotation for room_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: room_name -> session_manager.str
        [ARG_TYPE] RESOLVED room_name : session_manager.str
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.get_current_session
    [RESOLVE] Attempting to resolve: ['self', 'get_current_session']
    [RESOLVE] Chain resolution needed for: ['self', 'get_current_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_session
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.get_current_session
        [RETURN_TYPE_RESOLUTION] Resolving return type: UserSession
        [RETURN_TYPE_RESOLUTION] Found in current module: session_manager.UserSession
      [TYPE_INFERENCE] RESOLVED Inferred type: session_manager.UserSession (from return type)
      [SYMBOL_UPDATE] Function: session -> session_manager.UserSession
        [ASSIGNMENT] RESOLVED Updated symbol table: session = session_manager.UserSession
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self.get_current_session
    [RESOLVE] Attempting to resolve: ['self', 'get_current_session']
    [RESOLVE] Chain resolution needed for: ['self', 'get_current_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_session
            [INTERMEDIATE] Tracking chain steps for: self.get_current_session
            [INTERMEDIATE] Step 1: self.get_current_session
      -> Resolved to: session_manager.SessionManager.get_current_session
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self.get_current_session
        [CACHE] self.get_current_session -> session_manager.SessionManager.get_current_session (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ASSIGNMENT] Processing: access_granted = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.haven_proxy.validate_room_access
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy', 'validate_room_access']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy', 'validate_room_access']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 2: Resolving session_manager.SessionManager.haven_proxy.validate_room_access
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy.validate_room_access
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy.validate_room_access
      [CHAIN] Step 2 resolved: session_manager.SessionManager.haven_proxy.validate_room_access
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy.validate_room_access
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.haven_proxy.validate_room_access
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for access_granted
      [NAME] Found name reference: access_granted
    [RESOLVE] Attempting to resolve: ['access_granted']
      [RESOLVE_SIMPLE] Resolving base: access_granted
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable access_granted not found in any scope
      [LOCAL_RESOLVER] can_resolve(access_granted): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(access_granted): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(access_granted): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(access_granted): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(access_granted): session_manager.access_granted
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: access_granted -> session_manager.access_granted
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.access_granted
      -> Not module state
      [CALL] Found call: self.haven_proxy.validate_room_access
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy', 'validate_room_access']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy', 'validate_room_access']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 2: Resolving session_manager.SessionManager.haven_proxy.validate_room_access
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy.validate_room_access
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy.validate_room_access
      [CHAIN] Step 2 resolved: session_manager.SessionManager.haven_proxy.validate_room_access
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy.validate_room_access
            [INTERMEDIATE] Tracking chain steps for: self.haven_proxy.validate_room_access
            [INTERMEDIATE] Step 1: self.haven_proxy
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.haven_proxy
            [INTERMEDIATE] Step 2: self.haven_proxy.validate_room_access
      -> Resolved to: session_manager.SessionManager.haven_proxy.validate_room_access
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: room_name
    [RESOLVE] Attempting to resolve: ['room_name']
      [RESOLVE_SIMPLE] Resolving base: room_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found room_name in function scope: session_manager.str
      [LOCAL_RESOLVER] can_resolve(room_name): True
      [SYMBOL_LOOKUP] Found room_name in function scope: session_manager.str
      [LOCAL_RESOLVER] resolve(room_name): session_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: room_name -> session_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.str
      [ATTRIBUTE] Found attribute access: self.haven_proxy.validate_room_access
        [CACHE] self.haven_proxy.validate_room_access -> session_manager.SessionManager.haven_proxy.validate_room_access (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.haven_proxy
        [CACHE] self.haven_proxy -> session_manager.SessionManager.haven_proxy (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.user_id
    [RESOLVE] Attempting to resolve: ['session', 'user_id']
    [RESOLVE] Chain resolution needed for: ['session', 'user_id']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.user_id
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.user_id
        [ATTRIBUTE] Direct match found: session_manager.UserSession.user_id
      [CHAIN] Step 1 resolved: session_manager.UserSession.user_id
    [RESOLVE] RESOLVED to: session_manager.UserSession.user_id
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: room_name
    [RESOLVE] Attempting to resolve: ['room_name']
      [RESOLVE_SIMPLE] Resolving base: room_name
      [CACHE] Hit for room_name: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [NAME] Found name reference: access_granted
        [CACHE] access_granted -> session_manager.access_granted (cached)
      -> Not module state
      [CALL] Found call: session.metrics.rooms_joined.add
    [RESOLVE] Attempting to resolve: ['session', 'metrics', 'rooms_joined', 'add']
    [RESOLVE] Chain resolution needed for: ['session', 'metrics', 'rooms_joined', 'add']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
      [CHAIN] Step 2: Resolving session_manager.UserSession.metrics.rooms_joined
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics.rooms_joined
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics.rooms_joined
      [CHAIN] Step 2 resolved: session_manager.UserSession.metrics.rooms_joined
      [CHAIN] Step 3: Resolving session_manager.UserSession.metrics.rooms_joined.add
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics.rooms_joined.add
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics.rooms_joined.add
      [CHAIN] Step 3 resolved: session_manager.UserSession.metrics.rooms_joined.add
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics.rooms_joined.add
            [INTERMEDIATE] Tracking chain steps for: session.metrics.rooms_joined.add
            [INTERMEDIATE] Step 1: session.metrics
    [RESOLVE] Attempting to resolve: ['session', 'metrics']
    [RESOLVE] Chain resolution needed for: ['session', 'metrics']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics
            [INTERMEDIATE] Step 1 resolved to: session_manager.UserSession.metrics
            [INTERMEDIATE] Step 2: session.metrics.rooms_joined
    [RESOLVE] Attempting to resolve: ['session', 'metrics', 'rooms_joined']
    [RESOLVE] Chain resolution needed for: ['session', 'metrics', 'rooms_joined']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
      [CHAIN] Step 2: Resolving session_manager.UserSession.metrics.rooms_joined
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics.rooms_joined
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics.rooms_joined
      [CHAIN] Step 2 resolved: session_manager.UserSession.metrics.rooms_joined
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics.rooms_joined
            [INTERMEDIATE] Step 2 resolved to: session_manager.UserSession.metrics.rooms_joined
            [INTERMEDIATE] Step 3: session.metrics.rooms_joined.add
      -> Resolved to: session_manager.UserSession.metrics.rooms_joined.add
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: room_name
    [RESOLVE] Attempting to resolve: ['room_name']
      [RESOLVE_SIMPLE] Resolving base: room_name
      [CACHE] Hit for room_name: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [ATTRIBUTE] Found attribute access: session.metrics.rooms_joined.add
        [CACHE] session.metrics.rooms_joined.add -> session_manager.UserSession.metrics.rooms_joined.add (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics.rooms_joined
        [CACHE] session.metrics.rooms_joined -> session_manager.UserSession.metrics.rooms_joined (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics
        [CACHE] session.metrics -> session_manager.UserSession.metrics (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> session_manager.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.context_data
    [RESOLVE] Attempting to resolve: ['session', 'context_data']
    [RESOLVE] Chain resolution needed for: ['session', 'context_data']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.context_data
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.context_data
        [ATTRIBUTE] Direct match found: session_manager.UserSession.context_data
      [CHAIN] Step 1 resolved: session_manager.UserSession.context_data
    [RESOLVE] RESOLVED to: session_manager.UserSession.context_data
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> session_manager.str (cached)
      -> Not module state
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
      [NAME] Found name reference: access_granted
        [CACHE] access_granted -> session_manager.access_granted (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.validate_room_access
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.validate_room_access
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.get_user_room
    [CONTEXT] Entered function: session_manager.SessionManager.get_user_room (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'Optional[str]'}
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      -> Not module state
      [ASSIGNMENT] Processing: user_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.get_current_user_id
    [RESOLVE] Attempting to resolve: ['self', 'get_current_user_id']
    [RESOLVE] Chain resolution needed for: ['self', 'get_current_user_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_user_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_user_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_user_id
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.get_current_user_id
        [RETURN_TYPE_RESOLUTION] Resolving return type: str
        [RETURN_TYPE_RESOLUTION] Class 'str' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: str
      [TYPE_INFERENCE] Could not resolve return type 'str' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: str (from return type - unresolved)
      [SYMBOL_UPDATE] Function: user_id -> str
        [ASSIGNMENT] RESOLVED Updated symbol table: user_id = str
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [CALL] Found call: self.get_current_user_id
    [RESOLVE] Attempting to resolve: ['self', 'get_current_user_id']
    [RESOLVE] Chain resolution needed for: ['self', 'get_current_user_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_user_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_user_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_user_id
            [INTERMEDIATE] Tracking chain steps for: self.get_current_user_id
            [INTERMEDIATE] Step 1: self.get_current_user_id
      -> Resolved to: session_manager.SessionManager.get_current_user_id
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self.get_current_user_id
        [CACHE] self.get_current_user_id -> session_manager.SessionManager.get_current_user_id (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.get_user_room
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.get_user_room
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.get_user_rooms
    [CONTEXT] Entered function: session_manager.SessionManager.get_user_rooms (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: user_id -> session_manager.str
        [ARG_TYPE] RESOLVED user_id : session_manager.str
      [ATTRIBUTE] Found attribute access: self.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_lock
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ASSIGNMENT] Processing: rooms = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: rooms
    [RESOLVE] Attempting to resolve: ['rooms']
      [RESOLVE_SIMPLE] Resolving base: rooms
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable rooms not found in any scope
      [LOCAL_RESOLVER] can_resolve(rooms): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(rooms): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(rooms): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(rooms): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(rooms): session_manager.rooms
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: rooms -> session_manager.rooms
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.rooms
      -> Not module state
      [NAME] Found name reference: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      -> Not module state
      [CALL] Found call: self.user_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'user_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'user_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.user_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.user_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.user_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.user_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.user_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.user_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.user_sessions.get
            [INTERMEDIATE] Tracking chain steps for: self.user_sessions.get
            [INTERMEDIATE] Step 1: self.user_sessions
    [RESOLVE] Attempting to resolve: ['self', 'user_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'user_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.user_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.user_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.user_sessions
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.user_sessions
            [INTERMEDIATE] Step 2: self.user_sessions.get
      -> Resolved to: session_manager.SessionManager.user_sessions.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      [ATTRIBUTE] Found attribute access: self.user_sessions.get
        [CACHE] self.user_sessions.get -> session_manager.SessionManager.user_sessions.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      -> Not module state
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.get
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.active_sessions.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for session
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.get
            [INTERMEDIATE] Tracking chain steps for: self.active_sessions.get
            [INTERMEDIATE] Step 1: self.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 2: self.active_sessions.get
      -> Resolved to: session_manager.SessionManager.active_sessions.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      [ATTRIBUTE] Found attribute access: self.active_sessions.get
        [CACHE] self.active_sessions.get -> session_manager.SessionManager.active_sessions.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: rooms.extend
    [RESOLVE] Attempting to resolve: ['rooms', 'extend']
    [RESOLVE] Chain resolution needed for: ['rooms', 'extend']
      [CHAIN] Resolving base: rooms
      [RESOLVE_SIMPLE] Resolving base: rooms
      [CACHE] Hit for rooms: session_manager.rooms
      [CHAIN] Base resolved: rooms -> session_manager.rooms
      [CHAIN] Step 1: Resolving session_manager.rooms.extend
        [ATTRIBUTE] Resolving attribute: session_manager.rooms.extend
        [ATTRIBUTE] Direct match found: session_manager.rooms.extend
      [CHAIN] Step 1 resolved: session_manager.rooms.extend
    [RESOLVE] RESOLVED to: session_manager.rooms.extend
            [INTERMEDIATE] Tracking chain steps for: rooms.extend
            [INTERMEDIATE] Step 1: rooms.extend
      -> Resolved to: session_manager.rooms.extend
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: rooms.extend
        [CACHE] rooms.extend -> session_manager.rooms.extend (cached)
      -> Not module state
      [NAME] Found name reference: rooms
        [CACHE] rooms -> session_manager.rooms (cached)
      -> Not module state
      [CALL] Found call: list
      -> IGNORED (built-in function)
      [NAME] Found name reference: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable list not found in any scope
      [LOCAL_RESOLVER] can_resolve(list): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(list): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(list): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(list): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(list): session_manager.list
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: list -> session_manager.list
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.list
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics.rooms_joined
    [RESOLVE] Attempting to resolve: ['session', 'metrics', 'rooms_joined']
    [RESOLVE] Chain resolution needed for: ['session', 'metrics', 'rooms_joined']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
      [CHAIN] Step 2: Resolving session_manager.UserSession.metrics.rooms_joined
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics.rooms_joined
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics.rooms_joined
      [CHAIN] Step 2 resolved: session_manager.UserSession.metrics.rooms_joined
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics.rooms_joined
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics
    [RESOLVE] Attempting to resolve: ['session', 'metrics']
    [RESOLVE] Chain resolution needed for: ['session', 'metrics']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: rooms.append
    [RESOLVE] Attempting to resolve: ['rooms', 'append']
    [RESOLVE] Chain resolution needed for: ['rooms', 'append']
      [CHAIN] Resolving base: rooms
      [RESOLVE_SIMPLE] Resolving base: rooms
      [CACHE] Hit for rooms: session_manager.rooms
      [CHAIN] Base resolved: rooms -> session_manager.rooms
      [CHAIN] Step 1: Resolving session_manager.rooms.append
        [ATTRIBUTE] Resolving attribute: session_manager.rooms.append
        [ATTRIBUTE] Direct match found: session_manager.rooms.append
      [CHAIN] Step 1 resolved: session_manager.rooms.append
    [RESOLVE] RESOLVED to: session_manager.rooms.append
            [INTERMEDIATE] Tracking chain steps for: rooms.append
            [INTERMEDIATE] Step 1: rooms.append
      -> Resolved to: session_manager.rooms.append
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: rooms.append
        [CACHE] rooms.append -> session_manager.rooms.append (cached)
      -> Not module state
      [NAME] Found name reference: rooms
        [CACHE] rooms -> session_manager.rooms (cached)
      -> Not module state
      [CALL] Found call: self.get_user_room
    [RESOLVE] Attempting to resolve: ['self', 'get_user_room']
    [RESOLVE] Chain resolution needed for: ['self', 'get_user_room']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_user_room
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_user_room
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_user_room
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_user_room
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_user_room
            [INTERMEDIATE] Tracking chain steps for: self.get_user_room
            [INTERMEDIATE] Step 1: self.get_user_room
      -> Resolved to: session_manager.SessionManager.get_user_room
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      [ATTRIBUTE] Found attribute access: self.get_user_room
        [CACHE] self.get_user_room -> session_manager.SessionManager.get_user_room (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [CALL] Found call: list
      -> IGNORED (built-in function)
      [NAME] Found name reference: list
        [CACHE] list -> session_manager.list (cached)
      -> Not module state
      [CALL] Found call: set
      -> IGNORED (built-in function)
      [NAME] Found name reference: set
    [RESOLVE] Attempting to resolve: ['set']
      [RESOLVE_SIMPLE] Resolving base: set
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable set not found in any scope
      [LOCAL_RESOLVER] can_resolve(set): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(set): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(set): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(set): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(set): session_manager.set
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: set -> session_manager.set
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.set
      -> Not module state
      [NAME] Found name reference: rooms
        [CACHE] rooms -> session_manager.rooms (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.get_user_rooms
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.get_user_rooms
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.get_active_users
    [CONTEXT] Entered function: session_manager.SessionManager.get_active_users (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_lock
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ASSIGNMENT] Processing: active_users = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: set
    [RESOLVE] Attempting to resolve: ['set']
      [RESOLVE_SIMPLE] Resolving base: set
      [CACHE] Hit for set: session_manager.set
    [RESOLVE] RESOLVED to: session_manager.set
      [TYPE_INFERENCE] Call resolved to: session_manager.set
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for active_users
      [NAME] Found name reference: active_users
    [RESOLVE] Attempting to resolve: ['active_users']
      [RESOLVE_SIMPLE] Resolving base: active_users
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable active_users not found in any scope
      [LOCAL_RESOLVER] can_resolve(active_users): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(active_users): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(active_users): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(active_users): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(active_users): session_manager.active_users
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: active_users -> session_manager.active_users
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.active_users
      -> Not module state
      [CALL] Found call: set
      -> IGNORED (built-in function)
      [NAME] Found name reference: set
    [RESOLVE] Attempting to resolve: ['set']
      [RESOLVE_SIMPLE] Resolving base: set
      [CACHE] Hit for set: session_manager.set
    [RESOLVE] RESOLVED to: session_manager.set
      -> Not module state
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self.active_sessions.values
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'values']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'values']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.values
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.values
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.values
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.values
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.values
            [INTERMEDIATE] Tracking chain steps for: self.active_sessions.values
            [INTERMEDIATE] Step 1: self.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 2: self.active_sessions.values
      -> Resolved to: session_manager.SessionManager.active_sessions.values
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.active_sessions.values
        [CACHE] self.active_sessions.values -> session_manager.SessionManager.active_sessions.values (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [CALL] Found call: session.is_valid
    [RESOLVE] Attempting to resolve: ['session', 'is_valid']
    [RESOLVE] Chain resolution needed for: ['session', 'is_valid']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.is_valid
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.is_valid
        [ATTRIBUTE] Direct match found: session_manager.UserSession.is_valid
      [CHAIN] Step 1 resolved: session_manager.UserSession.is_valid
    [RESOLVE] RESOLVED to: session_manager.UserSession.is_valid
            [INTERMEDIATE] Tracking chain steps for: session.is_valid
            [INTERMEDIATE] Step 1: session.is_valid
      -> Resolved to: session_manager.UserSession.is_valid
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session.is_valid
        [CACHE] session.is_valid -> session_manager.UserSession.is_valid (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.user_role
    [RESOLVE] Attempting to resolve: ['session', 'user_role']
    [RESOLVE] Chain resolution needed for: ['session', 'user_role']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.user_role
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.user_role
        [ATTRIBUTE] Direct match found: session_manager.UserSession.user_role
      [CHAIN] Step 1 resolved: session_manager.UserSession.user_role
    [RESOLVE] RESOLVED to: session_manager.UserSession.user_role
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: UserRole.GUEST
    [RESOLVE] Attempting to resolve: ['UserRole', 'GUEST']
    [RESOLVE] Chain resolution needed for: ['UserRole', 'GUEST']
      [CHAIN] Resolving base: UserRole
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
      [CHAIN] Base resolved: UserRole -> session_manager.UserRole
      [CHAIN] Step 1: Resolving session_manager.UserRole.GUEST
        [ATTRIBUTE] Resolving attribute: session_manager.UserRole.GUEST
        [ATTRIBUTE] Direct match found: session_manager.UserRole.GUEST
      [CHAIN] Step 1 resolved: session_manager.UserRole.GUEST
    [RESOLVE] RESOLVED to: session_manager.UserRole.GUEST
      -> Not module state
      [NAME] Found name reference: UserRole
    [RESOLVE] Attempting to resolve: ['UserRole']
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
    [RESOLVE] RESOLVED to: session_manager.UserRole
      -> Not module state
      [CALL] Found call: active_users.add
    [RESOLVE] Attempting to resolve: ['active_users', 'add']
    [RESOLVE] Chain resolution needed for: ['active_users', 'add']
      [CHAIN] Resolving base: active_users
      [RESOLVE_SIMPLE] Resolving base: active_users
      [CACHE] Hit for active_users: session_manager.active_users
      [CHAIN] Base resolved: active_users -> session_manager.active_users
      [CHAIN] Step 1: Resolving session_manager.active_users.add
        [ATTRIBUTE] Resolving attribute: session_manager.active_users.add
        [ATTRIBUTE] Direct match found: session_manager.active_users.add
      [CHAIN] Step 1 resolved: session_manager.active_users.add
    [RESOLVE] RESOLVED to: session_manager.active_users.add
            [INTERMEDIATE] Tracking chain steps for: active_users.add
            [INTERMEDIATE] Step 1: active_users.add
      -> Resolved to: session_manager.active_users.add
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: active_users.add
        [CACHE] active_users.add -> session_manager.active_users.add (cached)
      -> Not module state
      [NAME] Found name reference: active_users
        [CACHE] active_users -> session_manager.active_users (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.user_id
    [RESOLVE] Attempting to resolve: ['session', 'user_id']
    [RESOLVE] Chain resolution needed for: ['session', 'user_id']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.user_id
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.user_id
        [ATTRIBUTE] Direct match found: session_manager.UserSession.user_id
      [CHAIN] Step 1 resolved: session_manager.UserSession.user_id
    [RESOLVE] RESOLVED to: session_manager.UserSession.user_id
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: list
      -> IGNORED (built-in function)
      [NAME] Found name reference: list
    [RESOLVE] Attempting to resolve: ['list']
      [RESOLVE_SIMPLE] Resolving base: list
      [CACHE] Hit for list: session_manager.list
    [RESOLVE] RESOLVED to: session_manager.list
      -> Not module state
      [NAME] Found name reference: active_users
        [CACHE] active_users -> session_manager.active_users (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.get_active_users
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.get_active_users
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.cleanup_user_session
    [DECORATOR] @trace
    [CONTEXT] Entered function: session_manager.SessionManager.cleanup_user_session (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: user_id -> session_manager.str
        [ARG_TYPE] RESOLVED user_id : session_manager.str
      [ATTRIBUTE] Found attribute access: self.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_lock
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ASSIGNMENT] Processing: session_ids = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] No name parts extracted from call
        [ASSIGNMENT] FAILED Could not infer type for session_ids
      [NAME] Found name reference: session_ids
    [RESOLVE] Attempting to resolve: ['session_ids']
      [RESOLVE_SIMPLE] Resolving base: session_ids
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable session_ids not found in any scope
      [LOCAL_RESOLVER] can_resolve(session_ids): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(session_ids): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(session_ids): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(session_ids): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(session_ids): session_manager.session_ids
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: session_ids -> session_manager.session_ids
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.session_ids
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: self.user_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'user_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'user_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.user_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.user_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.user_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.user_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.user_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.user_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.user_sessions.get
            [INTERMEDIATE] Tracking chain steps for: self.user_sessions.get
            [INTERMEDIATE] Step 1: self.user_sessions
    [RESOLVE] Attempting to resolve: ['self', 'user_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'user_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.user_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.user_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.user_sessions
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.user_sessions
            [INTERMEDIATE] Step 2: self.user_sessions.get
      -> Resolved to: session_manager.SessionManager.user_sessions.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      [ATTRIBUTE] Found attribute access: self.user_sessions.get
        [CACHE] self.user_sessions.get -> session_manager.SessionManager.user_sessions.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      -> Not module state
      [NAME] Found name reference: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      -> Not module state
      [NAME] Found name reference: session_ids
        [CACHE] session_ids -> session_manager.session_ids (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.state
    [RESOLVE] Attempting to resolve: ['session', 'state']
    [RESOLVE] Chain resolution needed for: ['session', 'state']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.state
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.state
        [ATTRIBUTE] Direct match found: session_manager.UserSession.state
      [CHAIN] Step 1 resolved: session_manager.UserSession.state
    [RESOLVE] RESOLVED to: session_manager.UserSession.state
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: SessionState.TERMINATED
    [RESOLVE] Attempting to resolve: ['SessionState', 'TERMINATED']
    [RESOLVE] Chain resolution needed for: ['SessionState', 'TERMINATED']
      [CHAIN] Resolving base: SessionState
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
      [CHAIN] Base resolved: SessionState -> session_manager.SessionState
      [CHAIN] Step 1: Resolving session_manager.SessionState.TERMINATED
        [ATTRIBUTE] Resolving attribute: session_manager.SessionState.TERMINATED
        [ATTRIBUTE] Direct match found: session_manager.SessionState.TERMINATED
      [CHAIN] Step 1 resolved: session_manager.SessionState.TERMINATED
    [RESOLVE] RESOLVED to: session_manager.SessionState.TERMINATED
      -> Not module state
      [NAME] Found name reference: SessionState
    [RESOLVE] Attempting to resolve: ['SessionState']
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
    [RESOLVE] RESOLVED to: session_manager.SessionState
      -> Not module state
      [CALL] Found call: self._trigger_event
    [RESOLVE] Attempting to resolve: ['self', '_trigger_event']
    [RESOLVE] Chain resolution needed for: ['self', '_trigger_event']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._trigger_event
      [CHAIN] Step 1 resolved: session_manager.SessionManager._trigger_event
    [RESOLVE] RESOLVED to: session_manager.SessionManager._trigger_event
            [INTERMEDIATE] Tracking chain steps for: self._trigger_event
            [INTERMEDIATE] Step 1: self._trigger_event
      -> Resolved to: session_manager.SessionManager._trigger_event
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      [ATTRIBUTE] Found attribute access: self._trigger_event
        [CACHE] self._trigger_event -> session_manager.SessionManager._trigger_event (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.cleanup_user_session
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.cleanup_user_session
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.destroy_session
    [DECORATOR] @trace
    [CONTEXT] Entered function: session_manager.SessionManager.destroy_session (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'session_id': 'str'}
        [ARG_TYPE] Processing type annotation for session_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: session_id -> session_manager.str
        [ARG_TYPE] RESOLVED session_id : session_manager.str
      [ATTRIBUTE] Found attribute access: self.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_lock
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.get
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.active_sessions.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for session
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.get
            [INTERMEDIATE] Tracking chain steps for: self.active_sessions.get
            [INTERMEDIATE] Step 1: self.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 2: self.active_sessions.get
      -> Resolved to: session_manager.SessionManager.active_sessions.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      [ATTRIBUTE] Found attribute access: self.active_sessions.get
        [CACHE] self.active_sessions.get -> session_manager.SessionManager.active_sessions.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ASSIGNMENT] Processing: user_id = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.user_id
    [RESOLVE] Attempting to resolve: ['session', 'user_id']
    [RESOLVE] Chain resolution needed for: ['session', 'user_id']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.user_id
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.user_id
        [ATTRIBUTE] Direct match found: session_manager.UserSession.user_id
      [CHAIN] Step 1 resolved: session_manager.UserSession.user_id
    [RESOLVE] RESOLVED to: session_manager.UserSession.user_id
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
    [RESOLVE] Attempting to resolve: ['self', 'user_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'user_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.user_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.user_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.user_sessions
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
        [CACHE] self.user_sessions -> session_manager.SessionManager.user_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_session_id
    [RESOLVE] Attempting to resolve: ['self', 'current_session_id']
    [RESOLVE] Chain resolution needed for: ['self', 'current_session_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.current_session_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.current_session_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.current_session_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.current_session_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.current_session_id
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_session_id
        [CACHE] self.current_session_id -> session_manager.SessionManager.current_session_id (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.state
    [RESOLVE] Attempting to resolve: ['session', 'state']
    [RESOLVE] Chain resolution needed for: ['session', 'state']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.state
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.state
        [ATTRIBUTE] Direct match found: session_manager.UserSession.state
      [CHAIN] Step 1 resolved: session_manager.UserSession.state
    [RESOLVE] RESOLVED to: session_manager.UserSession.state
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: SessionState.TERMINATED
    [RESOLVE] Attempting to resolve: ['SessionState', 'TERMINATED']
    [RESOLVE] Chain resolution needed for: ['SessionState', 'TERMINATED']
      [CHAIN] Resolving base: SessionState
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
      [CHAIN] Base resolved: SessionState -> session_manager.SessionState
      [CHAIN] Step 1: Resolving session_manager.SessionState.TERMINATED
        [ATTRIBUTE] Resolving attribute: session_manager.SessionState.TERMINATED
        [ATTRIBUTE] Direct match found: session_manager.SessionState.TERMINATED
      [CHAIN] Step 1 resolved: session_manager.SessionState.TERMINATED
    [RESOLVE] RESOLVED to: session_manager.SessionState.TERMINATED
      -> Not module state
      [NAME] Found name reference: SessionState
    [RESOLVE] Attempting to resolve: ['SessionState']
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
    [RESOLVE] RESOLVED to: session_manager.SessionState
      -> Not module state
      [CALL] Found call: self._trigger_event
    [RESOLVE] Attempting to resolve: ['self', '_trigger_event']
    [RESOLVE] Chain resolution needed for: ['self', '_trigger_event']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._trigger_event
      [CHAIN] Step 1 resolved: session_manager.SessionManager._trigger_event
    [RESOLVE] RESOLVED to: session_manager.SessionManager._trigger_event
            [INTERMEDIATE] Tracking chain steps for: self._trigger_event
            [INTERMEDIATE] Step 1: self._trigger_event
      -> Resolved to: session_manager.SessionManager._trigger_event
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      [ATTRIBUTE] Found attribute access: self._trigger_event
        [CACHE] self._trigger_event -> session_manager.SessionManager._trigger_event (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.destroy_session
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.destroy_session
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager._determine_user_role
    [CONTEXT] Entered function: session_manager.SessionManager._determine_user_role (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: user_id -> session_manager.str
        [ARG_TYPE] RESOLVED user_id : session_manager.str
      [CALL] Found call: self.haven_proxy.validate_admin_role
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy', 'validate_admin_role']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy', 'validate_admin_role']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 2: Resolving session_manager.SessionManager.haven_proxy.validate_admin_role
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy.validate_admin_role
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy.validate_admin_role
      [CHAIN] Step 2 resolved: session_manager.SessionManager.haven_proxy.validate_admin_role
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy.validate_admin_role
            [INTERMEDIATE] Tracking chain steps for: self.haven_proxy.validate_admin_role
            [INTERMEDIATE] Step 1: self.haven_proxy
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.haven_proxy
            [INTERMEDIATE] Step 2: self.haven_proxy.validate_admin_role
      -> Resolved to: session_manager.SessionManager.haven_proxy.validate_admin_role
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      [ATTRIBUTE] Found attribute access: self.haven_proxy.validate_admin_role
        [CACHE] self.haven_proxy.validate_admin_role -> session_manager.SessionManager.haven_proxy.validate_admin_role (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.haven_proxy
        [CACHE] self.haven_proxy -> session_manager.SessionManager.haven_proxy (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      -> Not module state
      [ATTRIBUTE] Found attribute access: UserRole.ADMIN
    [RESOLVE] Attempting to resolve: ['UserRole', 'ADMIN']
    [RESOLVE] Chain resolution needed for: ['UserRole', 'ADMIN']
      [CHAIN] Resolving base: UserRole
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
      [CHAIN] Base resolved: UserRole -> session_manager.UserRole
      [CHAIN] Step 1: Resolving session_manager.UserRole.ADMIN
        [ATTRIBUTE] Resolving attribute: session_manager.UserRole.ADMIN
        [ATTRIBUTE] Direct match found: session_manager.UserRole.ADMIN
      [CHAIN] Step 1 resolved: session_manager.UserRole.ADMIN
    [RESOLVE] RESOLVED to: session_manager.UserRole.ADMIN
      -> Not module state
      [NAME] Found name reference: UserRole
    [RESOLVE] Attempting to resolve: ['UserRole']
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
    [RESOLVE] RESOLVED to: session_manager.UserRole
      -> Not module state
      [CALL] Found call: self.haven_proxy.validate_moderator_role
    [RESOLVE] Attempting to resolve: ['self', 'haven_proxy', 'validate_moderator_role']
    [RESOLVE] Chain resolution needed for: ['self', 'haven_proxy', 'validate_moderator_role']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 1 resolved: session_manager.SessionManager.haven_proxy
      [CHAIN] Step 2: Resolving session_manager.SessionManager.haven_proxy.validate_moderator_role
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.haven_proxy.validate_moderator_role
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.haven_proxy.validate_moderator_role
      [CHAIN] Step 2 resolved: session_manager.SessionManager.haven_proxy.validate_moderator_role
    [RESOLVE] RESOLVED to: session_manager.SessionManager.haven_proxy.validate_moderator_role
            [INTERMEDIATE] Tracking chain steps for: self.haven_proxy.validate_moderator_role
            [INTERMEDIATE] Step 1: self.haven_proxy
    [CACHE] self.haven_proxy -> session_manager.SessionManager.haven_proxy (cached)
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.haven_proxy
            [INTERMEDIATE] Step 2: self.haven_proxy.validate_moderator_role
      -> Resolved to: session_manager.SessionManager.haven_proxy.validate_moderator_role
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
    [RESOLVE] RESOLVED to: session_manager.user_id
      [ATTRIBUTE] Found attribute access: self.haven_proxy.validate_moderator_role
        [CACHE] self.haven_proxy.validate_moderator_role -> session_manager.SessionManager.haven_proxy.validate_moderator_role (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.haven_proxy
        [CACHE] self.haven_proxy -> session_manager.SessionManager.haven_proxy (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: UserRole.MODERATOR
    [RESOLVE] Attempting to resolve: ['UserRole', 'MODERATOR']
    [RESOLVE] Chain resolution needed for: ['UserRole', 'MODERATOR']
      [CHAIN] Resolving base: UserRole
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
      [CHAIN] Base resolved: UserRole -> session_manager.UserRole
      [CHAIN] Step 1: Resolving session_manager.UserRole.MODERATOR
        [ATTRIBUTE] Resolving attribute: session_manager.UserRole.MODERATOR
        [ATTRIBUTE] Direct match found: session_manager.UserRole.MODERATOR
      [CHAIN] Step 1 resolved: session_manager.UserRole.MODERATOR
    [RESOLVE] RESOLVED to: session_manager.UserRole.MODERATOR
      -> Not module state
      [NAME] Found name reference: UserRole
        [CACHE] UserRole -> session_manager.UserRole (cached)
      -> Not module state
      [CALL] Found call: user_id.startswith
    [RESOLVE] Attempting to resolve: ['user_id', 'startswith']
    [RESOLVE] Chain resolution needed for: ['user_id', 'startswith']
      [CHAIN] Resolving base: user_id
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.user_id
      [CHAIN] Base resolved: user_id -> session_manager.user_id
      [CHAIN] Step 1: Resolving session_manager.user_id.startswith
        [ATTRIBUTE] Resolving attribute: session_manager.user_id.startswith
        [ATTRIBUTE] Direct match found: session_manager.user_id.startswith
      [CHAIN] Step 1 resolved: session_manager.user_id.startswith
    [RESOLVE] RESOLVED to: session_manager.user_id.startswith
            [INTERMEDIATE] Tracking chain steps for: user_id.startswith
            [INTERMEDIATE] Step 1: user_id.startswith
      -> Resolved to: session_manager.user_id.startswith
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: user_id.startswith
        [CACHE] user_id.startswith -> session_manager.user_id.startswith (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> session_manager.user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: UserRole.GUEST
    [RESOLVE] Attempting to resolve: ['UserRole', 'GUEST']
    [RESOLVE] Chain resolution needed for: ['UserRole', 'GUEST']
      [CHAIN] Resolving base: UserRole
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
      [CHAIN] Base resolved: UserRole -> session_manager.UserRole
      [CHAIN] Step 1: Resolving session_manager.UserRole.GUEST
        [ATTRIBUTE] Resolving attribute: session_manager.UserRole.GUEST
        [ATTRIBUTE] Direct match found: session_manager.UserRole.GUEST
      [CHAIN] Step 1 resolved: session_manager.UserRole.GUEST
    [RESOLVE] RESOLVED to: session_manager.UserRole.GUEST
      -> Not module state
      [NAME] Found name reference: UserRole
        [CACHE] UserRole -> session_manager.UserRole (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: UserRole.USER
    [RESOLVE] Attempting to resolve: ['UserRole', 'USER']
    [RESOLVE] Chain resolution needed for: ['UserRole', 'USER']
      [CHAIN] Resolving base: UserRole
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
      [CHAIN] Base resolved: UserRole -> session_manager.UserRole
      [CHAIN] Step 1: Resolving session_manager.UserRole.USER
        [ATTRIBUTE] Resolving attribute: session_manager.UserRole.USER
        [ATTRIBUTE] Direct match found: session_manager.UserRole.USER
      [CHAIN] Step 1 resolved: session_manager.UserRole.USER
    [RESOLVE] RESOLVED to: session_manager.UserRole.USER
      -> Not module state
      [NAME] Found name reference: UserRole
        [CACHE] UserRole -> session_manager.UserRole (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager._determine_user_role
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager._determine_user_role
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager._get_role_permissions
    [CONTEXT] Entered function: session_manager.SessionManager._get_role_permissions (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'role': 'UserRole'}
        [ARG_TYPE] Processing type annotation for role: UserRole
    [RESOLVE] Attempting to resolve: ['UserRole']
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
    [RESOLVE] RESOLVED to: session_manager.UserRole
      [SYMBOL_UPDATE] Function: role -> session_manager.UserRole
        [ARG_TYPE] RESOLVED role : session_manager.UserRole
      [ASSIGNMENT] Processing: base_permissions = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: base_permissions
    [RESOLVE] Attempting to resolve: ['base_permissions']
      [RESOLVE_SIMPLE] Resolving base: base_permissions
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable base_permissions not found in any scope
      [LOCAL_RESOLVER] can_resolve(base_permissions): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(base_permissions): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(base_permissions): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(base_permissions): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(base_permissions): session_manager.base_permissions
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: base_permissions -> session_manager.base_permissions
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.base_permissions
      -> Not module state
      [NAME] Found name reference: role
    [RESOLVE] Attempting to resolve: ['role']
      [RESOLVE_SIMPLE] Resolving base: role
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found role in function scope: session_manager.UserRole
      [LOCAL_RESOLVER] can_resolve(role): True
      [SYMBOL_LOOKUP] Found role in function scope: session_manager.UserRole
      [LOCAL_RESOLVER] resolve(role): session_manager.UserRole
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: role -> session_manager.UserRole
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.UserRole
      -> Not module state
      [ATTRIBUTE] Found attribute access: UserRole.GUEST
    [RESOLVE] Attempting to resolve: ['UserRole', 'GUEST']
    [RESOLVE] Chain resolution needed for: ['UserRole', 'GUEST']
      [CHAIN] Resolving base: UserRole
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
      [CHAIN] Base resolved: UserRole -> session_manager.UserRole
      [CHAIN] Step 1: Resolving session_manager.UserRole.GUEST
        [ATTRIBUTE] Resolving attribute: session_manager.UserRole.GUEST
        [ATTRIBUTE] Direct match found: session_manager.UserRole.GUEST
      [CHAIN] Step 1 resolved: session_manager.UserRole.GUEST
    [RESOLVE] RESOLVED to: session_manager.UserRole.GUEST
      -> Not module state
      [NAME] Found name reference: UserRole
        [CACHE] UserRole -> session_manager.UserRole (cached)
      -> Not module state
      [NAME] Found name reference: base_permissions
        [CACHE] base_permissions -> session_manager.base_permissions (cached)
      -> Not module state
      [NAME] Found name reference: role
        [CACHE] role -> session_manager.UserRole (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: UserRole.USER
    [RESOLVE] Attempting to resolve: ['UserRole', 'USER']
    [RESOLVE] Chain resolution needed for: ['UserRole', 'USER']
      [CHAIN] Resolving base: UserRole
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
      [CHAIN] Base resolved: UserRole -> session_manager.UserRole
      [CHAIN] Step 1: Resolving session_manager.UserRole.USER
        [ATTRIBUTE] Resolving attribute: session_manager.UserRole.USER
        [ATTRIBUTE] Direct match found: session_manager.UserRole.USER
      [CHAIN] Step 1 resolved: session_manager.UserRole.USER
    [RESOLVE] RESOLVED to: session_manager.UserRole.USER
      -> Not module state
      [NAME] Found name reference: UserRole
        [CACHE] UserRole -> session_manager.UserRole (cached)
      -> Not module state
      [NAME] Found name reference: base_permissions
        [CACHE] base_permissions -> session_manager.base_permissions (cached)
      -> Not module state
      [NAME] Found name reference: role
        [CACHE] role -> session_manager.UserRole (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: UserRole.MODERATOR
    [RESOLVE] Attempting to resolve: ['UserRole', 'MODERATOR']
    [RESOLVE] Chain resolution needed for: ['UserRole', 'MODERATOR']
      [CHAIN] Resolving base: UserRole
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
      [CHAIN] Base resolved: UserRole -> session_manager.UserRole
      [CHAIN] Step 1: Resolving session_manager.UserRole.MODERATOR
        [ATTRIBUTE] Resolving attribute: session_manager.UserRole.MODERATOR
        [ATTRIBUTE] Direct match found: session_manager.UserRole.MODERATOR
      [CHAIN] Step 1 resolved: session_manager.UserRole.MODERATOR
    [RESOLVE] RESOLVED to: session_manager.UserRole.MODERATOR
      -> Not module state
      [NAME] Found name reference: UserRole
        [CACHE] UserRole -> session_manager.UserRole (cached)
      -> Not module state
      [NAME] Found name reference: base_permissions
        [CACHE] base_permissions -> session_manager.base_permissions (cached)
      -> Not module state
      [NAME] Found name reference: role
        [CACHE] role -> session_manager.UserRole (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: UserRole.ADMIN
    [RESOLVE] Attempting to resolve: ['UserRole', 'ADMIN']
    [RESOLVE] Chain resolution needed for: ['UserRole', 'ADMIN']
      [CHAIN] Resolving base: UserRole
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
      [CHAIN] Base resolved: UserRole -> session_manager.UserRole
      [CHAIN] Step 1: Resolving session_manager.UserRole.ADMIN
        [ATTRIBUTE] Resolving attribute: session_manager.UserRole.ADMIN
        [ATTRIBUTE] Direct match found: session_manager.UserRole.ADMIN
      [CHAIN] Step 1 resolved: session_manager.UserRole.ADMIN
    [RESOLVE] RESOLVED to: session_manager.UserRole.ADMIN
      -> Not module state
      [NAME] Found name reference: UserRole
        [CACHE] UserRole -> session_manager.UserRole (cached)
      -> Not module state
      [NAME] Found name reference: base_permissions
        [CACHE] base_permissions -> session_manager.base_permissions (cached)
      -> Not module state
      [NAME] Found name reference: role
        [CACHE] role -> session_manager.UserRole (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: UserRole.SYSTEM
    [RESOLVE] Attempting to resolve: ['UserRole', 'SYSTEM']
    [RESOLVE] Chain resolution needed for: ['UserRole', 'SYSTEM']
      [CHAIN] Resolving base: UserRole
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
      [CHAIN] Base resolved: UserRole -> session_manager.UserRole
      [CHAIN] Step 1: Resolving session_manager.UserRole.SYSTEM
        [ATTRIBUTE] Resolving attribute: session_manager.UserRole.SYSTEM
        [ATTRIBUTE] Direct match found: session_manager.UserRole.SYSTEM
      [CHAIN] Step 1 resolved: session_manager.UserRole.SYSTEM
    [RESOLVE] RESOLVED to: session_manager.UserRole.SYSTEM
      -> Not module state
      [NAME] Found name reference: UserRole
        [CACHE] UserRole -> session_manager.UserRole (cached)
      -> Not module state
      [NAME] Found name reference: base_permissions
        [CACHE] base_permissions -> session_manager.base_permissions (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager._get_role_permissions
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager._get_role_permissions
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager._expire_session
    [CONTEXT] Entered function: session_manager.SessionManager._expire_session (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'session_id': 'str'}
        [ARG_TYPE] Processing type annotation for session_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: session_id -> session_manager.str
        [ARG_TYPE] RESOLVED session_id : session_manager.str
      [ATTRIBUTE] Found attribute access: self.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_lock
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.get
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.active_sessions.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for session
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.get
            [INTERMEDIATE] Tracking chain steps for: self.active_sessions.get
            [INTERMEDIATE] Step 1: self.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 2: self.active_sessions.get
      -> Resolved to: session_manager.SessionManager.active_sessions.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      [ATTRIBUTE] Found attribute access: self.active_sessions.get
        [CACHE] self.active_sessions.get -> session_manager.SessionManager.active_sessions.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.state
    [RESOLVE] Attempting to resolve: ['session', 'state']
    [RESOLVE] Chain resolution needed for: ['session', 'state']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.state
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.state
        [ATTRIBUTE] Direct match found: session_manager.UserSession.state
      [CHAIN] Step 1 resolved: session_manager.UserSession.state
    [RESOLVE] RESOLVED to: session_manager.UserSession.state
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: SessionState.EXPIRED
    [RESOLVE] Attempting to resolve: ['SessionState', 'EXPIRED']
    [RESOLVE] Chain resolution needed for: ['SessionState', 'EXPIRED']
      [CHAIN] Resolving base: SessionState
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
      [CHAIN] Base resolved: SessionState -> session_manager.SessionState
      [CHAIN] Step 1: Resolving session_manager.SessionState.EXPIRED
        [ATTRIBUTE] Resolving attribute: session_manager.SessionState.EXPIRED
        [ATTRIBUTE] Direct match found: session_manager.SessionState.EXPIRED
      [CHAIN] Step 1 resolved: session_manager.SessionState.EXPIRED
    [RESOLVE] RESOLVED to: session_manager.SessionState.EXPIRED
      -> Not module state
      [NAME] Found name reference: SessionState
    [RESOLVE] Attempting to resolve: ['SessionState']
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
    [RESOLVE] RESOLVED to: session_manager.SessionState
      -> Not module state
      [CALL] Found call: self._trigger_event
    [RESOLVE] Attempting to resolve: ['self', '_trigger_event']
    [RESOLVE] Chain resolution needed for: ['self', '_trigger_event']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._trigger_event
      [CHAIN] Step 1 resolved: session_manager.SessionManager._trigger_event
    [RESOLVE] RESOLVED to: session_manager.SessionManager._trigger_event
            [INTERMEDIATE] Tracking chain steps for: self._trigger_event
            [INTERMEDIATE] Step 1: self._trigger_event
      -> Resolved to: session_manager.SessionManager._trigger_event
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      [ATTRIBUTE] Found attribute access: self._trigger_event
        [CACHE] self._trigger_event -> session_manager.SessionManager._trigger_event (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager._expire_session
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager._expire_session
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager._terminate_session
    [CONTEXT] Entered function: session_manager.SessionManager._terminate_session (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'session_id': 'str', 'reason': 'str'}
        [ARG_TYPE] Processing type annotation for session_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: session_id -> session_manager.str
        [ARG_TYPE] RESOLVED session_id : session_manager.str
        [ARG_TYPE] Processing type annotation for reason: str
        [CACHE] str -> session_manager.str (cached)
      [SYMBOL_UPDATE] Function: reason -> session_manager.str
        [ARG_TYPE] RESOLVED reason : session_manager.str
      [ATTRIBUTE] Found attribute access: self.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_lock
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.get
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.active_sessions.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for session
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.get
            [INTERMEDIATE] Tracking chain steps for: self.active_sessions.get
            [INTERMEDIATE] Step 1: self.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 2: self.active_sessions.get
      -> Resolved to: session_manager.SessionManager.active_sessions.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      [ATTRIBUTE] Found attribute access: self.active_sessions.get
        [CACHE] self.active_sessions.get -> session_manager.SessionManager.active_sessions.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.state
    [RESOLVE] Attempting to resolve: ['session', 'state']
    [RESOLVE] Chain resolution needed for: ['session', 'state']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.state
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.state
        [ATTRIBUTE] Direct match found: session_manager.UserSession.state
      [CHAIN] Step 1 resolved: session_manager.UserSession.state
    [RESOLVE] RESOLVED to: session_manager.UserSession.state
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: SessionState.TERMINATED
    [RESOLVE] Attempting to resolve: ['SessionState', 'TERMINATED']
    [RESOLVE] Chain resolution needed for: ['SessionState', 'TERMINATED']
      [CHAIN] Resolving base: SessionState
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
      [CHAIN] Base resolved: SessionState -> session_manager.SessionState
      [CHAIN] Step 1: Resolving session_manager.SessionState.TERMINATED
        [ATTRIBUTE] Resolving attribute: session_manager.SessionState.TERMINATED
        [ATTRIBUTE] Direct match found: session_manager.SessionState.TERMINATED
      [CHAIN] Step 1 resolved: session_manager.SessionState.TERMINATED
    [RESOLVE] RESOLVED to: session_manager.SessionState.TERMINATED
      -> Not module state
      [NAME] Found name reference: SessionState
    [RESOLVE] Attempting to resolve: ['SessionState']
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
    [RESOLVE] RESOLVED to: session_manager.SessionState
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.context_data
    [RESOLVE] Attempting to resolve: ['session', 'context_data']
    [RESOLVE] Chain resolution needed for: ['session', 'context_data']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.context_data
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.context_data
        [ATTRIBUTE] Direct match found: session_manager.UserSession.context_data
      [CHAIN] Step 1 resolved: session_manager.UserSession.context_data
    [RESOLVE] RESOLVED to: session_manager.UserSession.context_data
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: reason
    [RESOLVE] Attempting to resolve: ['reason']
      [RESOLVE_SIMPLE] Resolving base: reason
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found reason in function scope: session_manager.str
      [LOCAL_RESOLVER] can_resolve(reason): True
      [SYMBOL_LOOKUP] Found reason in function scope: session_manager.str
      [LOCAL_RESOLVER] resolve(reason): session_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: reason -> session_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [CALL] Found call: self._trigger_event
    [RESOLVE] Attempting to resolve: ['self', '_trigger_event']
    [RESOLVE] Chain resolution needed for: ['self', '_trigger_event']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._trigger_event
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._trigger_event
      [CHAIN] Step 1 resolved: session_manager.SessionManager._trigger_event
    [RESOLVE] RESOLVED to: session_manager.SessionManager._trigger_event
            [INTERMEDIATE] Tracking chain steps for: self._trigger_event
            [INTERMEDIATE] Step 1: self._trigger_event
      -> Resolved to: session_manager.SessionManager._trigger_event
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      [ATTRIBUTE] Found attribute access: self._trigger_event
        [CACHE] self._trigger_event -> session_manager.SessionManager._trigger_event (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: self.destroy_session
    [RESOLVE] Attempting to resolve: ['self', 'destroy_session']
    [RESOLVE] Chain resolution needed for: ['self', 'destroy_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.destroy_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.destroy_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.destroy_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.destroy_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.destroy_session
            [INTERMEDIATE] Tracking chain steps for: self.destroy_session
            [INTERMEDIATE] Step 1: self.destroy_session
      -> Resolved to: session_manager.SessionManager.destroy_session
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      [ATTRIBUTE] Found attribute access: self.destroy_session
        [CACHE] self.destroy_session -> session_manager.SessionManager.destroy_session (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager._terminate_session
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager._terminate_session
        Calls: 2
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager._trigger_event
    [CONTEXT] Entered function: session_manager.SessionManager._trigger_event (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'event_name': 'str', 'session': 'UserSession'}
        [ARG_TYPE] Processing type annotation for event_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: event_name -> session_manager.str
        [ARG_TYPE] RESOLVED event_name : session_manager.str
        [ARG_TYPE] Processing type annotation for session: UserSession
    [RESOLVE] Attempting to resolve: ['UserSession']
      [RESOLVE_SIMPLE] Resolving base: UserSession
      [CACHE] Hit for UserSession: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      [SYMBOL_UPDATE] Function: session -> session_manager.UserSession
        [ARG_TYPE] RESOLVED session : session_manager.UserSession
      [NAME] Found name reference: handler
    [RESOLVE] Attempting to resolve: ['handler']
      [RESOLVE_SIMPLE] Resolving base: handler
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable handler not found in any scope
      [LOCAL_RESOLVER] can_resolve(handler): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(handler): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(handler): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(handler): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(handler): session_manager.handler
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: handler -> session_manager.handler
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.handler
      -> Not module state
      [CALL] Found call: self.event_handlers.get
    [RESOLVE] Attempting to resolve: ['self', 'event_handlers', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'event_handlers', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.event_handlers
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.event_handlers
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.event_handlers
      [CHAIN] Step 1 resolved: session_manager.SessionManager.event_handlers
      [CHAIN] Step 2: Resolving session_manager.SessionManager.event_handlers.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.event_handlers.get
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.event_handlers.get
      [CHAIN] Step 2 resolved: session_manager.SessionManager.event_handlers.get
    [RESOLVE] RESOLVED to: session_manager.SessionManager.event_handlers.get
            [INTERMEDIATE] Tracking chain steps for: self.event_handlers.get
            [INTERMEDIATE] Step 1: self.event_handlers
    [RESOLVE] Attempting to resolve: ['self', 'event_handlers']
    [RESOLVE] Chain resolution needed for: ['self', 'event_handlers']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.event_handlers
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.event_handlers
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.event_handlers
      [CHAIN] Step 1 resolved: session_manager.SessionManager.event_handlers
    [RESOLVE] RESOLVED to: session_manager.SessionManager.event_handlers
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.event_handlers
            [INTERMEDIATE] Step 2: self.event_handlers.get
      -> Resolved to: session_manager.SessionManager.event_handlers.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: event_name
    [RESOLVE] Attempting to resolve: ['event_name']
      [RESOLVE_SIMPLE] Resolving base: event_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found event_name in function scope: session_manager.str
      [LOCAL_RESOLVER] can_resolve(event_name): True
      [SYMBOL_LOOKUP] Found event_name in function scope: session_manager.str
      [LOCAL_RESOLVER] resolve(event_name): session_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: event_name -> session_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.str
      [ATTRIBUTE] Found attribute access: self.event_handlers.get
        [CACHE] self.event_handlers.get -> session_manager.SessionManager.event_handlers.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.event_handlers
        [CACHE] self.event_handlers -> session_manager.SessionManager.event_handlers (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [NAME] Found name reference: event_name
    [RESOLVE] Attempting to resolve: ['event_name']
      [RESOLVE_SIMPLE] Resolving base: event_name
      [CACHE] Hit for event_name: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [CALL] Found call: handler
    [CACHE] handler -> session_manager.handler (cached)
      -> Resolved to: session_manager.handler
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      [NAME] Found name reference: handler
        [CACHE] handler -> session_manager.handler (cached)
      -> Not module state
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [NAME] Found name reference: Exception
    [RESOLVE] Attempting to resolve: ['Exception']
      [RESOLVE_SIMPLE] Resolving base: Exception
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Exception not found in any scope
      [LOCAL_RESOLVER] can_resolve(Exception): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Exception): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Exception): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(Exception): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(Exception): session_manager.Exception
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: Exception -> session_manager.Exception
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.Exception
      -> Not module state
      [CALL] Found call: print
      -> IGNORED (built-in function)
      [NAME] Found name reference: print
    [RESOLVE] Attempting to resolve: ['print']
      [RESOLVE_SIMPLE] Resolving base: print
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable print not found in any scope
      [LOCAL_RESOLVER] can_resolve(print): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(print): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(print): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(print): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(print): session_manager.print
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: print -> session_manager.print
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.print
      -> Not module state
      [NAME] Found name reference: event_name
        [CACHE] event_name -> session_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: e
    [RESOLVE] Attempting to resolve: ['e']
      [RESOLVE_SIMPLE] Resolving base: e
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable e not found in any scope
      [LOCAL_RESOLVER] can_resolve(e): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(e): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(e): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(e): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(e): session_manager.e
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: e -> session_manager.e
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.e
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager._trigger_event
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager._trigger_event
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.get_session_statistics
    [DECORATOR] @trace
    [DECORATOR] @rate_limit(calls=100, period=60)
    [CONTEXT] Entered function: session_manager.SessionManager.get_session_statistics (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ATTRIBUTE] Found attribute access: self.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_lock
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ASSIGNMENT] Processing: total_sessions = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [CACHE] Hit for len: session_manager.len
    [RESOLVE] RESOLVED to: session_manager.len
      [TYPE_INFERENCE] Call resolved to: session_manager.len
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for total_sessions
      [NAME] Found name reference: total_sessions
    [RESOLVE] Attempting to resolve: ['total_sessions']
      [RESOLVE_SIMPLE] Resolving base: total_sessions
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable total_sessions not found in any scope
      [LOCAL_RESOLVER] can_resolve(total_sessions): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(total_sessions): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(total_sessions): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(total_sessions): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(total_sessions): session_manager.total_sessions
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: total_sessions -> session_manager.total_sessions
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.total_sessions
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [CACHE] Hit for len: session_manager.len
    [RESOLVE] RESOLVED to: session_manager.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ASSIGNMENT] Processing: active_sessions = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: sum
    [RESOLVE] Attempting to resolve: ['sum']
      [RESOLVE_SIMPLE] Resolving base: sum
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable sum not found in any scope
      [LOCAL_RESOLVER] can_resolve(sum): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(sum): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(sum): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(sum): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(sum): session_manager.sum
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: sum -> session_manager.sum
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.sum
      [TYPE_INFERENCE] Call resolved to: session_manager.sum
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for active_sessions
      [NAME] Found name reference: active_sessions
    [RESOLVE] Attempting to resolve: ['active_sessions']
      [RESOLVE_SIMPLE] Resolving base: active_sessions
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable active_sessions not found in any scope
      [LOCAL_RESOLVER] can_resolve(active_sessions): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(active_sessions): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(active_sessions): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(active_sessions): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(active_sessions): session_manager.active_sessions
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: active_sessions -> session_manager.active_sessions
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.active_sessions
      -> Not module state
      [CALL] Found call: sum
      -> IGNORED (built-in function)
      [NAME] Found name reference: sum
    [RESOLVE] Attempting to resolve: ['sum']
      [RESOLVE_SIMPLE] Resolving base: sum
      [CACHE] Hit for sum: session_manager.sum
    [RESOLVE] RESOLVED to: session_manager.sum
      -> Not module state
      [NAME] Found name reference: s
    [RESOLVE] Attempting to resolve: ['s']
      [RESOLVE_SIMPLE] Resolving base: s
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable s not found in any scope
      [LOCAL_RESOLVER] can_resolve(s): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(s): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(s): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(s): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(s): session_manager.s
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: s -> session_manager.s
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.s
      -> Not module state
      [CALL] Found call: self.active_sessions.values
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'values']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'values']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.values
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.values
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.values
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.values
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.values
            [INTERMEDIATE] Tracking chain steps for: self.active_sessions.values
            [INTERMEDIATE] Step 1: self.active_sessions
    [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 2: self.active_sessions.values
      -> Resolved to: session_manager.SessionManager.active_sessions.values
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.active_sessions.values
        [CACHE] self.active_sessions.values -> session_manager.SessionManager.active_sessions.values (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: s.state
    [RESOLVE] Attempting to resolve: ['s', 'state']
    [RESOLVE] Chain resolution needed for: ['s', 'state']
      [CHAIN] Resolving base: s
      [RESOLVE_SIMPLE] Resolving base: s
      [CACHE] Hit for s: session_manager.s
      [CHAIN] Base resolved: s -> session_manager.s
      [CHAIN] Step 1: Resolving session_manager.s.state
        [ATTRIBUTE] Resolving attribute: session_manager.s.state
        [ATTRIBUTE] Direct match found: session_manager.s.state
      [CHAIN] Step 1 resolved: session_manager.s.state
    [RESOLVE] RESOLVED to: session_manager.s.state
      -> Not module state
      [NAME] Found name reference: s
        [CACHE] s -> session_manager.s (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: SessionState.ACTIVE
    [RESOLVE] Attempting to resolve: ['SessionState', 'ACTIVE']
    [RESOLVE] Chain resolution needed for: ['SessionState', 'ACTIVE']
      [CHAIN] Resolving base: SessionState
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
      [CHAIN] Base resolved: SessionState -> session_manager.SessionState
      [CHAIN] Step 1: Resolving session_manager.SessionState.ACTIVE
        [ATTRIBUTE] Resolving attribute: session_manager.SessionState.ACTIVE
        [ATTRIBUTE] Direct match found: session_manager.SessionState.ACTIVE
      [CHAIN] Step 1 resolved: session_manager.SessionState.ACTIVE
    [RESOLVE] RESOLVED to: session_manager.SessionState.ACTIVE
      -> Not module state
      [NAME] Found name reference: SessionState
    [RESOLVE] Attempting to resolve: ['SessionState']
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
    [RESOLVE] RESOLVED to: session_manager.SessionState
      -> Not module state
      [ASSIGNMENT] Processing: idle_sessions = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: sum
    [RESOLVE] Attempting to resolve: ['sum']
      [RESOLVE_SIMPLE] Resolving base: sum
      [CACHE] Hit for sum: session_manager.sum
    [RESOLVE] RESOLVED to: session_manager.sum
      [TYPE_INFERENCE] Call resolved to: session_manager.sum
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for idle_sessions
      [NAME] Found name reference: idle_sessions
    [RESOLVE] Attempting to resolve: ['idle_sessions']
      [RESOLVE_SIMPLE] Resolving base: idle_sessions
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable idle_sessions not found in any scope
      [LOCAL_RESOLVER] can_resolve(idle_sessions): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(idle_sessions): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(idle_sessions): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(idle_sessions): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(idle_sessions): session_manager.idle_sessions
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: idle_sessions -> session_manager.idle_sessions
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.idle_sessions
      -> Not module state
      [CALL] Found call: sum
      -> IGNORED (built-in function)
      [NAME] Found name reference: sum
        [CACHE] sum -> session_manager.sum (cached)
      -> Not module state
      [NAME] Found name reference: s
        [CACHE] s -> session_manager.s (cached)
      -> Not module state
      [CALL] Found call: self.active_sessions.values
    [CACHE] self.active_sessions.values -> session_manager.SessionManager.active_sessions.values (cached)
            [INTERMEDIATE] Tracking chain steps for: self.active_sessions.values
            [INTERMEDIATE] Step 1: self.active_sessions
    [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 2: self.active_sessions.values
      -> Resolved to: session_manager.SessionManager.active_sessions.values
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.active_sessions.values
        [CACHE] self.active_sessions.values -> session_manager.SessionManager.active_sessions.values (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: s.state
        [CACHE] s.state -> session_manager.s.state (cached)
      -> Not module state
      [NAME] Found name reference: s
        [CACHE] s -> session_manager.s (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: SessionState.IDLE
    [RESOLVE] Attempting to resolve: ['SessionState', 'IDLE']
    [RESOLVE] Chain resolution needed for: ['SessionState', 'IDLE']
      [CHAIN] Resolving base: SessionState
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
      [CHAIN] Base resolved: SessionState -> session_manager.SessionState
      [CHAIN] Step 1: Resolving session_manager.SessionState.IDLE
        [ATTRIBUTE] Resolving attribute: session_manager.SessionState.IDLE
        [ATTRIBUTE] Direct match found: session_manager.SessionState.IDLE
      [CHAIN] Step 1 resolved: session_manager.SessionState.IDLE
    [RESOLVE] RESOLVED to: session_manager.SessionState.IDLE
      -> Not module state
      [NAME] Found name reference: SessionState
        [CACHE] SessionState -> session_manager.SessionState (cached)
      -> Not module state
      [ASSIGNMENT] Processing: role_distribution = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: role_distribution
    [RESOLVE] Attempting to resolve: ['role_distribution']
      [RESOLVE_SIMPLE] Resolving base: role_distribution
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable role_distribution not found in any scope
      [LOCAL_RESOLVER] can_resolve(role_distribution): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(role_distribution): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(role_distribution): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(role_distribution): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(role_distribution): session_manager.role_distribution
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: role_distribution -> session_manager.role_distribution
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.role_distribution
      -> Not module state
      [NAME] Found name reference: role
    [RESOLVE] Attempting to resolve: ['role']
      [RESOLVE_SIMPLE] Resolving base: role
      [CACHE] Hit for role: session_manager.UserRole
    [RESOLVE] RESOLVED to: session_manager.UserRole
      -> Not module state
      [NAME] Found name reference: UserRole
    [RESOLVE] Attempting to resolve: ['UserRole']
      [RESOLVE_SIMPLE] Resolving base: UserRole
      [CACHE] Hit for UserRole: session_manager.UserRole
    [RESOLVE] RESOLVED to: session_manager.UserRole
      -> Not module state
      [NAME] Found name reference: role_distribution
        [CACHE] role_distribution -> session_manager.role_distribution (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: role.name
    [RESOLVE] Attempting to resolve: ['role', 'name']
    [RESOLVE] Chain resolution needed for: ['role', 'name']
      [CHAIN] Resolving base: role
      [RESOLVE_SIMPLE] Resolving base: role
      [CACHE] Hit for role: session_manager.UserRole
      [CHAIN] Base resolved: role -> session_manager.UserRole
      [CHAIN] Step 1: Resolving session_manager.UserRole.name
        [ATTRIBUTE] Resolving attribute: session_manager.UserRole.name
        [ATTRIBUTE] Direct match found: session_manager.UserRole.name
      [CHAIN] Step 1 resolved: session_manager.UserRole.name
    [RESOLVE] RESOLVED to: session_manager.UserRole.name
      -> Not module state
      [NAME] Found name reference: role
        [CACHE] role -> session_manager.UserRole (cached)
      -> Not module state
      [CALL] Found call: sum
      -> IGNORED (built-in function)
      [NAME] Found name reference: sum
        [CACHE] sum -> session_manager.sum (cached)
      -> Not module state
      [NAME] Found name reference: s
        [CACHE] s -> session_manager.s (cached)
      -> Not module state
      [CALL] Found call: self.active_sessions.values
    [CACHE] self.active_sessions.values -> session_manager.SessionManager.active_sessions.values (cached)
            [INTERMEDIATE] Tracking chain steps for: self.active_sessions.values
            [INTERMEDIATE] Step 1: self.active_sessions
    [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 2: self.active_sessions.values
      -> Resolved to: session_manager.SessionManager.active_sessions.values
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.active_sessions.values
        [CACHE] self.active_sessions.values -> session_manager.SessionManager.active_sessions.values (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: s.user_role
    [RESOLVE] Attempting to resolve: ['s', 'user_role']
    [RESOLVE] Chain resolution needed for: ['s', 'user_role']
      [CHAIN] Resolving base: s
      [RESOLVE_SIMPLE] Resolving base: s
      [CACHE] Hit for s: session_manager.s
      [CHAIN] Base resolved: s -> session_manager.s
      [CHAIN] Step 1: Resolving session_manager.s.user_role
        [ATTRIBUTE] Resolving attribute: session_manager.s.user_role
        [ATTRIBUTE] Direct match found: session_manager.s.user_role
      [CHAIN] Step 1 resolved: session_manager.s.user_role
    [RESOLVE] RESOLVED to: session_manager.s.user_role
      -> Not module state
      [NAME] Found name reference: s
        [CACHE] s -> session_manager.s (cached)
      -> Not module state
      [NAME] Found name reference: role
        [CACHE] role -> session_manager.UserRole (cached)
      -> Not module state
      [ASSIGNMENT] Processing: total_activity = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: sum
    [RESOLVE] Attempting to resolve: ['sum']
      [RESOLVE_SIMPLE] Resolving base: sum
      [CACHE] Hit for sum: session_manager.sum
    [RESOLVE] RESOLVED to: session_manager.sum
      [TYPE_INFERENCE] Call resolved to: session_manager.sum
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for total_activity
      [NAME] Found name reference: total_activity
    [RESOLVE] Attempting to resolve: ['total_activity']
      [RESOLVE_SIMPLE] Resolving base: total_activity
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable total_activity not found in any scope
      [LOCAL_RESOLVER] can_resolve(total_activity): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(total_activity): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(total_activity): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(total_activity): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(total_activity): session_manager.total_activity
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: total_activity -> session_manager.total_activity
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.total_activity
      -> Not module state
      [CALL] Found call: sum
      -> IGNORED (built-in function)
      [NAME] Found name reference: sum
        [CACHE] sum -> session_manager.sum (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: s.metrics.activity_count
    [RESOLVE] Attempting to resolve: ['s', 'metrics', 'activity_count']
    [RESOLVE] Chain resolution needed for: ['s', 'metrics', 'activity_count']
      [CHAIN] Resolving base: s
      [RESOLVE_SIMPLE] Resolving base: s
      [CACHE] Hit for s: session_manager.s
      [CHAIN] Base resolved: s -> session_manager.s
      [CHAIN] Step 1: Resolving session_manager.s.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.s.metrics
        [ATTRIBUTE] Direct match found: session_manager.s.metrics
      [CHAIN] Step 1 resolved: session_manager.s.metrics
      [CHAIN] Step 2: Resolving session_manager.s.metrics.activity_count
        [ATTRIBUTE] Resolving attribute: session_manager.s.metrics.activity_count
        [ATTRIBUTE] Direct match found: session_manager.s.metrics.activity_count
      [CHAIN] Step 2 resolved: session_manager.s.metrics.activity_count
    [RESOLVE] RESOLVED to: session_manager.s.metrics.activity_count
      -> Not module state
      [ATTRIBUTE] Found attribute access: s.metrics
    [RESOLVE] Attempting to resolve: ['s', 'metrics']
    [RESOLVE] Chain resolution needed for: ['s', 'metrics']
      [CHAIN] Resolving base: s
      [RESOLVE_SIMPLE] Resolving base: s
      [CACHE] Hit for s: session_manager.s
      [CHAIN] Base resolved: s -> session_manager.s
      [CHAIN] Step 1: Resolving session_manager.s.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.s.metrics
        [ATTRIBUTE] Direct match found: session_manager.s.metrics
      [CHAIN] Step 1 resolved: session_manager.s.metrics
    [RESOLVE] RESOLVED to: session_manager.s.metrics
      -> Not module state
      [NAME] Found name reference: s
        [CACHE] s -> session_manager.s (cached)
      -> Not module state
      [NAME] Found name reference: s
        [CACHE] s -> session_manager.s (cached)
      -> Not module state
      [CALL] Found call: self.active_sessions.values
    [CACHE] self.active_sessions.values -> session_manager.SessionManager.active_sessions.values (cached)
            [INTERMEDIATE] Tracking chain steps for: self.active_sessions.values
            [INTERMEDIATE] Step 1: self.active_sessions
    [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 2: self.active_sessions.values
      -> Resolved to: session_manager.SessionManager.active_sessions.values
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.active_sessions.values
        [CACHE] self.active_sessions.values -> session_manager.SessionManager.active_sessions.values (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ASSIGNMENT] Processing: total_data_transferred = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: sum
    [RESOLVE] Attempting to resolve: ['sum']
      [RESOLVE_SIMPLE] Resolving base: sum
      [CACHE] Hit for sum: session_manager.sum
    [RESOLVE] RESOLVED to: session_manager.sum
      [TYPE_INFERENCE] Call resolved to: session_manager.sum
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for total_data_transferred
      [NAME] Found name reference: total_data_transferred
    [RESOLVE] Attempting to resolve: ['total_data_transferred']
      [RESOLVE_SIMPLE] Resolving base: total_data_transferred
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable total_data_transferred not found in any scope
      [LOCAL_RESOLVER] can_resolve(total_data_transferred): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(total_data_transferred): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(total_data_transferred): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(total_data_transferred): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(total_data_transferred): session_manager.total_data_transferred
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: total_data_transferred -> session_manager.total_data_transferred
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.total_data_transferred
      -> Not module state
      [CALL] Found call: sum
      -> IGNORED (built-in function)
      [NAME] Found name reference: sum
        [CACHE] sum -> session_manager.sum (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: s.metrics.data_transferred
    [RESOLVE] Attempting to resolve: ['s', 'metrics', 'data_transferred']
    [RESOLVE] Chain resolution needed for: ['s', 'metrics', 'data_transferred']
      [CHAIN] Resolving base: s
      [RESOLVE_SIMPLE] Resolving base: s
      [CACHE] Hit for s: session_manager.s
      [CHAIN] Base resolved: s -> session_manager.s
      [CHAIN] Step 1: Resolving session_manager.s.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.s.metrics
        [ATTRIBUTE] Direct match found: session_manager.s.metrics
      [CHAIN] Step 1 resolved: session_manager.s.metrics
      [CHAIN] Step 2: Resolving session_manager.s.metrics.data_transferred
        [ATTRIBUTE] Resolving attribute: session_manager.s.metrics.data_transferred
        [ATTRIBUTE] Direct match found: session_manager.s.metrics.data_transferred
      [CHAIN] Step 2 resolved: session_manager.s.metrics.data_transferred
    [RESOLVE] RESOLVED to: session_manager.s.metrics.data_transferred
      -> Not module state
      [ATTRIBUTE] Found attribute access: s.metrics
        [CACHE] s.metrics -> session_manager.s.metrics (cached)
      -> Not module state
      [NAME] Found name reference: s
        [CACHE] s -> session_manager.s (cached)
      -> Not module state
      [NAME] Found name reference: s
        [CACHE] s -> session_manager.s (cached)
      -> Not module state
      [CALL] Found call: self.active_sessions.values
    [CACHE] self.active_sessions.values -> session_manager.SessionManager.active_sessions.values (cached)
            [INTERMEDIATE] Tracking chain steps for: self.active_sessions.values
            [INTERMEDIATE] Step 1: self.active_sessions
    [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 2: self.active_sessions.values
      -> Resolved to: session_manager.SessionManager.active_sessions.values
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.active_sessions.values
        [CACHE] self.active_sessions.values -> session_manager.SessionManager.active_sessions.values (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: total_sessions
        [CACHE] total_sessions -> session_manager.total_sessions (cached)
      -> Not module state
      [NAME] Found name reference: active_sessions
        [CACHE] active_sessions -> session_manager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: idle_sessions
        [CACHE] idle_sessions -> session_manager.idle_sessions (cached)
      -> Not module state
      [NAME] Found name reference: role_distribution
        [CACHE] role_distribution -> session_manager.role_distribution (cached)
      -> Not module state
      [NAME] Found name reference: total_activity
        [CACHE] total_activity -> session_manager.total_activity (cached)
      -> Not module state
      [NAME] Found name reference: total_data_transferred
        [CACHE] total_data_transferred -> session_manager.total_data_transferred (cached)
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
        [CACHE] len -> session_manager.len (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_sessions
    [RESOLVE] Attempting to resolve: ['self', 'user_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'user_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.user_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.user_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.user_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.user_sessions
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.get_session_statistics
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.get_session_statistics
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.session_context
    [DECORATOR] @contextmanager
      [CODE_STANDARD_VIOLATION] MISSING_RETURN_TYPE: Function session_manager.SessionManager.session_context
      [IMPACT] Cannot infer return type - chained method calls may fail
      [ACTION_REQUIRED] Add appropriate type annotation
      [CODE_QUALITY] Found 1 violations in session_manager.SessionManager.session_context
    [CONTEXT] Entered function: session_manager.SessionManager.session_context (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'session_id': 'str'}
        [ARG_TYPE] Processing type annotation for session_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: session_id -> session_manager.str
        [ARG_TYPE] RESOLVED session_id : session_manager.str
      [ASSIGNMENT] Processing: original_session_id = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: original_session_id
    [RESOLVE] Attempting to resolve: ['original_session_id']
      [RESOLVE_SIMPLE] Resolving base: original_session_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable original_session_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(original_session_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(original_session_id): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(original_session_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(original_session_id): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(original_session_id): session_manager.original_session_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: original_session_id -> session_manager.original_session_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.original_session_id
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_session_id
    [RESOLVE] Attempting to resolve: ['self', 'current_session_id']
    [RESOLVE] Chain resolution needed for: ['self', 'current_session_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.current_session_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.current_session_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.current_session_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.current_session_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.current_session_id
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_session_id
        [CACHE] self.current_session_id -> session_manager.SessionManager.current_session_id (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      -> Not module state
      [CALL] Found call: self.get_current_session
    [RESOLVE] Attempting to resolve: ['self', 'get_current_session']
    [RESOLVE] Chain resolution needed for: ['self', 'get_current_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_session
            [INTERMEDIATE] Tracking chain steps for: self.get_current_session
            [INTERMEDIATE] Step 1: self.get_current_session
      -> Resolved to: session_manager.SessionManager.get_current_session
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: self.get_current_session
        [CACHE] self.get_current_session -> session_manager.SessionManager.get_current_session (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.current_session_id
        [CACHE] self.current_session_id -> session_manager.SessionManager.current_session_id (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: original_session_id
        [CACHE] original_session_id -> session_manager.original_session_id (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.session_context
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.session_context
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.add_session_event_handler
    [CONTEXT] Entered function: session_manager.SessionManager.add_session_event_handler (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'event_name': 'str', 'handler': 'Callable'}
        [ARG_TYPE] Processing type annotation for event_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: event_name -> session_manager.str
        [ARG_TYPE] RESOLVED event_name : session_manager.str
        [ARG_TYPE] Processing type annotation for handler: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Function: handler -> typing.Callable
        [ARG_TYPE] RESOLVED handler : typing.Callable
      [NAME] Found name reference: event_name
    [RESOLVE] Attempting to resolve: ['event_name']
      [RESOLVE_SIMPLE] Resolving base: event_name
      [CACHE] Hit for event_name: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.event_handlers
    [RESOLVE] Attempting to resolve: ['self', 'event_handlers']
    [RESOLVE] Chain resolution needed for: ['self', 'event_handlers']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.event_handlers
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.event_handlers
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.event_handlers
      [CHAIN] Step 1 resolved: session_manager.SessionManager.event_handlers
    [RESOLVE] RESOLVED to: session_manager.SessionManager.event_handlers
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.event_handlers
        [CACHE] self.event_handlers -> session_manager.SessionManager.event_handlers (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: event_name
        [CACHE] event_name -> session_manager.str (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [ATTRIBUTE] Found attribute access: self.event_handlers
        [CACHE] self.event_handlers -> session_manager.SessionManager.event_handlers (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: event_name
        [CACHE] event_name -> session_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: handler
    [RESOLVE] Attempting to resolve: ['handler']
      [RESOLVE_SIMPLE] Resolving base: handler
      [CACHE] Hit for handler: session_manager.handler
    [RESOLVE] RESOLVED to: session_manager.handler
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.add_session_event_handler
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.add_session_event_handler
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionManager.periodic_cleanup
    [DECORATOR] @monitor_performance
    [CONTEXT] Entered function: session_manager.SessionManager.periodic_cleanup (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
      [ASSIGNMENT] Processing: expired_count = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: expired_count
    [RESOLVE] Attempting to resolve: ['expired_count']
      [RESOLVE_SIMPLE] Resolving base: expired_count
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable expired_count not found in any scope
      [LOCAL_RESOLVER] can_resolve(expired_count): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(expired_count): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(expired_count): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(expired_count): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(expired_count): session_manager.expired_count
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: expired_count -> session_manager.expired_count
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.expired_count
      -> Not module state
      [ASSIGNMENT] Processing: idle_count = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: idle_count
    [RESOLVE] Attempting to resolve: ['idle_count']
      [RESOLVE_SIMPLE] Resolving base: idle_count
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable idle_count not found in any scope
      [LOCAL_RESOLVER] can_resolve(idle_count): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(idle_count): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(idle_count): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(idle_count): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(idle_count): session_manager.idle_count
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: idle_count -> session_manager.idle_count
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.idle_count
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.session_lock
      [CHAIN] Step 1 resolved: session_manager.SessionManager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionManager.session_lock
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ASSIGNMENT] Processing: sessions_to_expire = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: sessions_to_expire
    [RESOLVE] Attempting to resolve: ['sessions_to_expire']
      [RESOLVE_SIMPLE] Resolving base: sessions_to_expire
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable sessions_to_expire not found in any scope
      [LOCAL_RESOLVER] can_resolve(sessions_to_expire): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(sessions_to_expire): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(sessions_to_expire): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(sessions_to_expire): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(sessions_to_expire): session_manager.sessions_to_expire
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: sessions_to_expire -> session_manager.sessions_to_expire
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.sessions_to_expire
      -> Not module state
      [ASSIGNMENT] Processing: sessions_to_idle = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: sessions_to_idle
    [RESOLVE] Attempting to resolve: ['sessions_to_idle']
      [RESOLVE_SIMPLE] Resolving base: sessions_to_idle
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable sessions_to_idle not found in any scope
      [LOCAL_RESOLVER] can_resolve(sessions_to_idle): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(sessions_to_idle): False (current_class: session_manager.SessionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(sessions_to_idle): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(sessions_to_idle): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(sessions_to_idle): session_manager.sessions_to_idle
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: sessions_to_idle -> session_manager.sessions_to_idle
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.sessions_to_idle
      -> Not module state
      [ASSIGNMENT] Processing: current_time = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
      [TYPE_INFERENCE] Call resolved to: datetime.datetime.now
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for current_time
      [NAME] Found name reference: current_time
    [RESOLVE] Attempting to resolve: ['current_time']
      [RESOLVE_SIMPLE] Resolving base: current_time
      [CACHE] Hit for current_time: session_manager.current_time
    [RESOLVE] RESOLVED to: session_manager.current_time
      -> Not module state
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
      [NAME] Found name reference: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      -> Not module state
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self.active_sessions.items
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions', 'items']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions', 'items']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
      [CHAIN] Step 2: Resolving session_manager.SessionManager.active_sessions.items
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions.items
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions.items
      [CHAIN] Step 2 resolved: session_manager.SessionManager.active_sessions.items
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions.items
            [INTERMEDIATE] Tracking chain steps for: self.active_sessions.items
            [INTERMEDIATE] Step 1: self.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.active_sessions
      [CHAIN] Step 1 resolved: session_manager.SessionManager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionManager.active_sessions
            [INTERMEDIATE] Step 2: self.active_sessions.items
      -> Resolved to: session_manager.SessionManager.active_sessions.items
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: self.active_sessions.items
        [CACHE] self.active_sessions.items -> session_manager.SessionManager.active_sessions.items (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [CALL] Found call: session.is_expired
    [RESOLVE] Attempting to resolve: ['session', 'is_expired']
    [RESOLVE] Chain resolution needed for: ['session', 'is_expired']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.is_expired
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.is_expired
        [ATTRIBUTE] Direct match found: session_manager.UserSession.is_expired
      [CHAIN] Step 1 resolved: session_manager.UserSession.is_expired
    [RESOLVE] RESOLVED to: session_manager.UserSession.is_expired
            [INTERMEDIATE] Tracking chain steps for: session.is_expired
            [INTERMEDIATE] Step 1: session.is_expired
      -> Resolved to: session_manager.UserSession.is_expired
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session.is_expired
        [CACHE] session.is_expired -> session_manager.UserSession.is_expired (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: sessions_to_expire.append
    [RESOLVE] Attempting to resolve: ['sessions_to_expire', 'append']
    [RESOLVE] Chain resolution needed for: ['sessions_to_expire', 'append']
      [CHAIN] Resolving base: sessions_to_expire
      [RESOLVE_SIMPLE] Resolving base: sessions_to_expire
      [CACHE] Hit for sessions_to_expire: session_manager.sessions_to_expire
      [CHAIN] Base resolved: sessions_to_expire -> session_manager.sessions_to_expire
      [CHAIN] Step 1: Resolving session_manager.sessions_to_expire.append
        [ATTRIBUTE] Resolving attribute: session_manager.sessions_to_expire.append
        [ATTRIBUTE] Direct match found: session_manager.sessions_to_expire.append
      [CHAIN] Step 1 resolved: session_manager.sessions_to_expire.append
    [RESOLVE] RESOLVED to: session_manager.sessions_to_expire.append
            [INTERMEDIATE] Tracking chain steps for: sessions_to_expire.append
            [INTERMEDIATE] Step 1: sessions_to_expire.append
      -> Resolved to: session_manager.sessions_to_expire.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      [ATTRIBUTE] Found attribute access: sessions_to_expire.append
        [CACHE] sessions_to_expire.append -> session_manager.sessions_to_expire.append (cached)
      -> Not module state
      [NAME] Found name reference: sessions_to_expire
        [CACHE] sessions_to_expire -> session_manager.sessions_to_expire (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.state
    [RESOLVE] Attempting to resolve: ['session', 'state']
    [RESOLVE] Chain resolution needed for: ['session', 'state']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.state
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.state
        [ATTRIBUTE] Direct match found: session_manager.UserSession.state
      [CHAIN] Step 1 resolved: session_manager.UserSession.state
    [RESOLVE] RESOLVED to: session_manager.UserSession.state
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: SessionState.ACTIVE
    [RESOLVE] Attempting to resolve: ['SessionState', 'ACTIVE']
    [RESOLVE] Chain resolution needed for: ['SessionState', 'ACTIVE']
      [CHAIN] Resolving base: SessionState
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
      [CHAIN] Base resolved: SessionState -> session_manager.SessionState
      [CHAIN] Step 1: Resolving session_manager.SessionState.ACTIVE
        [ATTRIBUTE] Resolving attribute: session_manager.SessionState.ACTIVE
        [ATTRIBUTE] Direct match found: session_manager.SessionState.ACTIVE
      [CHAIN] Step 1 resolved: session_manager.SessionState.ACTIVE
    [RESOLVE] RESOLVED to: session_manager.SessionState.ACTIVE
      -> Not module state
      [NAME] Found name reference: SessionState
    [RESOLVE] Attempting to resolve: ['SessionState']
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
    [RESOLVE] RESOLVED to: session_manager.SessionState
      -> Not module state
      [NAME] Found name reference: current_time
        [CACHE] current_time -> session_manager.current_time (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.last_activity
    [RESOLVE] Attempting to resolve: ['session', 'last_activity']
    [RESOLVE] Chain resolution needed for: ['session', 'last_activity']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.last_activity
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.last_activity
        [ATTRIBUTE] Direct match found: session_manager.UserSession.last_activity
      [CHAIN] Step 1 resolved: session_manager.UserSession.last_activity
    [RESOLVE] RESOLVED to: session_manager.UserSession.last_activity
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: timedelta
    [RESOLVE] Attempting to resolve: ['timedelta']
      [RESOLVE_SIMPLE] Resolving base: timedelta
      [CACHE] Hit for timedelta: datetime.timedelta
    [RESOLVE] RESOLVED to: datetime.timedelta
      -> Resolved to: datetime.timedelta
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: timedelta
        [CACHE] timedelta -> datetime.timedelta (cached)
      -> Not module state
      [CALL] Found call: sessions_to_idle.append
    [RESOLVE] Attempting to resolve: ['sessions_to_idle', 'append']
    [RESOLVE] Chain resolution needed for: ['sessions_to_idle', 'append']
      [CHAIN] Resolving base: sessions_to_idle
      [RESOLVE_SIMPLE] Resolving base: sessions_to_idle
      [CACHE] Hit for sessions_to_idle: session_manager.sessions_to_idle
      [CHAIN] Base resolved: sessions_to_idle -> session_manager.sessions_to_idle
      [CHAIN] Step 1: Resolving session_manager.sessions_to_idle.append
        [ATTRIBUTE] Resolving attribute: session_manager.sessions_to_idle.append
        [ATTRIBUTE] Direct match found: session_manager.sessions_to_idle.append
      [CHAIN] Step 1 resolved: session_manager.sessions_to_idle.append
    [RESOLVE] RESOLVED to: session_manager.sessions_to_idle.append
            [INTERMEDIATE] Tracking chain steps for: sessions_to_idle.append
            [INTERMEDIATE] Step 1: sessions_to_idle.append
      -> Resolved to: session_manager.sessions_to_idle.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      [ATTRIBUTE] Found attribute access: sessions_to_idle.append
        [CACHE] sessions_to_idle.append -> session_manager.sessions_to_idle.append (cached)
      -> Not module state
      [NAME] Found name reference: sessions_to_idle
        [CACHE] sessions_to_idle -> session_manager.sessions_to_idle (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [NAME] Found name reference: sessions_to_expire
        [CACHE] sessions_to_expire -> session_manager.sessions_to_expire (cached)
      -> Not module state
      [CALL] Found call: self._expire_session
    [RESOLVE] Attempting to resolve: ['self', '_expire_session']
    [RESOLVE] Chain resolution needed for: ['self', '_expire_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionManager
      [CHAIN] Base resolved: self -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager._expire_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager._expire_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager._expire_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager._expire_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager._expire_session
            [INTERMEDIATE] Tracking chain steps for: self._expire_session
            [INTERMEDIATE] Step 1: self._expire_session
      -> Resolved to: session_manager.SessionManager._expire_session
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      [ATTRIBUTE] Found attribute access: self._expire_session
        [CACHE] self._expire_session -> session_manager.SessionManager._expire_session (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [NAME] Found name reference: expired_count
        [CACHE] expired_count -> session_manager.expired_count (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [NAME] Found name reference: sessions_to_idle
        [CACHE] sessions_to_idle -> session_manager.sessions_to_idle (cached)
      -> Not module state
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.active_sessions
        [CACHE] self.active_sessions -> session_manager.SessionManager.active_sessions (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.state
        [CACHE] session.state -> session_manager.UserSession.state (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: SessionState.IDLE
    [RESOLVE] Attempting to resolve: ['SessionState', 'IDLE']
    [RESOLVE] Chain resolution needed for: ['SessionState', 'IDLE']
      [CHAIN] Resolving base: SessionState
      [RESOLVE_SIMPLE] Resolving base: SessionState
      [CACHE] Hit for SessionState: session_manager.SessionState
      [CHAIN] Base resolved: SessionState -> session_manager.SessionState
      [CHAIN] Step 1: Resolving session_manager.SessionState.IDLE
        [ATTRIBUTE] Resolving attribute: session_manager.SessionState.IDLE
        [ATTRIBUTE] Direct match found: session_manager.SessionState.IDLE
      [CHAIN] Step 1 resolved: session_manager.SessionState.IDLE
    [RESOLVE] RESOLVED to: session_manager.SessionState.IDLE
      -> Not module state
      [NAME] Found name reference: SessionState
        [CACHE] SessionState -> session_manager.SessionState (cached)
      -> Not module state
      [NAME] Found name reference: idle_count
        [CACHE] idle_count -> session_manager.idle_count (cached)
      -> Not module state
      [NAME] Found name reference: expired_count
        [CACHE] expired_count -> session_manager.expired_count (cached)
      -> Not module state
      [NAME] Found name reference: idle_count
        [CACHE] idle_count -> session_manager.idle_count (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionManager.periodic_cleanup
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionManager.periodic_cleanup
        Calls: 2
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: session_manager.SessionManager
    [SYMBOL_TABLE] Exited class scope
      [ANNOTATED_ASSIGNMENT] _global_session_manager : Optional[SessionManager]
  [FUNCTION] Analyzing function: initialize_session_manager
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.initialize_session_manager
    [CONTEXT] Entered function: session_manager.initialize_session_manager (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'haven_proxy': 'HavenProxy'}
        [ARG_TYPE] Processing type annotation for haven_proxy: HavenProxy
    [RESOLVE] Attempting to resolve: ['HavenProxy']
      [RESOLVE_SIMPLE] Resolving base: HavenProxy
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable HavenProxy not found in any scope
      [LOCAL_RESOLVER] can_resolve(HavenProxy): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(HavenProxy): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(HavenProxy): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(HavenProxy): proxy_handler.HavenProxy (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: HavenProxy -> proxy_handler.HavenProxy
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      [SYMBOL_UPDATE] Function: haven_proxy -> proxy_handler.HavenProxy
        [ARG_TYPE] RESOLVED haven_proxy : proxy_handler.HavenProxy
      [ASSIGNMENT] Processing: _global_session_manager = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: SessionManager
    [RESOLVE] Attempting to resolve: ['SessionManager']
      [RESOLVE_SIMPLE] Resolving base: SessionManager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable SessionManager not found in any scope
      [LOCAL_RESOLVER] can_resolve(SessionManager): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(SessionManager): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(SessionManager): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(SessionManager): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(SessionManager): session_manager.SessionManager
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: SessionManager -> session_manager.SessionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager
      [TYPE_INFERENCE] RESOLVED Inferred type: session_manager.SessionManager (class instantiation)
      [SYMBOL_UPDATE] Function: _global_session_manager -> session_manager.SessionManager
        [ASSIGNMENT] RESOLVED Updated symbol table: _global_session_manager = session_manager.SessionManager
      [NAME] Found name reference: _global_session_manager
    [RESOLVE] Attempting to resolve: ['_global_session_manager']
      [RESOLVE_SIMPLE] Resolving base: _global_session_manager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found _global_session_manager in function scope: session_manager.SessionManager
      [LOCAL_RESOLVER] can_resolve(_global_session_manager): True
      [SYMBOL_LOOKUP] Found _global_session_manager in function scope: session_manager.SessionManager
      [LOCAL_RESOLVER] resolve(_global_session_manager): session_manager.SessionManager
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: _global_session_manager -> session_manager.SessionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [CALL] Found call: SessionManager
    [RESOLVE] Attempting to resolve: ['SessionManager']
      [RESOLVE_SIMPLE] Resolving base: SessionManager
      [CACHE] Hit for SessionManager: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Resolved to: session_manager.SessionManager
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: haven_proxy
    [RESOLVE] Attempting to resolve: ['haven_proxy']
      [RESOLVE_SIMPLE] Resolving base: haven_proxy
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found haven_proxy in function scope: proxy_handler.HavenProxy
      [LOCAL_RESOLVER] can_resolve(haven_proxy): True
      [SYMBOL_LOOKUP] Found haven_proxy in function scope: proxy_handler.HavenProxy
      [LOCAL_RESOLVER] resolve(haven_proxy): proxy_handler.HavenProxy
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: haven_proxy -> proxy_handler.HavenProxy
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      [NAME] Found name reference: SessionManager
        [CACHE] SessionManager -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: haven_proxy
    [RESOLVE] Attempting to resolve: ['haven_proxy']
      [RESOLVE_SIMPLE] Resolving base: haven_proxy
      [CACHE] Hit for haven_proxy: proxy_handler.HavenProxy
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      -> Not module state
      [NAME] Found name reference: _global_session_manager
        [CACHE] _global_session_manager -> session_manager.SessionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.initialize_session_manager
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.initialize_session_manager
        Calls: 0
        Instantiations: 1
        State Access: 0
  [FUNCTION] Analyzing function: get_current_session
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.get_current_session
    [CONTEXT] Entered function: session_manager.get_current_session (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [NAME] Found name reference: _global_session_manager
    [RESOLVE] Attempting to resolve: ['_global_session_manager']
      [RESOLVE_SIMPLE] Resolving base: _global_session_manager
      [CACHE] Hit for _global_session_manager: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [CALL] Found call: _global_session_manager.get_current_session
    [RESOLVE] Attempting to resolve: ['_global_session_manager', 'get_current_session']
    [RESOLVE] Chain resolution needed for: ['_global_session_manager', 'get_current_session']
      [CHAIN] Resolving base: _global_session_manager
      [RESOLVE_SIMPLE] Resolving base: _global_session_manager
      [CACHE] Hit for _global_session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _global_session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_session
            [INTERMEDIATE] Tracking chain steps for: _global_session_manager.get_current_session
            [INTERMEDIATE] Step 1: _global_session_manager.get_current_session
      -> Resolved to: session_manager.SessionManager.get_current_session
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _global_session_manager.get_current_session
        [CACHE] _global_session_manager.get_current_session -> session_manager.SessionManager.get_current_session (cached)
      -> Not module state
      [NAME] Found name reference: _global_session_manager
        [CACHE] _global_session_manager -> session_manager.SessionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.get_current_session
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.get_current_session
        Calls: 1
        Instantiations: 0
        State Access: 0
  [FUNCTION] Analyzing function: get_current_user
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.get_current_user
    [CONTEXT] Entered function: session_manager.get_current_user (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [NAME] Found name reference: _global_session_manager
    [RESOLVE] Attempting to resolve: ['_global_session_manager']
      [RESOLVE_SIMPLE] Resolving base: _global_session_manager
      [CACHE] Hit for _global_session_manager: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [CALL] Found call: _global_session_manager.get_current_user
    [RESOLVE] Attempting to resolve: ['_global_session_manager', 'get_current_user']
    [RESOLVE] Chain resolution needed for: ['_global_session_manager', 'get_current_user']
      [CHAIN] Resolving base: _global_session_manager
      [RESOLVE_SIMPLE] Resolving base: _global_session_manager
      [CACHE] Hit for _global_session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _global_session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_user
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_user
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_user
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_user
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_user
            [INTERMEDIATE] Tracking chain steps for: _global_session_manager.get_current_user
            [INTERMEDIATE] Step 1: _global_session_manager.get_current_user
      -> Resolved to: session_manager.SessionManager.get_current_user
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _global_session_manager.get_current_user
        [CACHE] _global_session_manager.get_current_user -> session_manager.SessionManager.get_current_user (cached)
      -> Not module state
      [NAME] Found name reference: _global_session_manager
        [CACHE] _global_session_manager -> session_manager.SessionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.get_current_user
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.get_current_user
        Calls: 1
        Instantiations: 0
        State Access: 0
  [FUNCTION] Analyzing function: get_current_user_id
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.get_current_user_id
    [CONTEXT] Entered function: session_manager.get_current_user_id (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 0 arguments
      [NAME] Found name reference: _global_session_manager
    [RESOLVE] Attempting to resolve: ['_global_session_manager']
      [RESOLVE_SIMPLE] Resolving base: _global_session_manager
      [CACHE] Hit for _global_session_manager: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [CALL] Found call: _global_session_manager.get_current_user_id
    [RESOLVE] Attempting to resolve: ['_global_session_manager', 'get_current_user_id']
    [RESOLVE] Chain resolution needed for: ['_global_session_manager', 'get_current_user_id']
      [CHAIN] Resolving base: _global_session_manager
      [RESOLVE_SIMPLE] Resolving base: _global_session_manager
      [CACHE] Hit for _global_session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _global_session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_user_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_user_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_user_id
            [INTERMEDIATE] Tracking chain steps for: _global_session_manager.get_current_user_id
            [INTERMEDIATE] Step 1: _global_session_manager.get_current_user_id
      -> Resolved to: session_manager.SessionManager.get_current_user_id
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _global_session_manager.get_current_user_id
        [CACHE] _global_session_manager.get_current_user_id -> session_manager.SessionManager.get_current_user_id (cached)
      -> Not module state
      [NAME] Found name reference: _global_session_manager
        [CACHE] _global_session_manager -> session_manager.SessionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.get_current_user_id
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.get_current_user_id
        Calls: 1
        Instantiations: 0
        State Access: 0
  [CLASS] Analyzing class: SessionInteractionManager
    [CONTEXT] Entered class: session_manager.SessionInteractionManager
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionInteractionManager.__init__
    [CONTEXT] Entered function: session_manager.SessionInteractionManager.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'session_manager': 'SessionManager'}
        [ARG_TYPE] Processing type annotation for session_manager: SessionManager
    [RESOLVE] Attempting to resolve: ['SessionManager']
      [RESOLVE_SIMPLE] Resolving base: SessionManager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable SessionManager not found in any scope
      [LOCAL_RESOLVER] can_resolve(SessionManager): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(SessionManager): False (current_class: session_manager.SessionInteractionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(SessionManager): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(SessionManager): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(SessionManager): session_manager.SessionManager
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: SessionManager -> session_manager.SessionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      [SYMBOL_UPDATE] Function: session_manager -> session_manager.SessionManager
        [ARG_TYPE] RESOLVED session_manager : session_manager.SessionManager
      [ATTRIBUTE] Found attribute access: self.session_manager
    [RESOLVE] Attempting to resolve: ['self', 'session_manager']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: session_manager.SessionInteractionManager)
      [SELF_RESOLVER] resolve(self): session_manager.SessionInteractionManager
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> session_manager.SessionInteractionManager
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.session_manager
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.session_manager
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager
      -> Not module state
      [NAME] Found name reference: session_manager
    [RESOLVE] Attempting to resolve: ['session_manager']
      [RESOLVE_SIMPLE] Resolving base: session_manager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found session_manager in function scope: session_manager.SessionManager
      [LOCAL_RESOLVER] can_resolve(session_manager): True
      [SYMBOL_LOOKUP] Found session_manager in function scope: session_manager.SessionManager
      [LOCAL_RESOLVER] resolve(session_manager): session_manager.SessionManager
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: session_manager -> session_manager.SessionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.interaction_log
    [RESOLVE] Attempting to resolve: ['self', 'interaction_log']
    [RESOLVE] Chain resolution needed for: ['self', 'interaction_log']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.interaction_log
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.interaction_log
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.interaction_log
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.interaction_log
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.interaction_log
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionInteractionManager (cached)
      -> Not module state
      [NAME] Found name reference: List
    [RESOLVE] Attempting to resolve: ['List']
      [RESOLVE_SIMPLE] Resolving base: List
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable List not found in any scope
      [LOCAL_RESOLVER] can_resolve(List): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(List): False (current_class: session_manager.SessionInteractionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(List): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(List): typing.List (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: List -> typing.List
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.List
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: session_manager.SessionInteractionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: session_manager.SessionInteractionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(str): session_manager.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> session_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [NAME] Found name reference: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: session_manager.SessionInteractionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_relationships
    [RESOLVE] Attempting to resolve: ['self', 'user_relationships']
    [RESOLVE] Chain resolution needed for: ['self', 'user_relationships']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.user_relationships
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.user_relationships
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.user_relationships
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.user_relationships
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.user_relationships
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionInteractionManager (cached)
      -> Not module state
      [NAME] Found name reference: Dict
        [CACHE] Dict -> typing.Dict (cached)
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> session_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: Set
    [RESOLVE] Attempting to resolve: ['Set']
      [RESOLVE_SIMPLE] Resolving base: Set
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Set not found in any scope
      [LOCAL_RESOLVER] can_resolve(Set): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Set): False (current_class: session_manager.SessionInteractionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Set): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Set): typing.Set (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Set -> typing.Set
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Set
      -> Not module state
      [NAME] Found name reference: str
        [CACHE] str -> session_manager.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_analytics
    [RESOLVE] Attempting to resolve: ['self', 'session_analytics']
    [RESOLVE] Chain resolution needed for: ['self', 'session_analytics']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.session_analytics
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_analytics
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_analytics
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.session_analytics
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.session_analytics
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionInteractionManager (cached)
      -> Not module state
      [CALL] Found call: SessionAnalytics
    [RESOLVE] Attempting to resolve: ['SessionAnalytics']
      [RESOLVE_SIMPLE] Resolving base: SessionAnalytics
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable SessionAnalytics not found in any scope
      [LOCAL_RESOLVER] can_resolve(SessionAnalytics): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(SessionAnalytics): False (current_class: session_manager.SessionInteractionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(SessionAnalytics): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(SessionAnalytics): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(SessionAnalytics): session_manager.SessionAnalytics
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: SessionAnalytics -> session_manager.SessionAnalytics
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics
      -> Resolved to: session_manager.SessionAnalytics
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: session_manager
    [RESOLVE] Attempting to resolve: ['session_manager']
      [RESOLVE_SIMPLE] Resolving base: session_manager
      [CACHE] Hit for session_manager: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      [NAME] Found name reference: SessionAnalytics
        [CACHE] SessionAnalytics -> session_manager.SessionAnalytics (cached)
      -> Not module state
      [NAME] Found name reference: session_manager
        [CACHE] session_manager -> session_manager.SessionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionInteractionManager.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionInteractionManager.__init__
        Calls: 0
        Instantiations: 1
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionInteractionManager.record_user_interaction
    [DECORATOR] @trace
    [CONTEXT] Entered function: session_manager.SessionInteractionManager.record_user_interaction (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 5 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user1_id': 'str', 'user2_id': 'str', 'interaction_type': 'str', 'data': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for user1_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: user1_id -> session_manager.str
        [ARG_TYPE] RESOLVED user1_id : session_manager.str
        [ARG_TYPE] Processing type annotation for user2_id: str
        [CACHE] str -> session_manager.str (cached)
      [SYMBOL_UPDATE] Function: user2_id -> session_manager.str
        [ARG_TYPE] RESOLVED user2_id : session_manager.str
        [ARG_TYPE] Processing type annotation for interaction_type: str
        [CACHE] str -> session_manager.str (cached)
      [SYMBOL_UPDATE] Function: interaction_type -> session_manager.str
        [ARG_TYPE] RESOLVED interaction_type : session_manager.str
      [ASSIGNMENT] Processing: interaction = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: interaction
    [RESOLVE] Attempting to resolve: ['interaction']
      [RESOLVE_SIMPLE] Resolving base: interaction
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable interaction not found in any scope
      [LOCAL_RESOLVER] can_resolve(interaction): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(interaction): False (current_class: session_manager.SessionInteractionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(interaction): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(interaction): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(interaction): session_manager.interaction
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: interaction -> session_manager.interaction
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.interaction
      -> Not module state
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable datetime not found in any scope
      [LOCAL_RESOLVER] can_resolve(datetime): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(datetime): False (current_class: session_manager.SessionInteractionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(datetime): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(datetime): datetime.datetime (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: datetime -> datetime.datetime
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
      [NAME] Found name reference: user1_id
    [RESOLVE] Attempting to resolve: ['user1_id']
      [RESOLVE_SIMPLE] Resolving base: user1_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found user1_id in function scope: session_manager.str
      [LOCAL_RESOLVER] can_resolve(user1_id): True
      [SYMBOL_LOOKUP] Found user1_id in function scope: session_manager.str
      [LOCAL_RESOLVER] resolve(user1_id): session_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: user1_id -> session_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [NAME] Found name reference: user2_id
    [RESOLVE] Attempting to resolve: ['user2_id']
      [RESOLVE_SIMPLE] Resolving base: user2_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found user2_id in function scope: session_manager.str
      [LOCAL_RESOLVER] can_resolve(user2_id): True
      [SYMBOL_LOOKUP] Found user2_id in function scope: session_manager.str
      [LOCAL_RESOLVER] resolve(user2_id): session_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: user2_id -> session_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [NAME] Found name reference: interaction_type
    [RESOLVE] Attempting to resolve: ['interaction_type']
      [RESOLVE_SIMPLE] Resolving base: interaction_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found interaction_type in function scope: session_manager.str
      [LOCAL_RESOLVER] can_resolve(interaction_type): True
      [SYMBOL_LOOKUP] Found interaction_type in function scope: session_manager.str
      [LOCAL_RESOLVER] resolve(interaction_type): session_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: interaction_type -> session_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable data not found in any scope
      [LOCAL_RESOLVER] can_resolve(data): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(data): False (current_class: session_manager.SessionInteractionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(data): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(data): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(data): session_manager.data
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: data -> session_manager.data
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.data
      -> Not module state
      [CALL] Found call: self.interaction_log.append
    [RESOLVE] Attempting to resolve: ['self', 'interaction_log', 'append']
    [RESOLVE] Chain resolution needed for: ['self', 'interaction_log', 'append']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.interaction_log
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.interaction_log
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.interaction_log
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.interaction_log
      [CHAIN] Step 2: Resolving session_manager.SessionInteractionManager.interaction_log.append
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.interaction_log.append
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.interaction_log.append
      [CHAIN] Step 2 resolved: session_manager.SessionInteractionManager.interaction_log.append
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.interaction_log.append
            [INTERMEDIATE] Tracking chain steps for: self.interaction_log.append
            [INTERMEDIATE] Step 1: self.interaction_log
    [RESOLVE] Attempting to resolve: ['self', 'interaction_log']
    [RESOLVE] Chain resolution needed for: ['self', 'interaction_log']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.interaction_log
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.interaction_log
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.interaction_log
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.interaction_log
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.interaction_log
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionInteractionManager.interaction_log
            [INTERMEDIATE] Step 2: self.interaction_log.append
      -> Resolved to: session_manager.SessionInteractionManager.interaction_log.append
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: interaction
    [RESOLVE] Attempting to resolve: ['interaction']
      [RESOLVE_SIMPLE] Resolving base: interaction
      [CACHE] Hit for interaction: session_manager.interaction
    [RESOLVE] RESOLVED to: session_manager.interaction
      [ATTRIBUTE] Found attribute access: self.interaction_log.append
        [CACHE] self.interaction_log.append -> session_manager.SessionInteractionManager.interaction_log.append (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.interaction_log
        [CACHE] self.interaction_log -> session_manager.SessionInteractionManager.interaction_log (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager
      -> Not module state
      [NAME] Found name reference: interaction
        [CACHE] interaction -> session_manager.interaction (cached)
      -> Not module state
      [NAME] Found name reference: user1_id
        [CACHE] user1_id -> session_manager.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_relationships
    [RESOLVE] Attempting to resolve: ['self', 'user_relationships']
    [RESOLVE] Chain resolution needed for: ['self', 'user_relationships']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.user_relationships
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.user_relationships
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.user_relationships
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.user_relationships
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.user_relationships
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionInteractionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_relationships
        [CACHE] self.user_relationships -> session_manager.SessionInteractionManager.user_relationships (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionInteractionManager (cached)
      -> Not module state
      [NAME] Found name reference: user1_id
        [CACHE] user1_id -> session_manager.str (cached)
      -> Not module state
      [CALL] Found call: set
      -> IGNORED (built-in function)
      [NAME] Found name reference: set
    [RESOLVE] Attempting to resolve: ['set']
      [RESOLVE_SIMPLE] Resolving base: set
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable set not found in any scope
      [LOCAL_RESOLVER] can_resolve(set): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(set): False (current_class: session_manager.SessionInteractionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(set): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(set): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(set): session_manager.set
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: set -> session_manager.set
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.set
      -> Not module state
      [NAME] Found name reference: user2_id
        [CACHE] user2_id -> session_manager.str (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_relationships
        [CACHE] self.user_relationships -> session_manager.SessionInteractionManager.user_relationships (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionInteractionManager (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.user_relationships
        [CACHE] self.user_relationships -> session_manager.SessionInteractionManager.user_relationships (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionInteractionManager (cached)
      -> Not module state
      [NAME] Found name reference: user2_id
        [CACHE] user2_id -> session_manager.str (cached)
      -> Not module state
      [CALL] Found call: set
      -> IGNORED (built-in function)
      [NAME] Found name reference: set
        [CACHE] set -> session_manager.set (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [ATTRIBUTE] Found attribute access: self.user_relationships
        [CACHE] self.user_relationships -> session_manager.SessionInteractionManager.user_relationships (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionInteractionManager (cached)
      -> Not module state
      [NAME] Found name reference: user1_id
        [CACHE] user1_id -> session_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: user2_id
        [CACHE] user2_id -> session_manager.str (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [ATTRIBUTE] Found attribute access: self.user_relationships
        [CACHE] self.user_relationships -> session_manager.SessionInteractionManager.user_relationships (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionInteractionManager (cached)
      -> Not module state
      [NAME] Found name reference: user2_id
        [CACHE] user2_id -> session_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: user1_id
        [CACHE] user1_id -> session_manager.str (cached)
      -> Not module state
      [ASSIGNMENT] Processing: session1 = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self._get_user_session
    [RESOLVE] Attempting to resolve: ['self', '_get_user_session']
    [RESOLVE] Chain resolution needed for: ['self', '_get_user_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager._get_user_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager._get_user_session
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager._get_user_session
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager._get_user_session
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager._get_user_session
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionInteractionManager._get_user_session
        [RETURN_TYPE_RESOLUTION] Resolving return type: UserSession
        [RETURN_TYPE_RESOLUTION] Found in current module: session_manager.UserSession
      [TYPE_INFERENCE] RESOLVED Inferred type: session_manager.UserSession (from return type)
      [SYMBOL_UPDATE] Function: session1 -> session_manager.UserSession
        [ASSIGNMENT] RESOLVED Updated symbol table: session1 = session_manager.UserSession
      [NAME] Found name reference: session1
    [RESOLVE] Attempting to resolve: ['session1']
      [RESOLVE_SIMPLE] Resolving base: session1
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found session1 in function scope: session_manager.UserSession
      [LOCAL_RESOLVER] can_resolve(session1): True
      [SYMBOL_LOOKUP] Found session1 in function scope: session_manager.UserSession
      [LOCAL_RESOLVER] resolve(session1): session_manager.UserSession
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: session1 -> session_manager.UserSession
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self._get_user_session
    [RESOLVE] Attempting to resolve: ['self', '_get_user_session']
    [RESOLVE] Chain resolution needed for: ['self', '_get_user_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager._get_user_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager._get_user_session
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager._get_user_session
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager._get_user_session
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager._get_user_session
            [INTERMEDIATE] Tracking chain steps for: self._get_user_session
            [INTERMEDIATE] Step 1: self._get_user_session
      -> Resolved to: session_manager.SessionInteractionManager._get_user_session
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: user1_id
    [RESOLVE] Attempting to resolve: ['user1_id']
      [RESOLVE_SIMPLE] Resolving base: user1_id
      [CACHE] Hit for user1_id: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [ATTRIBUTE] Found attribute access: self._get_user_session
        [CACHE] self._get_user_session -> session_manager.SessionInteractionManager._get_user_session (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionInteractionManager (cached)
      -> Not module state
      [NAME] Found name reference: user1_id
        [CACHE] user1_id -> session_manager.str (cached)
      -> Not module state
      [ASSIGNMENT] Processing: session2 = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self._get_user_session
    [RESOLVE] Attempting to resolve: ['self', '_get_user_session']
    [RESOLVE] Chain resolution needed for: ['self', '_get_user_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager._get_user_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager._get_user_session
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager._get_user_session
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager._get_user_session
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager._get_user_session
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionInteractionManager._get_user_session
        [RETURN_TYPE_RESOLUTION] Resolving return type: UserSession
        [RETURN_TYPE_RESOLUTION] Found in current module: session_manager.UserSession
      [TYPE_INFERENCE] RESOLVED Inferred type: session_manager.UserSession (from return type)
      [SYMBOL_UPDATE] Function: session2 -> session_manager.UserSession
        [ASSIGNMENT] RESOLVED Updated symbol table: session2 = session_manager.UserSession
      [NAME] Found name reference: session2
    [RESOLVE] Attempting to resolve: ['session2']
      [RESOLVE_SIMPLE] Resolving base: session2
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found session2 in function scope: session_manager.UserSession
      [LOCAL_RESOLVER] can_resolve(session2): True
      [SYMBOL_LOOKUP] Found session2 in function scope: session_manager.UserSession
      [LOCAL_RESOLVER] resolve(session2): session_manager.UserSession
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: session2 -> session_manager.UserSession
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self._get_user_session
    [CACHE] self._get_user_session -> session_manager.SessionInteractionManager._get_user_session (cached)
            [INTERMEDIATE] Tracking chain steps for: self._get_user_session
            [INTERMEDIATE] Step 1: self._get_user_session
      -> Resolved to: session_manager.SessionInteractionManager._get_user_session
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: user2_id
    [RESOLVE] Attempting to resolve: ['user2_id']
      [RESOLVE_SIMPLE] Resolving base: user2_id
      [CACHE] Hit for user2_id: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [ATTRIBUTE] Found attribute access: self._get_user_session
        [CACHE] self._get_user_session -> session_manager.SessionInteractionManager._get_user_session (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionInteractionManager (cached)
      -> Not module state
      [NAME] Found name reference: user2_id
        [CACHE] user2_id -> session_manager.str (cached)
      -> Not module state
      [NAME] Found name reference: session1
        [CACHE] session1 -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session1.metrics.events_emitted
    [RESOLVE] Attempting to resolve: ['session1', 'metrics', 'events_emitted']
    [RESOLVE] Chain resolution needed for: ['session1', 'metrics', 'events_emitted']
      [CHAIN] Resolving base: session1
      [RESOLVE_SIMPLE] Resolving base: session1
      [CACHE] Hit for session1: session_manager.UserSession
      [CHAIN] Base resolved: session1 -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
      [CHAIN] Step 2: Resolving session_manager.UserSession.metrics.events_emitted
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics.events_emitted
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics.events_emitted
      [CHAIN] Step 2 resolved: session_manager.UserSession.metrics.events_emitted
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics.events_emitted
      -> Not module state
      [ATTRIBUTE] Found attribute access: session1.metrics
    [RESOLVE] Attempting to resolve: ['session1', 'metrics']
    [RESOLVE] Chain resolution needed for: ['session1', 'metrics']
      [CHAIN] Resolving base: session1
      [RESOLVE_SIMPLE] Resolving base: session1
      [CACHE] Hit for session1: session_manager.UserSession
      [CHAIN] Base resolved: session1 -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics
      -> Not module state
      [NAME] Found name reference: session1
        [CACHE] session1 -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: session2
        [CACHE] session2 -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session2.metrics.events_received
    [RESOLVE] Attempting to resolve: ['session2', 'metrics', 'events_received']
    [RESOLVE] Chain resolution needed for: ['session2', 'metrics', 'events_received']
      [CHAIN] Resolving base: session2
      [RESOLVE_SIMPLE] Resolving base: session2
      [CACHE] Hit for session2: session_manager.UserSession
      [CHAIN] Base resolved: session2 -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
      [CHAIN] Step 2: Resolving session_manager.UserSession.metrics.events_received
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics.events_received
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics.events_received
      [CHAIN] Step 2 resolved: session_manager.UserSession.metrics.events_received
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics.events_received
      -> Not module state
      [ATTRIBUTE] Found attribute access: session2.metrics
    [RESOLVE] Attempting to resolve: ['session2', 'metrics']
    [RESOLVE] Chain resolution needed for: ['session2', 'metrics']
      [CHAIN] Resolving base: session2
      [RESOLVE_SIMPLE] Resolving base: session2
      [CACHE] Hit for session2: session_manager.UserSession
      [CHAIN] Base resolved: session2 -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics
      -> Not module state
      [NAME] Found name reference: session2
        [CACHE] session2 -> session_manager.UserSession (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionInteractionManager.record_user_interaction
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionInteractionManager.record_user_interaction
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionInteractionManager._get_user_session
    [CONTEXT] Entered function: session_manager.SessionInteractionManager._get_user_session (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: user_id -> session_manager.str
        [ARG_TYPE] RESOLVED user_id : session_manager.str
      [ATTRIBUTE] Found attribute access: self.session_manager.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 2: Resolving session_manager.SessionInteractionManager.session_manager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager.session_lock
      [CHAIN] Step 2 resolved: session_manager.SessionInteractionManager.session_manager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.session_manager.session_lock
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
    [RESOLVE] Attempting to resolve: ['self', 'session_manager']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.session_manager
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.session_manager
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager
      -> Not module state
      [NAME] Found name reference: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable session_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(session_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(session_id): False (current_class: session_manager.SessionInteractionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(session_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(session_id): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(session_id): session_manager.session_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: session_id -> session_manager.session_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.session_id
      -> Not module state
      [CALL] Found call: self.session_manager.user_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'user_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'user_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 2: Resolving session_manager.SessionInteractionManager.session_manager.user_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager.user_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager.user_sessions
      [CHAIN] Step 2 resolved: session_manager.SessionInteractionManager.session_manager.user_sessions
      [CHAIN] Step 3: Resolving session_manager.SessionInteractionManager.session_manager.user_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager.user_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager.user_sessions.get
      [CHAIN] Step 3 resolved: session_manager.SessionInteractionManager.session_manager.user_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.session_manager.user_sessions.get
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.user_sessions.get
            [INTERMEDIATE] Step 1: self.session_manager
    [CACHE] self.session_manager -> session_manager.SessionInteractionManager.session_manager (cached)
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionInteractionManager.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.user_sessions
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'user_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'user_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 2: Resolving session_manager.SessionInteractionManager.session_manager.user_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager.user_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager.user_sessions
      [CHAIN] Step 2 resolved: session_manager.SessionInteractionManager.session_manager.user_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.session_manager.user_sessions
            [INTERMEDIATE] Step 2 resolved to: session_manager.SessionInteractionManager.session_manager.user_sessions
            [INTERMEDIATE] Step 3: self.session_manager.user_sessions.get
      -> Resolved to: session_manager.SessionInteractionManager.session_manager.user_sessions.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found user_id in function scope: session_manager.str
      [LOCAL_RESOLVER] can_resolve(user_id): True
      [SYMBOL_LOOKUP] Found user_id in function scope: session_manager.str
      [LOCAL_RESOLVER] resolve(user_id): session_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: user_id -> session_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.str
      [ATTRIBUTE] Found attribute access: self.session_manager.user_sessions.get
        [CACHE] self.session_manager.user_sessions.get -> session_manager.SessionInteractionManager.session_manager.user_sessions.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager.user_sessions
        [CACHE] self.session_manager.user_sessions -> session_manager.SessionInteractionManager.session_manager.user_sessions (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> session_manager.SessionInteractionManager.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionInteractionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.session_manager.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 2: Resolving session_manager.SessionInteractionManager.session_manager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager.active_sessions
      [CHAIN] Step 2 resolved: session_manager.SessionInteractionManager.session_manager.active_sessions
      [CHAIN] Step 3: Resolving session_manager.SessionInteractionManager.session_manager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager.active_sessions.get
      [CHAIN] Step 3 resolved: session_manager.SessionInteractionManager.session_manager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.session_manager.active_sessions.get
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionInteractionManager.session_manager.active_sessions.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for session
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable session not found in any scope
      [LOCAL_RESOLVER] can_resolve(session): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(session): False (current_class: session_manager.SessionInteractionManager)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(session): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(session): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(session): session_manager.session
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: session -> session_manager.session
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.session
      -> Not module state
      [CALL] Found call: self.session_manager.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 2: Resolving session_manager.SessionInteractionManager.session_manager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager.active_sessions
      [CHAIN] Step 2 resolved: session_manager.SessionInteractionManager.session_manager.active_sessions
      [CHAIN] Step 3: Resolving session_manager.SessionInteractionManager.session_manager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager.active_sessions.get
      [CHAIN] Step 3 resolved: session_manager.SessionInteractionManager.session_manager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.session_manager.active_sessions.get
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.active_sessions.get
            [INTERMEDIATE] Step 1: self.session_manager
    [CACHE] self.session_manager -> session_manager.SessionInteractionManager.session_manager (cached)
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionInteractionManager.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionInteractionManager
      [CHAIN] Base resolved: self -> session_manager.SessionInteractionManager
      [CHAIN] Step 1: Resolving session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionInteractionManager.session_manager
      [CHAIN] Step 2: Resolving session_manager.SessionInteractionManager.session_manager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionInteractionManager.session_manager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionInteractionManager.session_manager.active_sessions
      [CHAIN] Step 2 resolved: session_manager.SessionInteractionManager.session_manager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionInteractionManager.session_manager.active_sessions
            [INTERMEDIATE] Step 2 resolved to: session_manager.SessionInteractionManager.session_manager.active_sessions
            [INTERMEDIATE] Step 3: self.session_manager.active_sessions.get
      -> Resolved to: session_manager.SessionInteractionManager.session_manager.active_sessions.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      [ATTRIBUTE] Found attribute access: self.session_manager.active_sessions.get
        [CACHE] self.session_manager.active_sessions.get -> session_manager.SessionInteractionManager.session_manager.active_sessions.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager.active_sessions
        [CACHE] self.session_manager.active_sessions -> session_manager.SessionInteractionManager.session_manager.active_sessions (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> session_manager.SessionInteractionManager.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionInteractionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.session (cached)
      -> Not module state
      [CALL] Found call: session.is_valid
    [RESOLVE] Attempting to resolve: ['session', 'is_valid']
    [RESOLVE] Chain resolution needed for: ['session', 'is_valid']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.session
      [CHAIN] Base resolved: session -> session_manager.session
      [CHAIN] Step 1: Resolving session_manager.session.is_valid
        [ATTRIBUTE] Resolving attribute: session_manager.session.is_valid
        [ATTRIBUTE] Direct match found: session_manager.session.is_valid
      [CHAIN] Step 1 resolved: session_manager.session.is_valid
    [RESOLVE] RESOLVED to: session_manager.session.is_valid
            [INTERMEDIATE] Tracking chain steps for: session.is_valid
            [INTERMEDIATE] Step 1: session.is_valid
      -> Resolved to: session_manager.session.is_valid
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: session.is_valid
        [CACHE] session.is_valid -> session_manager.session.is_valid (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.session (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.session (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionInteractionManager._get_user_session
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionInteractionManager._get_user_session
        Calls: 0
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: session_manager.SessionInteractionManager
    [SYMBOL_TABLE] Exited class scope
  [CLASS] Analyzing class: SessionAnalytics
    [CONTEXT] Entered class: session_manager.SessionAnalytics
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionAnalytics.__init__
    [CONTEXT] Entered function: session_manager.SessionAnalytics.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'session_manager': 'SessionManager'}
        [ARG_TYPE] Processing type annotation for session_manager: SessionManager
    [RESOLVE] Attempting to resolve: ['SessionManager']
      [RESOLVE_SIMPLE] Resolving base: SessionManager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable SessionManager not found in any scope
      [LOCAL_RESOLVER] can_resolve(SessionManager): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(SessionManager): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(SessionManager): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(SessionManager): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(SessionManager): session_manager.SessionManager
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: SessionManager -> session_manager.SessionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      [SYMBOL_UPDATE] Function: session_manager -> session_manager.SessionManager
        [ARG_TYPE] RESOLVED session_manager : session_manager.SessionManager
      [ATTRIBUTE] Found attribute access: self.session_manager
    [RESOLVE] Attempting to resolve: ['self', 'session_manager']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: session_manager.SessionAnalytics)
      [SELF_RESOLVER] resolve(self): session_manager.SessionAnalytics
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> session_manager.SessionAnalytics
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> session_manager.SessionAnalytics
      [CHAIN] Step 1: Resolving session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionAnalytics.session_manager
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics.session_manager
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionAnalytics
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics
      -> Not module state
      [NAME] Found name reference: session_manager
    [RESOLVE] Attempting to resolve: ['session_manager']
      [RESOLVE_SIMPLE] Resolving base: session_manager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found session_manager in function scope: session_manager.SessionManager
      [LOCAL_RESOLVER] can_resolve(session_manager): True
      [SYMBOL_LOOKUP] Found session_manager in function scope: session_manager.SessionManager
      [LOCAL_RESOLVER] resolve(session_manager): session_manager.SessionManager
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: session_manager -> session_manager.SessionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.analytics_cache
    [RESOLVE] Attempting to resolve: ['self', 'analytics_cache']
    [RESOLVE] Chain resolution needed for: ['self', 'analytics_cache']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionAnalytics
      [CHAIN] Base resolved: self -> session_manager.SessionAnalytics
      [CHAIN] Step 1: Resolving session_manager.SessionAnalytics.analytics_cache
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.analytics_cache
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.analytics_cache
      [CHAIN] Step 1 resolved: session_manager.SessionAnalytics.analytics_cache
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics.analytics_cache
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionAnalytics (cached)
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(str): session_manager.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> session_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [NAME] Found name reference: Any
    [RESOLVE] Attempting to resolve: ['Any']
      [RESOLVE_SIMPLE] Resolving base: Any
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Any not found in any scope
      [LOCAL_RESOLVER] can_resolve(Any): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Any): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Any): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Any): typing.Any (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Any -> typing.Any
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Any
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionAnalytics.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionAnalytics.__init__
        Calls: 0
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionAnalytics.compute_user_engagement_score
    [DECORATOR] @trace
    [DECORATOR] @monitor_performance
    [CONTEXT] Entered function: session_manager.SessionAnalytics.compute_user_engagement_score (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: user_id -> session_manager.str
        [ARG_TYPE] RESOLVED user_id : session_manager.str
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self._get_user_session
    [RESOLVE] Attempting to resolve: ['self', '_get_user_session']
    [RESOLVE] Chain resolution needed for: ['self', '_get_user_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionAnalytics
      [CHAIN] Base resolved: self -> session_manager.SessionAnalytics
      [CHAIN] Step 1: Resolving session_manager.SessionAnalytics._get_user_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics._get_user_session
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics._get_user_session
      [CHAIN] Step 1 resolved: session_manager.SessionAnalytics._get_user_session
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics._get_user_session
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionAnalytics._get_user_session
        [RETURN_TYPE_RESOLUTION] Resolving return type: UserSession
        [RETURN_TYPE_RESOLUTION] Found in current module: session_manager.UserSession
      [TYPE_INFERENCE] RESOLVED Inferred type: session_manager.UserSession (from return type)
      [SYMBOL_UPDATE] Function: session -> session_manager.UserSession
        [ASSIGNMENT] RESOLVED Updated symbol table: session = session_manager.UserSession
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found session in function scope: session_manager.UserSession
      [LOCAL_RESOLVER] can_resolve(session): True
      [SYMBOL_LOOKUP] Found session in function scope: session_manager.UserSession
      [LOCAL_RESOLVER] resolve(session): session_manager.UserSession
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: session -> session_manager.UserSession
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self._get_user_session
    [RESOLVE] Attempting to resolve: ['self', '_get_user_session']
    [RESOLVE] Chain resolution needed for: ['self', '_get_user_session']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionAnalytics
      [CHAIN] Base resolved: self -> session_manager.SessionAnalytics
      [CHAIN] Step 1: Resolving session_manager.SessionAnalytics._get_user_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics._get_user_session
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics._get_user_session
      [CHAIN] Step 1 resolved: session_manager.SessionAnalytics._get_user_session
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics._get_user_session
            [INTERMEDIATE] Tracking chain steps for: self._get_user_session
            [INTERMEDIATE] Step 1: self._get_user_session
      -> Resolved to: session_manager.SessionAnalytics._get_user_session
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found user_id in function scope: session_manager.str
      [LOCAL_RESOLVER] can_resolve(user_id): True
      [SYMBOL_LOOKUP] Found user_id in function scope: session_manager.str
      [LOCAL_RESOLVER] resolve(user_id): session_manager.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: user_id -> session_manager.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.str
      [ATTRIBUTE] Found attribute access: self._get_user_session
        [CACHE] self._get_user_session -> session_manager.SessionAnalytics._get_user_session (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionAnalytics
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ASSIGNMENT] Processing: activity_score = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: min
    [RESOLVE] Attempting to resolve: ['min']
      [RESOLVE_SIMPLE] Resolving base: min
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable min not found in any scope
      [LOCAL_RESOLVER] can_resolve(min): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(min): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(min): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(min): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(min): session_manager.min
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: min -> session_manager.min
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.min
      [TYPE_INFERENCE] Call resolved to: session_manager.min
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for activity_score
      [NAME] Found name reference: activity_score
    [RESOLVE] Attempting to resolve: ['activity_score']
      [RESOLVE_SIMPLE] Resolving base: activity_score
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable activity_score not found in any scope
      [LOCAL_RESOLVER] can_resolve(activity_score): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(activity_score): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(activity_score): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(activity_score): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(activity_score): session_manager.activity_score
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: activity_score -> session_manager.activity_score
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.activity_score
      -> Not module state
      [CALL] Found call: min
      -> IGNORED (built-in function)
      [NAME] Found name reference: min
    [RESOLVE] Attempting to resolve: ['min']
      [RESOLVE_SIMPLE] Resolving base: min
      [CACHE] Hit for min: session_manager.min
    [RESOLVE] RESOLVED to: session_manager.min
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics.activity_count
    [RESOLVE] Attempting to resolve: ['session', 'metrics', 'activity_count']
    [RESOLVE] Chain resolution needed for: ['session', 'metrics', 'activity_count']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
      [CHAIN] Step 2: Resolving session_manager.UserSession.metrics.activity_count
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics.activity_count
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics.activity_count
      [CHAIN] Step 2 resolved: session_manager.UserSession.metrics.activity_count
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics.activity_count
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics
    [RESOLVE] Attempting to resolve: ['session', 'metrics']
    [RESOLVE] Chain resolution needed for: ['session', 'metrics']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ASSIGNMENT] Processing: room_diversity = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: room_diversity
    [RESOLVE] Attempting to resolve: ['room_diversity']
      [RESOLVE_SIMPLE] Resolving base: room_diversity
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable room_diversity not found in any scope
      [LOCAL_RESOLVER] can_resolve(room_diversity): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(room_diversity): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(room_diversity): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(room_diversity): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(room_diversity): session_manager.room_diversity
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: room_diversity -> session_manager.room_diversity
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.room_diversity
      -> Not module state
      [CALL] Found call: len
      -> IGNORED (built-in function)
      [NAME] Found name reference: len
    [RESOLVE] Attempting to resolve: ['len']
      [RESOLVE_SIMPLE] Resolving base: len
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable len not found in any scope
      [LOCAL_RESOLVER] can_resolve(len): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(len): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(len): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(len): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(len): session_manager.len
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: len -> session_manager.len
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.len
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics.rooms_joined
    [RESOLVE] Attempting to resolve: ['session', 'metrics', 'rooms_joined']
    [RESOLVE] Chain resolution needed for: ['session', 'metrics', 'rooms_joined']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
      [CHAIN] Step 2: Resolving session_manager.UserSession.metrics.rooms_joined
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics.rooms_joined
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics.rooms_joined
      [CHAIN] Step 2 resolved: session_manager.UserSession.metrics.rooms_joined
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics.rooms_joined
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics
        [CACHE] session.metrics -> session_manager.UserSession.metrics (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ASSIGNMENT] Processing: interaction_ratio = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: interaction_ratio
    [RESOLVE] Attempting to resolve: ['interaction_ratio']
      [RESOLVE_SIMPLE] Resolving base: interaction_ratio
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable interaction_ratio not found in any scope
      [LOCAL_RESOLVER] can_resolve(interaction_ratio): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(interaction_ratio): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(interaction_ratio): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(interaction_ratio): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(interaction_ratio): session_manager.interaction_ratio
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: interaction_ratio -> session_manager.interaction_ratio
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.interaction_ratio
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics.events_emitted
    [RESOLVE] Attempting to resolve: ['session', 'metrics', 'events_emitted']
    [RESOLVE] Chain resolution needed for: ['session', 'metrics', 'events_emitted']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
      [CHAIN] Step 2: Resolving session_manager.UserSession.metrics.events_emitted
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics.events_emitted
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics.events_emitted
      [CHAIN] Step 2 resolved: session_manager.UserSession.metrics.events_emitted
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics.events_emitted
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics
        [CACHE] session.metrics -> session_manager.UserSession.metrics (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics.events_received
    [RESOLVE] Attempting to resolve: ['session', 'metrics', 'events_received']
    [RESOLVE] Chain resolution needed for: ['session', 'metrics', 'events_received']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.metrics
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics
      [CHAIN] Step 1 resolved: session_manager.UserSession.metrics
      [CHAIN] Step 2: Resolving session_manager.UserSession.metrics.events_received
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.metrics.events_received
        [ATTRIBUTE] Direct match found: session_manager.UserSession.metrics.events_received
      [CHAIN] Step 2 resolved: session_manager.UserSession.metrics.events_received
    [RESOLVE] RESOLVED to: session_manager.UserSession.metrics.events_received
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics
        [CACHE] session.metrics -> session_manager.UserSession.metrics (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: max
      -> IGNORED (built-in function)
      [NAME] Found name reference: max
    [RESOLVE] Attempting to resolve: ['max']
      [RESOLVE_SIMPLE] Resolving base: max
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable max not found in any scope
      [LOCAL_RESOLVER] can_resolve(max): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(max): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(max): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(max): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(max): session_manager.max
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: max -> session_manager.max
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.max
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics.activity_count
        [CACHE] session.metrics.activity_count -> session_manager.UserSession.metrics.activity_count (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.metrics
        [CACHE] session.metrics -> session_manager.UserSession.metrics (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ASSIGNMENT] Processing: session_duration = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: session_duration
    [RESOLVE] Attempting to resolve: ['session_duration']
      [RESOLVE_SIMPLE] Resolving base: session_duration
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable session_duration not found in any scope
      [LOCAL_RESOLVER] can_resolve(session_duration): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(session_duration): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(session_duration): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(session_duration): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(session_duration): session_manager.session_duration
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: session_duration -> session_manager.session_duration
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.session_duration
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: datetime.now
    [RESOLVE] Attempting to resolve: ['datetime', 'now']
    [RESOLVE] Chain resolution needed for: ['datetime', 'now']
      [CHAIN] Resolving base: datetime
      [RESOLVE_SIMPLE] Resolving base: datetime
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable datetime not found in any scope
      [LOCAL_RESOLVER] can_resolve(datetime): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(datetime): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(datetime): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(datetime): datetime.datetime (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: datetime -> datetime.datetime
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: datetime -> datetime.datetime
      [CHAIN] Step 1: Resolving datetime.datetime.now
        [ATTRIBUTE] Resolving attribute: datetime.datetime.now
        [ATTRIBUTE] Direct match found: datetime.datetime.now
      [CHAIN] Step 1 resolved: datetime.datetime.now
    [RESOLVE] RESOLVED to: datetime.datetime.now
            [INTERMEDIATE] Tracking chain steps for: datetime.now
            [INTERMEDIATE] Step 1: datetime.now
      -> Resolved to: datetime.datetime.now
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: datetime.now
        [CACHE] datetime.now -> datetime.datetime.now (cached)
      -> Not module state
      [NAME] Found name reference: datetime
    [RESOLVE] Attempting to resolve: ['datetime']
      [RESOLVE_SIMPLE] Resolving base: datetime
      [CACHE] Hit for datetime: datetime.datetime
    [RESOLVE] RESOLVED to: datetime.datetime
      -> Not module state
      [ATTRIBUTE] Found attribute access: session.created_at
    [RESOLVE] Attempting to resolve: ['session', 'created_at']
    [RESOLVE] Chain resolution needed for: ['session', 'created_at']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.created_at
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.created_at
        [ATTRIBUTE] Direct match found: session_manager.UserSession.created_at
      [CHAIN] Step 1 resolved: session_manager.UserSession.created_at
    [RESOLVE] RESOLVED to: session_manager.UserSession.created_at
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [ASSIGNMENT] Processing: duration_factor = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: min
    [RESOLVE] Attempting to resolve: ['min']
      [RESOLVE_SIMPLE] Resolving base: min
      [CACHE] Hit for min: session_manager.min
    [RESOLVE] RESOLVED to: session_manager.min
      [TYPE_INFERENCE] Call resolved to: session_manager.min
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for duration_factor
      [NAME] Found name reference: duration_factor
    [RESOLVE] Attempting to resolve: ['duration_factor']
      [RESOLVE_SIMPLE] Resolving base: duration_factor
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable duration_factor not found in any scope
      [LOCAL_RESOLVER] can_resolve(duration_factor): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(duration_factor): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(duration_factor): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(duration_factor): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(duration_factor): session_manager.duration_factor
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: duration_factor -> session_manager.duration_factor
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.duration_factor
      -> Not module state
      [CALL] Found call: min
      -> IGNORED (built-in function)
      [NAME] Found name reference: min
        [CACHE] min -> session_manager.min (cached)
      -> Not module state
      [NAME] Found name reference: session_duration
        [CACHE] session_duration -> session_manager.session_duration (cached)
      -> Not module state
      [ASSIGNMENT] Processing: engagement_score = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: engagement_score
    [RESOLVE] Attempting to resolve: ['engagement_score']
      [RESOLVE_SIMPLE] Resolving base: engagement_score
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable engagement_score not found in any scope
      [LOCAL_RESOLVER] can_resolve(engagement_score): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(engagement_score): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(engagement_score): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(engagement_score): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(engagement_score): session_manager.engagement_score
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: engagement_score -> session_manager.engagement_score
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.engagement_score
      -> Not module state
      [NAME] Found name reference: activity_score
        [CACHE] activity_score -> session_manager.activity_score (cached)
      -> Not module state
      [NAME] Found name reference: room_diversity
        [CACHE] room_diversity -> session_manager.room_diversity (cached)
      -> Not module state
      [NAME] Found name reference: interaction_ratio
        [CACHE] interaction_ratio -> session_manager.interaction_ratio (cached)
      -> Not module state
      [NAME] Found name reference: duration_factor
        [CACHE] duration_factor -> session_manager.duration_factor (cached)
      -> Not module state
      [CALL] Found call: min
      -> IGNORED (built-in function)
      [NAME] Found name reference: min
        [CACHE] min -> session_manager.min (cached)
      -> Not module state
      [NAME] Found name reference: engagement_score
        [CACHE] engagement_score -> session_manager.engagement_score (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionAnalytics.compute_user_engagement_score
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionAnalytics.compute_user_engagement_score
        Calls: 1
        Instantiations: 0
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: session_manager.SessionAnalytics._get_user_session
    [CONTEXT] Entered function: session_manager.SessionAnalytics._get_user_session (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'user_id': 'str'}
        [ARG_TYPE] Processing type annotation for user_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [SYMBOL_UPDATE] Function: user_id -> session_manager.str
        [ARG_TYPE] RESOLVED user_id : session_manager.str
      [ATTRIBUTE] Found attribute access: self.session_manager.session_lock
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'session_lock']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'session_lock']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionAnalytics
      [CHAIN] Base resolved: self -> session_manager.SessionAnalytics
      [CHAIN] Step 1: Resolving session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 2: Resolving session_manager.SessionAnalytics.session_manager.session_lock
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager.session_lock
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager.session_lock
      [CHAIN] Step 2 resolved: session_manager.SessionAnalytics.session_manager.session_lock
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics.session_manager.session_lock
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
    [RESOLVE] Attempting to resolve: ['self', 'session_manager']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionAnalytics
      [CHAIN] Base resolved: self -> session_manager.SessionAnalytics
      [CHAIN] Step 1: Resolving session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionAnalytics.session_manager
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics.session_manager
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionAnalytics
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics
      -> Not module state
      [NAME] Found name reference: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable session_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(session_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(session_id): False (current_class: session_manager.SessionAnalytics)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(session_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(session_id): True (fallback, module: session_manager)
      [MODULE_RESOLVER] resolve(session_id): session_manager.session_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: session_id -> session_manager.session_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.session_id
      -> Not module state
      [CALL] Found call: self.session_manager.user_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'user_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'user_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionAnalytics
      [CHAIN] Base resolved: self -> session_manager.SessionAnalytics
      [CHAIN] Step 1: Resolving session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 2: Resolving session_manager.SessionAnalytics.session_manager.user_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager.user_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager.user_sessions
      [CHAIN] Step 2 resolved: session_manager.SessionAnalytics.session_manager.user_sessions
      [CHAIN] Step 3: Resolving session_manager.SessionAnalytics.session_manager.user_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager.user_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager.user_sessions.get
      [CHAIN] Step 3 resolved: session_manager.SessionAnalytics.session_manager.user_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics.session_manager.user_sessions.get
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.user_sessions.get
            [INTERMEDIATE] Step 1: self.session_manager
    [CACHE] self.session_manager -> session_manager.SessionAnalytics.session_manager (cached)
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionAnalytics.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.user_sessions
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'user_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'user_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionAnalytics
      [CHAIN] Base resolved: self -> session_manager.SessionAnalytics
      [CHAIN] Step 1: Resolving session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 2: Resolving session_manager.SessionAnalytics.session_manager.user_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager.user_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager.user_sessions
      [CHAIN] Step 2 resolved: session_manager.SessionAnalytics.session_manager.user_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics.session_manager.user_sessions
            [INTERMEDIATE] Step 2 resolved to: session_manager.SessionAnalytics.session_manager.user_sessions
            [INTERMEDIATE] Step 3: self.session_manager.user_sessions.get
      -> Resolved to: session_manager.SessionAnalytics.session_manager.user_sessions.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      [ATTRIBUTE] Found attribute access: self.session_manager.user_sessions.get
        [CACHE] self.session_manager.user_sessions.get -> session_manager.SessionAnalytics.session_manager.user_sessions.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager.user_sessions
        [CACHE] self.session_manager.user_sessions -> session_manager.SessionAnalytics.session_manager.user_sessions (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> session_manager.SessionAnalytics.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionAnalytics (cached)
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: session_manager.str
    [RESOLVE] RESOLVED to: session_manager.str
      -> Not module state
      [ASSIGNMENT] Processing: session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.session_manager.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionAnalytics
      [CHAIN] Base resolved: self -> session_manager.SessionAnalytics
      [CHAIN] Step 1: Resolving session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 2: Resolving session_manager.SessionAnalytics.session_manager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager.active_sessions
      [CHAIN] Step 2 resolved: session_manager.SessionAnalytics.session_manager.active_sessions
      [CHAIN] Step 3: Resolving session_manager.SessionAnalytics.session_manager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager.active_sessions.get
      [CHAIN] Step 3 resolved: session_manager.SessionAnalytics.session_manager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics.session_manager.active_sessions.get
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionAnalytics.session_manager.active_sessions.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for session
      [NAME] Found name reference: session
    [RESOLVE] Attempting to resolve: ['session']
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: self.session_manager.active_sessions.get
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'active_sessions', 'get']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'active_sessions', 'get']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionAnalytics
      [CHAIN] Base resolved: self -> session_manager.SessionAnalytics
      [CHAIN] Step 1: Resolving session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 2: Resolving session_manager.SessionAnalytics.session_manager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager.active_sessions
      [CHAIN] Step 2 resolved: session_manager.SessionAnalytics.session_manager.active_sessions
      [CHAIN] Step 3: Resolving session_manager.SessionAnalytics.session_manager.active_sessions.get
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager.active_sessions.get
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager.active_sessions.get
      [CHAIN] Step 3 resolved: session_manager.SessionAnalytics.session_manager.active_sessions.get
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics.session_manager.active_sessions.get
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.active_sessions.get
            [INTERMEDIATE] Step 1: self.session_manager
    [CACHE] self.session_manager -> session_manager.SessionAnalytics.session_manager (cached)
            [INTERMEDIATE] Step 1 resolved to: session_manager.SessionAnalytics.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.active_sessions
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'active_sessions']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'active_sessions']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: session_manager.SessionAnalytics
      [CHAIN] Base resolved: self -> session_manager.SessionAnalytics
      [CHAIN] Step 1: Resolving session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 1 resolved: session_manager.SessionAnalytics.session_manager
      [CHAIN] Step 2: Resolving session_manager.SessionAnalytics.session_manager.active_sessions
        [ATTRIBUTE] Resolving attribute: session_manager.SessionAnalytics.session_manager.active_sessions
        [ATTRIBUTE] Direct match found: session_manager.SessionAnalytics.session_manager.active_sessions
      [CHAIN] Step 2 resolved: session_manager.SessionAnalytics.session_manager.active_sessions
    [RESOLVE] RESOLVED to: session_manager.SessionAnalytics.session_manager.active_sessions
            [INTERMEDIATE] Step 2 resolved to: session_manager.SessionAnalytics.session_manager.active_sessions
            [INTERMEDIATE] Step 3: self.session_manager.active_sessions.get
      -> Resolved to: session_manager.SessionAnalytics.session_manager.active_sessions.get
      -> REJECTED (not in catalog or allowlist)
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: session_manager.session_id
    [RESOLVE] RESOLVED to: session_manager.session_id
      [ATTRIBUTE] Found attribute access: self.session_manager.active_sessions.get
        [CACHE] self.session_manager.active_sessions.get -> session_manager.SessionAnalytics.session_manager.active_sessions.get (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager.active_sessions
        [CACHE] self.session_manager.active_sessions -> session_manager.SessionAnalytics.session_manager.active_sessions (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> session_manager.SessionAnalytics.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> session_manager.SessionAnalytics (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> session_manager.session_id (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [CALL] Found call: session.is_valid
    [RESOLVE] Attempting to resolve: ['session', 'is_valid']
    [RESOLVE] Chain resolution needed for: ['session', 'is_valid']
      [CHAIN] Resolving base: session
      [RESOLVE_SIMPLE] Resolving base: session
      [CACHE] Hit for session: session_manager.UserSession
      [CHAIN] Base resolved: session -> session_manager.UserSession
      [CHAIN] Step 1: Resolving session_manager.UserSession.is_valid
        [ATTRIBUTE] Resolving attribute: session_manager.UserSession.is_valid
        [ATTRIBUTE] Direct match found: session_manager.UserSession.is_valid
      [CHAIN] Step 1 resolved: session_manager.UserSession.is_valid
    [RESOLVE] RESOLVED to: session_manager.UserSession.is_valid
            [INTERMEDIATE] Tracking chain steps for: session.is_valid
            [INTERMEDIATE] Step 1: session.is_valid
      -> Resolved to: session_manager.UserSession.is_valid
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session.is_valid
        [CACHE] session.is_valid -> session_manager.UserSession.is_valid (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
      [NAME] Found name reference: session
        [CACHE] session -> session_manager.UserSession (cached)
      -> Not module state
    [CONTEXT] Exited function: session_manager.SessionAnalytics._get_user_session
    [FUNCTION_ANALYSIS] Completed analysis of: session_manager.SessionAnalytics._get_user_session
        Calls: 1
        Instantiations: 0
        State Access: 0
    [CONTEXT] Exited class: session_manager.SessionAnalytics
    [SYMBOL_TABLE] Exited class scope
=== Module Analysis Complete ===
  Module analysis complete
=== Analyzing socketio_events.py ===
  [RESOLVER] Using implementation: refactored
=== Starting Module Analysis ===
    [FROM_IMPORT] Dict -> typing.Dict
    [FROM_IMPORT] Any -> typing.Any
    [FROM_IMPORT] Optional -> typing.Optional
    [FROM_IMPORT] Callable -> typing.Callable
    [FROM_IMPORT] List -> typing.List
    [FROM_IMPORT] Union -> typing.Union
    [FROM_IMPORT] wraps -> functools.wraps
    [IMPORT] logging -> logging
    [FROM_IMPORT] SocketIO -> flask_socketio.SocketIO
    [FROM_IMPORT] emit -> flask_socketio.emit
    [FROM_IMPORT] disconnect -> flask_socketio.disconnect
    [FROM_IMPORT] join_room -> flask_socketio.join_room
    [FROM_IMPORT] leave_room -> flask_socketio.leave_room
    [FROM_IMPORT] trace -> decorators.trace
    [FROM_IMPORT] monitor_performance -> decorators.monitor_performance
    [FROM_IMPORT] validate_auth -> decorators.validate_auth
    [FROM_IMPORT] rate_limit -> decorators.rate_limit
    [FROM_IMPORT] SessionManager -> session_manager.SessionManager
    [FROM_IMPORT] UserSession -> session_manager.UserSession
    [FROM_IMPORT] HavenProxy -> proxy_handler.HavenProxy
    [FROM_IMPORT] DataProxy -> proxy_handler.DataProxy
    [FROM_IMPORT] EventValidator -> event_validator.EventValidator
    [FROM_IMPORT] MessageValidator -> event_validator.MessageValidator
    [MODULE_STATE] _socketio_instance : Optional[SocketIO] = None
    [MODULE_STATE] _haven_proxy : Optional[HavenProxy] = None
    [MODULE_STATE] _session_manager : Optional[SessionManager] = None
    [MODULE_STATE] EVENT_HANDLERS : Dict[str, Callable] = {}
    [MODULE_STATE] ACTIVE_ROOMS : Dict[str, List[str]] = {}
  [CLASS] Analyzing class: SocketIOEventRegistry
    [CONTEXT] Entered class: socketio_events.SocketIOEventRegistry
    [SYMBOL_TABLE] Entered class scope
    [FUNCTION_ANALYSIS] Starting analysis of: socketio_events.SocketIOEventRegistry.__init__
    [CONTEXT] Entered function: socketio_events.SocketIOEventRegistry.__init__ (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'socketio': 'SocketIO', 'session_manager': 'SessionManager'}
        [ARG_TYPE] Processing type annotation for socketio: SocketIO
    [RESOLVE] Attempting to resolve: ['SocketIO']
      [RESOLVE_SIMPLE] Resolving base: SocketIO
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable SocketIO not found in any scope
      [LOCAL_RESOLVER] can_resolve(SocketIO): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(SocketIO): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(SocketIO): True (import: True, external: True)
      [IMPORT_RESOLVER] resolve(SocketIO): flask_socketio.SocketIO (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: SocketIO -> flask_socketio.SocketIO
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: flask_socketio.SocketIO
      [SYMBOL_UPDATE] Function: socketio -> flask_socketio.SocketIO
        [ARG_TYPE] RESOLVED socketio : flask_socketio.SocketIO
        [ARG_TYPE] Processing type annotation for session_manager: SessionManager
    [RESOLVE] Attempting to resolve: ['SessionManager']
      [RESOLVE_SIMPLE] Resolving base: SessionManager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable SessionManager not found in any scope
      [LOCAL_RESOLVER] can_resolve(SessionManager): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(SessionManager): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(SessionManager): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(SessionManager): session_manager.SessionManager (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: SessionManager -> session_manager.SessionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      [SYMBOL_UPDATE] Function: session_manager -> session_manager.SessionManager
        [ARG_TYPE] RESOLVED session_manager : session_manager.SessionManager
      [ATTRIBUTE] Found attribute access: self.socketio
    [RESOLVE] Attempting to resolve: ['self', 'socketio']
    [RESOLVE] Chain resolution needed for: ['self', 'socketio']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable self not found in any scope
      [LOCAL_RESOLVER] can_resolve(self): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(self): True (current_class: socketio_events.SocketIOEventRegistry)
      [SELF_RESOLVER] resolve(self): socketio_events.SocketIOEventRegistry
      [STRATEGY] SUCCESS SelfResolverVisitor succeeded: self -> socketio_events.SocketIOEventRegistry
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.socketio
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.socketio
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.socketio
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry
      -> Not module state
      [NAME] Found name reference: socketio
    [RESOLVE] Attempting to resolve: ['socketio']
      [RESOLVE_SIMPLE] Resolving base: socketio
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found socketio in function scope: flask_socketio.SocketIO
      [LOCAL_RESOLVER] can_resolve(socketio): True
      [SYMBOL_LOOKUP] Found socketio in function scope: flask_socketio.SocketIO
      [LOCAL_RESOLVER] resolve(socketio): flask_socketio.SocketIO
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: socketio -> flask_socketio.SocketIO
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: flask_socketio.SocketIO
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
    [RESOLVE] Attempting to resolve: ['self', 'session_manager']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: session_manager
    [RESOLVE] Attempting to resolve: ['session_manager']
      [RESOLVE_SIMPLE] Resolving base: session_manager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found session_manager in function scope: session_manager.SessionManager
      [LOCAL_RESOLVER] can_resolve(session_manager): True
      [SYMBOL_LOOKUP] Found session_manager in function scope: session_manager.SessionManager
      [LOCAL_RESOLVER] resolve(session_manager): session_manager.SessionManager
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: session_manager -> session_manager.SessionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.event_validator
    [RESOLVE] Attempting to resolve: ['self', 'event_validator']
    [RESOLVE] Chain resolution needed for: ['self', 'event_validator']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.event_validator
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.event_validator
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.event_validator
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.event_validator
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.event_validator
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [CALL] Found call: EventValidator
    [RESOLVE] Attempting to resolve: ['EventValidator']
      [RESOLVE_SIMPLE] Resolving base: EventValidator
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable EventValidator not found in any scope
      [LOCAL_RESOLVER] can_resolve(EventValidator): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(EventValidator): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(EventValidator): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(EventValidator): event_validator.EventValidator (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: EventValidator -> event_validator.EventValidator
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.EventValidator
      -> Resolved to: event_validator.EventValidator
      -> ADDED to instantiations
      [NAME] Found name reference: EventValidator
        [CACHE] EventValidator -> event_validator.EventValidator (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.message_validator
    [RESOLVE] Attempting to resolve: ['self', 'message_validator']
    [RESOLVE] Chain resolution needed for: ['self', 'message_validator']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.message_validator
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.message_validator
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.message_validator
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.message_validator
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.message_validator
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [CALL] Found call: MessageValidator
    [RESOLVE] Attempting to resolve: ['MessageValidator']
      [RESOLVE_SIMPLE] Resolving base: MessageValidator
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable MessageValidator not found in any scope
      [LOCAL_RESOLVER] can_resolve(MessageValidator): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(MessageValidator): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(MessageValidator): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(MessageValidator): event_validator.MessageValidator (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: MessageValidator -> event_validator.MessageValidator
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: event_validator.MessageValidator
      -> Resolved to: event_validator.MessageValidator
      -> ADDED to instantiations
      [NAME] Found name reference: MessageValidator
        [CACHE] MessageValidator -> event_validator.MessageValidator (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.registered_events
    [RESOLVE] Attempting to resolve: ['self', 'registered_events']
    [RESOLVE] Chain resolution needed for: ['self', 'registered_events']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.registered_events
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.registered_events
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.registered_events
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.registered_events
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.registered_events
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: Dict
    [RESOLVE] Attempting to resolve: ['Dict']
      [RESOLVE_SIMPLE] Resolving base: Dict
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Dict not found in any scope
      [LOCAL_RESOLVER] can_resolve(Dict): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Dict): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Dict): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Dict): typing.Dict (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Dict -> typing.Dict
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Dict
      -> Not module state
      [NAME] Found name reference: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(str): socketio_events.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> socketio_events.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.str
      -> Not module state
      [NAME] Found name reference: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable Callable not found in any scope
      [LOCAL_RESOLVER] can_resolve(Callable): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(Callable): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(Callable): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(Callable): typing.Callable (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: Callable -> typing.Callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Callable
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.middleware_stack
    [RESOLVE] Attempting to resolve: ['self', 'middleware_stack']
    [RESOLVE] Chain resolution needed for: ['self', 'middleware_stack']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.middleware_stack
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.middleware_stack
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.middleware_stack
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.middleware_stack
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.middleware_stack
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: List
    [RESOLVE] Attempting to resolve: ['List']
      [RESOLVE_SIMPLE] Resolving base: List
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable List not found in any scope
      [LOCAL_RESOLVER] can_resolve(List): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(List): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(List): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(List): typing.List (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: List -> typing.List
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.List
      -> Not module state
      [NAME] Found name reference: Callable
        [CACHE] Callable -> typing.Callable (cached)
      -> Not module state
    [CONTEXT] Exited function: socketio_events.SocketIOEventRegistry.__init__
    [FUNCTION_ANALYSIS] Completed analysis of: socketio_events.SocketIOEventRegistry.__init__
        Calls: 0
        Instantiations: 2
        State Access: 0
    [FUNCTION_ANALYSIS] Starting analysis of: socketio_events.SocketIOEventRegistry.register_dynamic_event
    [DECORATOR] @trace
    [DECORATOR] @monitor_performance
    [CONTEXT] Entered function: socketio_events.SocketIOEventRegistry.register_dynamic_event (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'event_name': 'str', 'handler': 'Callable'}
        [ARG_TYPE] Processing type annotation for event_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: socketio_events.str
    [RESOLVE] RESOLVED to: socketio_events.str
      [SYMBOL_UPDATE] Function: event_name -> socketio_events.str
        [ARG_TYPE] RESOLVED event_name : socketio_events.str
        [ARG_TYPE] Processing type annotation for handler: Callable
    [RESOLVE] Attempting to resolve: ['Callable']
      [RESOLVE_SIMPLE] Resolving base: Callable
      [CACHE] Hit for Callable: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [SYMBOL_UPDATE] Function: handler -> typing.Callable
        [ARG_TYPE] RESOLVED handler : typing.Callable
      [NESTED_FUNCTION] Analyzing nested function: wrapped_handler
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 0 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'event_name': 'str', 'handler': 'Callable'}
      [CALL] Found call: self.socketio.emit
    [RESOLVE] Attempting to resolve: ['self', 'socketio', 'emit']
    [RESOLVE] Chain resolution needed for: ['self', 'socketio', 'emit']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.socketio
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.socketio
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.socketio.emit
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.socketio.emit
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.socketio.emit
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.socketio.emit
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.socketio.emit
            [INTERMEDIATE] Tracking chain steps for: self.socketio.emit
            [INTERMEDIATE] Step 1: self.socketio
    [RESOLVE] Attempting to resolve: ['self', 'socketio']
    [RESOLVE] Chain resolution needed for: ['self', 'socketio']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.socketio
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.socketio
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.socketio
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.socketio
            [INTERMEDIATE] Step 2: self.socketio.emit
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.socketio.emit
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.socketio.emit::event_received
      [ATTRIBUTE] Found attribute access: self.socketio.emit
        [CACHE] self.socketio.emit -> socketio_events.SocketIOEventRegistry.socketio.emit (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.socketio
        [CACHE] self.socketio -> socketio_events.SocketIOEventRegistry.socketio (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry
      -> Not module state
      [NAME] Found name reference: event_name
    [RESOLVE] Attempting to resolve: ['event_name']
      [RESOLVE_SIMPLE] Resolving base: event_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found event_name in function scope: socketio_events.str
      [LOCAL_RESOLVER] can_resolve(event_name): True
      [SYMBOL_LOOKUP] Found event_name in function scope: socketio_events.str
      [LOCAL_RESOLVER] resolve(event_name): socketio_events.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: event_name -> socketio_events.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.str
      -> Not module state
      [CALL] Found call: self.session_manager.get_current_timestamp
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'get_current_timestamp']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'get_current_timestamp']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: self.session_manager
    [RESOLVE] Attempting to resolve: ['self', 'session_manager']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.get_current_timestamp
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp::unknown_event
      [ATTRIBUTE] Found attribute access: self.session_manager.get_current_timestamp
        [CACHE] self.session_manager.get_current_timestamp -> socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [CALL] Found call: self.session_manager.get_current_session_id
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'get_current_session_id']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'get_current_session_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.session_manager.get_current_session_id
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager.get_current_session_id
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager.get_current_session_id
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.session_manager.get_current_session_id
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager.get_current_session_id
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.get_current_session_id
            [INTERMEDIATE] Step 1: self.session_manager
    [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.get_current_session_id
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.session_manager.get_current_session_id
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.session_manager.get_current_session_id::unknown_event
      [ATTRIBUTE] Found attribute access: self.session_manager.get_current_session_id
        [CACHE] self.session_manager.get_current_session_id -> socketio_events.SocketIOEventRegistry.session_manager.get_current_session_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: handler
    [RESOLVE] Attempting to resolve: ['handler']
      [RESOLVE_SIMPLE] Resolving base: handler
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found handler in function scope: typing.Callable
      [LOCAL_RESOLVER] can_resolve(handler): True
      [SYMBOL_LOOKUP] Found handler in function scope: typing.Callable
      [LOCAL_RESOLVER] resolve(handler): typing.Callable
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: handler -> typing.Callable
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: typing.Callable
      [TYPE_INFERENCE] Call resolved to: typing.Callable
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for result
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable result not found in any scope
      [LOCAL_RESOLVER] can_resolve(result): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(result): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(result): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(result): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(result): socketio_events.result
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: result -> socketio_events.result
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.result
      -> Not module state
      [CALL] Found call: handler
    [RESOLVE] Attempting to resolve: ['handler']
      [RESOLVE_SIMPLE] Resolving base: handler
      [CACHE] Hit for handler: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      -> Resolved to: typing.Callable
      -> REJECTED (not in catalog or allowlist)
      [NAME] Found name reference: handler
        [CACHE] handler -> typing.Callable (cached)
      -> Not module state
      [NAME] Found name reference: args
    [RESOLVE] Attempting to resolve: ['args']
      [RESOLVE_SIMPLE] Resolving base: args
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable args not found in any scope
      [LOCAL_RESOLVER] can_resolve(args): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(args): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(args): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(args): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(args): socketio_events.args
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: args -> socketio_events.args
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.args
      -> Not module state
      [NAME] Found name reference: kwargs
    [RESOLVE] Attempting to resolve: ['kwargs']
      [RESOLVE_SIMPLE] Resolving base: kwargs
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable kwargs not found in any scope
      [LOCAL_RESOLVER] can_resolve(kwargs): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(kwargs): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(kwargs): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(kwargs): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(kwargs): socketio_events.kwargs
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: kwargs -> socketio_events.kwargs
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.kwargs
      -> Not module state
      [CALL] Found call: self.event_validator.validate_result
    [RESOLVE] Attempting to resolve: ['self', 'event_validator', 'validate_result']
    [RESOLVE] Chain resolution needed for: ['self', 'event_validator', 'validate_result']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.event_validator
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.event_validator
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.event_validator
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.event_validator
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.event_validator.validate_result
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.event_validator.validate_result
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.event_validator.validate_result
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.event_validator.validate_result
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.event_validator.validate_result
            [INTERMEDIATE] Tracking chain steps for: self.event_validator.validate_result
            [INTERMEDIATE] Step 1: self.event_validator
    [RESOLVE] Attempting to resolve: ['self', 'event_validator']
    [RESOLVE] Chain resolution needed for: ['self', 'event_validator']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.event_validator
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.event_validator
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.event_validator
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.event_validator
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.event_validator
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.event_validator
            [INTERMEDIATE] Step 2: self.event_validator.validate_result
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.event_validator.validate_result
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.event_validator.validate_result::$result
        [FUNCTION_ARG] Checking argument: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: socketio_events.result
    [RESOLVE] RESOLVED to: socketio_events.result
      [ATTRIBUTE] Found attribute access: self.event_validator.validate_result
        [CACHE] self.event_validator.validate_result -> socketio_events.SocketIOEventRegistry.event_validator.validate_result (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.event_validator
        [CACHE] self.event_validator -> socketio_events.SocketIOEventRegistry.event_validator (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> socketio_events.result (cached)
      -> Not module state
      [CALL] Found call: self.socketio.emit
    [CACHE] self.socketio.emit -> socketio_events.SocketIOEventRegistry.socketio.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: self.socketio.emit
            [INTERMEDIATE] Step 1: self.socketio
    [CACHE] self.socketio -> socketio_events.SocketIOEventRegistry.socketio (cached)
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.socketio
            [INTERMEDIATE] Step 2: self.socketio.emit
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.socketio.emit
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.socketio.emit::${event_name}_success
        [EMIT] Room parameter: dynamic_value
      [ATTRIBUTE] Found attribute access: self.socketio.emit
        [CACHE] self.socketio.emit -> socketio_events.SocketIOEventRegistry.socketio.emit (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.socketio
        [CACHE] self.socketio -> socketio_events.SocketIOEventRegistry.socketio (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: event_name
        [CACHE] event_name -> socketio_events.str (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> socketio_events.result (cached)
      -> Not module state
      [CALL] Found call: self.event_validator.get_validation_details
    [RESOLVE] Attempting to resolve: ['self', 'event_validator', 'get_validation_details']
    [RESOLVE] Chain resolution needed for: ['self', 'event_validator', 'get_validation_details']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.event_validator
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.event_validator
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.event_validator
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.event_validator
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.event_validator.get_validation_details
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.event_validator.get_validation_details
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.event_validator.get_validation_details
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.event_validator.get_validation_details
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.event_validator.get_validation_details
            [INTERMEDIATE] Tracking chain steps for: self.event_validator.get_validation_details
            [INTERMEDIATE] Step 1: self.event_validator
    [CACHE] self.event_validator -> socketio_events.SocketIOEventRegistry.event_validator (cached)
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.event_validator
            [INTERMEDIATE] Step 2: self.event_validator.get_validation_details
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.event_validator.get_validation_details
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.event_validator.get_validation_details::unknown_event
      [ATTRIBUTE] Found attribute access: self.event_validator.get_validation_details
        [CACHE] self.event_validator.get_validation_details -> socketio_events.SocketIOEventRegistry.event_validator.get_validation_details (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.event_validator
        [CACHE] self.event_validator -> socketio_events.SocketIOEventRegistry.event_validator (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [CALL] Found call: self.session_manager.get_user_room
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'get_user_room']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'get_user_room']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.session_manager.get_user_room
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.get_user_room
            [INTERMEDIATE] Step 1: self.session_manager
    [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.get_user_room
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.session_manager.get_user_room::unknown_event
      [ATTRIBUTE] Found attribute access: self.session_manager.get_user_room
        [CACHE] self.session_manager.get_user_room -> socketio_events.SocketIOEventRegistry.session_manager.get_user_room (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> socketio_events.result (cached)
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [ATTRIBUTE] Found attribute access: self.registered_events
    [RESOLVE] Attempting to resolve: ['self', 'registered_events']
    [RESOLVE] Chain resolution needed for: ['self', 'registered_events']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.registered_events
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.registered_events
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.registered_events
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.registered_events
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.registered_events
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: event_name
        [CACHE] event_name -> socketio_events.str (cached)
      -> Not module state
      [NAME] Found name reference: wrapped_handler
    [RESOLVE] Attempting to resolve: ['wrapped_handler']
      [RESOLVE_SIMPLE] Resolving base: wrapped_handler
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable wrapped_handler not found in any scope
      [LOCAL_RESOLVER] can_resolve(wrapped_handler): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(wrapped_handler): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(wrapped_handler): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(wrapped_handler): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(wrapped_handler): socketio_events.wrapped_handler
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: wrapped_handler -> socketio_events.wrapped_handler
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.wrapped_handler
      -> Not module state
    [CONTEXT] Exited function: socketio_events.SocketIOEventRegistry.register_dynamic_event
    [FUNCTION_ANALYSIS] Completed analysis of: socketio_events.SocketIOEventRegistry.register_dynamic_event
        Calls: 7
        Instantiations: 0
        State Access: 0
        SocketIO Emits: 2
    [FUNCTION_ANALYSIS] Starting analysis of: socketio_events.SocketIOEventRegistry.batch_register_events
    [CONTEXT] Entered function: socketio_events.SocketIOEventRegistry.batch_register_events (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'event_configs': 'List[Dict[str, Any]]'}
      [NAME] Found name reference: config
    [RESOLVE] Attempting to resolve: ['config']
      [RESOLVE_SIMPLE] Resolving base: config
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable config not found in any scope
      [LOCAL_RESOLVER] can_resolve(config): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(config): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(config): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(config): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(config): socketio_events.config
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: config -> socketio_events.config
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.config
      -> Not module state
      [NAME] Found name reference: event_configs
    [RESOLVE] Attempting to resolve: ['event_configs']
      [RESOLVE_SIMPLE] Resolving base: event_configs
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable event_configs not found in any scope
      [LOCAL_RESOLVER] can_resolve(event_configs): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(event_configs): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(event_configs): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(event_configs): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(event_configs): socketio_events.event_configs
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: event_configs -> socketio_events.event_configs
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.event_configs
      -> Not module state
      [ASSIGNMENT] Processing: event_name = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: event_name
    [RESOLVE] Attempting to resolve: ['event_name']
      [RESOLVE_SIMPLE] Resolving base: event_name
      [CACHE] Hit for event_name: socketio_events.str
    [RESOLVE] RESOLVED to: socketio_events.str
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> socketio_events.config (cached)
      -> Not module state
      [ASSIGNMENT] Processing: handler = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.create_event_handler
    [RESOLVE] Attempting to resolve: ['self', 'create_event_handler']
    [RESOLVE] Chain resolution needed for: ['self', 'create_event_handler']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.create_event_handler
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.create_event_handler
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.create_event_handler
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.create_event_handler
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.create_event_handler
      [TYPE_INFERENCE] Call resolved to: socketio_events.SocketIOEventRegistry.create_event_handler
        [RETURN_TYPE_RESOLUTION] Resolving return type: Callable
        [RETURN_TYPE_RESOLUTION] Class 'Callable' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: Callable
      [TYPE_INFERENCE] Could not resolve return type 'Callable' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: Callable (from return type - unresolved)
      [SYMBOL_UPDATE] Function: handler -> Callable
        [ASSIGNMENT] RESOLVED Updated symbol table: handler = Callable
      [NAME] Found name reference: handler
    [RESOLVE] Attempting to resolve: ['handler']
      [RESOLVE_SIMPLE] Resolving base: handler
      [CACHE] Hit for handler: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      -> Not module state
      [CALL] Found call: self.create_event_handler
    [RESOLVE] Attempting to resolve: ['self', 'create_event_handler']
    [RESOLVE] Chain resolution needed for: ['self', 'create_event_handler']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.create_event_handler
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.create_event_handler
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.create_event_handler
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.create_event_handler
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.create_event_handler
            [INTERMEDIATE] Tracking chain steps for: self.create_event_handler
            [INTERMEDIATE] Step 1: self.create_event_handler
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.create_event_handler
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.create_event_handler::$config
        [FUNCTION_ARG] Checking argument: config
    [RESOLVE] Attempting to resolve: ['config']
      [RESOLVE_SIMPLE] Resolving base: config
      [CACHE] Hit for config: socketio_events.config
    [RESOLVE] RESOLVED to: socketio_events.config
      [ATTRIBUTE] Found attribute access: self.create_event_handler
        [CACHE] self.create_event_handler -> socketio_events.SocketIOEventRegistry.create_event_handler (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> socketio_events.config (cached)
      -> Not module state
      [ASSIGNMENT] Processing: decorated_handler = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.apply_middleware_stack
    [RESOLVE] Attempting to resolve: ['self', 'apply_middleware_stack']
    [RESOLVE] Chain resolution needed for: ['self', 'apply_middleware_stack']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.apply_middleware_stack
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.apply_middleware_stack
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.apply_middleware_stack
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.apply_middleware_stack
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.apply_middleware_stack
      [TYPE_INFERENCE] Call resolved to: socketio_events.SocketIOEventRegistry.apply_middleware_stack
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for decorated_handler
      [NAME] Found name reference: decorated_handler
    [RESOLVE] Attempting to resolve: ['decorated_handler']
      [RESOLVE_SIMPLE] Resolving base: decorated_handler
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable decorated_handler not found in any scope
      [LOCAL_RESOLVER] can_resolve(decorated_handler): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(decorated_handler): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(decorated_handler): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(decorated_handler): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(decorated_handler): socketio_events.decorated_handler
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: decorated_handler -> socketio_events.decorated_handler
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.decorated_handler
      -> Not module state
      [CALL] Found call: self.apply_middleware_stack
    [RESOLVE] Attempting to resolve: ['self', 'apply_middleware_stack']
    [RESOLVE] Chain resolution needed for: ['self', 'apply_middleware_stack']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.apply_middleware_stack
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.apply_middleware_stack
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.apply_middleware_stack
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.apply_middleware_stack
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.apply_middleware_stack
            [INTERMEDIATE] Tracking chain steps for: self.apply_middleware_stack
            [INTERMEDIATE] Step 1: self.apply_middleware_stack
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.apply_middleware_stack
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.apply_middleware_stack::$handler
        [FUNCTION_ARG] Checking argument: handler
    [RESOLVE] Attempting to resolve: ['handler']
      [RESOLVE_SIMPLE] Resolving base: handler
      [CACHE] Hit for handler: typing.Callable
    [RESOLVE] RESOLVED to: typing.Callable
      [ATTRIBUTE] Found attribute access: self.apply_middleware_stack
        [CACHE] self.apply_middleware_stack -> socketio_events.SocketIOEventRegistry.apply_middleware_stack (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: handler
        [CACHE] handler -> typing.Callable (cached)
      -> Not module state
      [CALL] Found call: config.get
    [RESOLVE] Attempting to resolve: ['config', 'get']
    [RESOLVE] Chain resolution needed for: ['config', 'get']
      [CHAIN] Resolving base: config
      [RESOLVE_SIMPLE] Resolving base: config
      [CACHE] Hit for config: socketio_events.config
      [CHAIN] Base resolved: config -> socketio_events.config
      [CHAIN] Step 1: Resolving socketio_events.config.get
        [ATTRIBUTE] Resolving attribute: socketio_events.config.get
        [ATTRIBUTE] Direct match found: socketio_events.config.get
      [CHAIN] Step 1 resolved: socketio_events.config.get
    [RESOLVE] RESOLVED to: socketio_events.config.get
            [INTERMEDIATE] Tracking chain steps for: config.get
            [INTERMEDIATE] Step 1: config.get
        [EMIT_DETECTION] Direct FQN match: socketio_events.config.get
      -> DETECTED and ADDED emit call: socketio_events.config.get::middleware
      [ATTRIBUTE] Found attribute access: config.get
        [CACHE] config.get -> socketio_events.config.get (cached)
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> socketio_events.config (cached)
      -> Not module state
      [CALL] Could not extract name parts from call
      [CALL] Found call: self.socketio.on
    [RESOLVE] Attempting to resolve: ['self', 'socketio', 'on']
    [RESOLVE] Chain resolution needed for: ['self', 'socketio', 'on']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.socketio
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.socketio
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.socketio.on
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.socketio.on
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.socketio.on
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.socketio.on
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.socketio.on
            [INTERMEDIATE] Tracking chain steps for: self.socketio.on
            [INTERMEDIATE] Step 1: self.socketio
    [RESOLVE] Attempting to resolve: ['self', 'socketio']
    [RESOLVE] Chain resolution needed for: ['self', 'socketio']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.socketio
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.socketio
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.socketio
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.socketio
            [INTERMEDIATE] Step 2: self.socketio.on
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.socketio.on
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.socketio.on::$event_name
        [FUNCTION_ARG] Checking argument: event_name
    [RESOLVE] Attempting to resolve: ['event_name']
      [RESOLVE_SIMPLE] Resolving base: event_name
      [CACHE] Hit for event_name: socketio_events.str
    [RESOLVE] RESOLVED to: socketio_events.str
      [ATTRIBUTE] Found attribute access: self.socketio.on
        [CACHE] self.socketio.on -> socketio_events.SocketIOEventRegistry.socketio.on (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.socketio
        [CACHE] self.socketio -> socketio_events.SocketIOEventRegistry.socketio (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: event_name
        [CACHE] event_name -> socketio_events.str (cached)
      -> Not module state
      [NAME] Found name reference: decorated_handler
        [CACHE] decorated_handler -> socketio_events.decorated_handler (cached)
      -> Not module state
    [CONTEXT] Exited function: socketio_events.SocketIOEventRegistry.batch_register_events
    [FUNCTION_ANALYSIS] Completed analysis of: socketio_events.SocketIOEventRegistry.batch_register_events
        Calls: 4
        Instantiations: 0
        State Access: 0
        SocketIO Emits: 2
    [FUNCTION_ANALYSIS] Starting analysis of: socketio_events.SocketIOEventRegistry.create_event_handler
    [CONTEXT] Entered function: socketio_events.SocketIOEventRegistry.create_event_handler (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'config': 'Dict[str, Any]'}
      [ASSIGNMENT] Processing: event_type = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: config.get
    [RESOLVE] Attempting to resolve: ['config', 'get']
    [RESOLVE] Chain resolution needed for: ['config', 'get']
      [CHAIN] Resolving base: config
      [RESOLVE_SIMPLE] Resolving base: config
      [CACHE] Hit for config: socketio_events.config
      [CHAIN] Base resolved: config -> socketio_events.config
      [CHAIN] Step 1: Resolving socketio_events.config.get
        [ATTRIBUTE] Resolving attribute: socketio_events.config.get
        [ATTRIBUTE] Direct match found: socketio_events.config.get
      [CHAIN] Step 1 resolved: socketio_events.config.get
    [RESOLVE] RESOLVED to: socketio_events.config.get
      [TYPE_INFERENCE] Call resolved to: socketio_events.config.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for event_type
      [NAME] Found name reference: event_type
    [RESOLVE] Attempting to resolve: ['event_type']
      [RESOLVE_SIMPLE] Resolving base: event_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable event_type not found in any scope
      [LOCAL_RESOLVER] can_resolve(event_type): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(event_type): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(event_type): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(event_type): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(event_type): socketio_events.event_type
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: event_type -> socketio_events.event_type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.event_type
      -> Not module state
      [CALL] Found call: config.get
    [RESOLVE] Attempting to resolve: ['config', 'get']
    [RESOLVE] Chain resolution needed for: ['config', 'get']
      [CHAIN] Resolving base: config
      [RESOLVE_SIMPLE] Resolving base: config
      [CACHE] Hit for config: socketio_events.config
      [CHAIN] Base resolved: config -> socketio_events.config
      [CHAIN] Step 1: Resolving socketio_events.config.get
        [ATTRIBUTE] Resolving attribute: socketio_events.config.get
        [ATTRIBUTE] Direct match found: socketio_events.config.get
      [CHAIN] Step 1 resolved: socketio_events.config.get
    [RESOLVE] RESOLVED to: socketio_events.config.get
            [INTERMEDIATE] Tracking chain steps for: config.get
            [INTERMEDIATE] Step 1: config.get
        [EMIT_DETECTION] Direct FQN match: socketio_events.config.get
      -> DETECTED and ADDED emit call: socketio_events.config.get::type
      [ATTRIBUTE] Found attribute access: config.get
        [CACHE] config.get -> socketio_events.config.get (cached)
      -> Not module state
      [NAME] Found name reference: config
    [RESOLVE] Attempting to resolve: ['config']
      [RESOLVE_SIMPLE] Resolving base: config
      [CACHE] Hit for config: socketio_events.config
    [RESOLVE] RESOLVED to: socketio_events.config
      -> Not module state
      [NAME] Found name reference: event_type
        [CACHE] event_type -> socketio_events.event_type (cached)
      -> Not module state
      [CALL] Found call: self._create_room_handler
    [RESOLVE] Attempting to resolve: ['self', '_create_room_handler']
    [RESOLVE] Chain resolution needed for: ['self', '_create_room_handler']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry._create_room_handler
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry._create_room_handler
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry._create_room_handler
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry._create_room_handler
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry._create_room_handler
            [INTERMEDIATE] Tracking chain steps for: self._create_room_handler
            [INTERMEDIATE] Step 1: self._create_room_handler
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry._create_room_handler
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry._create_room_handler::$config
        [FUNCTION_ARG] Checking argument: config
    [RESOLVE] Attempting to resolve: ['config']
      [RESOLVE_SIMPLE] Resolving base: config
      [CACHE] Hit for config: socketio_events.config
    [RESOLVE] RESOLVED to: socketio_events.config
      [ATTRIBUTE] Found attribute access: self._create_room_handler
        [CACHE] self._create_room_handler -> socketio_events.SocketIOEventRegistry._create_room_handler (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> socketio_events.config (cached)
      -> Not module state
      [NAME] Found name reference: event_type
        [CACHE] event_type -> socketio_events.event_type (cached)
      -> Not module state
      [CALL] Found call: self._create_broadcast_handler
    [RESOLVE] Attempting to resolve: ['self', '_create_broadcast_handler']
    [RESOLVE] Chain resolution needed for: ['self', '_create_broadcast_handler']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry._create_broadcast_handler
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry._create_broadcast_handler
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry._create_broadcast_handler
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry._create_broadcast_handler
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry._create_broadcast_handler
            [INTERMEDIATE] Tracking chain steps for: self._create_broadcast_handler
            [INTERMEDIATE] Step 1: self._create_broadcast_handler
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry._create_broadcast_handler
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry._create_broadcast_handler::$config
        [FUNCTION_ARG] Checking argument: config
    [RESOLVE] Attempting to resolve: ['config']
      [RESOLVE_SIMPLE] Resolving base: config
      [CACHE] Hit for config: socketio_events.config
    [RESOLVE] RESOLVED to: socketio_events.config
      [ATTRIBUTE] Found attribute access: self._create_broadcast_handler
        [CACHE] self._create_broadcast_handler -> socketio_events.SocketIOEventRegistry._create_broadcast_handler (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> socketio_events.config (cached)
      -> Not module state
      [NAME] Found name reference: event_type
        [CACHE] event_type -> socketio_events.event_type (cached)
      -> Not module state
      [CALL] Found call: self._create_auth_handler
    [RESOLVE] Attempting to resolve: ['self', '_create_auth_handler']
    [RESOLVE] Chain resolution needed for: ['self', '_create_auth_handler']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry._create_auth_handler
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry._create_auth_handler
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry._create_auth_handler
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry._create_auth_handler
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry._create_auth_handler
            [INTERMEDIATE] Tracking chain steps for: self._create_auth_handler
            [INTERMEDIATE] Step 1: self._create_auth_handler
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry._create_auth_handler
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry._create_auth_handler::$config
        [FUNCTION_ARG] Checking argument: config
    [RESOLVE] Attempting to resolve: ['config']
      [RESOLVE_SIMPLE] Resolving base: config
      [CACHE] Hit for config: socketio_events.config
    [RESOLVE] RESOLVED to: socketio_events.config
      [ATTRIBUTE] Found attribute access: self._create_auth_handler
        [CACHE] self._create_auth_handler -> socketio_events.SocketIOEventRegistry._create_auth_handler (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> socketio_events.config (cached)
      -> Not module state
      [CALL] Found call: self._create_standard_handler
    [RESOLVE] Attempting to resolve: ['self', '_create_standard_handler']
    [RESOLVE] Chain resolution needed for: ['self', '_create_standard_handler']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry._create_standard_handler
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry._create_standard_handler
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry._create_standard_handler
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry._create_standard_handler
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry._create_standard_handler
            [INTERMEDIATE] Tracking chain steps for: self._create_standard_handler
            [INTERMEDIATE] Step 1: self._create_standard_handler
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry._create_standard_handler
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry._create_standard_handler::$config
        [FUNCTION_ARG] Checking argument: config
    [RESOLVE] Attempting to resolve: ['config']
      [RESOLVE_SIMPLE] Resolving base: config
      [CACHE] Hit for config: socketio_events.config
    [RESOLVE] RESOLVED to: socketio_events.config
      [ATTRIBUTE] Found attribute access: self._create_standard_handler
        [CACHE] self._create_standard_handler -> socketio_events.SocketIOEventRegistry._create_standard_handler (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: config
        [CACHE] config -> socketio_events.config (cached)
      -> Not module state
    [CONTEXT] Exited function: socketio_events.SocketIOEventRegistry.create_event_handler
    [FUNCTION_ANALYSIS] Completed analysis of: socketio_events.SocketIOEventRegistry.create_event_handler
        Calls: 5
        Instantiations: 0
        State Access: 0
        SocketIO Emits: 1
    [FUNCTION_ANALYSIS] Starting analysis of: socketio_events.SocketIOEventRegistry._create_room_handler
    [CONTEXT] Entered function: socketio_events.SocketIOEventRegistry._create_room_handler (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'config': 'Dict[str, Any]'}
      [NESTED_FUNCTION] Analyzing nested function: room_handler
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'config': 'Dict[str, Any]'}
      [ASSIGNMENT] Processing: room_name = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: data.get
    [RESOLVE] Attempting to resolve: ['data', 'get']
    [RESOLVE] Chain resolution needed for: ['data', 'get']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable data not found in any scope
      [LOCAL_RESOLVER] can_resolve(data): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(data): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(data): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(data): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(data): socketio_events.data
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: data -> socketio_events.data
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: data -> socketio_events.data
      [CHAIN] Step 1: Resolving socketio_events.data.get
        [ATTRIBUTE] Resolving attribute: socketio_events.data.get
        [ATTRIBUTE] Direct match found: socketio_events.data.get
      [CHAIN] Step 1 resolved: socketio_events.data.get
    [RESOLVE] RESOLVED to: socketio_events.data.get
      [TYPE_INFERENCE] Call resolved to: socketio_events.data.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for room_name
      [NAME] Found name reference: room_name
    [RESOLVE] Attempting to resolve: ['room_name']
      [RESOLVE_SIMPLE] Resolving base: room_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable room_name not found in any scope
      [LOCAL_RESOLVER] can_resolve(room_name): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(room_name): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(room_name): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(room_name): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(room_name): socketio_events.room_name
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: room_name -> socketio_events.room_name
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.room_name
      -> Not module state
      [CALL] Found call: data.get
    [RESOLVE] Attempting to resolve: ['data', 'get']
    [RESOLVE] Chain resolution needed for: ['data', 'get']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: socketio_events.data
      [CHAIN] Base resolved: data -> socketio_events.data
      [CHAIN] Step 1: Resolving socketio_events.data.get
        [ATTRIBUTE] Resolving attribute: socketio_events.data.get
        [ATTRIBUTE] Direct match found: socketio_events.data.get
      [CHAIN] Step 1 resolved: socketio_events.data.get
    [RESOLVE] RESOLVED to: socketio_events.data.get
            [INTERMEDIATE] Tracking chain steps for: data.get
            [INTERMEDIATE] Step 1: data.get
        [EMIT_DETECTION] Direct FQN match: socketio_events.data.get
      -> DETECTED and ADDED emit call: socketio_events.data.get::room
      [ATTRIBUTE] Found attribute access: data.get
        [CACHE] data.get -> socketio_events.data.get (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: socketio_events.data
    [RESOLVE] RESOLVED to: socketio_events.data
      -> Not module state
      [CALL] Found call: self.session_manager.validate_room_access
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'validate_room_access']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'validate_room_access']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.session_manager.validate_room_access
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager.validate_room_access
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager.validate_room_access
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.session_manager.validate_room_access
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager.validate_room_access
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.validate_room_access
            [INTERMEDIATE] Step 1: self.session_manager
    [RESOLVE] Attempting to resolve: ['self', 'session_manager']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.validate_room_access
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.session_manager.validate_room_access
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.session_manager.validate_room_access::$room_name
        [FUNCTION_ARG] Checking argument: room_name
    [RESOLVE] Attempting to resolve: ['room_name']
      [RESOLVE_SIMPLE] Resolving base: room_name
      [CACHE] Hit for room_name: socketio_events.room_name
    [RESOLVE] RESOLVED to: socketio_events.room_name
      [ATTRIBUTE] Found attribute access: self.session_manager.validate_room_access
        [CACHE] self.session_manager.validate_room_access -> socketio_events.SocketIOEventRegistry.session_manager.validate_room_access (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [CALL] Found call: join_room
    [RESOLVE] Attempting to resolve: ['join_room']
      [RESOLVE_SIMPLE] Resolving base: join_room
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable join_room not found in any scope
      [LOCAL_RESOLVER] can_resolve(join_room): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(join_room): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(join_room): True (import: True, external: True)
      [IMPORT_RESOLVER] resolve(join_room): flask_socketio.join_room (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: join_room -> flask_socketio.join_room
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: flask_socketio.join_room
        [EMIT_DETECTION] Direct FQN match: flask_socketio.join_room
      -> DETECTED and ADDED emit call: flask_socketio.join_room::$room_name
        [FUNCTION_ARG] Checking argument: room_name
    [RESOLVE] Attempting to resolve: ['room_name']
      [RESOLVE_SIMPLE] Resolving base: room_name
      [CACHE] Hit for room_name: socketio_events.room_name
    [RESOLVE] RESOLVED to: socketio_events.room_name
      [NAME] Found name reference: join_room
        [CACHE] join_room -> flask_socketio.join_room (cached)
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [CALL] Found call: self.socketio.emit
    [RESOLVE] Attempting to resolve: ['self', 'socketio', 'emit']
    [RESOLVE] Chain resolution needed for: ['self', 'socketio', 'emit']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.socketio
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.socketio
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.socketio.emit
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.socketio.emit
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.socketio.emit
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.socketio.emit
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.socketio.emit
            [INTERMEDIATE] Tracking chain steps for: self.socketio.emit
            [INTERMEDIATE] Step 1: self.socketio
    [RESOLVE] Attempting to resolve: ['self', 'socketio']
    [RESOLVE] Chain resolution needed for: ['self', 'socketio']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.socketio
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.socketio
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.socketio
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.socketio
            [INTERMEDIATE] Step 2: self.socketio.emit
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.socketio.emit
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.socketio.emit::user_joined_room
        [EMIT] Room parameter: $room_name
      [ATTRIBUTE] Found attribute access: self.socketio.emit
        [CACHE] self.socketio.emit -> socketio_events.SocketIOEventRegistry.socketio.emit (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.socketio
        [CACHE] self.socketio -> socketio_events.SocketIOEventRegistry.socketio (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [CALL] Found call: self.session_manager.get_current_user_id
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'get_current_user_id']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'get_current_user_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.get_current_user_id
            [INTERMEDIATE] Step 1: self.session_manager
    [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.get_current_user_id
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id::unknown_event
      [ATTRIBUTE] Found attribute access: self.session_manager.get_current_user_id
        [CACHE] self.session_manager.get_current_user_id -> socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [CALL] Found call: self.session_manager.get_current_timestamp
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'get_current_timestamp']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'get_current_timestamp']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: self.session_manager
    [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.get_current_timestamp
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp::unknown_event
      [ATTRIBUTE] Found attribute access: self.session_manager.get_current_timestamp
        [CACHE] self.session_manager.get_current_timestamp -> socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [NAME] Found name reference: active_room
    [RESOLVE] Attempting to resolve: ['active_room']
      [RESOLVE_SIMPLE] Resolving base: active_room
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable active_room not found in any scope
      [LOCAL_RESOLVER] can_resolve(active_room): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(active_room): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(active_room): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(active_room): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(active_room): socketio_events.active_room
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: active_room -> socketio_events.active_room
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.active_room
      -> Not module state
      [CALL] Found call: ACTIVE_ROOMS.get
    [RESOLVE] Attempting to resolve: ['ACTIVE_ROOMS', 'get']
    [RESOLVE] Chain resolution needed for: ['ACTIVE_ROOMS', 'get']
      [CHAIN] Resolving base: ACTIVE_ROOMS
      [RESOLVE_SIMPLE] Resolving base: ACTIVE_ROOMS
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable ACTIVE_ROOMS not found in any scope
      [LOCAL_RESOLVER] can_resolve(ACTIVE_ROOMS): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(ACTIVE_ROOMS): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(ACTIVE_ROOMS): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(ACTIVE_ROOMS): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(ACTIVE_ROOMS): socketio_events.ACTIVE_ROOMS
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: ACTIVE_ROOMS -> socketio_events.ACTIVE_ROOMS
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: ACTIVE_ROOMS -> socketio_events.ACTIVE_ROOMS
      [CHAIN] Step 1: Resolving socketio_events.ACTIVE_ROOMS.get
        [ATTRIBUTE] Resolving attribute: socketio_events.ACTIVE_ROOMS.get
        [ATTRIBUTE] Direct match found: socketio_events.ACTIVE_ROOMS.get
      [CHAIN] Step 1 resolved: socketio_events.ACTIVE_ROOMS.get
    [RESOLVE] RESOLVED to: socketio_events.ACTIVE_ROOMS.get
            [INTERMEDIATE] Tracking chain steps for: ACTIVE_ROOMS.get
            [INTERMEDIATE] Step 1: ACTIVE_ROOMS.get
        [EMIT_DETECTION] Direct FQN match: socketio_events.ACTIVE_ROOMS.get
      -> DETECTED and ADDED emit call: socketio_events.ACTIVE_ROOMS.get::$room_name
        [FUNCTION_ARG] Checking argument: room_name
    [RESOLVE] Attempting to resolve: ['room_name']
      [RESOLVE_SIMPLE] Resolving base: room_name
      [CACHE] Hit for room_name: socketio_events.room_name
    [RESOLVE] RESOLVED to: socketio_events.room_name
      [ATTRIBUTE] Found attribute access: ACTIVE_ROOMS.get
        [CACHE] ACTIVE_ROOMS.get -> socketio_events.ACTIVE_ROOMS.get (cached)
      -> Not module state
      [NAME] Found name reference: ACTIVE_ROOMS
    [RESOLVE] Attempting to resolve: ['ACTIVE_ROOMS']
      [RESOLVE_SIMPLE] Resolving base: ACTIVE_ROOMS
      [CACHE] Hit for ACTIVE_ROOMS: socketio_events.ACTIVE_ROOMS
    [RESOLVE] RESOLVED to: socketio_events.ACTIVE_ROOMS
      -> Resolved to state: socketio_events.ACTIVE_ROOMS
      [SYMBOL_LOOKUP] Variable ACTIVE_ROOMS not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [CALL] Found call: self.socketio.emit
    [CACHE] self.socketio.emit -> socketio_events.SocketIOEventRegistry.socketio.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: self.socketio.emit
            [INTERMEDIATE] Step 1: self.socketio
    [CACHE] self.socketio -> socketio_events.SocketIOEventRegistry.socketio (cached)
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.socketio
            [INTERMEDIATE] Step 2: self.socketio.emit
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.socketio.emit
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.socketio.emit::room_activity
        [EMIT] Room parameter: $active_room
      [ATTRIBUTE] Found attribute access: self.socketio.emit
        [CACHE] self.socketio.emit -> socketio_events.SocketIOEventRegistry.socketio.emit (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.socketio
        [CACHE] self.socketio -> socketio_events.SocketIOEventRegistry.socketio (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [NAME] Found name reference: active_room
        [CACHE] active_room -> socketio_events.active_room (cached)
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: room_handler
    [RESOLVE] Attempting to resolve: ['room_handler']
      [RESOLVE_SIMPLE] Resolving base: room_handler
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable room_handler not found in any scope
      [LOCAL_RESOLVER] can_resolve(room_handler): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(room_handler): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(room_handler): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(room_handler): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(room_handler): socketio_events.room_handler
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: room_handler -> socketio_events.room_handler
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.room_handler
      -> Not module state
    [CONTEXT] Exited function: socketio_events.SocketIOEventRegistry._create_room_handler
    [FUNCTION_ANALYSIS] Completed analysis of: socketio_events.SocketIOEventRegistry._create_room_handler
        Calls: 8
        Instantiations: 0
        State Access: 1
        SocketIO Emits: 4
    [FUNCTION_ANALYSIS] Starting analysis of: socketio_events.SocketIOEventRegistry._create_broadcast_handler
    [CONTEXT] Entered function: socketio_events.SocketIOEventRegistry._create_broadcast_handler (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'config': 'Dict[str, Any]'}
      [NESTED_FUNCTION] Analyzing nested function: broadcast_handler
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'config': 'Dict[str, Any]'}
      [ASSIGNMENT] Processing: message = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: data.get
    [RESOLVE] Attempting to resolve: ['data', 'get']
    [RESOLVE] Chain resolution needed for: ['data', 'get']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: socketio_events.data
      [CHAIN] Base resolved: data -> socketio_events.data
      [CHAIN] Step 1: Resolving socketio_events.data.get
        [ATTRIBUTE] Resolving attribute: socketio_events.data.get
        [ATTRIBUTE] Direct match found: socketio_events.data.get
      [CHAIN] Step 1 resolved: socketio_events.data.get
    [RESOLVE] RESOLVED to: socketio_events.data.get
      [TYPE_INFERENCE] Call resolved to: socketio_events.data.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for message
      [NAME] Found name reference: message
    [RESOLVE] Attempting to resolve: ['message']
      [RESOLVE_SIMPLE] Resolving base: message
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable message not found in any scope
      [LOCAL_RESOLVER] can_resolve(message): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(message): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(message): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(message): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(message): socketio_events.message
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: message -> socketio_events.message
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.message
      -> Not module state
      [CALL] Found call: data.get
    [RESOLVE] Attempting to resolve: ['data', 'get']
    [RESOLVE] Chain resolution needed for: ['data', 'get']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: socketio_events.data
      [CHAIN] Base resolved: data -> socketio_events.data
      [CHAIN] Step 1: Resolving socketio_events.data.get
        [ATTRIBUTE] Resolving attribute: socketio_events.data.get
        [ATTRIBUTE] Direct match found: socketio_events.data.get
      [CHAIN] Step 1 resolved: socketio_events.data.get
    [RESOLVE] RESOLVED to: socketio_events.data.get
            [INTERMEDIATE] Tracking chain steps for: data.get
            [INTERMEDIATE] Step 1: data.get
        [EMIT_DETECTION] Direct FQN match: socketio_events.data.get
      -> DETECTED and ADDED emit call: socketio_events.data.get::message
      [ATTRIBUTE] Found attribute access: data.get
        [CACHE] data.get -> socketio_events.data.get (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: socketio_events.data
    [RESOLVE] RESOLVED to: socketio_events.data
      -> Not module state
      [CALL] Found call: self.message_validator.validate_message
    [RESOLVE] Attempting to resolve: ['self', 'message_validator', 'validate_message']
    [RESOLVE] Chain resolution needed for: ['self', 'message_validator', 'validate_message']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.message_validator
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.message_validator
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.message_validator
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.message_validator
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.message_validator.validate_message
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.message_validator.validate_message
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.message_validator.validate_message
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.message_validator.validate_message
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.message_validator.validate_message
            [INTERMEDIATE] Tracking chain steps for: self.message_validator.validate_message
            [INTERMEDIATE] Step 1: self.message_validator
    [RESOLVE] Attempting to resolve: ['self', 'message_validator']
    [RESOLVE] Chain resolution needed for: ['self', 'message_validator']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.message_validator
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.message_validator
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.message_validator
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.message_validator
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.message_validator
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.message_validator
            [INTERMEDIATE] Step 2: self.message_validator.validate_message
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.message_validator.validate_message
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.message_validator.validate_message::$message
        [FUNCTION_ARG] Checking argument: message
    [RESOLVE] Attempting to resolve: ['message']
      [RESOLVE_SIMPLE] Resolving base: message
      [CACHE] Hit for message: socketio_events.message
    [RESOLVE] RESOLVED to: socketio_events.message
      [ATTRIBUTE] Found attribute access: self.message_validator.validate_message
        [CACHE] self.message_validator.validate_message -> socketio_events.SocketIOEventRegistry.message_validator.validate_message (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.message_validator
        [CACHE] self.message_validator -> socketio_events.SocketIOEventRegistry.message_validator (cached)
      -> Not module state
      [NAME] Found name reference: self
    [RESOLVE] Attempting to resolve: ['self']
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry
      -> Not module state
      [NAME] Found name reference: message
        [CACHE] message -> socketio_events.message (cached)
      -> Not module state
      [CALL] Found call: self.socketio.emit
    [RESOLVE] Attempting to resolve: ['self', 'socketio', 'emit']
    [RESOLVE] Chain resolution needed for: ['self', 'socketio', 'emit']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.socketio
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.socketio
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.socketio.emit
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.socketio.emit
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.socketio.emit
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.socketio.emit
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.socketio.emit
            [INTERMEDIATE] Tracking chain steps for: self.socketio.emit
            [INTERMEDIATE] Step 1: self.socketio
    [RESOLVE] Attempting to resolve: ['self', 'socketio']
    [RESOLVE] Chain resolution needed for: ['self', 'socketio']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.socketio
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.socketio
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.socketio
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.socketio
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.socketio
            [INTERMEDIATE] Step 2: self.socketio.emit
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.socketio.emit
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.socketio.emit::global_message
        [EMIT] Broadcast parameter: True
      [ATTRIBUTE] Found attribute access: self.socketio.emit
        [CACHE] self.socketio.emit -> socketio_events.SocketIOEventRegistry.socketio.emit (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.socketio
        [CACHE] self.socketio -> socketio_events.SocketIOEventRegistry.socketio (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: message
        [CACHE] message -> socketio_events.message (cached)
      -> Not module state
      [CALL] Found call: self.session_manager.get_current_user_id
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'get_current_user_id']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'get_current_user_id']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.get_current_user_id
            [INTERMEDIATE] Step 1: self.session_manager
    [RESOLVE] Attempting to resolve: ['self', 'session_manager']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.get_current_user_id
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id::unknown_event
      [ATTRIBUTE] Found attribute access: self.session_manager.get_current_user_id
        [CACHE] self.session_manager.get_current_user_id -> socketio_events.SocketIOEventRegistry.session_manager.get_current_user_id (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [CALL] Found call: self.session_manager.get_current_timestamp
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'get_current_timestamp']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'get_current_timestamp']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: self.session_manager
    [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.get_current_timestamp
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp::unknown_event
      [ATTRIBUTE] Found attribute access: self.session_manager.get_current_timestamp
        [CACHE] self.session_manager.get_current_timestamp -> socketio_events.SocketIOEventRegistry.session_manager.get_current_timestamp (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable user_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(user_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(user_id): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(user_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(user_id): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(user_id): socketio_events.user_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: user_id -> socketio_events.user_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.user_id
      -> Not module state
      [CALL] Found call: self.session_manager.get_active_users
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'get_active_users']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'get_active_users']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.session_manager.get_active_users
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager.get_active_users
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager.get_active_users
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.session_manager.get_active_users
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager.get_active_users
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.get_active_users
            [INTERMEDIATE] Step 1: self.session_manager
    [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.get_active_users
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.session_manager.get_active_users
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.session_manager.get_active_users::unknown_event
      [ATTRIBUTE] Found attribute access: self.session_manager.get_active_users
        [CACHE] self.session_manager.get_active_users -> socketio_events.SocketIOEventRegistry.session_manager.get_active_users (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [ASSIGNMENT] Processing: user_room = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: self.session_manager.get_user_room
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'get_user_room']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'get_user_room']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.session_manager.get_user_room
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
      [TYPE_INFERENCE] Call resolved to: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for user_room
      [NAME] Found name reference: user_room
    [RESOLVE] Attempting to resolve: ['user_room']
      [RESOLVE_SIMPLE] Resolving base: user_room
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable user_room not found in any scope
      [LOCAL_RESOLVER] can_resolve(user_room): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(user_room): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(user_room): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(user_room): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(user_room): socketio_events.user_room
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: user_room -> socketio_events.user_room
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.user_room
      -> Not module state
      [CALL] Found call: self.session_manager.get_user_room
    [RESOLVE] Attempting to resolve: ['self', 'session_manager', 'get_user_room']
    [RESOLVE] Chain resolution needed for: ['self', 'session_manager', 'get_user_room']
      [CHAIN] Resolving base: self
      [RESOLVE_SIMPLE] Resolving base: self
      [CACHE] Hit for self: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: self -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.session_manager
      [CHAIN] Step 2: Resolving socketio_events.SocketIOEventRegistry.session_manager.get_user_room
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
      [CHAIN] Step 2 resolved: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
            [INTERMEDIATE] Tracking chain steps for: self.session_manager.get_user_room
            [INTERMEDIATE] Step 1: self.session_manager
    [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.session_manager
            [INTERMEDIATE] Step 2: self.session_manager.get_user_room
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.session_manager.get_user_room
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.session_manager.get_user_room::$user_id
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
      [ATTRIBUTE] Found attribute access: self.session_manager.get_user_room
        [CACHE] self.session_manager.get_user_room -> socketio_events.SocketIOEventRegistry.session_manager.get_user_room (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.session_manager
        [CACHE] self.session_manager -> socketio_events.SocketIOEventRegistry.session_manager (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: self.socketio.emit
    [CACHE] self.socketio.emit -> socketio_events.SocketIOEventRegistry.socketio.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: self.socketio.emit
            [INTERMEDIATE] Step 1: self.socketio
    [CACHE] self.socketio -> socketio_events.SocketIOEventRegistry.socketio (cached)
            [INTERMEDIATE] Step 1 resolved to: socketio_events.SocketIOEventRegistry.socketio
            [INTERMEDIATE] Step 2: self.socketio.emit
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.socketio.emit
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.socketio.emit::personal_message
        [EMIT] Room parameter: $user_room
      [ATTRIBUTE] Found attribute access: self.socketio.emit
        [CACHE] self.socketio.emit -> socketio_events.SocketIOEventRegistry.socketio.emit (cached)
      -> Not module state
      [ATTRIBUTE] Found attribute access: self.socketio
        [CACHE] self.socketio -> socketio_events.SocketIOEventRegistry.socketio (cached)
      -> Not module state
      [NAME] Found name reference: self
        [CACHE] self -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: message
        [CACHE] message -> socketio_events.message (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [NAME] Found name reference: user_room
        [CACHE] user_room -> socketio_events.user_room (cached)
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: broadcast_handler
    [RESOLVE] Attempting to resolve: ['broadcast_handler']
      [RESOLVE_SIMPLE] Resolving base: broadcast_handler
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable broadcast_handler not found in any scope
      [LOCAL_RESOLVER] can_resolve(broadcast_handler): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(broadcast_handler): False (current_class: socketio_events.SocketIOEventRegistry)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(broadcast_handler): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(broadcast_handler): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(broadcast_handler): socketio_events.broadcast_handler
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: broadcast_handler -> socketio_events.broadcast_handler
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.broadcast_handler
      -> Not module state
    [CONTEXT] Exited function: socketio_events.SocketIOEventRegistry._create_broadcast_handler
    [FUNCTION_ANALYSIS] Completed analysis of: socketio_events.SocketIOEventRegistry._create_broadcast_handler
        Calls: 8
        Instantiations: 0
        State Access: 0
        SocketIO Emits: 3
    [CONTEXT] Exited class: socketio_events.SocketIOEventRegistry
    [SYMBOL_TABLE] Exited class scope
  [FUNCTION] Analyzing function: register_events
    [FUNCTION_ANALYSIS] Starting analysis of: socketio_events.register_events
    [DECORATOR] @trace
    [CONTEXT] Entered function: socketio_events.register_events (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'socketio': 'SocketIO', 'haven_proxy': 'HavenProxy'}
        [ARG_TYPE] Processing type annotation for socketio: SocketIO
    [RESOLVE] Attempting to resolve: ['SocketIO']
      [RESOLVE_SIMPLE] Resolving base: SocketIO
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable SocketIO not found in any scope
      [LOCAL_RESOLVER] can_resolve(SocketIO): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(SocketIO): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(SocketIO): True (import: True, external: True)
      [IMPORT_RESOLVER] resolve(SocketIO): flask_socketio.SocketIO (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: SocketIO -> flask_socketio.SocketIO
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: flask_socketio.SocketIO
      [SYMBOL_UPDATE] Function: socketio -> flask_socketio.SocketIO
        [ARG_TYPE] RESOLVED socketio : flask_socketio.SocketIO
        [ARG_TYPE] Processing type annotation for haven_proxy: HavenProxy
    [RESOLVE] Attempting to resolve: ['HavenProxy']
      [RESOLVE_SIMPLE] Resolving base: HavenProxy
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable HavenProxy not found in any scope
      [LOCAL_RESOLVER] can_resolve(HavenProxy): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(HavenProxy): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(HavenProxy): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(HavenProxy): proxy_handler.HavenProxy (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: HavenProxy -> proxy_handler.HavenProxy
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      [SYMBOL_UPDATE] Function: haven_proxy -> proxy_handler.HavenProxy
        [ARG_TYPE] RESOLVED haven_proxy : proxy_handler.HavenProxy
      [ASSIGNMENT] Processing: _socketio_instance = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: _socketio_instance
    [RESOLVE] Attempting to resolve: ['_socketio_instance']
      [RESOLVE_SIMPLE] Resolving base: _socketio_instance
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable _socketio_instance not found in any scope
      [LOCAL_RESOLVER] can_resolve(_socketio_instance): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(_socketio_instance): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(_socketio_instance): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(_socketio_instance): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(_socketio_instance): socketio_events._socketio_instance
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: _socketio_instance -> socketio_events._socketio_instance
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events._socketio_instance
      -> Resolved to state: socketio_events._socketio_instance
      [SYMBOL_LOOKUP] Variable _socketio_instance not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: socketio
    [RESOLVE] Attempting to resolve: ['socketio']
      [RESOLVE_SIMPLE] Resolving base: socketio
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found socketio in function scope: flask_socketio.SocketIO
      [LOCAL_RESOLVER] can_resolve(socketio): True
      [SYMBOL_LOOKUP] Found socketio in function scope: flask_socketio.SocketIO
      [LOCAL_RESOLVER] resolve(socketio): flask_socketio.SocketIO
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: socketio -> flask_socketio.SocketIO
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: flask_socketio.SocketIO
      -> Not module state
      [ASSIGNMENT] Processing: _haven_proxy = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: _haven_proxy
    [RESOLVE] Attempting to resolve: ['_haven_proxy']
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      [LOCAL_RESOLVER] can_resolve(_haven_proxy): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(_haven_proxy): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(_haven_proxy): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(_haven_proxy): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(_haven_proxy): socketio_events._haven_proxy
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: _haven_proxy -> socketio_events._haven_proxy
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: haven_proxy
    [RESOLVE] Attempting to resolve: ['haven_proxy']
      [RESOLVE_SIMPLE] Resolving base: haven_proxy
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found haven_proxy in function scope: proxy_handler.HavenProxy
      [LOCAL_RESOLVER] can_resolve(haven_proxy): True
      [SYMBOL_LOOKUP] Found haven_proxy in function scope: proxy_handler.HavenProxy
      [LOCAL_RESOLVER] resolve(haven_proxy): proxy_handler.HavenProxy
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: haven_proxy -> proxy_handler.HavenProxy
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      -> Not module state
      [ASSIGNMENT] Processing: _session_manager = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: SessionManager
    [RESOLVE] Attempting to resolve: ['SessionManager']
      [RESOLVE_SIMPLE] Resolving base: SessionManager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable SessionManager not found in any scope
      [LOCAL_RESOLVER] can_resolve(SessionManager): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(SessionManager): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(SessionManager): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(SessionManager): session_manager.SessionManager (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: SessionManager -> session_manager.SessionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager
      [TYPE_INFERENCE] RESOLVED Inferred type: session_manager.SessionManager (class instantiation)
      [SYMBOL_UPDATE] Function: _session_manager -> session_manager.SessionManager
        [ASSIGNMENT] RESOLVED Updated symbol table: _session_manager = session_manager.SessionManager
      [NAME] Found name reference: _session_manager
    [RESOLVE] Attempting to resolve: ['_session_manager']
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found _session_manager in function scope: session_manager.SessionManager
      [LOCAL_RESOLVER] can_resolve(_session_manager): True
      [SYMBOL_LOOKUP] Found _session_manager in function scope: session_manager.SessionManager
      [LOCAL_RESOLVER] resolve(_session_manager): session_manager.SessionManager
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: _session_manager -> session_manager.SessionManager
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [CALL] Found call: SessionManager
    [RESOLVE] Attempting to resolve: ['SessionManager']
      [RESOLVE_SIMPLE] Resolving base: SessionManager
      [CACHE] Hit for SessionManager: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Resolved to: session_manager.SessionManager
      -> ADDED to instantiations
        [FUNCTION_ARG] Checking argument: haven_proxy
    [RESOLVE] Attempting to resolve: ['haven_proxy']
      [RESOLVE_SIMPLE] Resolving base: haven_proxy
      [CACHE] Hit for haven_proxy: proxy_handler.HavenProxy
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      [NAME] Found name reference: SessionManager
        [CACHE] SessionManager -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: haven_proxy
        [CACHE] haven_proxy -> proxy_handler.HavenProxy (cached)
      -> Not module state
      [ASSIGNMENT] Processing: registry = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: SocketIOEventRegistry
    [RESOLVE] Attempting to resolve: ['SocketIOEventRegistry']
      [RESOLVE_SIMPLE] Resolving base: SocketIOEventRegistry
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable SocketIOEventRegistry not found in any scope
      [LOCAL_RESOLVER] can_resolve(SocketIOEventRegistry): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(SocketIOEventRegistry): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(SocketIOEventRegistry): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(SocketIOEventRegistry): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(SocketIOEventRegistry): socketio_events.SocketIOEventRegistry
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: SocketIOEventRegistry -> socketio_events.SocketIOEventRegistry
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry
      [TYPE_INFERENCE] Call resolved to: socketio_events.SocketIOEventRegistry
      [TYPE_INFERENCE] RESOLVED Inferred type: socketio_events.SocketIOEventRegistry (class instantiation)
      [SYMBOL_UPDATE] Function: registry -> socketio_events.SocketIOEventRegistry
        [ASSIGNMENT] RESOLVED Updated symbol table: registry = socketio_events.SocketIOEventRegistry
      [NAME] Found name reference: registry
    [RESOLVE] Attempting to resolve: ['registry']
      [RESOLVE_SIMPLE] Resolving base: registry
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found registry in function scope: socketio_events.SocketIOEventRegistry
      [LOCAL_RESOLVER] can_resolve(registry): True
      [SYMBOL_LOOKUP] Found registry in function scope: socketio_events.SocketIOEventRegistry
      [LOCAL_RESOLVER] resolve(registry): socketio_events.SocketIOEventRegistry
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: registry -> socketio_events.SocketIOEventRegistry
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry
      -> Not module state
      [CALL] Found call: SocketIOEventRegistry
    [RESOLVE] Attempting to resolve: ['SocketIOEventRegistry']
      [RESOLVE_SIMPLE] Resolving base: SocketIOEventRegistry
      [CACHE] Hit for SocketIOEventRegistry: socketio_events.SocketIOEventRegistry
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry::$socketio
        [FUNCTION_ARG] Checking argument: socketio
    [RESOLVE] Attempting to resolve: ['socketio']
      [RESOLVE_SIMPLE] Resolving base: socketio
      [CACHE] Hit for socketio: flask_socketio.SocketIO
    [RESOLVE] RESOLVED to: flask_socketio.SocketIO
        [FUNCTION_ARG] Checking argument: _session_manager
    [RESOLVE] Attempting to resolve: ['_session_manager']
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      [NAME] Found name reference: SocketIOEventRegistry
        [CACHE] SocketIOEventRegistry -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [NESTED_FUNCTION] Analyzing nested function: handle_connect
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'socketio': 'SocketIO', 'haven_proxy': 'HavenProxy'}
      [ASSIGNMENT] Processing: session_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: _session_manager.create_session
    [RESOLVE] Attempting to resolve: ['_session_manager', 'create_session']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'create_session']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.create_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.create_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.create_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.create_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.create_session
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.create_session
        [RETURN_TYPE_RESOLUTION] Resolving return type: str
        [RETURN_TYPE_RESOLUTION] Class 'str' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: str
      [TYPE_INFERENCE] Could not resolve return type 'str' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: str (from return type - unresolved)
      [SYMBOL_UPDATE] Nested: session_id -> str
        [ASSIGNMENT] RESOLVED Updated symbol table: session_id = str
      [NAME] Found name reference: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found session_id in nested scope: str
      [LOCAL_RESOLVER] can_resolve(session_id): True
      [SYMBOL_LOOKUP] Found session_id in nested scope: str
      [LOCAL_RESOLVER] resolve(session_id): str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: session_id -> str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: str
      -> Not module state
      [CALL] Found call: _session_manager.create_session
    [RESOLVE] Attempting to resolve: ['_session_manager', 'create_session']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'create_session']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.create_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.create_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.create_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.create_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.create_session
            [INTERMEDIATE] Tracking chain steps for: _session_manager.create_session
            [INTERMEDIATE] Step 1: _session_manager.create_session
      -> Resolved to: session_manager.SessionManager.create_session
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.create_session
        [CACHE] _session_manager.create_session -> session_manager.SessionManager.create_session (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: auth
    [RESOLVE] Attempting to resolve: ['auth']
      [RESOLVE_SIMPLE] Resolving base: auth
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable auth not found in any scope
      [LOCAL_RESOLVER] can_resolve(auth): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(auth): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(auth): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(auth): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(auth): socketio_events.auth
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: auth -> socketio_events.auth
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.auth
      -> Not module state
      [CALL] Found call: auth.get
    [RESOLVE] Attempting to resolve: ['auth', 'get']
    [RESOLVE] Chain resolution needed for: ['auth', 'get']
      [CHAIN] Resolving base: auth
      [RESOLVE_SIMPLE] Resolving base: auth
      [CACHE] Hit for auth: socketio_events.auth
      [CHAIN] Base resolved: auth -> socketio_events.auth
      [CHAIN] Step 1: Resolving socketio_events.auth.get
        [ATTRIBUTE] Resolving attribute: socketio_events.auth.get
        [ATTRIBUTE] Direct match found: socketio_events.auth.get
      [CHAIN] Step 1 resolved: socketio_events.auth.get
    [RESOLVE] RESOLVED to: socketio_events.auth.get
            [INTERMEDIATE] Tracking chain steps for: auth.get
            [INTERMEDIATE] Step 1: auth.get
        [EMIT_DETECTION] Direct FQN match: socketio_events.auth.get
      -> DETECTED and ADDED emit call: socketio_events.auth.get::is_runner
      [ATTRIBUTE] Found attribute access: auth.get
        [CACHE] auth.get -> socketio_events.auth.get (cached)
      -> Not module state
      [NAME] Found name reference: auth
        [CACHE] auth -> socketio_events.auth (cached)
      -> Not module state
      [CALL] Found call: logging.info
    [RESOLVE] Attempting to resolve: ['logging', 'info']
    [RESOLVE] Chain resolution needed for: ['logging', 'info']
      [CHAIN] Resolving base: logging
      [RESOLVE_SIMPLE] Resolving base: logging
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable logging not found in any scope
      [LOCAL_RESOLVER] can_resolve(logging): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(logging): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(logging): True (import: True, external: False)
      [IMPORT_RESOLVER] resolve(logging): logging (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: logging -> logging
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: logging -> logging
      [CHAIN] Step 1: Resolving logging.info
        [ATTRIBUTE] Resolving attribute: logging.info
        [ATTRIBUTE] Direct match found: logging.info
      [CHAIN] Step 1 resolved: logging.info
    [RESOLVE] RESOLVED to: logging.info
            [INTERMEDIATE] Tracking chain steps for: logging.info
            [INTERMEDIATE] Step 1: logging.info
      -> Resolved to: logging.info
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: logging.info
        [CACHE] logging.info -> logging.info (cached)
      -> Not module state
      [NAME] Found name reference: logging
    [RESOLVE] Attempting to resolve: ['logging']
      [RESOLVE_SIMPLE] Resolving base: logging
      [CACHE] Hit for logging: logging
    [RESOLVE] RESOLVED to: logging
      -> Not module state
      [CALL] Found call: socketio.emit
    [RESOLVE] Attempting to resolve: ['socketio', 'emit']
    [RESOLVE] Chain resolution needed for: ['socketio', 'emit']
      [CHAIN] Resolving base: socketio
      [RESOLVE_SIMPLE] Resolving base: socketio
      [CACHE] Hit for socketio: flask_socketio.SocketIO
      [CHAIN] Base resolved: socketio -> flask_socketio.SocketIO
      [CHAIN] Step 1: Resolving flask_socketio.SocketIO.emit
        [ATTRIBUTE] Resolving attribute: flask_socketio.SocketIO.emit
        [ATTRIBUTE] Direct match found: flask_socketio.SocketIO.emit
      [CHAIN] Step 1 resolved: flask_socketio.SocketIO.emit
    [RESOLVE] RESOLVED to: flask_socketio.SocketIO.emit
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::runner_connected
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> str (cached)
      -> Not module state
      [CALL] Found call: _haven_proxy.get_runner_capabilities
    [RESOLVE] Attempting to resolve: ['_haven_proxy', 'get_runner_capabilities']
    [RESOLVE] Chain resolution needed for: ['_haven_proxy', 'get_runner_capabilities']
      [CHAIN] Resolving base: _haven_proxy
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
      [CHAIN] Base resolved: _haven_proxy -> socketio_events._haven_proxy
      [CHAIN] Step 1: Resolving socketio_events._haven_proxy.get_runner_capabilities
        [ATTRIBUTE] Resolving attribute: socketio_events._haven_proxy.get_runner_capabilities
        [ATTRIBUTE] Direct match found: socketio_events._haven_proxy.get_runner_capabilities
      [CHAIN] Step 1 resolved: socketio_events._haven_proxy.get_runner_capabilities
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy.get_runner_capabilities
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.get_runner_capabilities
            [INTERMEDIATE] Step 1: _haven_proxy.get_runner_capabilities
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.get_runner_capabilities
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.get_runner_capabilities::unknown_event
      [ATTRIBUTE] Found attribute access: _haven_proxy.get_runner_capabilities
        [CACHE] _haven_proxy.get_runner_capabilities -> socketio_events._haven_proxy.get_runner_capabilities (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [CALL] Found call: _session_manager.get_current_timestamp
    [RESOLVE] Attempting to resolve: ['_session_manager', 'get_current_timestamp']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'get_current_timestamp']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_timestamp
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_timestamp
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_timestamp
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_timestamp
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_timestamp
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: _session_manager.get_current_timestamp
      -> Resolved to: session_manager.SessionManager.get_current_timestamp
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_timestamp
        [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [CALL] Found call: join_room
    [RESOLVE] Attempting to resolve: ['join_room']
      [RESOLVE_SIMPLE] Resolving base: join_room
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable join_room not found in any scope
      [LOCAL_RESOLVER] can_resolve(join_room): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(join_room): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(join_room): True (import: True, external: True)
      [IMPORT_RESOLVER] resolve(join_room): flask_socketio.join_room (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: join_room -> flask_socketio.join_room
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: flask_socketio.join_room
        [EMIT_DETECTION] Direct FQN match: flask_socketio.join_room
      -> DETECTED and ADDED emit call: flask_socketio.join_room::runners
      [NAME] Found name reference: join_room
        [CACHE] join_room -> flask_socketio.join_room (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::runner_room_joined
        [EMIT] Room parameter: runners
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> str (cached)
      -> Not module state
      [NAME] Found name reference: auth
        [CACHE] auth -> socketio_events.auth (cached)
      -> Not module state
      [CALL] Found call: _haven_proxy.validate_user_credentials
    [RESOLVE] Attempting to resolve: ['_haven_proxy', 'validate_user_credentials']
    [RESOLVE] Chain resolution needed for: ['_haven_proxy', 'validate_user_credentials']
      [CHAIN] Resolving base: _haven_proxy
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
      [CHAIN] Base resolved: _haven_proxy -> socketio_events._haven_proxy
      [CHAIN] Step 1: Resolving socketio_events._haven_proxy.validate_user_credentials
        [ATTRIBUTE] Resolving attribute: socketio_events._haven_proxy.validate_user_credentials
        [ATTRIBUTE] Direct match found: socketio_events._haven_proxy.validate_user_credentials
      [CHAIN] Step 1 resolved: socketio_events._haven_proxy.validate_user_credentials
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy.validate_user_credentials
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.validate_user_credentials
            [INTERMEDIATE] Step 1: _haven_proxy.validate_user_credentials
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.validate_user_credentials
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.validate_user_credentials::$auth
        [FUNCTION_ARG] Checking argument: auth
    [RESOLVE] Attempting to resolve: ['auth']
      [RESOLVE_SIMPLE] Resolving base: auth
      [CACHE] Hit for auth: socketio_events.auth
    [RESOLVE] RESOLVED to: socketio_events.auth
      [ATTRIBUTE] Found attribute access: _haven_proxy.validate_user_credentials
        [CACHE] _haven_proxy.validate_user_credentials -> socketio_events._haven_proxy.validate_user_credentials (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: auth
        [CACHE] auth -> socketio_events.auth (cached)
      -> Not module state
      [ASSIGNMENT] Processing: user_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: auth.get
    [RESOLVE] Attempting to resolve: ['auth', 'get']
    [RESOLVE] Chain resolution needed for: ['auth', 'get']
      [CHAIN] Resolving base: auth
      [RESOLVE_SIMPLE] Resolving base: auth
      [CACHE] Hit for auth: socketio_events.auth
      [CHAIN] Base resolved: auth -> socketio_events.auth
      [CHAIN] Step 1: Resolving socketio_events.auth.get
        [ATTRIBUTE] Resolving attribute: socketio_events.auth.get
        [ATTRIBUTE] Direct match found: socketio_events.auth.get
      [CHAIN] Step 1 resolved: socketio_events.auth.get
    [RESOLVE] RESOLVED to: socketio_events.auth.get
      [TYPE_INFERENCE] Call resolved to: socketio_events.auth.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for user_id
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable user_id not found in any scope
      [LOCAL_RESOLVER] can_resolve(user_id): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(user_id): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(user_id): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(user_id): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(user_id): socketio_events.user_id
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: user_id -> socketio_events.user_id
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.user_id
      -> Not module state
      [CALL] Found call: auth.get
    [CACHE] auth.get -> socketio_events.auth.get (cached)
            [INTERMEDIATE] Tracking chain steps for: auth.get
            [INTERMEDIATE] Step 1: auth.get
        [EMIT_DETECTION] Direct FQN match: socketio_events.auth.get
      -> DETECTED and ADDED emit call: socketio_events.auth.get::user_id
      [ATTRIBUTE] Found attribute access: auth.get
        [CACHE] auth.get -> socketio_events.auth.get (cached)
      -> Not module state
      [NAME] Found name reference: auth
        [CACHE] auth -> socketio_events.auth (cached)
      -> Not module state
      [ASSIGNMENT] Processing: user_session = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: _session_manager.create_user_session
    [RESOLVE] Attempting to resolve: ['_session_manager', 'create_user_session']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'create_user_session']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.create_user_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.create_user_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.create_user_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.create_user_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.create_user_session
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.create_user_session
        [RETURN_TYPE_RESOLUTION] Resolving return type: UserSession
        [RETURN_TYPE_RESOLUTION] Found in other module: session_manager.UserSession
      [TYPE_INFERENCE] RESOLVED Inferred type: session_manager.UserSession (from return type)
      [SYMBOL_UPDATE] Nested: user_session -> session_manager.UserSession
        [ASSIGNMENT] RESOLVED Updated symbol table: user_session = session_manager.UserSession
      [NAME] Found name reference: user_session
    [RESOLVE] Attempting to resolve: ['user_session']
      [RESOLVE_SIMPLE] Resolving base: user_session
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found user_session in nested scope: session_manager.UserSession
      [LOCAL_RESOLVER] can_resolve(user_session): True
      [SYMBOL_LOOKUP] Found user_session in nested scope: session_manager.UserSession
      [LOCAL_RESOLVER] resolve(user_session): session_manager.UserSession
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: user_session -> session_manager.UserSession
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: session_manager.UserSession
      -> Not module state
      [CALL] Found call: _session_manager.create_user_session
    [RESOLVE] Attempting to resolve: ['_session_manager', 'create_user_session']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'create_user_session']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.create_user_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.create_user_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.create_user_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.create_user_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.create_user_session
            [INTERMEDIATE] Tracking chain steps for: _session_manager.create_user_session
            [INTERMEDIATE] Step 1: _session_manager.create_user_session
      -> Resolved to: session_manager.SessionManager.create_user_session
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: str
    [RESOLVE] RESOLVED to: str
      [ATTRIBUTE] Found attribute access: _session_manager.create_user_session
        [CACHE] _session_manager.create_user_session -> session_manager.SessionManager.create_user_session (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> str (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::connection_established
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> str (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _haven_proxy.get_user_preferences
    [RESOLVE] Attempting to resolve: ['_haven_proxy', 'get_user_preferences']
    [RESOLVE] Chain resolution needed for: ['_haven_proxy', 'get_user_preferences']
      [CHAIN] Resolving base: _haven_proxy
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
      [CHAIN] Base resolved: _haven_proxy -> socketio_events._haven_proxy
      [CHAIN] Step 1: Resolving socketio_events._haven_proxy.get_user_preferences
        [ATTRIBUTE] Resolving attribute: socketio_events._haven_proxy.get_user_preferences
        [ATTRIBUTE] Direct match found: socketio_events._haven_proxy.get_user_preferences
      [CHAIN] Step 1 resolved: socketio_events._haven_proxy.get_user_preferences
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy.get_user_preferences
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.get_user_preferences
            [INTERMEDIATE] Step 1: _haven_proxy.get_user_preferences
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.get_user_preferences
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.get_user_preferences::$user_id
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
      [ATTRIBUTE] Found attribute access: _haven_proxy.get_user_preferences
        [CACHE] _haven_proxy.get_user_preferences -> socketio_events._haven_proxy.get_user_preferences (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [ASSIGNMENT] Processing: user_room = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: user_room
    [RESOLVE] Attempting to resolve: ['user_room']
      [RESOLVE_SIMPLE] Resolving base: user_room
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable user_room not found in any scope
      [LOCAL_RESOLVER] can_resolve(user_room): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(user_room): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(user_room): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(user_room): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(user_room): socketio_events.user_room
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: user_room -> socketio_events.user_room
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.user_room
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: join_room
    [CACHE] join_room -> flask_socketio.join_room (cached)
        [EMIT_DETECTION] Direct FQN match: flask_socketio.join_room
      -> DETECTED and ADDED emit call: flask_socketio.join_room::$user_room
        [FUNCTION_ARG] Checking argument: user_room
    [RESOLVE] Attempting to resolve: ['user_room']
      [RESOLVE_SIMPLE] Resolving base: user_room
      [CACHE] Hit for user_room: socketio_events.user_room
    [RESOLVE] RESOLVED to: socketio_events.user_room
      [NAME] Found name reference: join_room
        [CACHE] join_room -> flask_socketio.join_room (cached)
      -> Not module state
      [NAME] Found name reference: user_room
        [CACHE] user_room -> socketio_events.user_room (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::user_connected
        [EMIT] Broadcast parameter: True
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _session_manager.get_current_timestamp
    [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: _session_manager.get_current_timestamp
      -> Resolved to: session_manager.SessionManager.get_current_timestamp
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_timestamp
        [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::guest_connected
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> str (cached)
      -> Not module state
      [CALL] Found call: _haven_proxy.get_guest_limitations
    [RESOLVE] Attempting to resolve: ['_haven_proxy', 'get_guest_limitations']
    [RESOLVE] Chain resolution needed for: ['_haven_proxy', 'get_guest_limitations']
      [CHAIN] Resolving base: _haven_proxy
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
      [CHAIN] Base resolved: _haven_proxy -> socketio_events._haven_proxy
      [CHAIN] Step 1: Resolving socketio_events._haven_proxy.get_guest_limitations
        [ATTRIBUTE] Resolving attribute: socketio_events._haven_proxy.get_guest_limitations
        [ATTRIBUTE] Direct match found: socketio_events._haven_proxy.get_guest_limitations
      [CHAIN] Step 1 resolved: socketio_events._haven_proxy.get_guest_limitations
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy.get_guest_limitations
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.get_guest_limitations
            [INTERMEDIATE] Step 1: _haven_proxy.get_guest_limitations
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.get_guest_limitations
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.get_guest_limitations::unknown_event
      [ATTRIBUTE] Found attribute access: _haven_proxy.get_guest_limitations
        [CACHE] _haven_proxy.get_guest_limitations -> socketio_events._haven_proxy.get_guest_limitations (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [SYMBOL_TABLE] Exited nested scope
      [NESTED_FUNCTION] Analyzing nested function: handle_disconnect
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 0 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'socketio': 'SocketIO', 'haven_proxy': 'HavenProxy'}
      [ASSIGNMENT] Processing: session_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: _session_manager.get_current_session_id
    [RESOLVE] Attempting to resolve: ['_session_manager', 'get_current_session_id']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'get_current_session_id']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_session_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_session_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_session_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_session_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_session_id
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.get_current_session_id
        [RETURN_TYPE_RESOLUTION] Resolving return type: str
        [RETURN_TYPE_RESOLUTION] Class 'str' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: str
      [TYPE_INFERENCE] Could not resolve return type 'str' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: str (from return type - unresolved)
      [SYMBOL_UPDATE] Nested: session_id -> str
        [ASSIGNMENT] RESOLVED Updated symbol table: session_id = str
      [NAME] Found name reference: session_id
        [CACHE] session_id -> str (cached)
      -> Not module state
      [CALL] Found call: _session_manager.get_current_session_id
    [RESOLVE] Attempting to resolve: ['_session_manager', 'get_current_session_id']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'get_current_session_id']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_session_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_session_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_session_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_session_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_session_id
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_session_id
            [INTERMEDIATE] Step 1: _session_manager.get_current_session_id
      -> Resolved to: session_manager.SessionManager.get_current_session_id
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_session_id
        [CACHE] _session_manager.get_current_session_id -> session_manager.SessionManager.get_current_session_id (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [ASSIGNMENT] Processing: user_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: _session_manager.get_current_user_id
    [RESOLVE] Attempting to resolve: ['_session_manager', 'get_current_user_id']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'get_current_user_id']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_user_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_user_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_user_id
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.get_current_user_id
        [RETURN_TYPE_RESOLUTION] Resolving return type: str
        [RETURN_TYPE_RESOLUTION] Class 'str' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: str
      [TYPE_INFERENCE] Could not resolve return type 'str' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: str (from return type - unresolved)
      [SYMBOL_UPDATE] Nested: user_id -> str
        [ASSIGNMENT] RESOLVED Updated symbol table: user_id = str
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _session_manager.get_current_user_id
    [RESOLVE] Attempting to resolve: ['_session_manager', 'get_current_user_id']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'get_current_user_id']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_user_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_user_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_user_id
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_user_id
            [INTERMEDIATE] Step 1: _session_manager.get_current_user_id
      -> Resolved to: session_manager.SessionManager.get_current_user_id
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_user_id
        [CACHE] _session_manager.get_current_user_id -> session_manager.SessionManager.get_current_user_id (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _session_manager.cleanup_user_session
    [RESOLVE] Attempting to resolve: ['_session_manager', 'cleanup_user_session']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'cleanup_user_session']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.cleanup_user_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.cleanup_user_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.cleanup_user_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.cleanup_user_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.cleanup_user_session
            [INTERMEDIATE] Tracking chain steps for: _session_manager.cleanup_user_session
            [INTERMEDIATE] Step 1: _session_manager.cleanup_user_session
      -> Resolved to: session_manager.SessionManager.cleanup_user_session
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
      [ATTRIBUTE] Found attribute access: _session_manager.cleanup_user_session
        [CACHE] _session_manager.cleanup_user_session -> session_manager.SessionManager.cleanup_user_session (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::user_disconnected
        [EMIT] Broadcast parameter: True
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _session_manager.get_current_timestamp
    [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: _session_manager.get_current_timestamp
      -> Resolved to: session_manager.SessionManager.get_current_timestamp
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_timestamp
        [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: room
    [RESOLVE] Attempting to resolve: ['room']
      [RESOLVE_SIMPLE] Resolving base: room
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable room not found in any scope
      [LOCAL_RESOLVER] can_resolve(room): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(room): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(room): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(room): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(room): socketio_events.room
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: room -> socketio_events.room
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.room
      -> Not module state
      [CALL] Found call: _session_manager.get_user_rooms
    [RESOLVE] Attempting to resolve: ['_session_manager', 'get_user_rooms']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'get_user_rooms']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_user_rooms
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_user_rooms
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_user_rooms
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_user_rooms
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_user_rooms
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_user_rooms
            [INTERMEDIATE] Step 1: _session_manager.get_user_rooms
      -> Resolved to: session_manager.SessionManager.get_user_rooms
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
      [ATTRIBUTE] Found attribute access: _session_manager.get_user_rooms
        [CACHE] _session_manager.get_user_rooms -> session_manager.SessionManager.get_user_rooms (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: leave_room
    [RESOLVE] Attempting to resolve: ['leave_room']
      [RESOLVE_SIMPLE] Resolving base: leave_room
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable leave_room not found in any scope
      [LOCAL_RESOLVER] can_resolve(leave_room): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(leave_room): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(leave_room): True (import: True, external: True)
      [IMPORT_RESOLVER] resolve(leave_room): flask_socketio.leave_room (from import map)
      [STRATEGY] SUCCESS ImportResolverVisitor succeeded: leave_room -> flask_socketio.leave_room
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: flask_socketio.leave_room
        [EMIT_DETECTION] Direct FQN match: flask_socketio.leave_room
      -> DETECTED and ADDED emit call: flask_socketio.leave_room::$room
        [FUNCTION_ARG] Checking argument: room
    [RESOLVE] Attempting to resolve: ['room']
      [RESOLVE_SIMPLE] Resolving base: room
      [CACHE] Hit for room: socketio_events.room
    [RESOLVE] RESOLVED to: socketio_events.room
      [NAME] Found name reference: leave_room
        [CACHE] leave_room -> flask_socketio.leave_room (cached)
      -> Not module state
      [NAME] Found name reference: room
        [CACHE] room -> socketio_events.room (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::user_left_room
        [EMIT] Room parameter: $room
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [NAME] Found name reference: room
        [CACHE] room -> socketio_events.room (cached)
      -> Not module state
      [NAME] Found name reference: room
        [CACHE] room -> socketio_events.room (cached)
      -> Not module state
      [CALL] Found call: _session_manager.destroy_session
    [RESOLVE] Attempting to resolve: ['_session_manager', 'destroy_session']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'destroy_session']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.destroy_session
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.destroy_session
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.destroy_session
      [CHAIN] Step 1 resolved: session_manager.SessionManager.destroy_session
    [RESOLVE] RESOLVED to: session_manager.SessionManager.destroy_session
            [INTERMEDIATE] Tracking chain steps for: _session_manager.destroy_session
            [INTERMEDIATE] Step 1: _session_manager.destroy_session
      -> Resolved to: session_manager.SessionManager.destroy_session
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: session_id
    [RESOLVE] Attempting to resolve: ['session_id']
      [RESOLVE_SIMPLE] Resolving base: session_id
      [CACHE] Hit for session_id: str
    [RESOLVE] RESOLVED to: str
      [ATTRIBUTE] Found attribute access: _session_manager.destroy_session
        [CACHE] _session_manager.destroy_session -> session_manager.SessionManager.destroy_session (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: session_id
        [CACHE] session_id -> str (cached)
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NESTED_FUNCTION] Analyzing nested function: handle_join_room
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'socketio': 'SocketIO', 'haven_proxy': 'HavenProxy'}
      [ASSIGNMENT] Processing: room_name = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: data.get
    [RESOLVE] Attempting to resolve: ['data', 'get']
    [RESOLVE] Chain resolution needed for: ['data', 'get']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable data not found in any scope
      [LOCAL_RESOLVER] can_resolve(data): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(data): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(data): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(data): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(data): socketio_events.data
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: data -> socketio_events.data
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: data -> socketio_events.data
      [CHAIN] Step 1: Resolving socketio_events.data.get
        [ATTRIBUTE] Resolving attribute: socketio_events.data.get
        [ATTRIBUTE] Direct match found: socketio_events.data.get
      [CHAIN] Step 1 resolved: socketio_events.data.get
    [RESOLVE] RESOLVED to: socketio_events.data.get
      [TYPE_INFERENCE] Call resolved to: socketio_events.data.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for room_name
      [NAME] Found name reference: room_name
    [RESOLVE] Attempting to resolve: ['room_name']
      [RESOLVE_SIMPLE] Resolving base: room_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable room_name not found in any scope
      [LOCAL_RESOLVER] can_resolve(room_name): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(room_name): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(room_name): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(room_name): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(room_name): socketio_events.room_name
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: room_name -> socketio_events.room_name
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.room_name
      -> Not module state
      [CALL] Found call: data.get
    [RESOLVE] Attempting to resolve: ['data', 'get']
    [RESOLVE] Chain resolution needed for: ['data', 'get']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: socketio_events.data
      [CHAIN] Base resolved: data -> socketio_events.data
      [CHAIN] Step 1: Resolving socketio_events.data.get
        [ATTRIBUTE] Resolving attribute: socketio_events.data.get
        [ATTRIBUTE] Direct match found: socketio_events.data.get
      [CHAIN] Step 1 resolved: socketio_events.data.get
    [RESOLVE] RESOLVED to: socketio_events.data.get
            [INTERMEDIATE] Tracking chain steps for: data.get
            [INTERMEDIATE] Step 1: data.get
        [EMIT_DETECTION] Direct FQN match: socketio_events.data.get
      -> DETECTED and ADDED emit call: socketio_events.data.get::room
      [ATTRIBUTE] Found attribute access: data.get
        [CACHE] data.get -> socketio_events.data.get (cached)
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: socketio_events.data
    [RESOLVE] RESOLVED to: socketio_events.data
      -> Not module state
      [ASSIGNMENT] Processing: user_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: _session_manager.get_current_user_id
    [RESOLVE] Attempting to resolve: ['_session_manager', 'get_current_user_id']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'get_current_user_id']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_user_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_user_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_user_id
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.get_current_user_id
        [RETURN_TYPE_RESOLUTION] Resolving return type: str
        [RETURN_TYPE_RESOLUTION] Class 'str' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: str
      [TYPE_INFERENCE] Could not resolve return type 'str' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: str (from return type - unresolved)
      [SYMBOL_UPDATE] Nested: user_id -> str
        [ASSIGNMENT] RESOLVED Updated symbol table: user_id = str
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _session_manager.get_current_user_id
    [CACHE] _session_manager.get_current_user_id -> session_manager.SessionManager.get_current_user_id (cached)
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_user_id
            [INTERMEDIATE] Step 1: _session_manager.get_current_user_id
      -> Resolved to: session_manager.SessionManager.get_current_user_id
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_user_id
        [CACHE] _session_manager.get_current_user_id -> session_manager.SessionManager.get_current_user_id (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [CALL] Found call: _haven_proxy.validate_room_access
    [RESOLVE] Attempting to resolve: ['_haven_proxy', 'validate_room_access']
    [RESOLVE] Chain resolution needed for: ['_haven_proxy', 'validate_room_access']
      [CHAIN] Resolving base: _haven_proxy
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
      [CHAIN] Base resolved: _haven_proxy -> socketio_events._haven_proxy
      [CHAIN] Step 1: Resolving socketio_events._haven_proxy.validate_room_access
        [ATTRIBUTE] Resolving attribute: socketio_events._haven_proxy.validate_room_access
        [ATTRIBUTE] Direct match found: socketio_events._haven_proxy.validate_room_access
      [CHAIN] Step 1 resolved: socketio_events._haven_proxy.validate_room_access
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy.validate_room_access
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.validate_room_access
            [INTERMEDIATE] Step 1: _haven_proxy.validate_room_access
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.validate_room_access
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.validate_room_access::$user_id
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
        [FUNCTION_ARG] Checking argument: room_name
    [RESOLVE] Attempting to resolve: ['room_name']
      [RESOLVE_SIMPLE] Resolving base: room_name
      [CACHE] Hit for room_name: socketio_events.room_name
    [RESOLVE] RESOLVED to: socketio_events.room_name
      [ATTRIBUTE] Found attribute access: _haven_proxy.validate_room_access
        [CACHE] _haven_proxy.validate_room_access -> socketio_events._haven_proxy.validate_room_access (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [CALL] Found call: join_room
    [CACHE] join_room -> flask_socketio.join_room (cached)
        [EMIT_DETECTION] Direct FQN match: flask_socketio.join_room
      -> DETECTED and ADDED emit call: flask_socketio.join_room::$room_name
        [FUNCTION_ARG] Checking argument: room_name
    [RESOLVE] Attempting to resolve: ['room_name']
      [RESOLVE_SIMPLE] Resolving base: room_name
      [CACHE] Hit for room_name: socketio_events.room_name
    [RESOLVE] RESOLVED to: socketio_events.room_name
      [NAME] Found name reference: join_room
        [CACHE] join_room -> flask_socketio.join_room (cached)
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::room_joined
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _session_manager.get_current_timestamp
    [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: _session_manager.get_current_timestamp
      -> Resolved to: session_manager.SessionManager.get_current_timestamp
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_timestamp
        [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::new_room_member
        [EMIT] Room parameter: $room_name
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _haven_proxy.get_user_info
    [RESOLVE] Attempting to resolve: ['_haven_proxy', 'get_user_info']
    [RESOLVE] Chain resolution needed for: ['_haven_proxy', 'get_user_info']
      [CHAIN] Resolving base: _haven_proxy
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
      [CHAIN] Base resolved: _haven_proxy -> socketio_events._haven_proxy
      [CHAIN] Step 1: Resolving socketio_events._haven_proxy.get_user_info
        [ATTRIBUTE] Resolving attribute: socketio_events._haven_proxy.get_user_info
        [ATTRIBUTE] Direct match found: socketio_events._haven_proxy.get_user_info
      [CHAIN] Step 1 resolved: socketio_events._haven_proxy.get_user_info
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy.get_user_info
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.get_user_info
            [INTERMEDIATE] Step 1: _haven_proxy.get_user_info
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.get_user_info
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.get_user_info::$user_id
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
      [ATTRIBUTE] Found attribute access: _haven_proxy.get_user_info
        [CACHE] _haven_proxy.get_user_info -> socketio_events._haven_proxy.get_user_info (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [ASSIGNMENT] Processing: room_stats = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: _haven_proxy.get_room_statistics
    [RESOLVE] Attempting to resolve: ['_haven_proxy', 'get_room_statistics']
    [RESOLVE] Chain resolution needed for: ['_haven_proxy', 'get_room_statistics']
      [CHAIN] Resolving base: _haven_proxy
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
      [CHAIN] Base resolved: _haven_proxy -> socketio_events._haven_proxy
      [CHAIN] Step 1: Resolving socketio_events._haven_proxy.get_room_statistics
        [ATTRIBUTE] Resolving attribute: socketio_events._haven_proxy.get_room_statistics
        [ATTRIBUTE] Direct match found: socketio_events._haven_proxy.get_room_statistics
      [CHAIN] Step 1 resolved: socketio_events._haven_proxy.get_room_statistics
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy.get_room_statistics
      [TYPE_INFERENCE] Call resolved to: socketio_events._haven_proxy.get_room_statistics
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for room_stats
      [NAME] Found name reference: room_stats
    [RESOLVE] Attempting to resolve: ['room_stats']
      [RESOLVE_SIMPLE] Resolving base: room_stats
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable room_stats not found in any scope
      [LOCAL_RESOLVER] can_resolve(room_stats): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(room_stats): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(room_stats): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(room_stats): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(room_stats): socketio_events.room_stats
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: room_stats -> socketio_events.room_stats
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.room_stats
      -> Not module state
      [CALL] Found call: _haven_proxy.get_room_statistics
    [RESOLVE] Attempting to resolve: ['_haven_proxy', 'get_room_statistics']
    [RESOLVE] Chain resolution needed for: ['_haven_proxy', 'get_room_statistics']
      [CHAIN] Resolving base: _haven_proxy
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
      [CHAIN] Base resolved: _haven_proxy -> socketio_events._haven_proxy
      [CHAIN] Step 1: Resolving socketio_events._haven_proxy.get_room_statistics
        [ATTRIBUTE] Resolving attribute: socketio_events._haven_proxy.get_room_statistics
        [ATTRIBUTE] Direct match found: socketio_events._haven_proxy.get_room_statistics
      [CHAIN] Step 1 resolved: socketio_events._haven_proxy.get_room_statistics
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy.get_room_statistics
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.get_room_statistics
            [INTERMEDIATE] Step 1: _haven_proxy.get_room_statistics
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.get_room_statistics
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.get_room_statistics::$room_name
        [FUNCTION_ARG] Checking argument: room_name
    [RESOLVE] Attempting to resolve: ['room_name']
      [RESOLVE_SIMPLE] Resolving base: room_name
      [CACHE] Hit for room_name: socketio_events.room_name
    [RESOLVE] RESOLVED to: socketio_events.room_name
      [ATTRIBUTE] Found attribute access: _haven_proxy.get_room_statistics
        [CACHE] _haven_proxy.get_room_statistics -> socketio_events._haven_proxy.get_room_statistics (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::room_stats_updated
        [EMIT] Room parameter: $room_name
        [FUNCTION_ARG] Checking argument: room_stats
    [RESOLVE] Attempting to resolve: ['room_stats']
      [RESOLVE_SIMPLE] Resolving base: room_stats
      [CACHE] Hit for room_stats: socketio_events.room_stats
    [RESOLVE] RESOLVED to: socketio_events.room_stats
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: room_stats
        [CACHE] room_stats -> socketio_events.room_stats (cached)
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NESTED_FUNCTION] Analyzing nested function: handle_send_message
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'socketio': 'SocketIO', 'haven_proxy': 'HavenProxy'}
      [ASSIGNMENT] Processing: message = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: data.get
    [RESOLVE] Attempting to resolve: ['data', 'get']
    [RESOLVE] Chain resolution needed for: ['data', 'get']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: socketio_events.data
      [CHAIN] Base resolved: data -> socketio_events.data
      [CHAIN] Step 1: Resolving socketio_events.data.get
        [ATTRIBUTE] Resolving attribute: socketio_events.data.get
        [ATTRIBUTE] Direct match found: socketio_events.data.get
      [CHAIN] Step 1 resolved: socketio_events.data.get
    [RESOLVE] RESOLVED to: socketio_events.data.get
      [TYPE_INFERENCE] Call resolved to: socketio_events.data.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for message
      [NAME] Found name reference: message
    [RESOLVE] Attempting to resolve: ['message']
      [RESOLVE_SIMPLE] Resolving base: message
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable message not found in any scope
      [LOCAL_RESOLVER] can_resolve(message): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(message): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(message): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(message): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(message): socketio_events.message
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: message -> socketio_events.message
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.message
      -> Not module state
      [CALL] Found call: data.get
    [CACHE] data.get -> socketio_events.data.get (cached)
            [INTERMEDIATE] Tracking chain steps for: data.get
            [INTERMEDIATE] Step 1: data.get
        [EMIT_DETECTION] Direct FQN match: socketio_events.data.get
      -> DETECTED and ADDED emit call: socketio_events.data.get::message
      [ATTRIBUTE] Found attribute access: data.get
        [CACHE] data.get -> socketio_events.data.get (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> socketio_events.data (cached)
      -> Not module state
      [ASSIGNMENT] Processing: target_type = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: data.get
    [RESOLVE] Attempting to resolve: ['data', 'get']
    [RESOLVE] Chain resolution needed for: ['data', 'get']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: socketio_events.data
      [CHAIN] Base resolved: data -> socketio_events.data
      [CHAIN] Step 1: Resolving socketio_events.data.get
        [ATTRIBUTE] Resolving attribute: socketio_events.data.get
        [ATTRIBUTE] Direct match found: socketio_events.data.get
      [CHAIN] Step 1 resolved: socketio_events.data.get
    [RESOLVE] RESOLVED to: socketio_events.data.get
      [TYPE_INFERENCE] Call resolved to: socketio_events.data.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for target_type
      [NAME] Found name reference: target_type
    [RESOLVE] Attempting to resolve: ['target_type']
      [RESOLVE_SIMPLE] Resolving base: target_type
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable target_type not found in any scope
      [LOCAL_RESOLVER] can_resolve(target_type): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(target_type): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(target_type): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(target_type): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(target_type): socketio_events.target_type
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: target_type -> socketio_events.target_type
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.target_type
      -> Not module state
      [CALL] Found call: data.get
    [CACHE] data.get -> socketio_events.data.get (cached)
            [INTERMEDIATE] Tracking chain steps for: data.get
            [INTERMEDIATE] Step 1: data.get
        [EMIT_DETECTION] Direct FQN match: socketio_events.data.get
      -> DETECTED and ADDED emit call: socketio_events.data.get::target_type
      [ATTRIBUTE] Found attribute access: data.get
        [CACHE] data.get -> socketio_events.data.get (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> socketio_events.data (cached)
      -> Not module state
      [ASSIGNMENT] Processing: target = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: data.get
    [RESOLVE] Attempting to resolve: ['data', 'get']
    [RESOLVE] Chain resolution needed for: ['data', 'get']
      [CHAIN] Resolving base: data
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: socketio_events.data
      [CHAIN] Base resolved: data -> socketio_events.data
      [CHAIN] Step 1: Resolving socketio_events.data.get
        [ATTRIBUTE] Resolving attribute: socketio_events.data.get
        [ATTRIBUTE] Direct match found: socketio_events.data.get
      [CHAIN] Step 1 resolved: socketio_events.data.get
    [RESOLVE] RESOLVED to: socketio_events.data.get
      [TYPE_INFERENCE] Call resolved to: socketio_events.data.get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for target
      [NAME] Found name reference: target
    [RESOLVE] Attempting to resolve: ['target']
      [RESOLVE_SIMPLE] Resolving base: target
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable target not found in any scope
      [LOCAL_RESOLVER] can_resolve(target): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(target): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(target): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(target): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(target): socketio_events.target
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: target -> socketio_events.target
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.target
      -> Not module state
      [CALL] Found call: data.get
    [CACHE] data.get -> socketio_events.data.get (cached)
            [INTERMEDIATE] Tracking chain steps for: data.get
            [INTERMEDIATE] Step 1: data.get
        [EMIT_DETECTION] Direct FQN match: socketio_events.data.get
      -> DETECTED and ADDED emit call: socketio_events.data.get::target
      [ATTRIBUTE] Found attribute access: data.get
        [CACHE] data.get -> socketio_events.data.get (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> socketio_events.data (cached)
      -> Not module state
      [ASSIGNMENT] Processing: user_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: _session_manager.get_current_user_id
    [RESOLVE] Attempting to resolve: ['_session_manager', 'get_current_user_id']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'get_current_user_id']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_user_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_user_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_user_id
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.get_current_user_id
        [RETURN_TYPE_RESOLUTION] Resolving return type: str
        [RETURN_TYPE_RESOLUTION] Class 'str' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: str
      [TYPE_INFERENCE] Could not resolve return type 'str' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: str (from return type - unresolved)
      [SYMBOL_UPDATE] Nested: user_id -> str
        [ASSIGNMENT] RESOLVED Updated symbol table: user_id = str
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _session_manager.get_current_user_id
    [CACHE] _session_manager.get_current_user_id -> session_manager.SessionManager.get_current_user_id (cached)
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_user_id
            [INTERMEDIATE] Step 1: _session_manager.get_current_user_id
      -> Resolved to: session_manager.SessionManager.get_current_user_id
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_user_id
        [CACHE] _session_manager.get_current_user_id -> session_manager.SessionManager.get_current_user_id (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [CALL] Found call: _haven_proxy.validate_message_content
    [RESOLVE] Attempting to resolve: ['_haven_proxy', 'validate_message_content']
    [RESOLVE] Chain resolution needed for: ['_haven_proxy', 'validate_message_content']
      [CHAIN] Resolving base: _haven_proxy
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
      [CHAIN] Base resolved: _haven_proxy -> socketio_events._haven_proxy
      [CHAIN] Step 1: Resolving socketio_events._haven_proxy.validate_message_content
        [ATTRIBUTE] Resolving attribute: socketio_events._haven_proxy.validate_message_content
        [ATTRIBUTE] Direct match found: socketio_events._haven_proxy.validate_message_content
      [CHAIN] Step 1 resolved: socketio_events._haven_proxy.validate_message_content
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy.validate_message_content
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.validate_message_content
            [INTERMEDIATE] Step 1: _haven_proxy.validate_message_content
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.validate_message_content
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.validate_message_content::$message
        [FUNCTION_ARG] Checking argument: message
    [RESOLVE] Attempting to resolve: ['message']
      [RESOLVE_SIMPLE] Resolving base: message
      [CACHE] Hit for message: socketio_events.message
    [RESOLVE] RESOLVED to: socketio_events.message
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
      [ATTRIBUTE] Found attribute access: _haven_proxy.validate_message_content
        [CACHE] _haven_proxy.validate_message_content -> socketio_events._haven_proxy.validate_message_content (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: message
        [CACHE] message -> socketio_events.message (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::message_rejected
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [CALL] Found call: _session_manager.get_current_timestamp
    [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: _session_manager.get_current_timestamp
      -> Resolved to: session_manager.SessionManager.get_current_timestamp
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_timestamp
        [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: target_type
        [CACHE] target_type -> socketio_events.target_type (cached)
      -> Not module state
      [CALL] Found call: _haven_proxy.validate_room_access
    [CACHE] _haven_proxy.validate_room_access -> socketio_events._haven_proxy.validate_room_access (cached)
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.validate_room_access
            [INTERMEDIATE] Step 1: _haven_proxy.validate_room_access
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.validate_room_access
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.validate_room_access::$user_id
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
        [FUNCTION_ARG] Checking argument: target
    [RESOLVE] Attempting to resolve: ['target']
      [RESOLVE_SIMPLE] Resolving base: target
      [CACHE] Hit for target: socketio_events.target
    [RESOLVE] RESOLVED to: socketio_events.target
      [ATTRIBUTE] Found attribute access: _haven_proxy.validate_room_access
        [CACHE] _haven_proxy.validate_room_access -> socketio_events._haven_proxy.validate_room_access (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [NAME] Found name reference: target
        [CACHE] target -> socketio_events.target (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::room_message
        [EMIT] Room parameter: $target
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: message
        [CACHE] message -> socketio_events.message (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _haven_proxy.get_user_info
    [CACHE] _haven_proxy.get_user_info -> socketio_events._haven_proxy.get_user_info (cached)
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.get_user_info
            [INTERMEDIATE] Step 1: _haven_proxy.get_user_info
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.get_user_info
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.get_user_info::$user_id
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
      [ATTRIBUTE] Found attribute access: _haven_proxy.get_user_info
        [CACHE] _haven_proxy.get_user_info -> socketio_events._haven_proxy.get_user_info (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _session_manager.get_current_timestamp
    [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: _session_manager.get_current_timestamp
      -> Resolved to: session_manager.SessionManager.get_current_timestamp
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_timestamp
        [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: target
        [CACHE] target -> socketio_events.target (cached)
      -> Not module state
      [CALL] Found call: _haven_proxy.log_room_message
    [RESOLVE] Attempting to resolve: ['_haven_proxy', 'log_room_message']
    [RESOLVE] Chain resolution needed for: ['_haven_proxy', 'log_room_message']
      [CHAIN] Resolving base: _haven_proxy
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
      [CHAIN] Base resolved: _haven_proxy -> socketio_events._haven_proxy
      [CHAIN] Step 1: Resolving socketio_events._haven_proxy.log_room_message
        [ATTRIBUTE] Resolving attribute: socketio_events._haven_proxy.log_room_message
        [ATTRIBUTE] Direct match found: socketio_events._haven_proxy.log_room_message
      [CHAIN] Step 1 resolved: socketio_events._haven_proxy.log_room_message
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy.log_room_message
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.log_room_message
            [INTERMEDIATE] Step 1: _haven_proxy.log_room_message
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.log_room_message
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.log_room_message::$target
        [FUNCTION_ARG] Checking argument: target
    [RESOLVE] Attempting to resolve: ['target']
      [RESOLVE_SIMPLE] Resolving base: target
      [CACHE] Hit for target: socketio_events.target
    [RESOLVE] RESOLVED to: socketio_events.target
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
        [FUNCTION_ARG] Checking argument: message
    [RESOLVE] Attempting to resolve: ['message']
      [RESOLVE_SIMPLE] Resolving base: message
      [CACHE] Hit for message: socketio_events.message
    [RESOLVE] RESOLVED to: socketio_events.message
      [ATTRIBUTE] Found attribute access: _haven_proxy.log_room_message
        [CACHE] _haven_proxy.log_room_message -> socketio_events._haven_proxy.log_room_message (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: target
        [CACHE] target -> socketio_events.target (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [NAME] Found name reference: message
        [CACHE] message -> socketio_events.message (cached)
      -> Not module state
      [NAME] Found name reference: target_type
        [CACHE] target_type -> socketio_events.target_type (cached)
      -> Not module state
      [CALL] Found call: _haven_proxy.validate_direct_message_permission
    [RESOLVE] Attempting to resolve: ['_haven_proxy', 'validate_direct_message_permission']
    [RESOLVE] Chain resolution needed for: ['_haven_proxy', 'validate_direct_message_permission']
      [CHAIN] Resolving base: _haven_proxy
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
      [CHAIN] Base resolved: _haven_proxy -> socketio_events._haven_proxy
      [CHAIN] Step 1: Resolving socketio_events._haven_proxy.validate_direct_message_permission
        [ATTRIBUTE] Resolving attribute: socketio_events._haven_proxy.validate_direct_message_permission
        [ATTRIBUTE] Direct match found: socketio_events._haven_proxy.validate_direct_message_permission
      [CHAIN] Step 1 resolved: socketio_events._haven_proxy.validate_direct_message_permission
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy.validate_direct_message_permission
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.validate_direct_message_permission
            [INTERMEDIATE] Step 1: _haven_proxy.validate_direct_message_permission
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.validate_direct_message_permission
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.validate_direct_message_permission::$user_id
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
        [FUNCTION_ARG] Checking argument: target
    [RESOLVE] Attempting to resolve: ['target']
      [RESOLVE_SIMPLE] Resolving base: target
      [CACHE] Hit for target: socketio_events.target
    [RESOLVE] RESOLVED to: socketio_events.target
      [ATTRIBUTE] Found attribute access: _haven_proxy.validate_direct_message_permission
        [CACHE] _haven_proxy.validate_direct_message_permission -> socketio_events._haven_proxy.validate_direct_message_permission (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [NAME] Found name reference: target
        [CACHE] target -> socketio_events.target (cached)
      -> Not module state
      [ASSIGNMENT] Processing: target_room = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: target_room
    [RESOLVE] Attempting to resolve: ['target_room']
      [RESOLVE_SIMPLE] Resolving base: target_room
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable target_room not found in any scope
      [LOCAL_RESOLVER] can_resolve(target_room): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(target_room): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(target_room): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(target_room): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(target_room): socketio_events.target_room
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: target_room -> socketio_events.target_room
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.target_room
      -> Not module state
      [NAME] Found name reference: target
        [CACHE] target -> socketio_events.target (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::direct_message
        [EMIT] Room parameter: $target_room
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: message
        [CACHE] message -> socketio_events.message (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _haven_proxy.get_user_info
    [CACHE] _haven_proxy.get_user_info -> socketio_events._haven_proxy.get_user_info (cached)
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.get_user_info
            [INTERMEDIATE] Step 1: _haven_proxy.get_user_info
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.get_user_info
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.get_user_info::$user_id
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
      [ATTRIBUTE] Found attribute access: _haven_proxy.get_user_info
        [CACHE] _haven_proxy.get_user_info -> socketio_events._haven_proxy.get_user_info (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _session_manager.get_current_timestamp
    [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: _session_manager.get_current_timestamp
      -> Resolved to: session_manager.SessionManager.get_current_timestamp
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_timestamp
        [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: target_room
        [CACHE] target_room -> socketio_events.target_room (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::message_delivered
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: target
        [CACHE] target -> socketio_events.target (cached)
      -> Not module state
      [CALL] Found call: _session_manager.get_current_timestamp
    [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: _session_manager.get_current_timestamp
      -> Resolved to: session_manager.SessionManager.get_current_timestamp
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_timestamp
        [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [NAME] Found name reference: target_type
        [CACHE] target_type -> socketio_events.target_type (cached)
      -> Not module state
      [CALL] Found call: _haven_proxy.validate_broadcast_permission
    [RESOLVE] Attempting to resolve: ['_haven_proxy', 'validate_broadcast_permission']
    [RESOLVE] Chain resolution needed for: ['_haven_proxy', 'validate_broadcast_permission']
      [CHAIN] Resolving base: _haven_proxy
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
      [CHAIN] Base resolved: _haven_proxy -> socketio_events._haven_proxy
      [CHAIN] Step 1: Resolving socketio_events._haven_proxy.validate_broadcast_permission
        [ATTRIBUTE] Resolving attribute: socketio_events._haven_proxy.validate_broadcast_permission
        [ATTRIBUTE] Direct match found: socketio_events._haven_proxy.validate_broadcast_permission
      [CHAIN] Step 1 resolved: socketio_events._haven_proxy.validate_broadcast_permission
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy.validate_broadcast_permission
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.validate_broadcast_permission
            [INTERMEDIATE] Step 1: _haven_proxy.validate_broadcast_permission
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.validate_broadcast_permission
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.validate_broadcast_permission::$user_id
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
      [ATTRIBUTE] Found attribute access: _haven_proxy.validate_broadcast_permission
        [CACHE] _haven_proxy.validate_broadcast_permission -> socketio_events._haven_proxy.validate_broadcast_permission (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: socketio.emit
    [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: socketio.emit
            [INTERMEDIATE] Step 1: socketio.emit
        [EMIT_DETECTION] Direct FQN match: flask_socketio.SocketIO.emit
      -> DETECTED and ADDED emit call: flask_socketio.SocketIO.emit::broadcast_message
        [EMIT] Broadcast parameter: True
      [ATTRIBUTE] Found attribute access: socketio.emit
        [CACHE] socketio.emit -> flask_socketio.SocketIO.emit (cached)
      -> Not module state
      [NAME] Found name reference: socketio
        [CACHE] socketio -> flask_socketio.SocketIO (cached)
      -> Not module state
      [NAME] Found name reference: message
        [CACHE] message -> socketio_events.message (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: _session_manager.get_current_timestamp
    [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: _session_manager.get_current_timestamp
      -> Resolved to: session_manager.SessionManager.get_current_timestamp
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_timestamp
        [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [ASSIGNMENT] Processing: dynamic_events = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: dynamic_events
    [RESOLVE] Attempting to resolve: ['dynamic_events']
      [RESOLVE_SIMPLE] Resolving base: dynamic_events
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable dynamic_events not found in any scope
      [LOCAL_RESOLVER] can_resolve(dynamic_events): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(dynamic_events): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(dynamic_events): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(dynamic_events): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(dynamic_events): socketio_events.dynamic_events
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: dynamic_events -> socketio_events.dynamic_events
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.dynamic_events
      -> Not module state
      [CALL] Found call: registry.batch_register_events
    [RESOLVE] Attempting to resolve: ['registry', 'batch_register_events']
    [RESOLVE] Chain resolution needed for: ['registry', 'batch_register_events']
      [CHAIN] Resolving base: registry
      [RESOLVE_SIMPLE] Resolving base: registry
      [CACHE] Hit for registry: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: registry -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.batch_register_events
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.batch_register_events
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.batch_register_events
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.batch_register_events
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.batch_register_events
            [INTERMEDIATE] Tracking chain steps for: registry.batch_register_events
            [INTERMEDIATE] Step 1: registry.batch_register_events
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.batch_register_events
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.batch_register_events::$dynamic_events
        [FUNCTION_ARG] Checking argument: dynamic_events
    [RESOLVE] Attempting to resolve: ['dynamic_events']
      [RESOLVE_SIMPLE] Resolving base: dynamic_events
      [CACHE] Hit for dynamic_events: socketio_events.dynamic_events
    [RESOLVE] RESOLVED to: socketio_events.dynamic_events
      [ATTRIBUTE] Found attribute access: registry.batch_register_events
        [CACHE] registry.batch_register_events -> socketio_events.SocketIOEventRegistry.batch_register_events (cached)
      -> Not module state
      [NAME] Found name reference: registry
        [CACHE] registry -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: dynamic_events
        [CACHE] dynamic_events -> socketio_events.dynamic_events (cached)
      -> Not module state
      [NAME] Found name reference: event_name
    [RESOLVE] Attempting to resolve: ['event_name']
      [RESOLVE_SIMPLE] Resolving base: event_name
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable event_name not found in any scope
      [LOCAL_RESOLVER] can_resolve(event_name): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(event_name): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(event_name): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(event_name): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(event_name): socketio_events.event_name
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: event_name -> socketio_events.event_name
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.event_name
      -> Not module state
      [CALL] Found call: registry.register_dynamic_event
    [RESOLVE] Attempting to resolve: ['registry', 'register_dynamic_event']
    [RESOLVE] Chain resolution needed for: ['registry', 'register_dynamic_event']
      [CHAIN] Resolving base: registry
      [RESOLVE_SIMPLE] Resolving base: registry
      [CACHE] Hit for registry: socketio_events.SocketIOEventRegistry
      [CHAIN] Base resolved: registry -> socketio_events.SocketIOEventRegistry
      [CHAIN] Step 1: Resolving socketio_events.SocketIOEventRegistry.register_dynamic_event
        [ATTRIBUTE] Resolving attribute: socketio_events.SocketIOEventRegistry.register_dynamic_event
        [ATTRIBUTE] Direct match found: socketio_events.SocketIOEventRegistry.register_dynamic_event
      [CHAIN] Step 1 resolved: socketio_events.SocketIOEventRegistry.register_dynamic_event
    [RESOLVE] RESOLVED to: socketio_events.SocketIOEventRegistry.register_dynamic_event
            [INTERMEDIATE] Tracking chain steps for: registry.register_dynamic_event
            [INTERMEDIATE] Step 1: registry.register_dynamic_event
        [EMIT_DETECTION] Direct FQN match: socketio_events.SocketIOEventRegistry.register_dynamic_event
      -> DETECTED and ADDED emit call: socketio_events.SocketIOEventRegistry.register_dynamic_event::$event_name
        [FUNCTION_ARG] Checking argument: event_name
    [RESOLVE] Attempting to resolve: ['event_name']
      [RESOLVE_SIMPLE] Resolving base: event_name
      [CACHE] Hit for event_name: socketio_events.event_name
    [RESOLVE] RESOLVED to: socketio_events.event_name
      [ATTRIBUTE] Found attribute access: registry.register_dynamic_event
        [CACHE] registry.register_dynamic_event -> socketio_events.SocketIOEventRegistry.register_dynamic_event (cached)
      -> Not module state
      [NAME] Found name reference: registry
        [CACHE] registry -> socketio_events.SocketIOEventRegistry (cached)
      -> Not module state
      [NAME] Found name reference: event_name
        [CACHE] event_name -> socketio_events.event_name (cached)
      -> Not module state
      [CALL] Found call: create_dynamic_handler
    [RESOLVE] Attempting to resolve: ['create_dynamic_handler']
      [RESOLVE_SIMPLE] Resolving base: create_dynamic_handler
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable create_dynamic_handler not found in any scope
      [LOCAL_RESOLVER] can_resolve(create_dynamic_handler): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(create_dynamic_handler): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(create_dynamic_handler): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(create_dynamic_handler): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(create_dynamic_handler): socketio_events.create_dynamic_handler
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: create_dynamic_handler -> socketio_events.create_dynamic_handler
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.create_dynamic_handler
        [EMIT_DETECTION] Direct FQN match: socketio_events.create_dynamic_handler
      -> DETECTED and ADDED emit call: socketio_events.create_dynamic_handler::$event_name
        [FUNCTION_ARG] Checking argument: event_name
    [RESOLVE] Attempting to resolve: ['event_name']
      [RESOLVE_SIMPLE] Resolving base: event_name
      [CACHE] Hit for event_name: socketio_events.event_name
    [RESOLVE] RESOLVED to: socketio_events.event_name
        [FUNCTION_ARG] Checking argument: _haven_proxy
    [RESOLVE] Attempting to resolve: ['_haven_proxy']
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy
        [FUNCTION_ARG] Checking argument: _session_manager
    [RESOLVE] Attempting to resolve: ['_session_manager']
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      [NAME] Found name reference: create_dynamic_handler
        [CACHE] create_dynamic_handler -> socketio_events.create_dynamic_handler (cached)
      -> Not module state
      [NAME] Found name reference: event_name
        [CACHE] event_name -> socketio_events.event_name (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
        [CACHE] _haven_proxy -> socketio_events._haven_proxy (cached)
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: _session_manager
        [CACHE] _session_manager -> session_manager.SessionManager (cached)
      -> Not module state
    [CONTEXT] Exited function: socketio_events.register_events
    [FUNCTION_ANALYSIS] Completed analysis of: socketio_events.register_events
        Calls: 48
        Instantiations: 1
        State Access: 2
        SocketIO Emits: 24
  [FUNCTION] Analyzing function: create_dynamic_handler
    [FUNCTION_ANALYSIS] Starting analysis of: socketio_events.create_dynamic_handler
    [DECORATOR] @trace
    [DECORATOR] @monitor_performance
    [CONTEXT] Entered function: socketio_events.create_dynamic_handler (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 3 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'event_name': 'str', 'proxy': 'HavenProxy', 'session_manager': 'SessionManager'}
        [ARG_TYPE] Processing type annotation for event_name: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable str not found in any scope
      [LOCAL_RESOLVER] can_resolve(str): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(str): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(str): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(str): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(str): socketio_events.str
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: str -> socketio_events.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.str
      [SYMBOL_UPDATE] Function: event_name -> socketio_events.str
        [ARG_TYPE] RESOLVED event_name : socketio_events.str
        [ARG_TYPE] Processing type annotation for proxy: HavenProxy
    [RESOLVE] Attempting to resolve: ['HavenProxy']
      [RESOLVE_SIMPLE] Resolving base: HavenProxy
      [CACHE] Hit for HavenProxy: proxy_handler.HavenProxy
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      [SYMBOL_UPDATE] Function: proxy -> proxy_handler.HavenProxy
        [ARG_TYPE] RESOLVED proxy : proxy_handler.HavenProxy
        [ARG_TYPE] Processing type annotation for session_manager: SessionManager
    [RESOLVE] Attempting to resolve: ['SessionManager']
      [RESOLVE_SIMPLE] Resolving base: SessionManager
      [CACHE] Hit for SessionManager: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      [SYMBOL_UPDATE] Function: session_manager -> session_manager.SessionManager
        [ARG_TYPE] RESOLVED session_manager : session_manager.SessionManager
      [NESTED_FUNCTION] Analyzing nested function: dynamic_handler
      [SYMBOL_TABLE] Entered nested scope
      [ARG_PROCESSING] Processing 1 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'event_name': 'str', 'proxy': 'HavenProxy', 'session_manager': 'SessionManager'}
      [ASSIGNMENT] Processing: user_id = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: session_manager.get_current_user_id
    [RESOLVE] Attempting to resolve: ['session_manager', 'get_current_user_id']
    [RESOLVE] Chain resolution needed for: ['session_manager', 'get_current_user_id']
      [CHAIN] Resolving base: session_manager
      [RESOLVE_SIMPLE] Resolving base: session_manager
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found session_manager in function scope: session_manager.SessionManager
      [LOCAL_RESOLVER] can_resolve(session_manager): True
      [SYMBOL_LOOKUP] Found session_manager in function scope: session_manager.SessionManager
      [LOCAL_RESOLVER] resolve(session_manager): session_manager.SessionManager
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: session_manager -> session_manager.SessionManager
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_user_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_user_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_user_id
      [TYPE_INFERENCE] Call resolved to: session_manager.SessionManager.get_current_user_id
        [RETURN_TYPE_RESOLUTION] Resolving return type: str
        [RETURN_TYPE_RESOLUTION] Class 'str' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: str
      [TYPE_INFERENCE] Could not resolve return type 'str' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: str (from return type - unresolved)
      [SYMBOL_UPDATE] Nested: user_id -> str
        [ASSIGNMENT] RESOLVED Updated symbol table: user_id = str
      [NAME] Found name reference: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
      -> Not module state
      [CALL] Found call: session_manager.get_current_user_id
    [RESOLVE] Attempting to resolve: ['session_manager', 'get_current_user_id']
    [RESOLVE] Chain resolution needed for: ['session_manager', 'get_current_user_id']
      [CHAIN] Resolving base: session_manager
      [RESOLVE_SIMPLE] Resolving base: session_manager
      [CACHE] Hit for session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_user_id
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_user_id
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_user_id
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_user_id
            [INTERMEDIATE] Tracking chain steps for: session_manager.get_current_user_id
            [INTERMEDIATE] Step 1: session_manager.get_current_user_id
      -> Resolved to: session_manager.SessionManager.get_current_user_id
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session_manager.get_current_user_id
        [CACHE] session_manager.get_current_user_id -> session_manager.SessionManager.get_current_user_id (cached)
      -> Not module state
      [NAME] Found name reference: session_manager
    [RESOLVE] Attempting to resolve: ['session_manager']
      [RESOLVE_SIMPLE] Resolving base: session_manager
      [CACHE] Hit for session_manager: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
      [CALL] Found call: proxy.validate_event_data
    [RESOLVE] Attempting to resolve: ['proxy', 'validate_event_data']
    [RESOLVE] Chain resolution needed for: ['proxy', 'validate_event_data']
      [CHAIN] Resolving base: proxy
      [RESOLVE_SIMPLE] Resolving base: proxy
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found proxy in function scope: proxy_handler.HavenProxy
      [LOCAL_RESOLVER] can_resolve(proxy): True
      [SYMBOL_LOOKUP] Found proxy in function scope: proxy_handler.HavenProxy
      [LOCAL_RESOLVER] resolve(proxy): proxy_handler.HavenProxy
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: proxy -> proxy_handler.HavenProxy
      [VALIDATION] PASS Resolution validated
      [CHAIN] Base resolved: proxy -> proxy_handler.HavenProxy
      [CHAIN] Step 1: Resolving proxy_handler.HavenProxy.validate_event_data
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.validate_event_data
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.validate_event_data
      [CHAIN] Step 1 resolved: proxy_handler.HavenProxy.validate_event_data
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy.validate_event_data
            [INTERMEDIATE] Tracking chain steps for: proxy.validate_event_data
            [INTERMEDIATE] Step 1: proxy.validate_event_data
      -> Resolved to: proxy_handler.HavenProxy.validate_event_data
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: event_name
    [RESOLVE] Attempting to resolve: ['event_name']
      [RESOLVE_SIMPLE] Resolving base: event_name
      [CACHE] Hit for event_name: socketio_events.event_name
    [RESOLVE] RESOLVED to: socketio_events.event_name
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: socketio_events.data
    [RESOLVE] RESOLVED to: socketio_events.data
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
      [ATTRIBUTE] Found attribute access: proxy.validate_event_data
        [CACHE] proxy.validate_event_data -> proxy_handler.HavenProxy.validate_event_data (cached)
      -> Not module state
      [NAME] Found name reference: proxy
    [RESOLVE] Attempting to resolve: ['proxy']
      [RESOLVE_SIMPLE] Resolving base: proxy
      [CACHE] Hit for proxy: proxy_handler.HavenProxy
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy
      -> Not module state
      [NAME] Found name reference: event_name
    [RESOLVE] Attempting to resolve: ['event_name']
      [RESOLVE_SIMPLE] Resolving base: event_name
      [CACHE] Hit for event_name: socketio_events.event_name
    [RESOLVE] RESOLVED to: socketio_events.event_name
      -> Not module state
      [NAME] Found name reference: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: socketio_events.data
    [RESOLVE] RESOLVED to: socketio_events.data
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [ASSIGNMENT] Processing: result = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: proxy.process_event
    [RESOLVE] Attempting to resolve: ['proxy', 'process_event']
    [RESOLVE] Chain resolution needed for: ['proxy', 'process_event']
      [CHAIN] Resolving base: proxy
      [RESOLVE_SIMPLE] Resolving base: proxy
      [CACHE] Hit for proxy: proxy_handler.HavenProxy
      [CHAIN] Base resolved: proxy -> proxy_handler.HavenProxy
      [CHAIN] Step 1: Resolving proxy_handler.HavenProxy.process_event
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.process_event
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.process_event
      [CHAIN] Step 1 resolved: proxy_handler.HavenProxy.process_event
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy.process_event
      [TYPE_INFERENCE] Call resolved to: proxy_handler.HavenProxy.process_event
        [RETURN_TYPE_RESOLUTION] Resolving return type: Dict[str, Any]
        [RETURN_TYPE_RESOLUTION] Class 'Dict[str, Any]' not found in any module
        [RETURN_TYPE_RESOLUTION] Could not resolve return type: Dict[str, Any]
      [TYPE_INFERENCE] Could not resolve return type 'Dict[str, Any]' to FQN
      [TYPE_INFERENCE] RESOLVED Inferred type: Dict[str, Any] (from return type - unresolved)
      [SYMBOL_UPDATE] Nested: result -> Dict[str, Any]
        [ASSIGNMENT] RESOLVED Updated symbol table: result = Dict[str, Any]
      [NAME] Found name reference: result
    [RESOLVE] Attempting to resolve: ['result']
      [RESOLVE_SIMPLE] Resolving base: result
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found result in nested scope: Dict[str, Any]
      [LOCAL_RESOLVER] can_resolve(result): True
      [SYMBOL_LOOKUP] Found result in nested scope: Dict[str, Any]
      [LOCAL_RESOLVER] resolve(result): Dict[str, Any]
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: result -> Dict[str, Any]
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: Dict[str, Any]
      -> Not module state
      [CALL] Found call: proxy.process_event
    [RESOLVE] Attempting to resolve: ['proxy', 'process_event']
    [RESOLVE] Chain resolution needed for: ['proxy', 'process_event']
      [CHAIN] Resolving base: proxy
      [RESOLVE_SIMPLE] Resolving base: proxy
      [CACHE] Hit for proxy: proxy_handler.HavenProxy
      [CHAIN] Base resolved: proxy -> proxy_handler.HavenProxy
      [CHAIN] Step 1: Resolving proxy_handler.HavenProxy.process_event
        [ATTRIBUTE] Resolving attribute: proxy_handler.HavenProxy.process_event
        [ATTRIBUTE] Direct match found: proxy_handler.HavenProxy.process_event
      [CHAIN] Step 1 resolved: proxy_handler.HavenProxy.process_event
    [RESOLVE] RESOLVED to: proxy_handler.HavenProxy.process_event
            [INTERMEDIATE] Tracking chain steps for: proxy.process_event
            [INTERMEDIATE] Step 1: proxy.process_event
      -> Resolved to: proxy_handler.HavenProxy.process_event
      -> ADDED to calls
        [FUNCTION_ARG] Checking argument: event_name
    [RESOLVE] Attempting to resolve: ['event_name']
      [RESOLVE_SIMPLE] Resolving base: event_name
      [CACHE] Hit for event_name: socketio_events.event_name
    [RESOLVE] RESOLVED to: socketio_events.event_name
        [FUNCTION_ARG] Checking argument: data
    [RESOLVE] Attempting to resolve: ['data']
      [RESOLVE_SIMPLE] Resolving base: data
      [CACHE] Hit for data: socketio_events.data
    [RESOLVE] RESOLVED to: socketio_events.data
        [FUNCTION_ARG] Checking argument: user_id
    [RESOLVE] Attempting to resolve: ['user_id']
      [RESOLVE_SIMPLE] Resolving base: user_id
      [CACHE] Hit for user_id: socketio_events.user_id
    [RESOLVE] RESOLVED to: socketio_events.user_id
      [ATTRIBUTE] Found attribute access: proxy.process_event
        [CACHE] proxy.process_event -> proxy_handler.HavenProxy.process_event (cached)
      -> Not module state
      [NAME] Found name reference: proxy
        [CACHE] proxy -> proxy_handler.HavenProxy (cached)
      -> Not module state
      [NAME] Found name reference: event_name
        [CACHE] event_name -> socketio_events.event_name (cached)
      -> Not module state
      [NAME] Found name reference: data
        [CACHE] data -> socketio_events.data (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: result.get
    [RESOLVE] Attempting to resolve: ['result', 'get']
    [RESOLVE] Chain resolution needed for: ['result', 'get']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: Dict[str, Any]
      [CHAIN] Base resolved: result -> Dict[str, Any]
      [CHAIN] Step 1: Resolving Dict[str, Any].get
        [ATTRIBUTE] Resolving attribute: Dict[str, Any].get
        [ATTRIBUTE] Direct match found: Dict[str, Any].get
      [CHAIN] Step 1 resolved: Dict[str, Any].get
    [RESOLVE] RESOLVED to: Dict[str, Any].get
            [INTERMEDIATE] Tracking chain steps for: result.get
            [INTERMEDIATE] Step 1: result.get
      -> Resolved to: Dict[str, Any].get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: result.get
        [CACHE] result.get -> Dict[str, Any].get (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> Dict[str, Any] (cached)
      -> Not module state
      [CALL] Found call: _socketio_instance.emit
    [RESOLVE] Attempting to resolve: ['_socketio_instance', 'emit']
    [RESOLVE] Chain resolution needed for: ['_socketio_instance', 'emit']
      [CHAIN] Resolving base: _socketio_instance
      [RESOLVE_SIMPLE] Resolving base: _socketio_instance
      [CACHE] Hit for _socketio_instance: socketio_events._socketio_instance
      [CHAIN] Base resolved: _socketio_instance -> socketio_events._socketio_instance
      [CHAIN] Step 1: Resolving socketio_events._socketio_instance.emit
        [ATTRIBUTE] Resolving attribute: socketio_events._socketio_instance.emit
        [ATTRIBUTE] Direct match found: socketio_events._socketio_instance.emit
      [CHAIN] Step 1 resolved: socketio_events._socketio_instance.emit
    [RESOLVE] RESOLVED to: socketio_events._socketio_instance.emit
            [INTERMEDIATE] Tracking chain steps for: _socketio_instance.emit
            [INTERMEDIATE] Step 1: _socketio_instance.emit
        [EMIT_DETECTION] Direct FQN match: socketio_events._socketio_instance.emit
      -> DETECTED and ADDED emit call: socketio_events._socketio_instance.emit::${event_name}_processed
      [ATTRIBUTE] Found attribute access: _socketio_instance.emit
        [CACHE] _socketio_instance.emit -> socketio_events._socketio_instance.emit (cached)
      -> Not module state
      [NAME] Found name reference: _socketio_instance
    [RESOLVE] Attempting to resolve: ['_socketio_instance']
      [RESOLVE_SIMPLE] Resolving base: _socketio_instance
      [CACHE] Hit for _socketio_instance: socketio_events._socketio_instance
    [RESOLVE] RESOLVED to: socketio_events._socketio_instance
      -> Resolved to state: socketio_events._socketio_instance
      [SYMBOL_LOOKUP] Variable _socketio_instance not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: event_name
        [CACHE] event_name -> socketio_events.event_name (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> Dict[str, Any] (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: session_manager.get_current_timestamp
    [RESOLVE] Attempting to resolve: ['session_manager', 'get_current_timestamp']
    [RESOLVE] Chain resolution needed for: ['session_manager', 'get_current_timestamp']
      [CHAIN] Resolving base: session_manager
      [RESOLVE_SIMPLE] Resolving base: session_manager
      [CACHE] Hit for session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_timestamp
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_timestamp
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_timestamp
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_timestamp
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_timestamp
            [INTERMEDIATE] Tracking chain steps for: session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: session_manager.get_current_timestamp
      -> Resolved to: session_manager.SessionManager.get_current_timestamp
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session_manager.get_current_timestamp
        [CACHE] session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
      -> Not module state
      [NAME] Found name reference: session_manager
        [CACHE] session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [CALL] Found call: result.get
    [CACHE] result.get -> Dict[str, Any].get (cached)
            [INTERMEDIATE] Tracking chain steps for: result.get
            [INTERMEDIATE] Step 1: result.get
      -> Resolved to: Dict[str, Any].get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: result.get
        [CACHE] result.get -> Dict[str, Any].get (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> Dict[str, Any] (cached)
      -> Not module state
      [CALL] Found call: _socketio_instance.emit
    [CACHE] _socketio_instance.emit -> socketio_events._socketio_instance.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: _socketio_instance.emit
            [INTERMEDIATE] Step 1: _socketio_instance.emit
        [EMIT_DETECTION] Direct FQN match: socketio_events._socketio_instance.emit
      -> DETECTED and ADDED emit call: socketio_events._socketio_instance.emit::${event_name}_notification
        [EMIT] Broadcast parameter: True
      [ATTRIBUTE] Found attribute access: _socketio_instance.emit
        [CACHE] _socketio_instance.emit -> socketio_events._socketio_instance.emit (cached)
      -> Not module state
      [NAME] Found name reference: _socketio_instance
        [CACHE] _socketio_instance -> socketio_events._socketio_instance (cached)
      -> Resolved to state: socketio_events._socketio_instance
      [SYMBOL_LOOKUP] Variable _socketio_instance not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: event_name
        [CACHE] event_name -> socketio_events.event_name (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: result.get
    [CACHE] result.get -> Dict[str, Any].get (cached)
            [INTERMEDIATE] Tracking chain steps for: result.get
            [INTERMEDIATE] Step 1: result.get
      -> Resolved to: Dict[str, Any].get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: result.get
        [CACHE] result.get -> Dict[str, Any].get (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> Dict[str, Any] (cached)
      -> Not module state
      [CALL] Found call: result.get
    [CACHE] result.get -> Dict[str, Any].get (cached)
            [INTERMEDIATE] Tracking chain steps for: result.get
            [INTERMEDIATE] Step 1: result.get
      -> Resolved to: Dict[str, Any].get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: result.get
        [CACHE] result.get -> Dict[str, Any].get (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> Dict[str, Any] (cached)
      -> Not module state
      [ASSIGNMENT] Processing: room_name = ...
        [ASSIGNMENT] Call assignment detected
      [TYPE_INFERENCE] Attempting to infer type from call: result.get
    [RESOLVE] Attempting to resolve: ['result', 'get']
    [RESOLVE] Chain resolution needed for: ['result', 'get']
      [CHAIN] Resolving base: result
      [RESOLVE_SIMPLE] Resolving base: result
      [CACHE] Hit for result: Dict[str, Any]
      [CHAIN] Base resolved: result -> Dict[str, Any]
      [CHAIN] Step 1: Resolving Dict[str, Any].get
        [ATTRIBUTE] Resolving attribute: Dict[str, Any].get
        [ATTRIBUTE] Direct match found: Dict[str, Any].get
      [CHAIN] Step 1 resolved: Dict[str, Any].get
    [RESOLVE] RESOLVED to: Dict[str, Any].get
      [TYPE_INFERENCE] Call resolved to: Dict[str, Any].get
      [TYPE_INFERENCE] FAILED Could not infer type
        [ASSIGNMENT] FAILED Could not infer type for room_name
      [NAME] Found name reference: room_name
    [RESOLVE] Attempting to resolve: ['room_name']
      [RESOLVE_SIMPLE] Resolving base: room_name
      [CACHE] Hit for room_name: socketio_events.room_name
    [RESOLVE] RESOLVED to: socketio_events.room_name
      -> Not module state
      [CALL] Found call: result.get
    [CACHE] result.get -> Dict[str, Any].get (cached)
            [INTERMEDIATE] Tracking chain steps for: result.get
            [INTERMEDIATE] Step 1: result.get
      -> Resolved to: Dict[str, Any].get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: result.get
        [CACHE] result.get -> Dict[str, Any].get (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> Dict[str, Any] (cached)
      -> Not module state
      [CALL] Found call: _socketio_instance.emit
    [CACHE] _socketio_instance.emit -> socketio_events._socketio_instance.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: _socketio_instance.emit
            [INTERMEDIATE] Step 1: _socketio_instance.emit
        [EMIT_DETECTION] Direct FQN match: socketio_events._socketio_instance.emit
      -> DETECTED and ADDED emit call: socketio_events._socketio_instance.emit::${event_name}_room_update
        [EMIT] Room parameter: $room_name
      [ATTRIBUTE] Found attribute access: _socketio_instance.emit
        [CACHE] _socketio_instance.emit -> socketio_events._socketio_instance.emit (cached)
      -> Not module state
      [NAME] Found name reference: _socketio_instance
        [CACHE] _socketio_instance -> socketio_events._socketio_instance (cached)
      -> Resolved to state: socketio_events._socketio_instance
      [SYMBOL_LOOKUP] Variable _socketio_instance not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: event_name
        [CACHE] event_name -> socketio_events.event_name (cached)
      -> Not module state
      [CALL] Found call: result.get
    [CACHE] result.get -> Dict[str, Any].get (cached)
            [INTERMEDIATE] Tracking chain steps for: result.get
            [INTERMEDIATE] Step 1: result.get
      -> Resolved to: Dict[str, Any].get
      -> REJECTED (not in catalog or allowlist)
      [ATTRIBUTE] Found attribute access: result.get
        [CACHE] result.get -> Dict[str, Any].get (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> Dict[str, Any] (cached)
      -> Not module state
      [NAME] Found name reference: room_name
        [CACHE] room_name -> socketio_events.room_name (cached)
      -> Not module state
      [NAME] Found name reference: result
        [CACHE] result -> Dict[str, Any] (cached)
      -> Not module state
      [CALL] Found call: _socketio_instance.emit
    [CACHE] _socketio_instance.emit -> socketio_events._socketio_instance.emit (cached)
            [INTERMEDIATE] Tracking chain steps for: _socketio_instance.emit
            [INTERMEDIATE] Step 1: _socketio_instance.emit
        [EMIT_DETECTION] Direct FQN match: socketio_events._socketio_instance.emit
      -> DETECTED and ADDED emit call: socketio_events._socketio_instance.emit::${event_name}_error
      [ATTRIBUTE] Found attribute access: _socketio_instance.emit
        [CACHE] _socketio_instance.emit -> socketio_events._socketio_instance.emit (cached)
      -> Not module state
      [NAME] Found name reference: _socketio_instance
        [CACHE] _socketio_instance -> socketio_events._socketio_instance (cached)
      -> Resolved to state: socketio_events._socketio_instance
      [SYMBOL_LOOKUP] Variable _socketio_instance not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: event_name
        [CACHE] event_name -> socketio_events.event_name (cached)
      -> Not module state
      [NAME] Found name reference: user_id
        [CACHE] user_id -> socketio_events.user_id (cached)
      -> Not module state
      [CALL] Found call: session_manager.get_current_timestamp
    [CACHE] session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
            [INTERMEDIATE] Tracking chain steps for: session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: session_manager.get_current_timestamp
      -> Resolved to: session_manager.SessionManager.get_current_timestamp
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: session_manager.get_current_timestamp
        [CACHE] session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
      -> Not module state
      [NAME] Found name reference: session_manager
        [CACHE] session_manager -> session_manager.SessionManager (cached)
      -> Not module state
      [SYMBOL_TABLE] Exited nested scope
      [NAME] Found name reference: dynamic_handler
    [RESOLVE] Attempting to resolve: ['dynamic_handler']
      [RESOLVE_SIMPLE] Resolving base: dynamic_handler
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable dynamic_handler not found in any scope
      [LOCAL_RESOLVER] can_resolve(dynamic_handler): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(dynamic_handler): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(dynamic_handler): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(dynamic_handler): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(dynamic_handler): socketio_events.dynamic_handler
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: dynamic_handler -> socketio_events.dynamic_handler
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.dynamic_handler
      -> Not module state
    [CONTEXT] Exited function: socketio_events.create_dynamic_handler
    [FUNCTION_ANALYSIS] Completed analysis of: socketio_events.create_dynamic_handler
        Calls: 8
        Instantiations: 0
        State Access: 1
        SocketIO Emits: 4
  [FUNCTION] Analyzing function: emergency_broadcast
    [FUNCTION_ANALYSIS] Starting analysis of: socketio_events.emergency_broadcast
    [CONTEXT] Entered function: socketio_events.emergency_broadcast (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'message': 'str', 'severity': 'str'}
        [ARG_TYPE] Processing type annotation for message: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: socketio_events.str
    [RESOLVE] RESOLVED to: socketio_events.str
      [SYMBOL_UPDATE] Function: message -> socketio_events.str
        [ARG_TYPE] RESOLVED message : socketio_events.str
        [ARG_TYPE] Processing type annotation for severity: str
        [CACHE] str -> socketio_events.str (cached)
      [SYMBOL_UPDATE] Function: severity -> socketio_events.str
        [ARG_TYPE] RESOLVED severity : socketio_events.str
      [NAME] Found name reference: _socketio_instance
    [RESOLVE] Attempting to resolve: ['_socketio_instance']
      [RESOLVE_SIMPLE] Resolving base: _socketio_instance
      [CACHE] Hit for _socketio_instance: socketio_events._socketio_instance
    [RESOLVE] RESOLVED to: socketio_events._socketio_instance
      -> Resolved to state: socketio_events._socketio_instance
      [SYMBOL_LOOKUP] Variable _socketio_instance not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: _haven_proxy
    [RESOLVE] Attempting to resolve: ['_haven_proxy']
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [CALL] Found call: _socketio_instance.emit
    [RESOLVE] Attempting to resolve: ['_socketio_instance', 'emit']
    [RESOLVE] Chain resolution needed for: ['_socketio_instance', 'emit']
      [CHAIN] Resolving base: _socketio_instance
      [RESOLVE_SIMPLE] Resolving base: _socketio_instance
      [CACHE] Hit for _socketio_instance: socketio_events._socketio_instance
      [CHAIN] Base resolved: _socketio_instance -> socketio_events._socketio_instance
      [CHAIN] Step 1: Resolving socketio_events._socketio_instance.emit
        [ATTRIBUTE] Resolving attribute: socketio_events._socketio_instance.emit
        [ATTRIBUTE] Direct match found: socketio_events._socketio_instance.emit
      [CHAIN] Step 1 resolved: socketio_events._socketio_instance.emit
    [RESOLVE] RESOLVED to: socketio_events._socketio_instance.emit
            [INTERMEDIATE] Tracking chain steps for: _socketio_instance.emit
            [INTERMEDIATE] Step 1: _socketio_instance.emit
        [EMIT_DETECTION] Direct FQN match: socketio_events._socketio_instance.emit
      -> DETECTED and ADDED emit call: socketio_events._socketio_instance.emit::emergency_broadcast
        [EMIT] Broadcast parameter: True
      [ATTRIBUTE] Found attribute access: _socketio_instance.emit
        [CACHE] _socketio_instance.emit -> socketio_events._socketio_instance.emit (cached)
      -> Not module state
      [NAME] Found name reference: _socketio_instance
        [CACHE] _socketio_instance -> socketio_events._socketio_instance (cached)
      -> Resolved to state: socketio_events._socketio_instance
      [SYMBOL_LOOKUP] Variable _socketio_instance not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: message
    [RESOLVE] Attempting to resolve: ['message']
      [RESOLVE_SIMPLE] Resolving base: message
      [CACHE] Hit for message: socketio_events.message
    [RESOLVE] RESOLVED to: socketio_events.message
      -> Not module state
      [NAME] Found name reference: severity
    [RESOLVE] Attempting to resolve: ['severity']
      [RESOLVE_SIMPLE] Resolving base: severity
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found severity in function scope: socketio_events.str
      [LOCAL_RESOLVER] can_resolve(severity): True
      [SYMBOL_LOOKUP] Found severity in function scope: socketio_events.str
      [LOCAL_RESOLVER] resolve(severity): socketio_events.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: severity -> socketio_events.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.str
      -> Not module state
      [CALL] Found call: _session_manager.get_current_timestamp
    [RESOLVE] Attempting to resolve: ['_session_manager', 'get_current_timestamp']
    [RESOLVE] Chain resolution needed for: ['_session_manager', 'get_current_timestamp']
      [CHAIN] Resolving base: _session_manager
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
      [CHAIN] Base resolved: _session_manager -> session_manager.SessionManager
      [CHAIN] Step 1: Resolving session_manager.SessionManager.get_current_timestamp
        [ATTRIBUTE] Resolving attribute: session_manager.SessionManager.get_current_timestamp
        [ATTRIBUTE] Direct match found: session_manager.SessionManager.get_current_timestamp
      [CHAIN] Step 1 resolved: session_manager.SessionManager.get_current_timestamp
    [RESOLVE] RESOLVED to: session_manager.SessionManager.get_current_timestamp
            [INTERMEDIATE] Tracking chain steps for: _session_manager.get_current_timestamp
            [INTERMEDIATE] Step 1: _session_manager.get_current_timestamp
      -> Resolved to: session_manager.SessionManager.get_current_timestamp
      -> ADDED to calls
      [ATTRIBUTE] Found attribute access: _session_manager.get_current_timestamp
        [CACHE] _session_manager.get_current_timestamp -> session_manager.SessionManager.get_current_timestamp (cached)
      -> Not module state
      [NAME] Found name reference: _session_manager
    [RESOLVE] Attempting to resolve: ['_session_manager']
      [RESOLVE_SIMPLE] Resolving base: _session_manager
      [CACHE] Hit for _session_manager: session_manager.SessionManager
    [RESOLVE] RESOLVED to: session_manager.SessionManager
      -> Not module state
    [CONTEXT] Exited function: socketio_events.emergency_broadcast
    [FUNCTION_ANALYSIS] Completed analysis of: socketio_events.emergency_broadcast
        Calls: 2
        Instantiations: 0
        State Access: 2
        SocketIO Emits: 1
  [FUNCTION] Analyzing function: admin_notification
    [FUNCTION_ANALYSIS] Starting analysis of: socketio_events.admin_notification
    [CONTEXT] Entered function: socketio_events.admin_notification (depth: 1)
    [SYMBOL_TABLE] Entered function scope
      [ARG_PROCESSING] Processing 2 arguments
        [ARG_PROCESSING] Found parameter types in recon data: {'admin_id': 'str', 'notification': 'Dict[str, Any]'}
        [ARG_TYPE] Processing type annotation for admin_id: str
    [RESOLVE] Attempting to resolve: ['str']
      [RESOLVE_SIMPLE] Resolving base: str
      [CACHE] Hit for str: socketio_events.str
    [RESOLVE] RESOLVED to: socketio_events.str
      [SYMBOL_UPDATE] Function: admin_id -> socketio_events.str
        [ARG_TYPE] RESOLVED admin_id : socketio_events.str
      [NAME] Found name reference: _socketio_instance
    [RESOLVE] Attempting to resolve: ['_socketio_instance']
      [RESOLVE_SIMPLE] Resolving base: _socketio_instance
      [CACHE] Hit for _socketio_instance: socketio_events._socketio_instance
    [RESOLVE] RESOLVED to: socketio_events._socketio_instance
      -> Resolved to state: socketio_events._socketio_instance
      [SYMBOL_LOOKUP] Variable _socketio_instance not found in any scope
      -> ADDED to accessed_state
      [CALL] Found call: _haven_proxy.validate_admin_role
    [RESOLVE] Attempting to resolve: ['_haven_proxy', 'validate_admin_role']
    [RESOLVE] Chain resolution needed for: ['_haven_proxy', 'validate_admin_role']
      [CHAIN] Resolving base: _haven_proxy
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
      [CHAIN] Base resolved: _haven_proxy -> socketio_events._haven_proxy
      [CHAIN] Step 1: Resolving socketio_events._haven_proxy.validate_admin_role
        [ATTRIBUTE] Resolving attribute: socketio_events._haven_proxy.validate_admin_role
        [ATTRIBUTE] Direct match found: socketio_events._haven_proxy.validate_admin_role
      [CHAIN] Step 1 resolved: socketio_events._haven_proxy.validate_admin_role
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy.validate_admin_role
            [INTERMEDIATE] Tracking chain steps for: _haven_proxy.validate_admin_role
            [INTERMEDIATE] Step 1: _haven_proxy.validate_admin_role
        [EMIT_DETECTION] Direct FQN match: socketio_events._haven_proxy.validate_admin_role
      -> DETECTED and ADDED emit call: socketio_events._haven_proxy.validate_admin_role::$admin_id
        [FUNCTION_ARG] Checking argument: admin_id
    [RESOLVE] Attempting to resolve: ['admin_id']
      [RESOLVE_SIMPLE] Resolving base: admin_id
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Found admin_id in function scope: socketio_events.str
      [LOCAL_RESOLVER] can_resolve(admin_id): True
      [SYMBOL_LOOKUP] Found admin_id in function scope: socketio_events.str
      [LOCAL_RESOLVER] resolve(admin_id): socketio_events.str
      [STRATEGY] SUCCESS LocalVariableResolverVisitor succeeded: admin_id -> socketio_events.str
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.str
      [ATTRIBUTE] Found attribute access: _haven_proxy.validate_admin_role
        [CACHE] _haven_proxy.validate_admin_role -> socketio_events._haven_proxy.validate_admin_role (cached)
      -> Not module state
      [NAME] Found name reference: _haven_proxy
    [RESOLVE] Attempting to resolve: ['_haven_proxy']
      [RESOLVE_SIMPLE] Resolving base: _haven_proxy
      [CACHE] Hit for _haven_proxy: socketio_events._haven_proxy
    [RESOLVE] RESOLVED to: socketio_events._haven_proxy
      -> Resolved to state: socketio_events._haven_proxy
      [SYMBOL_LOOKUP] Variable _haven_proxy not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: admin_id
    [RESOLVE] Attempting to resolve: ['admin_id']
      [RESOLVE_SIMPLE] Resolving base: admin_id
      [CACHE] Hit for admin_id: socketio_events.str
    [RESOLVE] RESOLVED to: socketio_events.str
      -> Not module state
      [ASSIGNMENT] Processing: admin_room = ...
        [ASSIGNMENT] Non-call assignment
      [NAME] Found name reference: admin_room
    [RESOLVE] Attempting to resolve: ['admin_room']
      [RESOLVE_SIMPLE] Resolving base: admin_room
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable admin_room not found in any scope
      [LOCAL_RESOLVER] can_resolve(admin_room): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(admin_room): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(admin_room): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(admin_room): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(admin_room): socketio_events.admin_room
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: admin_room -> socketio_events.admin_room
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.admin_room
      -> Not module state
      [NAME] Found name reference: admin_id
        [CACHE] admin_id -> socketio_events.str (cached)
      -> Not module state
      [CALL] Found call: _socketio_instance.emit
    [RESOLVE] Attempting to resolve: ['_socketio_instance', 'emit']
    [RESOLVE] Chain resolution needed for: ['_socketio_instance', 'emit']
      [CHAIN] Resolving base: _socketio_instance
      [RESOLVE_SIMPLE] Resolving base: _socketio_instance
      [CACHE] Hit for _socketio_instance: socketio_events._socketio_instance
      [CHAIN] Base resolved: _socketio_instance -> socketio_events._socketio_instance
      [CHAIN] Step 1: Resolving socketio_events._socketio_instance.emit
        [ATTRIBUTE] Resolving attribute: socketio_events._socketio_instance.emit
        [ATTRIBUTE] Direct match found: socketio_events._socketio_instance.emit
      [CHAIN] Step 1 resolved: socketio_events._socketio_instance.emit
    [RESOLVE] RESOLVED to: socketio_events._socketio_instance.emit
            [INTERMEDIATE] Tracking chain steps for: _socketio_instance.emit
            [INTERMEDIATE] Step 1: _socketio_instance.emit
        [EMIT_DETECTION] Direct FQN match: socketio_events._socketio_instance.emit
      -> DETECTED and ADDED emit call: socketio_events._socketio_instance.emit::admin_notification
        [EMIT] Room parameter: $admin_room
        [FUNCTION_ARG] Checking argument: notification
    [RESOLVE] Attempting to resolve: ['notification']
      [RESOLVE_SIMPLE] Resolving base: notification
      [STRATEGY] Trying resolver 1: LocalVariableResolverVisitor
      [SYMBOL_LOOKUP] Variable notification not found in any scope
      [LOCAL_RESOLVER] can_resolve(notification): False
      [STRATEGY] SKIP LocalVariableResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 2: SelfResolverVisitor
      [SELF_RESOLVER] can_resolve(notification): False (current_class: None)
      [STRATEGY] SKIP SelfResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 3: ImportResolverVisitor
      [IMPORT_RESOLVER] can_resolve(notification): False (import: False, external: False)
      [STRATEGY] SKIP ImportResolverVisitor cannot resolve
      [STRATEGY] Trying resolver 4: ModuleResolverVisitor
      [MODULE_RESOLVER] can_resolve(notification): True (fallback, module: socketio_events)
      [MODULE_RESOLVER] resolve(notification): socketio_events.notification
      [STRATEGY] SUCCESS ModuleResolverVisitor succeeded: notification -> socketio_events.notification
      [VALIDATION] PASS Resolution validated
    [RESOLVE] RESOLVED to: socketio_events.notification
      [ATTRIBUTE] Found attribute access: _socketio_instance.emit
        [CACHE] _socketio_instance.emit -> socketio_events._socketio_instance.emit (cached)
      -> Not module state
      [NAME] Found name reference: _socketio_instance
        [CACHE] _socketio_instance -> socketio_events._socketio_instance (cached)
      -> Resolved to state: socketio_events._socketio_instance
      [SYMBOL_LOOKUP] Variable _socketio_instance not found in any scope
      -> ADDED to accessed_state
      [NAME] Found name reference: notification
    [RESOLVE] Attempting to resolve: ['notification']
      [RESOLVE_SIMPLE] Resolving base: notification
      [CACHE] Hit for notification: socketio_events.notification
    [RESOLVE] RESOLVED to: socketio_events.notification
      -> Not module state
      [NAME] Found name reference: admin_room
        [CACHE] admin_room -> socketio_events.admin_room (cached)
      -> Not module state
    [CONTEXT] Exited function: socketio_events.admin_notification
    [FUNCTION_ANALYSIS] Completed analysis of: socketio_events.admin_notification
        Calls: 2
        Instantiations: 0
        State Access: 2
        SocketIO Emits: 1
=== Module Analysis Complete ===
  Module analysis complete
=== ANALYSIS PASS COMPLETE ===

Generating report...
=== GENERATING JSON REPORT ===
Report successfully written to: code_atlas_report.json
Report size: 204668 bytes
=== CODE ATLAS GENERATION COMPLETE ===
Analysis successful using recon:refactored + analysis:refactored!
Check 'code_atlas_report.json' for results.
